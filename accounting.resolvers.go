package mazza

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.52

import (
	"context"
	"fmt"
	accountingentry "mazza/app/accountingEntry"
	balancesheet "mazza/app/financial-reports/balance-sheet"
	incomestatement "mazza/app/financial-reports/income-statement"
	"mazza/app/financial-reports/ledger"
	trialbalance "mazza/app/financial-reports/trial-balance"
	"mazza/ent/generated"
	"mazza/ent/generated/company"
	"mazza/ent/generated/invoice"
	"mazza/ent/utils"
	"mazza/mazza/generated/model"
	"time"
)

// IssueSalesQuotation is the resolver for the issueSalesQuotation field.
func (r *mutationResolver) IssueSalesQuotation(ctx context.Context, input model.SalesQuotationInput) (*model.InvoiceIssuanceOutput, error) {
	return nil, nil
}

// IssueInvoice is the resolver for the issueInvoice field.
func (r *mutationResolver) IssueInvoice(ctx context.Context, input model.InvoiceInput) (*model.InvoiceIssuanceOutput, error) {
	activeUser, activeCompany := utils.GetSession(&ctx)
	// FIRST, CHECK THAT THE INVOICE NUMBER DOES NOT EXIST FOR THE COMPANY
	exists, err := r.client.Invoice.Query().Where(
		invoice.HasCompanyWith(company.ID(activeCompany.ID)),
		invoice.Number(*input.InvoiceData.Number),
	).Exist(ctx)

	if exists {
		fmt.Println("err:", err)
		return nil, fmt.Errorf("invalid invoice number. refresh company details")
	}

	// Start db transaction
	tx, err := r.client.Tx(ctx)
	if err != nil {
		fmt.Println("err:", err)
		return nil, fmt.Errorf("an error occurred")
	}

	result, err := accountingentry.RegisterAccountingOperations(ctx, tx, *input.AccountingEntryData)
	if err != nil {
		_ = tx.Rollback()
		fmt.Println("InvoiceIssuance err:", err)
		return nil, fmt.Errorf("an error occurred")
	}

	if input.InventoryMovements != nil {
		// Create inventory movement
		for _, movement := range input.InventoryMovements {
			// input := generated.CreateInventoryMovementInput{
			// 	Category:    movement.Category,
			// 	Quantity:    movement.Quantity,
			// 	Value:       movement.Value,
			// 	Date:        movement.Date,
			// 	Source:      movement.Source,
			// 	Destination: movement.Destination,
			// 	Notes:       movement.Notes,
			// 	InventoryID: movement,
			// }
			_, err := accountingentry.CreateInventoryMovement(ctx, tx, *movement, nil)
			if err != nil {
				fmt.Println("InvoiceIssuance err:", err)
				return nil, fmt.Errorf("an error occurred")
			}
		}
	}

	// Update the number of issued invoices in the company model
	_, err = tx.Company.UpdateOneID(activeCompany.ID).AddLastInvoiceNumber(1).Save(ctx)
	if err != nil {
		_ = tx.Rollback()
		fmt.Println("err:", err)
		return nil, fmt.Errorf("an error occurred")
	}

	// Create invoice entry
	// status := invoice.StatusPAID
	// status := *input.InvoiceData.Status
	// if input.InvoiceData.Terms != nil && *input.InvoiceData.Terms > 0 {
	// 	status = invoice.StatusPENDING
	// }
	invoiceEntry, err := tx.Invoice.Create().SetInput(*input.InvoiceData).
		SetCompanyID(activeCompany.ID).
		SetIssuedByID(activeUser.ID).
		Save(ctx)
	if err != nil {
		_ = tx.Rollback()
		fmt.Println("err:", err)
		return nil, fmt.Errorf("an error occurred")
	}
	_ = invoiceEntry

	if err = tx.Commit(); err != nil {
		fmt.Println("err:", err)
		_ = tx.Rollback()
		return nil, fmt.Errorf("an error occurred")
	}

	output := model.InvoiceIssuanceOutput{
		Message: *result,
		FileURL: *input.InvoiceData.URL,
	}

	return &output, nil
}

// CreateInvoiceDraft is the resolver for the createInvoiceDraft field.
func (r *mutationResolver) CreateInvoiceDraft(ctx context.Context, input generated.CreateInvoiceInput) (*generated.Invoice, error) {
	activeUser, activeCompany := utils.GetSession(&ctx)
	// var number string
	draft, err := r.client.Invoice.Create().SetInput(input).
		SetStatus(invoice.StatusDRAFT).
		// SetNumber(number).
		SetNillableNumber(nil).
		SetCompanyID(activeCompany.ID).
		SetIssuedByID(activeUser.ID).
		Save(ctx)
	if err != nil {
		fmt.Println("err:", err)
		return nil, fmt.Errorf("an error occurred")
	}

	return draft, nil
}

// DeleteInvoiceDraft is the resolver for the deleteInvoiceDraft field.
func (r *mutationResolver) DeleteInvoiceDraft(ctx context.Context, id int) (bool, error) {
	_, activeCompany := utils.GetSession(&ctx)
	err := r.client.Invoice.DeleteOneID(id).
		Where(
			invoice.HasCompanyWith(company.ID(activeCompany.ID)),
			invoice.StatusEQ(invoice.StatusDRAFT),
		).Exec(ctx)
	if err != nil {
		return false, fmt.Errorf("an error occurred.")
	}
	return true, nil
}

// RegisterAccountingEntries is the resolver for the registerAccountingEntries field.
func (r *mutationResolver) RegisterAccountingEntries(ctx context.Context, input model.BaseEntryRegistrationInput) (*string, error) {
	tx, err := r.client.Tx(ctx)
	if err != nil {
		fmt.Println("err:", err)
		return nil, fmt.Errorf("an error occurred")
	}

	result, err := accountingentry.RegisterAccountingOperations(ctx, tx, input)
	if err != nil {
		fmt.Println("err:", err)
		return nil, fmt.Errorf("an error occurred")
	}

	if err = tx.Commit(); err != nil {
		fmt.Println("err:", err)
		return nil, fmt.Errorf("an error occurred")
	}
	return result, nil
}

// TrialBalance is the resolver for the trialBalance field.
func (r *queryResolver) TrialBalance(ctx context.Context, date time.Time) ([]*model.TrialBalanceRowItem, error) {
	user, company := utils.GetSession(&ctx)
	output, err := trialbalance.GetTrialBalance(r.client, ctx, *user, *company, date, []string{})
	return output, err
}

// IncomeStatement is the resolver for the incomeStatement field.
func (r *queryResolver) IncomeStatement(ctx context.Context, date time.Time) (*model.IncomeStatementOuput, error) {
	user, company := utils.GetSession(&ctx)
	output, err := incomestatement.GetIncomeStatement(r.client, ctx, *user, *company, date)
	return output, err
}

// BalanceSheet is the resolver for the balanceSheet field.
func (r *queryResolver) BalanceSheet(ctx context.Context, date time.Time) (*model.BalanceSheetOuput, error) {
	user, company := utils.GetSession(&ctx)
	output, err := balancesheet.GetBalanceSheet(r.client, ctx, *user, *company, date)
	return output, err
}

// DownloadLedger is the resolver for the downloadLedger field.
func (r *queryResolver) DownloadLedger(ctx context.Context, where model.LedgerDownloadInput) (*model.FileDetailsOutput, error) {
	user, company := utils.GetSession(&ctx)
	output, err := ledger.BuildReport(r.client, ctx, *user, *company, where.StartDate, where.EndDate)
	return output, err
}

// DownloadTrialBalance is the resolver for the downloadTrialBalance field.
func (r *queryResolver) DownloadTrialBalance(ctx context.Context, where model.ReportInput) (*model.FileDetailsOutput, error) {
	user, company := utils.GetSession(&ctx)
	output, err := trialbalance.BuildReport(r.client, ctx, *user, *company, where.Date)
	return output, err
}

// DownloadIncomeStatement is the resolver for the downloadIncomeStatement field.
func (r *queryResolver) DownloadIncomeStatement(ctx context.Context, where model.ReportInput) (*model.FileDetailsOutput, error) {
	user, company := utils.GetSession(&ctx)
	output, err := incomestatement.BuildReport(r.client, ctx, *user, *company, where.Date)
	return output, err
}

// DownloadBalanceSheet is the resolver for the downloadBalanceSheet field.
func (r *queryResolver) DownloadBalanceSheet(ctx context.Context, where model.ReportInput) (*model.FileDetailsOutput, error) {
	user, company := utils.GetSession(&ctx)
	output, err := balancesheet.BuildReport(r.client, ctx, *user, *company, where.Date)
	return output, err
}

// CountInvoices is the resolver for the countInvoices field.
func (r *queryResolver) CountInvoices(ctx context.Context) ([]*model.InvoiceCount, error) {
	_, currentCompany := utils.GetSession(&ctx)
	var output []*model.InvoiceCount
	companyFilter := invoice.HasCompanyWith(company.ID(currentCompany.ID))

	err := r.client.Invoice.Query().Where(companyFilter).
		GroupBy(invoice.FieldStatus).
		Aggregate(generated.Count()).
		Scan(ctx, &output)
	if err != nil {
		fmt.Println("CountInvoices err:", err)
		return nil, err
	}

	return output, nil
}
