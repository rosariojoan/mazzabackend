// Code generated by ent, DO NOT EDIT.

package generated

import (
	"context"
	"errors"
	"fmt"
	"log"
	"reflect"

	"mazza/ent/generated/migrate"

	"mazza/ent/generated/accountingentry"
	"mazza/ent/generated/cashmovement"
	"mazza/ent/generated/company"
	"mazza/ent/generated/customer"
	"mazza/ent/generated/employee"
	"mazza/ent/generated/file"
	"mazza/ent/generated/payable"
	"mazza/ent/generated/product"
	"mazza/ent/generated/productmovement"
	"mazza/ent/generated/receivable"
	"mazza/ent/generated/supplier"
	"mazza/ent/generated/token"
	"mazza/ent/generated/treasury"
	"mazza/ent/generated/user"
	"mazza/ent/generated/userrole"
	"mazza/ent/generated/workshift"
	"mazza/ent/generated/worktag"
	"mazza/ent/generated/worktask"

	"entgo.io/ent"
	"entgo.io/ent/dialect"
	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
)

// Client is the client that holds all ent builders.
type Client struct {
	config
	// Schema is the client for creating, migrating and dropping schema.
	Schema *migrate.Schema
	// AccountingEntry is the client for interacting with the AccountingEntry builders.
	AccountingEntry *AccountingEntryClient
	// CashMovement is the client for interacting with the CashMovement builders.
	CashMovement *CashMovementClient
	// Company is the client for interacting with the Company builders.
	Company *CompanyClient
	// Customer is the client for interacting with the Customer builders.
	Customer *CustomerClient
	// Employee is the client for interacting with the Employee builders.
	Employee *EmployeeClient
	// File is the client for interacting with the File builders.
	File *FileClient
	// Payable is the client for interacting with the Payable builders.
	Payable *PayableClient
	// Product is the client for interacting with the Product builders.
	Product *ProductClient
	// ProductMovement is the client for interacting with the ProductMovement builders.
	ProductMovement *ProductMovementClient
	// Receivable is the client for interacting with the Receivable builders.
	Receivable *ReceivableClient
	// Supplier is the client for interacting with the Supplier builders.
	Supplier *SupplierClient
	// Token is the client for interacting with the Token builders.
	Token *TokenClient
	// Treasury is the client for interacting with the Treasury builders.
	Treasury *TreasuryClient
	// User is the client for interacting with the User builders.
	User *UserClient
	// UserRole is the client for interacting with the UserRole builders.
	UserRole *UserRoleClient
	// Workshift is the client for interacting with the Workshift builders.
	Workshift *WorkshiftClient
	// Worktag is the client for interacting with the Worktag builders.
	Worktag *WorktagClient
	// Worktask is the client for interacting with the Worktask builders.
	Worktask *WorktaskClient
	// additional fields for node api
	tables tables
}

// NewClient creates a new client configured with the given options.
func NewClient(opts ...Option) *Client {
	client := &Client{config: newConfig(opts...)}
	client.init()
	return client
}

func (c *Client) init() {
	c.Schema = migrate.NewSchema(c.driver)
	c.AccountingEntry = NewAccountingEntryClient(c.config)
	c.CashMovement = NewCashMovementClient(c.config)
	c.Company = NewCompanyClient(c.config)
	c.Customer = NewCustomerClient(c.config)
	c.Employee = NewEmployeeClient(c.config)
	c.File = NewFileClient(c.config)
	c.Payable = NewPayableClient(c.config)
	c.Product = NewProductClient(c.config)
	c.ProductMovement = NewProductMovementClient(c.config)
	c.Receivable = NewReceivableClient(c.config)
	c.Supplier = NewSupplierClient(c.config)
	c.Token = NewTokenClient(c.config)
	c.Treasury = NewTreasuryClient(c.config)
	c.User = NewUserClient(c.config)
	c.UserRole = NewUserRoleClient(c.config)
	c.Workshift = NewWorkshiftClient(c.config)
	c.Worktag = NewWorktagClient(c.config)
	c.Worktask = NewWorktaskClient(c.config)
}

type (
	// config is the configuration for the client and its builder.
	config struct {
		// driver used for executing database requests.
		driver dialect.Driver
		// debug enable a debug logging.
		debug bool
		// log used for logging on debug mode.
		log func(...any)
		// hooks to execute on mutations.
		hooks *hooks
		// interceptors to execute on queries.
		inters *inters
	}
	// Option function to configure the client.
	Option func(*config)
)

// newConfig creates a new config for the client.
func newConfig(opts ...Option) config {
	cfg := config{log: log.Println, hooks: &hooks{}, inters: &inters{}}
	cfg.options(opts...)
	return cfg
}

// options applies the options on the config object.
func (c *config) options(opts ...Option) {
	for _, opt := range opts {
		opt(c)
	}
	if c.debug {
		c.driver = dialect.Debug(c.driver, c.log)
	}
}

// Debug enables debug logging on the ent.Driver.
func Debug() Option {
	return func(c *config) {
		c.debug = true
	}
}

// Log sets the logging function for debug mode.
func Log(fn func(...any)) Option {
	return func(c *config) {
		c.log = fn
	}
}

// Driver configures the client driver.
func Driver(driver dialect.Driver) Option {
	return func(c *config) {
		c.driver = driver
	}
}

// Open opens a database/sql.DB specified by the driver name and
// the data source name, and returns a new client attached to it.
// Optional parameters can be added for configuring the client.
func Open(driverName, dataSourceName string, options ...Option) (*Client, error) {
	switch driverName {
	case dialect.MySQL, dialect.Postgres, dialect.SQLite:
		drv, err := sql.Open(driverName, dataSourceName)
		if err != nil {
			return nil, err
		}
		return NewClient(append(options, Driver(drv))...), nil
	default:
		return nil, fmt.Errorf("unsupported driver: %q", driverName)
	}
}

// ErrTxStarted is returned when trying to start a new transaction from a transactional client.
var ErrTxStarted = errors.New("generated: cannot start a transaction within a transaction")

// Tx returns a new transactional client. The provided context
// is used until the transaction is committed or rolled back.
func (c *Client) Tx(ctx context.Context) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, ErrTxStarted
	}
	tx, err := newTx(ctx, c.driver)
	if err != nil {
		return nil, fmt.Errorf("generated: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = tx
	return &Tx{
		ctx:             ctx,
		config:          cfg,
		AccountingEntry: NewAccountingEntryClient(cfg),
		CashMovement:    NewCashMovementClient(cfg),
		Company:         NewCompanyClient(cfg),
		Customer:        NewCustomerClient(cfg),
		Employee:        NewEmployeeClient(cfg),
		File:            NewFileClient(cfg),
		Payable:         NewPayableClient(cfg),
		Product:         NewProductClient(cfg),
		ProductMovement: NewProductMovementClient(cfg),
		Receivable:      NewReceivableClient(cfg),
		Supplier:        NewSupplierClient(cfg),
		Token:           NewTokenClient(cfg),
		Treasury:        NewTreasuryClient(cfg),
		User:            NewUserClient(cfg),
		UserRole:        NewUserRoleClient(cfg),
		Workshift:       NewWorkshiftClient(cfg),
		Worktag:         NewWorktagClient(cfg),
		Worktask:        NewWorktaskClient(cfg),
	}, nil
}

// BeginTx returns a transactional client with specified options.
func (c *Client) BeginTx(ctx context.Context, opts *sql.TxOptions) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, errors.New("ent: cannot start a transaction within a transaction")
	}
	tx, err := c.driver.(interface {
		BeginTx(context.Context, *sql.TxOptions) (dialect.Tx, error)
	}).BeginTx(ctx, opts)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = &txDriver{tx: tx, drv: c.driver}
	return &Tx{
		ctx:             ctx,
		config:          cfg,
		AccountingEntry: NewAccountingEntryClient(cfg),
		CashMovement:    NewCashMovementClient(cfg),
		Company:         NewCompanyClient(cfg),
		Customer:        NewCustomerClient(cfg),
		Employee:        NewEmployeeClient(cfg),
		File:            NewFileClient(cfg),
		Payable:         NewPayableClient(cfg),
		Product:         NewProductClient(cfg),
		ProductMovement: NewProductMovementClient(cfg),
		Receivable:      NewReceivableClient(cfg),
		Supplier:        NewSupplierClient(cfg),
		Token:           NewTokenClient(cfg),
		Treasury:        NewTreasuryClient(cfg),
		User:            NewUserClient(cfg),
		UserRole:        NewUserRoleClient(cfg),
		Workshift:       NewWorkshiftClient(cfg),
		Worktag:         NewWorktagClient(cfg),
		Worktask:        NewWorktaskClient(cfg),
	}, nil
}

// Debug returns a new debug-client. It's used to get verbose logging on specific operations.
//
//	client.Debug().
//		AccountingEntry.
//		Query().
//		Count(ctx)
func (c *Client) Debug() *Client {
	if c.debug {
		return c
	}
	cfg := c.config
	cfg.driver = dialect.Debug(c.driver, c.log)
	client := &Client{config: cfg}
	client.init()
	return client
}

// Close closes the database connection and prevents new queries from starting.
func (c *Client) Close() error {
	return c.driver.Close()
}

// Use adds the mutation hooks to all the entity clients.
// In order to add hooks to a specific client, call: `client.Node.Use(...)`.
func (c *Client) Use(hooks ...Hook) {
	for _, n := range []interface{ Use(...Hook) }{
		c.AccountingEntry, c.CashMovement, c.Company, c.Customer, c.Employee, c.File,
		c.Payable, c.Product, c.ProductMovement, c.Receivable, c.Supplier, c.Token,
		c.Treasury, c.User, c.UserRole, c.Workshift, c.Worktag, c.Worktask,
	} {
		n.Use(hooks...)
	}
}

// Intercept adds the query interceptors to all the entity clients.
// In order to add interceptors to a specific client, call: `client.Node.Intercept(...)`.
func (c *Client) Intercept(interceptors ...Interceptor) {
	for _, n := range []interface{ Intercept(...Interceptor) }{
		c.AccountingEntry, c.CashMovement, c.Company, c.Customer, c.Employee, c.File,
		c.Payable, c.Product, c.ProductMovement, c.Receivable, c.Supplier, c.Token,
		c.Treasury, c.User, c.UserRole, c.Workshift, c.Worktag, c.Worktask,
	} {
		n.Intercept(interceptors...)
	}
}

// Mutate implements the ent.Mutator interface.
func (c *Client) Mutate(ctx context.Context, m Mutation) (Value, error) {
	switch m := m.(type) {
	case *AccountingEntryMutation:
		return c.AccountingEntry.mutate(ctx, m)
	case *CashMovementMutation:
		return c.CashMovement.mutate(ctx, m)
	case *CompanyMutation:
		return c.Company.mutate(ctx, m)
	case *CustomerMutation:
		return c.Customer.mutate(ctx, m)
	case *EmployeeMutation:
		return c.Employee.mutate(ctx, m)
	case *FileMutation:
		return c.File.mutate(ctx, m)
	case *PayableMutation:
		return c.Payable.mutate(ctx, m)
	case *ProductMutation:
		return c.Product.mutate(ctx, m)
	case *ProductMovementMutation:
		return c.ProductMovement.mutate(ctx, m)
	case *ReceivableMutation:
		return c.Receivable.mutate(ctx, m)
	case *SupplierMutation:
		return c.Supplier.mutate(ctx, m)
	case *TokenMutation:
		return c.Token.mutate(ctx, m)
	case *TreasuryMutation:
		return c.Treasury.mutate(ctx, m)
	case *UserMutation:
		return c.User.mutate(ctx, m)
	case *UserRoleMutation:
		return c.UserRole.mutate(ctx, m)
	case *WorkshiftMutation:
		return c.Workshift.mutate(ctx, m)
	case *WorktagMutation:
		return c.Worktag.mutate(ctx, m)
	case *WorktaskMutation:
		return c.Worktask.mutate(ctx, m)
	default:
		return nil, fmt.Errorf("generated: unknown mutation type %T", m)
	}
}

// AccountingEntryClient is a client for the AccountingEntry schema.
type AccountingEntryClient struct {
	config
}

// NewAccountingEntryClient returns a client for the AccountingEntry from the given config.
func NewAccountingEntryClient(c config) *AccountingEntryClient {
	return &AccountingEntryClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `accountingentry.Hooks(f(g(h())))`.
func (c *AccountingEntryClient) Use(hooks ...Hook) {
	c.hooks.AccountingEntry = append(c.hooks.AccountingEntry, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `accountingentry.Intercept(f(g(h())))`.
func (c *AccountingEntryClient) Intercept(interceptors ...Interceptor) {
	c.inters.AccountingEntry = append(c.inters.AccountingEntry, interceptors...)
}

// Create returns a builder for creating a AccountingEntry entity.
func (c *AccountingEntryClient) Create() *AccountingEntryCreate {
	mutation := newAccountingEntryMutation(c.config, OpCreate)
	return &AccountingEntryCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of AccountingEntry entities.
func (c *AccountingEntryClient) CreateBulk(builders ...*AccountingEntryCreate) *AccountingEntryCreateBulk {
	return &AccountingEntryCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *AccountingEntryClient) MapCreateBulk(slice any, setFunc func(*AccountingEntryCreate, int)) *AccountingEntryCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &AccountingEntryCreateBulk{err: fmt.Errorf("calling to AccountingEntryClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*AccountingEntryCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &AccountingEntryCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for AccountingEntry.
func (c *AccountingEntryClient) Update() *AccountingEntryUpdate {
	mutation := newAccountingEntryMutation(c.config, OpUpdate)
	return &AccountingEntryUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *AccountingEntryClient) UpdateOne(ae *AccountingEntry) *AccountingEntryUpdateOne {
	mutation := newAccountingEntryMutation(c.config, OpUpdateOne, withAccountingEntry(ae))
	return &AccountingEntryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *AccountingEntryClient) UpdateOneID(id int) *AccountingEntryUpdateOne {
	mutation := newAccountingEntryMutation(c.config, OpUpdateOne, withAccountingEntryID(id))
	return &AccountingEntryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for AccountingEntry.
func (c *AccountingEntryClient) Delete() *AccountingEntryDelete {
	mutation := newAccountingEntryMutation(c.config, OpDelete)
	return &AccountingEntryDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *AccountingEntryClient) DeleteOne(ae *AccountingEntry) *AccountingEntryDeleteOne {
	return c.DeleteOneID(ae.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *AccountingEntryClient) DeleteOneID(id int) *AccountingEntryDeleteOne {
	builder := c.Delete().Where(accountingentry.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &AccountingEntryDeleteOne{builder}
}

// Query returns a query builder for AccountingEntry.
func (c *AccountingEntryClient) Query() *AccountingEntryQuery {
	return &AccountingEntryQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeAccountingEntry},
		inters: c.Interceptors(),
	}
}

// Get returns a AccountingEntry entity by its id.
func (c *AccountingEntryClient) Get(ctx context.Context, id int) (*AccountingEntry, error) {
	return c.Query().Where(accountingentry.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *AccountingEntryClient) GetX(ctx context.Context, id int) *AccountingEntry {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryCompany queries the company edge of a AccountingEntry.
func (c *AccountingEntryClient) QueryCompany(ae *AccountingEntry) *CompanyQuery {
	query := (&CompanyClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ae.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(accountingentry.Table, accountingentry.FieldID, id),
			sqlgraph.To(company.Table, company.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, accountingentry.CompanyTable, accountingentry.CompanyColumn),
		)
		fromV = sqlgraph.Neighbors(ae.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryUser queries the user edge of a AccountingEntry.
func (c *AccountingEntryClient) QueryUser(ae *AccountingEntry) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ae.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(accountingentry.Table, accountingentry.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, accountingentry.UserTable, accountingentry.UserColumn),
		)
		fromV = sqlgraph.Neighbors(ae.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *AccountingEntryClient) Hooks() []Hook {
	return c.hooks.AccountingEntry
}

// Interceptors returns the client interceptors.
func (c *AccountingEntryClient) Interceptors() []Interceptor {
	return c.inters.AccountingEntry
}

func (c *AccountingEntryClient) mutate(ctx context.Context, m *AccountingEntryMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&AccountingEntryCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&AccountingEntryUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&AccountingEntryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&AccountingEntryDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown AccountingEntry mutation op: %q", m.Op())
	}
}

// CashMovementClient is a client for the CashMovement schema.
type CashMovementClient struct {
	config
}

// NewCashMovementClient returns a client for the CashMovement from the given config.
func NewCashMovementClient(c config) *CashMovementClient {
	return &CashMovementClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `cashmovement.Hooks(f(g(h())))`.
func (c *CashMovementClient) Use(hooks ...Hook) {
	c.hooks.CashMovement = append(c.hooks.CashMovement, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `cashmovement.Intercept(f(g(h())))`.
func (c *CashMovementClient) Intercept(interceptors ...Interceptor) {
	c.inters.CashMovement = append(c.inters.CashMovement, interceptors...)
}

// Create returns a builder for creating a CashMovement entity.
func (c *CashMovementClient) Create() *CashMovementCreate {
	mutation := newCashMovementMutation(c.config, OpCreate)
	return &CashMovementCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of CashMovement entities.
func (c *CashMovementClient) CreateBulk(builders ...*CashMovementCreate) *CashMovementCreateBulk {
	return &CashMovementCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *CashMovementClient) MapCreateBulk(slice any, setFunc func(*CashMovementCreate, int)) *CashMovementCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &CashMovementCreateBulk{err: fmt.Errorf("calling to CashMovementClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*CashMovementCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &CashMovementCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for CashMovement.
func (c *CashMovementClient) Update() *CashMovementUpdate {
	mutation := newCashMovementMutation(c.config, OpUpdate)
	return &CashMovementUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *CashMovementClient) UpdateOne(cm *CashMovement) *CashMovementUpdateOne {
	mutation := newCashMovementMutation(c.config, OpUpdateOne, withCashMovement(cm))
	return &CashMovementUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *CashMovementClient) UpdateOneID(id int) *CashMovementUpdateOne {
	mutation := newCashMovementMutation(c.config, OpUpdateOne, withCashMovementID(id))
	return &CashMovementUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for CashMovement.
func (c *CashMovementClient) Delete() *CashMovementDelete {
	mutation := newCashMovementMutation(c.config, OpDelete)
	return &CashMovementDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *CashMovementClient) DeleteOne(cm *CashMovement) *CashMovementDeleteOne {
	return c.DeleteOneID(cm.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *CashMovementClient) DeleteOneID(id int) *CashMovementDeleteOne {
	builder := c.Delete().Where(cashmovement.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &CashMovementDeleteOne{builder}
}

// Query returns a query builder for CashMovement.
func (c *CashMovementClient) Query() *CashMovementQuery {
	return &CashMovementQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeCashMovement},
		inters: c.Interceptors(),
	}
}

// Get returns a CashMovement entity by its id.
func (c *CashMovementClient) Get(ctx context.Context, id int) (*CashMovement, error) {
	return c.Query().Where(cashmovement.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *CashMovementClient) GetX(ctx context.Context, id int) *CashMovement {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryTreasury queries the treasury edge of a CashMovement.
func (c *CashMovementClient) QueryTreasury(cm *CashMovement) *TreasuryQuery {
	query := (&TreasuryClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := cm.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(cashmovement.Table, cashmovement.FieldID, id),
			sqlgraph.To(treasury.Table, treasury.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, cashmovement.TreasuryTable, cashmovement.TreasuryColumn),
		)
		fromV = sqlgraph.Neighbors(cm.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *CashMovementClient) Hooks() []Hook {
	return c.hooks.CashMovement
}

// Interceptors returns the client interceptors.
func (c *CashMovementClient) Interceptors() []Interceptor {
	return c.inters.CashMovement
}

func (c *CashMovementClient) mutate(ctx context.Context, m *CashMovementMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&CashMovementCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&CashMovementUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&CashMovementUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&CashMovementDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown CashMovement mutation op: %q", m.Op())
	}
}

// CompanyClient is a client for the Company schema.
type CompanyClient struct {
	config
}

// NewCompanyClient returns a client for the Company from the given config.
func NewCompanyClient(c config) *CompanyClient {
	return &CompanyClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `company.Hooks(f(g(h())))`.
func (c *CompanyClient) Use(hooks ...Hook) {
	c.hooks.Company = append(c.hooks.Company, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `company.Intercept(f(g(h())))`.
func (c *CompanyClient) Intercept(interceptors ...Interceptor) {
	c.inters.Company = append(c.inters.Company, interceptors...)
}

// Create returns a builder for creating a Company entity.
func (c *CompanyClient) Create() *CompanyCreate {
	mutation := newCompanyMutation(c.config, OpCreate)
	return &CompanyCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Company entities.
func (c *CompanyClient) CreateBulk(builders ...*CompanyCreate) *CompanyCreateBulk {
	return &CompanyCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *CompanyClient) MapCreateBulk(slice any, setFunc func(*CompanyCreate, int)) *CompanyCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &CompanyCreateBulk{err: fmt.Errorf("calling to CompanyClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*CompanyCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &CompanyCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Company.
func (c *CompanyClient) Update() *CompanyUpdate {
	mutation := newCompanyMutation(c.config, OpUpdate)
	return &CompanyUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *CompanyClient) UpdateOne(co *Company) *CompanyUpdateOne {
	mutation := newCompanyMutation(c.config, OpUpdateOne, withCompany(co))
	return &CompanyUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *CompanyClient) UpdateOneID(id int) *CompanyUpdateOne {
	mutation := newCompanyMutation(c.config, OpUpdateOne, withCompanyID(id))
	return &CompanyUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Company.
func (c *CompanyClient) Delete() *CompanyDelete {
	mutation := newCompanyMutation(c.config, OpDelete)
	return &CompanyDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *CompanyClient) DeleteOne(co *Company) *CompanyDeleteOne {
	return c.DeleteOneID(co.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *CompanyClient) DeleteOneID(id int) *CompanyDeleteOne {
	builder := c.Delete().Where(company.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &CompanyDeleteOne{builder}
}

// Query returns a query builder for Company.
func (c *CompanyClient) Query() *CompanyQuery {
	return &CompanyQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeCompany},
		inters: c.Interceptors(),
	}
}

// Get returns a Company entity by its id.
func (c *CompanyClient) Get(ctx context.Context, id int) (*Company, error) {
	return c.Query().Where(company.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *CompanyClient) GetX(ctx context.Context, id int) *Company {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryAvailableRoles queries the availableRoles edge of a Company.
func (c *CompanyClient) QueryAvailableRoles(co *Company) *UserRoleQuery {
	query := (&UserRoleClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := co.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(company.Table, company.FieldID, id),
			sqlgraph.To(userrole.Table, userrole.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, company.AvailableRolesTable, company.AvailableRolesColumn),
		)
		fromV = sqlgraph.Neighbors(co.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryAccountingEntries queries the accountingEntries edge of a Company.
func (c *CompanyClient) QueryAccountingEntries(co *Company) *AccountingEntryQuery {
	query := (&AccountingEntryClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := co.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(company.Table, company.FieldID, id),
			sqlgraph.To(accountingentry.Table, accountingentry.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, company.AccountingEntriesTable, company.AccountingEntriesColumn),
		)
		fromV = sqlgraph.Neighbors(co.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryCustomers queries the customers edge of a Company.
func (c *CompanyClient) QueryCustomers(co *Company) *CustomerQuery {
	query := (&CustomerClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := co.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(company.Table, company.FieldID, id),
			sqlgraph.To(customer.Table, customer.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, company.CustomersTable, company.CustomersColumn),
		)
		fromV = sqlgraph.Neighbors(co.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryEmployees queries the employees edge of a Company.
func (c *CompanyClient) QueryEmployees(co *Company) *EmployeeQuery {
	query := (&EmployeeClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := co.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(company.Table, company.FieldID, id),
			sqlgraph.To(employee.Table, employee.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, company.EmployeesTable, company.EmployeesColumn),
		)
		fromV = sqlgraph.Neighbors(co.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryFiles queries the files edge of a Company.
func (c *CompanyClient) QueryFiles(co *Company) *FileQuery {
	query := (&FileClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := co.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(company.Table, company.FieldID, id),
			sqlgraph.To(file.Table, file.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, company.FilesTable, company.FilesColumn),
		)
		fromV = sqlgraph.Neighbors(co.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryProducts queries the products edge of a Company.
func (c *CompanyClient) QueryProducts(co *Company) *ProductQuery {
	query := (&ProductClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := co.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(company.Table, company.FieldID, id),
			sqlgraph.To(product.Table, product.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, company.ProductsTable, company.ProductsColumn),
		)
		fromV = sqlgraph.Neighbors(co.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QuerySuppliers queries the suppliers edge of a Company.
func (c *CompanyClient) QuerySuppliers(co *Company) *SupplierQuery {
	query := (&SupplierClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := co.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(company.Table, company.FieldID, id),
			sqlgraph.To(supplier.Table, supplier.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, company.SuppliersTable, company.SuppliersColumn),
		)
		fromV = sqlgraph.Neighbors(co.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTokens queries the tokens edge of a Company.
func (c *CompanyClient) QueryTokens(co *Company) *TokenQuery {
	query := (&TokenClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := co.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(company.Table, company.FieldID, id),
			sqlgraph.To(token.Table, token.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, company.TokensTable, company.TokensColumn),
		)
		fromV = sqlgraph.Neighbors(co.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTreasuries queries the treasuries edge of a Company.
func (c *CompanyClient) QueryTreasuries(co *Company) *TreasuryQuery {
	query := (&TreasuryClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := co.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(company.Table, company.FieldID, id),
			sqlgraph.To(treasury.Table, treasury.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, company.TreasuriesTable, company.TreasuriesColumn),
		)
		fromV = sqlgraph.Neighbors(co.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryWorkShifts queries the workShifts edge of a Company.
func (c *CompanyClient) QueryWorkShifts(co *Company) *WorkshiftQuery {
	query := (&WorkshiftClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := co.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(company.Table, company.FieldID, id),
			sqlgraph.To(workshift.Table, workshift.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, company.WorkShiftsTable, company.WorkShiftsColumn),
		)
		fromV = sqlgraph.Neighbors(co.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryWorkTasks queries the workTasks edge of a Company.
func (c *CompanyClient) QueryWorkTasks(co *Company) *WorktaskQuery {
	query := (&WorktaskClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := co.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(company.Table, company.FieldID, id),
			sqlgraph.To(worktask.Table, worktask.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, company.WorkTasksTable, company.WorkTasksColumn),
		)
		fromV = sqlgraph.Neighbors(co.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryWorkTags queries the workTags edge of a Company.
func (c *CompanyClient) QueryWorkTags(co *Company) *WorktagQuery {
	query := (&WorktagClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := co.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(company.Table, company.FieldID, id),
			sqlgraph.To(worktag.Table, worktag.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, company.WorkTagsTable, company.WorkTagsColumn),
		)
		fromV = sqlgraph.Neighbors(co.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryUsers queries the users edge of a Company.
func (c *CompanyClient) QueryUsers(co *Company) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := co.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(company.Table, company.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, company.UsersTable, company.UsersPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(co.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryDaughterCompanies queries the daughterCompanies edge of a Company.
func (c *CompanyClient) QueryDaughterCompanies(co *Company) *CompanyQuery {
	query := (&CompanyClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := co.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(company.Table, company.FieldID, id),
			sqlgraph.To(company.Table, company.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, company.DaughterCompaniesTable, company.DaughterCompaniesColumn),
		)
		fromV = sqlgraph.Neighbors(co.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryParentCompany queries the parentCompany edge of a Company.
func (c *CompanyClient) QueryParentCompany(co *Company) *CompanyQuery {
	query := (&CompanyClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := co.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(company.Table, company.FieldID, id),
			sqlgraph.To(company.Table, company.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, company.ParentCompanyTable, company.ParentCompanyColumn),
		)
		fromV = sqlgraph.Neighbors(co.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *CompanyClient) Hooks() []Hook {
	return c.hooks.Company
}

// Interceptors returns the client interceptors.
func (c *CompanyClient) Interceptors() []Interceptor {
	return c.inters.Company
}

func (c *CompanyClient) mutate(ctx context.Context, m *CompanyMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&CompanyCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&CompanyUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&CompanyUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&CompanyDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown Company mutation op: %q", m.Op())
	}
}

// CustomerClient is a client for the Customer schema.
type CustomerClient struct {
	config
}

// NewCustomerClient returns a client for the Customer from the given config.
func NewCustomerClient(c config) *CustomerClient {
	return &CustomerClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `customer.Hooks(f(g(h())))`.
func (c *CustomerClient) Use(hooks ...Hook) {
	c.hooks.Customer = append(c.hooks.Customer, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `customer.Intercept(f(g(h())))`.
func (c *CustomerClient) Intercept(interceptors ...Interceptor) {
	c.inters.Customer = append(c.inters.Customer, interceptors...)
}

// Create returns a builder for creating a Customer entity.
func (c *CustomerClient) Create() *CustomerCreate {
	mutation := newCustomerMutation(c.config, OpCreate)
	return &CustomerCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Customer entities.
func (c *CustomerClient) CreateBulk(builders ...*CustomerCreate) *CustomerCreateBulk {
	return &CustomerCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *CustomerClient) MapCreateBulk(slice any, setFunc func(*CustomerCreate, int)) *CustomerCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &CustomerCreateBulk{err: fmt.Errorf("calling to CustomerClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*CustomerCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &CustomerCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Customer.
func (c *CustomerClient) Update() *CustomerUpdate {
	mutation := newCustomerMutation(c.config, OpUpdate)
	return &CustomerUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *CustomerClient) UpdateOne(cu *Customer) *CustomerUpdateOne {
	mutation := newCustomerMutation(c.config, OpUpdateOne, withCustomer(cu))
	return &CustomerUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *CustomerClient) UpdateOneID(id int) *CustomerUpdateOne {
	mutation := newCustomerMutation(c.config, OpUpdateOne, withCustomerID(id))
	return &CustomerUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Customer.
func (c *CustomerClient) Delete() *CustomerDelete {
	mutation := newCustomerMutation(c.config, OpDelete)
	return &CustomerDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *CustomerClient) DeleteOne(cu *Customer) *CustomerDeleteOne {
	return c.DeleteOneID(cu.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *CustomerClient) DeleteOneID(id int) *CustomerDeleteOne {
	builder := c.Delete().Where(customer.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &CustomerDeleteOne{builder}
}

// Query returns a query builder for Customer.
func (c *CustomerClient) Query() *CustomerQuery {
	return &CustomerQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeCustomer},
		inters: c.Interceptors(),
	}
}

// Get returns a Customer entity by its id.
func (c *CustomerClient) Get(ctx context.Context, id int) (*Customer, error) {
	return c.Query().Where(customer.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *CustomerClient) GetX(ctx context.Context, id int) *Customer {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryCompany queries the company edge of a Customer.
func (c *CustomerClient) QueryCompany(cu *Customer) *CompanyQuery {
	query := (&CompanyClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := cu.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(customer.Table, customer.FieldID, id),
			sqlgraph.To(company.Table, company.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, customer.CompanyTable, customer.CompanyColumn),
		)
		fromV = sqlgraph.Neighbors(cu.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryReceivables queries the receivables edge of a Customer.
func (c *CustomerClient) QueryReceivables(cu *Customer) *ReceivableQuery {
	query := (&ReceivableClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := cu.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(customer.Table, customer.FieldID, id),
			sqlgraph.To(receivable.Table, receivable.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, customer.ReceivablesTable, customer.ReceivablesColumn),
		)
		fromV = sqlgraph.Neighbors(cu.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *CustomerClient) Hooks() []Hook {
	return c.hooks.Customer
}

// Interceptors returns the client interceptors.
func (c *CustomerClient) Interceptors() []Interceptor {
	return c.inters.Customer
}

func (c *CustomerClient) mutate(ctx context.Context, m *CustomerMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&CustomerCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&CustomerUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&CustomerUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&CustomerDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown Customer mutation op: %q", m.Op())
	}
}

// EmployeeClient is a client for the Employee schema.
type EmployeeClient struct {
	config
}

// NewEmployeeClient returns a client for the Employee from the given config.
func NewEmployeeClient(c config) *EmployeeClient {
	return &EmployeeClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `employee.Hooks(f(g(h())))`.
func (c *EmployeeClient) Use(hooks ...Hook) {
	c.hooks.Employee = append(c.hooks.Employee, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `employee.Intercept(f(g(h())))`.
func (c *EmployeeClient) Intercept(interceptors ...Interceptor) {
	c.inters.Employee = append(c.inters.Employee, interceptors...)
}

// Create returns a builder for creating a Employee entity.
func (c *EmployeeClient) Create() *EmployeeCreate {
	mutation := newEmployeeMutation(c.config, OpCreate)
	return &EmployeeCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Employee entities.
func (c *EmployeeClient) CreateBulk(builders ...*EmployeeCreate) *EmployeeCreateBulk {
	return &EmployeeCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *EmployeeClient) MapCreateBulk(slice any, setFunc func(*EmployeeCreate, int)) *EmployeeCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &EmployeeCreateBulk{err: fmt.Errorf("calling to EmployeeClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*EmployeeCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &EmployeeCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Employee.
func (c *EmployeeClient) Update() *EmployeeUpdate {
	mutation := newEmployeeMutation(c.config, OpUpdate)
	return &EmployeeUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *EmployeeClient) UpdateOne(e *Employee) *EmployeeUpdateOne {
	mutation := newEmployeeMutation(c.config, OpUpdateOne, withEmployee(e))
	return &EmployeeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *EmployeeClient) UpdateOneID(id int) *EmployeeUpdateOne {
	mutation := newEmployeeMutation(c.config, OpUpdateOne, withEmployeeID(id))
	return &EmployeeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Employee.
func (c *EmployeeClient) Delete() *EmployeeDelete {
	mutation := newEmployeeMutation(c.config, OpDelete)
	return &EmployeeDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *EmployeeClient) DeleteOne(e *Employee) *EmployeeDeleteOne {
	return c.DeleteOneID(e.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *EmployeeClient) DeleteOneID(id int) *EmployeeDeleteOne {
	builder := c.Delete().Where(employee.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &EmployeeDeleteOne{builder}
}

// Query returns a query builder for Employee.
func (c *EmployeeClient) Query() *EmployeeQuery {
	return &EmployeeQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeEmployee},
		inters: c.Interceptors(),
	}
}

// Get returns a Employee entity by its id.
func (c *EmployeeClient) Get(ctx context.Context, id int) (*Employee, error) {
	return c.Query().Where(employee.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *EmployeeClient) GetX(ctx context.Context, id int) *Employee {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryCompany queries the company edge of a Employee.
func (c *EmployeeClient) QueryCompany(e *Employee) *CompanyQuery {
	query := (&CompanyClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := e.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(employee.Table, employee.FieldID, id),
			sqlgraph.To(company.Table, company.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, employee.CompanyTable, employee.CompanyColumn),
		)
		fromV = sqlgraph.Neighbors(e.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryUser queries the user edge of a Employee.
func (c *EmployeeClient) QueryUser(e *Employee) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := e.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(employee.Table, employee.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, true, employee.UserTable, employee.UserColumn),
		)
		fromV = sqlgraph.Neighbors(e.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QuerySubordinates queries the subordinates edge of a Employee.
func (c *EmployeeClient) QuerySubordinates(e *Employee) *EmployeeQuery {
	query := (&EmployeeClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := e.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(employee.Table, employee.FieldID, id),
			sqlgraph.To(employee.Table, employee.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, employee.SubordinatesTable, employee.SubordinatesColumn),
		)
		fromV = sqlgraph.Neighbors(e.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryLeader queries the leader edge of a Employee.
func (c *EmployeeClient) QueryLeader(e *Employee) *EmployeeQuery {
	query := (&EmployeeClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := e.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(employee.Table, employee.FieldID, id),
			sqlgraph.To(employee.Table, employee.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, employee.LeaderTable, employee.LeaderColumn),
		)
		fromV = sqlgraph.Neighbors(e.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryWorkShifts queries the workShifts edge of a Employee.
func (c *EmployeeClient) QueryWorkShifts(e *Employee) *WorkshiftQuery {
	query := (&WorkshiftClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := e.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(employee.Table, employee.FieldID, id),
			sqlgraph.To(workshift.Table, workshift.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, employee.WorkShiftsTable, employee.WorkShiftsColumn),
		)
		fromV = sqlgraph.Neighbors(e.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryApprovedWorkShifts queries the approvedWorkShifts edge of a Employee.
func (c *EmployeeClient) QueryApprovedWorkShifts(e *Employee) *WorkshiftQuery {
	query := (&WorkshiftClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := e.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(employee.Table, employee.FieldID, id),
			sqlgraph.To(workshift.Table, workshift.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, employee.ApprovedWorkShiftsTable, employee.ApprovedWorkShiftsColumn),
		)
		fromV = sqlgraph.Neighbors(e.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryAssignedTasks queries the assignedTasks edge of a Employee.
func (c *EmployeeClient) QueryAssignedTasks(e *Employee) *WorktaskQuery {
	query := (&WorktaskClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := e.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(employee.Table, employee.FieldID, id),
			sqlgraph.To(worktask.Table, worktask.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, employee.AssignedTasksTable, employee.AssignedTasksPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(e.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *EmployeeClient) Hooks() []Hook {
	return c.hooks.Employee
}

// Interceptors returns the client interceptors.
func (c *EmployeeClient) Interceptors() []Interceptor {
	return c.inters.Employee
}

func (c *EmployeeClient) mutate(ctx context.Context, m *EmployeeMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&EmployeeCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&EmployeeUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&EmployeeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&EmployeeDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown Employee mutation op: %q", m.Op())
	}
}

// FileClient is a client for the File schema.
type FileClient struct {
	config
}

// NewFileClient returns a client for the File from the given config.
func NewFileClient(c config) *FileClient {
	return &FileClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `file.Hooks(f(g(h())))`.
func (c *FileClient) Use(hooks ...Hook) {
	c.hooks.File = append(c.hooks.File, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `file.Intercept(f(g(h())))`.
func (c *FileClient) Intercept(interceptors ...Interceptor) {
	c.inters.File = append(c.inters.File, interceptors...)
}

// Create returns a builder for creating a File entity.
func (c *FileClient) Create() *FileCreate {
	mutation := newFileMutation(c.config, OpCreate)
	return &FileCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of File entities.
func (c *FileClient) CreateBulk(builders ...*FileCreate) *FileCreateBulk {
	return &FileCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *FileClient) MapCreateBulk(slice any, setFunc func(*FileCreate, int)) *FileCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &FileCreateBulk{err: fmt.Errorf("calling to FileClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*FileCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &FileCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for File.
func (c *FileClient) Update() *FileUpdate {
	mutation := newFileMutation(c.config, OpUpdate)
	return &FileUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *FileClient) UpdateOne(f *File) *FileUpdateOne {
	mutation := newFileMutation(c.config, OpUpdateOne, withFile(f))
	return &FileUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *FileClient) UpdateOneID(id int) *FileUpdateOne {
	mutation := newFileMutation(c.config, OpUpdateOne, withFileID(id))
	return &FileUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for File.
func (c *FileClient) Delete() *FileDelete {
	mutation := newFileMutation(c.config, OpDelete)
	return &FileDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *FileClient) DeleteOne(f *File) *FileDeleteOne {
	return c.DeleteOneID(f.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *FileClient) DeleteOneID(id int) *FileDeleteOne {
	builder := c.Delete().Where(file.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &FileDeleteOne{builder}
}

// Query returns a query builder for File.
func (c *FileClient) Query() *FileQuery {
	return &FileQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeFile},
		inters: c.Interceptors(),
	}
}

// Get returns a File entity by its id.
func (c *FileClient) Get(ctx context.Context, id int) (*File, error) {
	return c.Query().Where(file.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *FileClient) GetX(ctx context.Context, id int) *File {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryCompany queries the company edge of a File.
func (c *FileClient) QueryCompany(f *File) *CompanyQuery {
	query := (&CompanyClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := f.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(file.Table, file.FieldID, id),
			sqlgraph.To(company.Table, company.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, file.CompanyTable, file.CompanyColumn),
		)
		fromV = sqlgraph.Neighbors(f.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryProduct queries the product edge of a File.
func (c *FileClient) QueryProduct(f *File) *ProductQuery {
	query := (&ProductClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := f.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(file.Table, file.FieldID, id),
			sqlgraph.To(product.Table, product.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, file.ProductTable, file.ProductColumn),
		)
		fromV = sqlgraph.Neighbors(f.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *FileClient) Hooks() []Hook {
	return c.hooks.File
}

// Interceptors returns the client interceptors.
func (c *FileClient) Interceptors() []Interceptor {
	return c.inters.File
}

func (c *FileClient) mutate(ctx context.Context, m *FileMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&FileCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&FileUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&FileUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&FileDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown File mutation op: %q", m.Op())
	}
}

// PayableClient is a client for the Payable schema.
type PayableClient struct {
	config
}

// NewPayableClient returns a client for the Payable from the given config.
func NewPayableClient(c config) *PayableClient {
	return &PayableClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `payable.Hooks(f(g(h())))`.
func (c *PayableClient) Use(hooks ...Hook) {
	c.hooks.Payable = append(c.hooks.Payable, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `payable.Intercept(f(g(h())))`.
func (c *PayableClient) Intercept(interceptors ...Interceptor) {
	c.inters.Payable = append(c.inters.Payable, interceptors...)
}

// Create returns a builder for creating a Payable entity.
func (c *PayableClient) Create() *PayableCreate {
	mutation := newPayableMutation(c.config, OpCreate)
	return &PayableCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Payable entities.
func (c *PayableClient) CreateBulk(builders ...*PayableCreate) *PayableCreateBulk {
	return &PayableCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *PayableClient) MapCreateBulk(slice any, setFunc func(*PayableCreate, int)) *PayableCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &PayableCreateBulk{err: fmt.Errorf("calling to PayableClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*PayableCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &PayableCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Payable.
func (c *PayableClient) Update() *PayableUpdate {
	mutation := newPayableMutation(c.config, OpUpdate)
	return &PayableUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *PayableClient) UpdateOne(pa *Payable) *PayableUpdateOne {
	mutation := newPayableMutation(c.config, OpUpdateOne, withPayable(pa))
	return &PayableUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *PayableClient) UpdateOneID(id int) *PayableUpdateOne {
	mutation := newPayableMutation(c.config, OpUpdateOne, withPayableID(id))
	return &PayableUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Payable.
func (c *PayableClient) Delete() *PayableDelete {
	mutation := newPayableMutation(c.config, OpDelete)
	return &PayableDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *PayableClient) DeleteOne(pa *Payable) *PayableDeleteOne {
	return c.DeleteOneID(pa.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *PayableClient) DeleteOneID(id int) *PayableDeleteOne {
	builder := c.Delete().Where(payable.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &PayableDeleteOne{builder}
}

// Query returns a query builder for Payable.
func (c *PayableClient) Query() *PayableQuery {
	return &PayableQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypePayable},
		inters: c.Interceptors(),
	}
}

// Get returns a Payable entity by its id.
func (c *PayableClient) Get(ctx context.Context, id int) (*Payable, error) {
	return c.Query().Where(payable.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *PayableClient) GetX(ctx context.Context, id int) *Payable {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QuerySupplier queries the supplier edge of a Payable.
func (c *PayableClient) QuerySupplier(pa *Payable) *SupplierQuery {
	query := (&SupplierClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pa.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(payable.Table, payable.FieldID, id),
			sqlgraph.To(supplier.Table, supplier.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, payable.SupplierTable, payable.SupplierColumn),
		)
		fromV = sqlgraph.Neighbors(pa.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *PayableClient) Hooks() []Hook {
	return c.hooks.Payable
}

// Interceptors returns the client interceptors.
func (c *PayableClient) Interceptors() []Interceptor {
	return c.inters.Payable
}

func (c *PayableClient) mutate(ctx context.Context, m *PayableMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&PayableCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&PayableUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&PayableUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&PayableDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown Payable mutation op: %q", m.Op())
	}
}

// ProductClient is a client for the Product schema.
type ProductClient struct {
	config
}

// NewProductClient returns a client for the Product from the given config.
func NewProductClient(c config) *ProductClient {
	return &ProductClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `product.Hooks(f(g(h())))`.
func (c *ProductClient) Use(hooks ...Hook) {
	c.hooks.Product = append(c.hooks.Product, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `product.Intercept(f(g(h())))`.
func (c *ProductClient) Intercept(interceptors ...Interceptor) {
	c.inters.Product = append(c.inters.Product, interceptors...)
}

// Create returns a builder for creating a Product entity.
func (c *ProductClient) Create() *ProductCreate {
	mutation := newProductMutation(c.config, OpCreate)
	return &ProductCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Product entities.
func (c *ProductClient) CreateBulk(builders ...*ProductCreate) *ProductCreateBulk {
	return &ProductCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ProductClient) MapCreateBulk(slice any, setFunc func(*ProductCreate, int)) *ProductCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ProductCreateBulk{err: fmt.Errorf("calling to ProductClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ProductCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ProductCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Product.
func (c *ProductClient) Update() *ProductUpdate {
	mutation := newProductMutation(c.config, OpUpdate)
	return &ProductUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ProductClient) UpdateOne(pr *Product) *ProductUpdateOne {
	mutation := newProductMutation(c.config, OpUpdateOne, withProduct(pr))
	return &ProductUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ProductClient) UpdateOneID(id int) *ProductUpdateOne {
	mutation := newProductMutation(c.config, OpUpdateOne, withProductID(id))
	return &ProductUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Product.
func (c *ProductClient) Delete() *ProductDelete {
	mutation := newProductMutation(c.config, OpDelete)
	return &ProductDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ProductClient) DeleteOne(pr *Product) *ProductDeleteOne {
	return c.DeleteOneID(pr.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ProductClient) DeleteOneID(id int) *ProductDeleteOne {
	builder := c.Delete().Where(product.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ProductDeleteOne{builder}
}

// Query returns a query builder for Product.
func (c *ProductClient) Query() *ProductQuery {
	return &ProductQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeProduct},
		inters: c.Interceptors(),
	}
}

// Get returns a Product entity by its id.
func (c *ProductClient) Get(ctx context.Context, id int) (*Product, error) {
	return c.Query().Where(product.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ProductClient) GetX(ctx context.Context, id int) *Product {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryCompany queries the company edge of a Product.
func (c *ProductClient) QueryCompany(pr *Product) *CompanyQuery {
	query := (&CompanyClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pr.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(product.Table, product.FieldID, id),
			sqlgraph.To(company.Table, company.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, product.CompanyTable, product.CompanyColumn),
		)
		fromV = sqlgraph.Neighbors(pr.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryPictures queries the pictures edge of a Product.
func (c *ProductClient) QueryPictures(pr *Product) *FileQuery {
	query := (&FileClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pr.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(product.Table, product.FieldID, id),
			sqlgraph.To(file.Table, file.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, product.PicturesTable, product.PicturesColumn),
		)
		fromV = sqlgraph.Neighbors(pr.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryProductMovements queries the productMovements edge of a Product.
func (c *ProductClient) QueryProductMovements(pr *Product) *ProductMovementQuery {
	query := (&ProductMovementClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pr.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(product.Table, product.FieldID, id),
			sqlgraph.To(productmovement.Table, productmovement.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, product.ProductMovementsTable, product.ProductMovementsColumn),
		)
		fromV = sqlgraph.Neighbors(pr.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ProductClient) Hooks() []Hook {
	return c.hooks.Product
}

// Interceptors returns the client interceptors.
func (c *ProductClient) Interceptors() []Interceptor {
	return c.inters.Product
}

func (c *ProductClient) mutate(ctx context.Context, m *ProductMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ProductCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ProductUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ProductUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ProductDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown Product mutation op: %q", m.Op())
	}
}

// ProductMovementClient is a client for the ProductMovement schema.
type ProductMovementClient struct {
	config
}

// NewProductMovementClient returns a client for the ProductMovement from the given config.
func NewProductMovementClient(c config) *ProductMovementClient {
	return &ProductMovementClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `productmovement.Hooks(f(g(h())))`.
func (c *ProductMovementClient) Use(hooks ...Hook) {
	c.hooks.ProductMovement = append(c.hooks.ProductMovement, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `productmovement.Intercept(f(g(h())))`.
func (c *ProductMovementClient) Intercept(interceptors ...Interceptor) {
	c.inters.ProductMovement = append(c.inters.ProductMovement, interceptors...)
}

// Create returns a builder for creating a ProductMovement entity.
func (c *ProductMovementClient) Create() *ProductMovementCreate {
	mutation := newProductMovementMutation(c.config, OpCreate)
	return &ProductMovementCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of ProductMovement entities.
func (c *ProductMovementClient) CreateBulk(builders ...*ProductMovementCreate) *ProductMovementCreateBulk {
	return &ProductMovementCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ProductMovementClient) MapCreateBulk(slice any, setFunc func(*ProductMovementCreate, int)) *ProductMovementCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ProductMovementCreateBulk{err: fmt.Errorf("calling to ProductMovementClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ProductMovementCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ProductMovementCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for ProductMovement.
func (c *ProductMovementClient) Update() *ProductMovementUpdate {
	mutation := newProductMovementMutation(c.config, OpUpdate)
	return &ProductMovementUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ProductMovementClient) UpdateOne(pm *ProductMovement) *ProductMovementUpdateOne {
	mutation := newProductMovementMutation(c.config, OpUpdateOne, withProductMovement(pm))
	return &ProductMovementUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ProductMovementClient) UpdateOneID(id int) *ProductMovementUpdateOne {
	mutation := newProductMovementMutation(c.config, OpUpdateOne, withProductMovementID(id))
	return &ProductMovementUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for ProductMovement.
func (c *ProductMovementClient) Delete() *ProductMovementDelete {
	mutation := newProductMovementMutation(c.config, OpDelete)
	return &ProductMovementDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ProductMovementClient) DeleteOne(pm *ProductMovement) *ProductMovementDeleteOne {
	return c.DeleteOneID(pm.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ProductMovementClient) DeleteOneID(id int) *ProductMovementDeleteOne {
	builder := c.Delete().Where(productmovement.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ProductMovementDeleteOne{builder}
}

// Query returns a query builder for ProductMovement.
func (c *ProductMovementClient) Query() *ProductMovementQuery {
	return &ProductMovementQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeProductMovement},
		inters: c.Interceptors(),
	}
}

// Get returns a ProductMovement entity by its id.
func (c *ProductMovementClient) Get(ctx context.Context, id int) (*ProductMovement, error) {
	return c.Query().Where(productmovement.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ProductMovementClient) GetX(ctx context.Context, id int) *ProductMovement {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryProduct queries the product edge of a ProductMovement.
func (c *ProductMovementClient) QueryProduct(pm *ProductMovement) *ProductQuery {
	query := (&ProductClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pm.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(productmovement.Table, productmovement.FieldID, id),
			sqlgraph.To(product.Table, product.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, productmovement.ProductTable, productmovement.ProductColumn),
		)
		fromV = sqlgraph.Neighbors(pm.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ProductMovementClient) Hooks() []Hook {
	return c.hooks.ProductMovement
}

// Interceptors returns the client interceptors.
func (c *ProductMovementClient) Interceptors() []Interceptor {
	return c.inters.ProductMovement
}

func (c *ProductMovementClient) mutate(ctx context.Context, m *ProductMovementMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ProductMovementCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ProductMovementUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ProductMovementUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ProductMovementDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown ProductMovement mutation op: %q", m.Op())
	}
}

// ReceivableClient is a client for the Receivable schema.
type ReceivableClient struct {
	config
}

// NewReceivableClient returns a client for the Receivable from the given config.
func NewReceivableClient(c config) *ReceivableClient {
	return &ReceivableClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `receivable.Hooks(f(g(h())))`.
func (c *ReceivableClient) Use(hooks ...Hook) {
	c.hooks.Receivable = append(c.hooks.Receivable, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `receivable.Intercept(f(g(h())))`.
func (c *ReceivableClient) Intercept(interceptors ...Interceptor) {
	c.inters.Receivable = append(c.inters.Receivable, interceptors...)
}

// Create returns a builder for creating a Receivable entity.
func (c *ReceivableClient) Create() *ReceivableCreate {
	mutation := newReceivableMutation(c.config, OpCreate)
	return &ReceivableCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Receivable entities.
func (c *ReceivableClient) CreateBulk(builders ...*ReceivableCreate) *ReceivableCreateBulk {
	return &ReceivableCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ReceivableClient) MapCreateBulk(slice any, setFunc func(*ReceivableCreate, int)) *ReceivableCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ReceivableCreateBulk{err: fmt.Errorf("calling to ReceivableClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ReceivableCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ReceivableCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Receivable.
func (c *ReceivableClient) Update() *ReceivableUpdate {
	mutation := newReceivableMutation(c.config, OpUpdate)
	return &ReceivableUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ReceivableClient) UpdateOne(r *Receivable) *ReceivableUpdateOne {
	mutation := newReceivableMutation(c.config, OpUpdateOne, withReceivable(r))
	return &ReceivableUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ReceivableClient) UpdateOneID(id int) *ReceivableUpdateOne {
	mutation := newReceivableMutation(c.config, OpUpdateOne, withReceivableID(id))
	return &ReceivableUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Receivable.
func (c *ReceivableClient) Delete() *ReceivableDelete {
	mutation := newReceivableMutation(c.config, OpDelete)
	return &ReceivableDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ReceivableClient) DeleteOne(r *Receivable) *ReceivableDeleteOne {
	return c.DeleteOneID(r.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ReceivableClient) DeleteOneID(id int) *ReceivableDeleteOne {
	builder := c.Delete().Where(receivable.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ReceivableDeleteOne{builder}
}

// Query returns a query builder for Receivable.
func (c *ReceivableClient) Query() *ReceivableQuery {
	return &ReceivableQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeReceivable},
		inters: c.Interceptors(),
	}
}

// Get returns a Receivable entity by its id.
func (c *ReceivableClient) Get(ctx context.Context, id int) (*Receivable, error) {
	return c.Query().Where(receivable.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ReceivableClient) GetX(ctx context.Context, id int) *Receivable {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryCustomer queries the customer edge of a Receivable.
func (c *ReceivableClient) QueryCustomer(r *Receivable) *CustomerQuery {
	query := (&CustomerClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := r.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(receivable.Table, receivable.FieldID, id),
			sqlgraph.To(customer.Table, customer.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, receivable.CustomerTable, receivable.CustomerColumn),
		)
		fromV = sqlgraph.Neighbors(r.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ReceivableClient) Hooks() []Hook {
	return c.hooks.Receivable
}

// Interceptors returns the client interceptors.
func (c *ReceivableClient) Interceptors() []Interceptor {
	return c.inters.Receivable
}

func (c *ReceivableClient) mutate(ctx context.Context, m *ReceivableMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ReceivableCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ReceivableUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ReceivableUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ReceivableDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown Receivable mutation op: %q", m.Op())
	}
}

// SupplierClient is a client for the Supplier schema.
type SupplierClient struct {
	config
}

// NewSupplierClient returns a client for the Supplier from the given config.
func NewSupplierClient(c config) *SupplierClient {
	return &SupplierClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `supplier.Hooks(f(g(h())))`.
func (c *SupplierClient) Use(hooks ...Hook) {
	c.hooks.Supplier = append(c.hooks.Supplier, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `supplier.Intercept(f(g(h())))`.
func (c *SupplierClient) Intercept(interceptors ...Interceptor) {
	c.inters.Supplier = append(c.inters.Supplier, interceptors...)
}

// Create returns a builder for creating a Supplier entity.
func (c *SupplierClient) Create() *SupplierCreate {
	mutation := newSupplierMutation(c.config, OpCreate)
	return &SupplierCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Supplier entities.
func (c *SupplierClient) CreateBulk(builders ...*SupplierCreate) *SupplierCreateBulk {
	return &SupplierCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *SupplierClient) MapCreateBulk(slice any, setFunc func(*SupplierCreate, int)) *SupplierCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &SupplierCreateBulk{err: fmt.Errorf("calling to SupplierClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*SupplierCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &SupplierCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Supplier.
func (c *SupplierClient) Update() *SupplierUpdate {
	mutation := newSupplierMutation(c.config, OpUpdate)
	return &SupplierUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *SupplierClient) UpdateOne(s *Supplier) *SupplierUpdateOne {
	mutation := newSupplierMutation(c.config, OpUpdateOne, withSupplier(s))
	return &SupplierUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *SupplierClient) UpdateOneID(id int) *SupplierUpdateOne {
	mutation := newSupplierMutation(c.config, OpUpdateOne, withSupplierID(id))
	return &SupplierUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Supplier.
func (c *SupplierClient) Delete() *SupplierDelete {
	mutation := newSupplierMutation(c.config, OpDelete)
	return &SupplierDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *SupplierClient) DeleteOne(s *Supplier) *SupplierDeleteOne {
	return c.DeleteOneID(s.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *SupplierClient) DeleteOneID(id int) *SupplierDeleteOne {
	builder := c.Delete().Where(supplier.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &SupplierDeleteOne{builder}
}

// Query returns a query builder for Supplier.
func (c *SupplierClient) Query() *SupplierQuery {
	return &SupplierQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeSupplier},
		inters: c.Interceptors(),
	}
}

// Get returns a Supplier entity by its id.
func (c *SupplierClient) Get(ctx context.Context, id int) (*Supplier, error) {
	return c.Query().Where(supplier.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *SupplierClient) GetX(ctx context.Context, id int) *Supplier {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryCompany queries the company edge of a Supplier.
func (c *SupplierClient) QueryCompany(s *Supplier) *CompanyQuery {
	query := (&CompanyClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := s.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(supplier.Table, supplier.FieldID, id),
			sqlgraph.To(company.Table, company.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, supplier.CompanyTable, supplier.CompanyColumn),
		)
		fromV = sqlgraph.Neighbors(s.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryPayables queries the payables edge of a Supplier.
func (c *SupplierClient) QueryPayables(s *Supplier) *PayableQuery {
	query := (&PayableClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := s.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(supplier.Table, supplier.FieldID, id),
			sqlgraph.To(payable.Table, payable.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, supplier.PayablesTable, supplier.PayablesColumn),
		)
		fromV = sqlgraph.Neighbors(s.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *SupplierClient) Hooks() []Hook {
	return c.hooks.Supplier
}

// Interceptors returns the client interceptors.
func (c *SupplierClient) Interceptors() []Interceptor {
	return c.inters.Supplier
}

func (c *SupplierClient) mutate(ctx context.Context, m *SupplierMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&SupplierCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&SupplierUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&SupplierUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&SupplierDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown Supplier mutation op: %q", m.Op())
	}
}

// TokenClient is a client for the Token schema.
type TokenClient struct {
	config
}

// NewTokenClient returns a client for the Token from the given config.
func NewTokenClient(c config) *TokenClient {
	return &TokenClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `token.Hooks(f(g(h())))`.
func (c *TokenClient) Use(hooks ...Hook) {
	c.hooks.Token = append(c.hooks.Token, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `token.Intercept(f(g(h())))`.
func (c *TokenClient) Intercept(interceptors ...Interceptor) {
	c.inters.Token = append(c.inters.Token, interceptors...)
}

// Create returns a builder for creating a Token entity.
func (c *TokenClient) Create() *TokenCreate {
	mutation := newTokenMutation(c.config, OpCreate)
	return &TokenCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Token entities.
func (c *TokenClient) CreateBulk(builders ...*TokenCreate) *TokenCreateBulk {
	return &TokenCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *TokenClient) MapCreateBulk(slice any, setFunc func(*TokenCreate, int)) *TokenCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &TokenCreateBulk{err: fmt.Errorf("calling to TokenClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*TokenCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &TokenCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Token.
func (c *TokenClient) Update() *TokenUpdate {
	mutation := newTokenMutation(c.config, OpUpdate)
	return &TokenUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *TokenClient) UpdateOne(t *Token) *TokenUpdateOne {
	mutation := newTokenMutation(c.config, OpUpdateOne, withToken(t))
	return &TokenUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *TokenClient) UpdateOneID(id int) *TokenUpdateOne {
	mutation := newTokenMutation(c.config, OpUpdateOne, withTokenID(id))
	return &TokenUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Token.
func (c *TokenClient) Delete() *TokenDelete {
	mutation := newTokenMutation(c.config, OpDelete)
	return &TokenDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *TokenClient) DeleteOne(t *Token) *TokenDeleteOne {
	return c.DeleteOneID(t.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *TokenClient) DeleteOneID(id int) *TokenDeleteOne {
	builder := c.Delete().Where(token.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &TokenDeleteOne{builder}
}

// Query returns a query builder for Token.
func (c *TokenClient) Query() *TokenQuery {
	return &TokenQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeToken},
		inters: c.Interceptors(),
	}
}

// Get returns a Token entity by its id.
func (c *TokenClient) Get(ctx context.Context, id int) (*Token, error) {
	return c.Query().Where(token.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *TokenClient) GetX(ctx context.Context, id int) *Token {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryCompany queries the company edge of a Token.
func (c *TokenClient) QueryCompany(t *Token) *CompanyQuery {
	query := (&CompanyClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := t.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(token.Table, token.FieldID, id),
			sqlgraph.To(company.Table, company.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, token.CompanyTable, token.CompanyColumn),
		)
		fromV = sqlgraph.Neighbors(t.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryUser queries the user edge of a Token.
func (c *TokenClient) QueryUser(t *Token) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := t.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(token.Table, token.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, token.UserTable, token.UserColumn),
		)
		fromV = sqlgraph.Neighbors(t.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *TokenClient) Hooks() []Hook {
	return c.hooks.Token
}

// Interceptors returns the client interceptors.
func (c *TokenClient) Interceptors() []Interceptor {
	return c.inters.Token
}

func (c *TokenClient) mutate(ctx context.Context, m *TokenMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&TokenCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&TokenUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&TokenUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&TokenDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown Token mutation op: %q", m.Op())
	}
}

// TreasuryClient is a client for the Treasury schema.
type TreasuryClient struct {
	config
}

// NewTreasuryClient returns a client for the Treasury from the given config.
func NewTreasuryClient(c config) *TreasuryClient {
	return &TreasuryClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `treasury.Hooks(f(g(h())))`.
func (c *TreasuryClient) Use(hooks ...Hook) {
	c.hooks.Treasury = append(c.hooks.Treasury, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `treasury.Intercept(f(g(h())))`.
func (c *TreasuryClient) Intercept(interceptors ...Interceptor) {
	c.inters.Treasury = append(c.inters.Treasury, interceptors...)
}

// Create returns a builder for creating a Treasury entity.
func (c *TreasuryClient) Create() *TreasuryCreate {
	mutation := newTreasuryMutation(c.config, OpCreate)
	return &TreasuryCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Treasury entities.
func (c *TreasuryClient) CreateBulk(builders ...*TreasuryCreate) *TreasuryCreateBulk {
	return &TreasuryCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *TreasuryClient) MapCreateBulk(slice any, setFunc func(*TreasuryCreate, int)) *TreasuryCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &TreasuryCreateBulk{err: fmt.Errorf("calling to TreasuryClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*TreasuryCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &TreasuryCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Treasury.
func (c *TreasuryClient) Update() *TreasuryUpdate {
	mutation := newTreasuryMutation(c.config, OpUpdate)
	return &TreasuryUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *TreasuryClient) UpdateOne(t *Treasury) *TreasuryUpdateOne {
	mutation := newTreasuryMutation(c.config, OpUpdateOne, withTreasury(t))
	return &TreasuryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *TreasuryClient) UpdateOneID(id int) *TreasuryUpdateOne {
	mutation := newTreasuryMutation(c.config, OpUpdateOne, withTreasuryID(id))
	return &TreasuryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Treasury.
func (c *TreasuryClient) Delete() *TreasuryDelete {
	mutation := newTreasuryMutation(c.config, OpDelete)
	return &TreasuryDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *TreasuryClient) DeleteOne(t *Treasury) *TreasuryDeleteOne {
	return c.DeleteOneID(t.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *TreasuryClient) DeleteOneID(id int) *TreasuryDeleteOne {
	builder := c.Delete().Where(treasury.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &TreasuryDeleteOne{builder}
}

// Query returns a query builder for Treasury.
func (c *TreasuryClient) Query() *TreasuryQuery {
	return &TreasuryQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeTreasury},
		inters: c.Interceptors(),
	}
}

// Get returns a Treasury entity by its id.
func (c *TreasuryClient) Get(ctx context.Context, id int) (*Treasury, error) {
	return c.Query().Where(treasury.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *TreasuryClient) GetX(ctx context.Context, id int) *Treasury {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryCompany queries the company edge of a Treasury.
func (c *TreasuryClient) QueryCompany(t *Treasury) *CompanyQuery {
	query := (&CompanyClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := t.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(treasury.Table, treasury.FieldID, id),
			sqlgraph.To(company.Table, company.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, treasury.CompanyTable, treasury.CompanyColumn),
		)
		fromV = sqlgraph.Neighbors(t.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryCashMovements queries the cashMovements edge of a Treasury.
func (c *TreasuryClient) QueryCashMovements(t *Treasury) *CashMovementQuery {
	query := (&CashMovementClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := t.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(treasury.Table, treasury.FieldID, id),
			sqlgraph.To(cashmovement.Table, cashmovement.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, treasury.CashMovementsTable, treasury.CashMovementsColumn),
		)
		fromV = sqlgraph.Neighbors(t.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *TreasuryClient) Hooks() []Hook {
	return c.hooks.Treasury
}

// Interceptors returns the client interceptors.
func (c *TreasuryClient) Interceptors() []Interceptor {
	return c.inters.Treasury
}

func (c *TreasuryClient) mutate(ctx context.Context, m *TreasuryMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&TreasuryCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&TreasuryUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&TreasuryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&TreasuryDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown Treasury mutation op: %q", m.Op())
	}
}

// UserClient is a client for the User schema.
type UserClient struct {
	config
}

// NewUserClient returns a client for the User from the given config.
func NewUserClient(c config) *UserClient {
	return &UserClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `user.Hooks(f(g(h())))`.
func (c *UserClient) Use(hooks ...Hook) {
	c.hooks.User = append(c.hooks.User, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `user.Intercept(f(g(h())))`.
func (c *UserClient) Intercept(interceptors ...Interceptor) {
	c.inters.User = append(c.inters.User, interceptors...)
}

// Create returns a builder for creating a User entity.
func (c *UserClient) Create() *UserCreate {
	mutation := newUserMutation(c.config, OpCreate)
	return &UserCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of User entities.
func (c *UserClient) CreateBulk(builders ...*UserCreate) *UserCreateBulk {
	return &UserCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *UserClient) MapCreateBulk(slice any, setFunc func(*UserCreate, int)) *UserCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &UserCreateBulk{err: fmt.Errorf("calling to UserClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*UserCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &UserCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for User.
func (c *UserClient) Update() *UserUpdate {
	mutation := newUserMutation(c.config, OpUpdate)
	return &UserUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *UserClient) UpdateOne(u *User) *UserUpdateOne {
	mutation := newUserMutation(c.config, OpUpdateOne, withUser(u))
	return &UserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *UserClient) UpdateOneID(id int) *UserUpdateOne {
	mutation := newUserMutation(c.config, OpUpdateOne, withUserID(id))
	return &UserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for User.
func (c *UserClient) Delete() *UserDelete {
	mutation := newUserMutation(c.config, OpDelete)
	return &UserDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *UserClient) DeleteOne(u *User) *UserDeleteOne {
	return c.DeleteOneID(u.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *UserClient) DeleteOneID(id int) *UserDeleteOne {
	builder := c.Delete().Where(user.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &UserDeleteOne{builder}
}

// Query returns a query builder for User.
func (c *UserClient) Query() *UserQuery {
	return &UserQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeUser},
		inters: c.Interceptors(),
	}
}

// Get returns a User entity by its id.
func (c *UserClient) Get(ctx context.Context, id int) (*User, error) {
	return c.Query().Where(user.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *UserClient) GetX(ctx context.Context, id int) *User {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryAccountingEntries queries the accountingEntries edge of a User.
func (c *UserClient) QueryAccountingEntries(u *User) *AccountingEntryQuery {
	query := (&AccountingEntryClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(accountingentry.Table, accountingentry.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.AccountingEntriesTable, user.AccountingEntriesColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryCompany queries the company edge of a User.
func (c *UserClient) QueryCompany(u *User) *CompanyQuery {
	query := (&CompanyClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(company.Table, company.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, user.CompanyTable, user.CompanyPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryAssignedRoles queries the assignedRoles edge of a User.
func (c *UserClient) QueryAssignedRoles(u *User) *UserRoleQuery {
	query := (&UserRoleClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(userrole.Table, userrole.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, user.AssignedRolesTable, user.AssignedRolesPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryCreatedTasks queries the createdTasks edge of a User.
func (c *UserClient) QueryCreatedTasks(u *User) *WorktaskQuery {
	query := (&WorktaskClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(worktask.Table, worktask.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.CreatedTasksTable, user.CreatedTasksColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryEmployee queries the employee edge of a User.
func (c *UserClient) QueryEmployee(u *User) *EmployeeQuery {
	query := (&EmployeeClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(employee.Table, employee.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, user.EmployeeTable, user.EmployeeColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTokens queries the tokens edge of a User.
func (c *UserClient) QueryTokens(u *User) *TokenQuery {
	query := (&TokenClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(token.Table, token.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.TokensTable, user.TokensColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *UserClient) Hooks() []Hook {
	return c.hooks.User
}

// Interceptors returns the client interceptors.
func (c *UserClient) Interceptors() []Interceptor {
	return c.inters.User
}

func (c *UserClient) mutate(ctx context.Context, m *UserMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&UserCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&UserUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&UserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&UserDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown User mutation op: %q", m.Op())
	}
}

// UserRoleClient is a client for the UserRole schema.
type UserRoleClient struct {
	config
}

// NewUserRoleClient returns a client for the UserRole from the given config.
func NewUserRoleClient(c config) *UserRoleClient {
	return &UserRoleClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `userrole.Hooks(f(g(h())))`.
func (c *UserRoleClient) Use(hooks ...Hook) {
	c.hooks.UserRole = append(c.hooks.UserRole, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `userrole.Intercept(f(g(h())))`.
func (c *UserRoleClient) Intercept(interceptors ...Interceptor) {
	c.inters.UserRole = append(c.inters.UserRole, interceptors...)
}

// Create returns a builder for creating a UserRole entity.
func (c *UserRoleClient) Create() *UserRoleCreate {
	mutation := newUserRoleMutation(c.config, OpCreate)
	return &UserRoleCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of UserRole entities.
func (c *UserRoleClient) CreateBulk(builders ...*UserRoleCreate) *UserRoleCreateBulk {
	return &UserRoleCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *UserRoleClient) MapCreateBulk(slice any, setFunc func(*UserRoleCreate, int)) *UserRoleCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &UserRoleCreateBulk{err: fmt.Errorf("calling to UserRoleClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*UserRoleCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &UserRoleCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for UserRole.
func (c *UserRoleClient) Update() *UserRoleUpdate {
	mutation := newUserRoleMutation(c.config, OpUpdate)
	return &UserRoleUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *UserRoleClient) UpdateOne(ur *UserRole) *UserRoleUpdateOne {
	mutation := newUserRoleMutation(c.config, OpUpdateOne, withUserRole(ur))
	return &UserRoleUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *UserRoleClient) UpdateOneID(id int) *UserRoleUpdateOne {
	mutation := newUserRoleMutation(c.config, OpUpdateOne, withUserRoleID(id))
	return &UserRoleUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for UserRole.
func (c *UserRoleClient) Delete() *UserRoleDelete {
	mutation := newUserRoleMutation(c.config, OpDelete)
	return &UserRoleDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *UserRoleClient) DeleteOne(ur *UserRole) *UserRoleDeleteOne {
	return c.DeleteOneID(ur.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *UserRoleClient) DeleteOneID(id int) *UserRoleDeleteOne {
	builder := c.Delete().Where(userrole.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &UserRoleDeleteOne{builder}
}

// Query returns a query builder for UserRole.
func (c *UserRoleClient) Query() *UserRoleQuery {
	return &UserRoleQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeUserRole},
		inters: c.Interceptors(),
	}
}

// Get returns a UserRole entity by its id.
func (c *UserRoleClient) Get(ctx context.Context, id int) (*UserRole, error) {
	return c.Query().Where(userrole.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *UserRoleClient) GetX(ctx context.Context, id int) *UserRole {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryCompany queries the company edge of a UserRole.
func (c *UserRoleClient) QueryCompany(ur *UserRole) *CompanyQuery {
	query := (&CompanyClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ur.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(userrole.Table, userrole.FieldID, id),
			sqlgraph.To(company.Table, company.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, userrole.CompanyTable, userrole.CompanyColumn),
		)
		fromV = sqlgraph.Neighbors(ur.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryUser queries the user edge of a UserRole.
func (c *UserRoleClient) QueryUser(ur *UserRole) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ur.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(userrole.Table, userrole.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, userrole.UserTable, userrole.UserPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(ur.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *UserRoleClient) Hooks() []Hook {
	return c.hooks.UserRole
}

// Interceptors returns the client interceptors.
func (c *UserRoleClient) Interceptors() []Interceptor {
	return c.inters.UserRole
}

func (c *UserRoleClient) mutate(ctx context.Context, m *UserRoleMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&UserRoleCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&UserRoleUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&UserRoleUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&UserRoleDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown UserRole mutation op: %q", m.Op())
	}
}

// WorkshiftClient is a client for the Workshift schema.
type WorkshiftClient struct {
	config
}

// NewWorkshiftClient returns a client for the Workshift from the given config.
func NewWorkshiftClient(c config) *WorkshiftClient {
	return &WorkshiftClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `workshift.Hooks(f(g(h())))`.
func (c *WorkshiftClient) Use(hooks ...Hook) {
	c.hooks.Workshift = append(c.hooks.Workshift, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `workshift.Intercept(f(g(h())))`.
func (c *WorkshiftClient) Intercept(interceptors ...Interceptor) {
	c.inters.Workshift = append(c.inters.Workshift, interceptors...)
}

// Create returns a builder for creating a Workshift entity.
func (c *WorkshiftClient) Create() *WorkshiftCreate {
	mutation := newWorkshiftMutation(c.config, OpCreate)
	return &WorkshiftCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Workshift entities.
func (c *WorkshiftClient) CreateBulk(builders ...*WorkshiftCreate) *WorkshiftCreateBulk {
	return &WorkshiftCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *WorkshiftClient) MapCreateBulk(slice any, setFunc func(*WorkshiftCreate, int)) *WorkshiftCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &WorkshiftCreateBulk{err: fmt.Errorf("calling to WorkshiftClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*WorkshiftCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &WorkshiftCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Workshift.
func (c *WorkshiftClient) Update() *WorkshiftUpdate {
	mutation := newWorkshiftMutation(c.config, OpUpdate)
	return &WorkshiftUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *WorkshiftClient) UpdateOne(w *Workshift) *WorkshiftUpdateOne {
	mutation := newWorkshiftMutation(c.config, OpUpdateOne, withWorkshift(w))
	return &WorkshiftUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *WorkshiftClient) UpdateOneID(id int) *WorkshiftUpdateOne {
	mutation := newWorkshiftMutation(c.config, OpUpdateOne, withWorkshiftID(id))
	return &WorkshiftUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Workshift.
func (c *WorkshiftClient) Delete() *WorkshiftDelete {
	mutation := newWorkshiftMutation(c.config, OpDelete)
	return &WorkshiftDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *WorkshiftClient) DeleteOne(w *Workshift) *WorkshiftDeleteOne {
	return c.DeleteOneID(w.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *WorkshiftClient) DeleteOneID(id int) *WorkshiftDeleteOne {
	builder := c.Delete().Where(workshift.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &WorkshiftDeleteOne{builder}
}

// Query returns a query builder for Workshift.
func (c *WorkshiftClient) Query() *WorkshiftQuery {
	return &WorkshiftQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeWorkshift},
		inters: c.Interceptors(),
	}
}

// Get returns a Workshift entity by its id.
func (c *WorkshiftClient) Get(ctx context.Context, id int) (*Workshift, error) {
	return c.Query().Where(workshift.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *WorkshiftClient) GetX(ctx context.Context, id int) *Workshift {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryCompany queries the company edge of a Workshift.
func (c *WorkshiftClient) QueryCompany(w *Workshift) *CompanyQuery {
	query := (&CompanyClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := w.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(workshift.Table, workshift.FieldID, id),
			sqlgraph.To(company.Table, company.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, workshift.CompanyTable, workshift.CompanyColumn),
		)
		fromV = sqlgraph.Neighbors(w.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryEmployee queries the employee edge of a Workshift.
func (c *WorkshiftClient) QueryEmployee(w *Workshift) *EmployeeQuery {
	query := (&EmployeeClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := w.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(workshift.Table, workshift.FieldID, id),
			sqlgraph.To(employee.Table, employee.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, workshift.EmployeeTable, workshift.EmployeeColumn),
		)
		fromV = sqlgraph.Neighbors(w.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryApprovedBy queries the approvedBy edge of a Workshift.
func (c *WorkshiftClient) QueryApprovedBy(w *Workshift) *EmployeeQuery {
	query := (&EmployeeClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := w.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(workshift.Table, workshift.FieldID, id),
			sqlgraph.To(employee.Table, employee.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, workshift.ApprovedByTable, workshift.ApprovedByColumn),
		)
		fromV = sqlgraph.Neighbors(w.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryWorkTask queries the workTask edge of a Workshift.
func (c *WorkshiftClient) QueryWorkTask(w *Workshift) *WorktaskQuery {
	query := (&WorktaskClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := w.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(workshift.Table, workshift.FieldID, id),
			sqlgraph.To(worktask.Table, worktask.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, workshift.WorkTaskTable, workshift.WorkTaskColumn),
		)
		fromV = sqlgraph.Neighbors(w.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryEditRequest queries the editRequest edge of a Workshift.
func (c *WorkshiftClient) QueryEditRequest(w *Workshift) *WorkshiftQuery {
	query := (&WorkshiftClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := w.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(workshift.Table, workshift.FieldID, id),
			sqlgraph.To(workshift.Table, workshift.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, workshift.EditRequestTable, workshift.EditRequestColumn),
		)
		fromV = sqlgraph.Neighbors(w.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryWorkShift queries the workShift edge of a Workshift.
func (c *WorkshiftClient) QueryWorkShift(w *Workshift) *WorkshiftQuery {
	query := (&WorkshiftClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := w.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(workshift.Table, workshift.FieldID, id),
			sqlgraph.To(workshift.Table, workshift.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, true, workshift.WorkShiftTable, workshift.WorkShiftColumn),
		)
		fromV = sqlgraph.Neighbors(w.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *WorkshiftClient) Hooks() []Hook {
	hooks := c.hooks.Workshift
	return append(hooks[:len(hooks):len(hooks)], workshift.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *WorkshiftClient) Interceptors() []Interceptor {
	return c.inters.Workshift
}

func (c *WorkshiftClient) mutate(ctx context.Context, m *WorkshiftMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&WorkshiftCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&WorkshiftUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&WorkshiftUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&WorkshiftDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown Workshift mutation op: %q", m.Op())
	}
}

// WorktagClient is a client for the Worktag schema.
type WorktagClient struct {
	config
}

// NewWorktagClient returns a client for the Worktag from the given config.
func NewWorktagClient(c config) *WorktagClient {
	return &WorktagClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `worktag.Hooks(f(g(h())))`.
func (c *WorktagClient) Use(hooks ...Hook) {
	c.hooks.Worktag = append(c.hooks.Worktag, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `worktag.Intercept(f(g(h())))`.
func (c *WorktagClient) Intercept(interceptors ...Interceptor) {
	c.inters.Worktag = append(c.inters.Worktag, interceptors...)
}

// Create returns a builder for creating a Worktag entity.
func (c *WorktagClient) Create() *WorktagCreate {
	mutation := newWorktagMutation(c.config, OpCreate)
	return &WorktagCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Worktag entities.
func (c *WorktagClient) CreateBulk(builders ...*WorktagCreate) *WorktagCreateBulk {
	return &WorktagCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *WorktagClient) MapCreateBulk(slice any, setFunc func(*WorktagCreate, int)) *WorktagCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &WorktagCreateBulk{err: fmt.Errorf("calling to WorktagClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*WorktagCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &WorktagCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Worktag.
func (c *WorktagClient) Update() *WorktagUpdate {
	mutation := newWorktagMutation(c.config, OpUpdate)
	return &WorktagUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *WorktagClient) UpdateOne(w *Worktag) *WorktagUpdateOne {
	mutation := newWorktagMutation(c.config, OpUpdateOne, withWorktag(w))
	return &WorktagUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *WorktagClient) UpdateOneID(id int) *WorktagUpdateOne {
	mutation := newWorktagMutation(c.config, OpUpdateOne, withWorktagID(id))
	return &WorktagUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Worktag.
func (c *WorktagClient) Delete() *WorktagDelete {
	mutation := newWorktagMutation(c.config, OpDelete)
	return &WorktagDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *WorktagClient) DeleteOne(w *Worktag) *WorktagDeleteOne {
	return c.DeleteOneID(w.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *WorktagClient) DeleteOneID(id int) *WorktagDeleteOne {
	builder := c.Delete().Where(worktag.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &WorktagDeleteOne{builder}
}

// Query returns a query builder for Worktag.
func (c *WorktagClient) Query() *WorktagQuery {
	return &WorktagQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeWorktag},
		inters: c.Interceptors(),
	}
}

// Get returns a Worktag entity by its id.
func (c *WorktagClient) Get(ctx context.Context, id int) (*Worktag, error) {
	return c.Query().Where(worktag.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *WorktagClient) GetX(ctx context.Context, id int) *Worktag {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryCompany queries the company edge of a Worktag.
func (c *WorktagClient) QueryCompany(w *Worktag) *CompanyQuery {
	query := (&CompanyClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := w.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(worktag.Table, worktag.FieldID, id),
			sqlgraph.To(company.Table, company.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, worktag.CompanyTable, worktag.CompanyColumn),
		)
		fromV = sqlgraph.Neighbors(w.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryWorkTasks queries the workTasks edge of a Worktag.
func (c *WorktagClient) QueryWorkTasks(w *Worktag) *WorktaskQuery {
	query := (&WorktaskClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := w.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(worktag.Table, worktag.FieldID, id),
			sqlgraph.To(worktask.Table, worktask.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, worktag.WorkTasksTable, worktag.WorkTasksPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(w.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *WorktagClient) Hooks() []Hook {
	return c.hooks.Worktag
}

// Interceptors returns the client interceptors.
func (c *WorktagClient) Interceptors() []Interceptor {
	return c.inters.Worktag
}

func (c *WorktagClient) mutate(ctx context.Context, m *WorktagMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&WorktagCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&WorktagUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&WorktagUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&WorktagDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown Worktag mutation op: %q", m.Op())
	}
}

// WorktaskClient is a client for the Worktask schema.
type WorktaskClient struct {
	config
}

// NewWorktaskClient returns a client for the Worktask from the given config.
func NewWorktaskClient(c config) *WorktaskClient {
	return &WorktaskClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `worktask.Hooks(f(g(h())))`.
func (c *WorktaskClient) Use(hooks ...Hook) {
	c.hooks.Worktask = append(c.hooks.Worktask, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `worktask.Intercept(f(g(h())))`.
func (c *WorktaskClient) Intercept(interceptors ...Interceptor) {
	c.inters.Worktask = append(c.inters.Worktask, interceptors...)
}

// Create returns a builder for creating a Worktask entity.
func (c *WorktaskClient) Create() *WorktaskCreate {
	mutation := newWorktaskMutation(c.config, OpCreate)
	return &WorktaskCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Worktask entities.
func (c *WorktaskClient) CreateBulk(builders ...*WorktaskCreate) *WorktaskCreateBulk {
	return &WorktaskCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *WorktaskClient) MapCreateBulk(slice any, setFunc func(*WorktaskCreate, int)) *WorktaskCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &WorktaskCreateBulk{err: fmt.Errorf("calling to WorktaskClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*WorktaskCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &WorktaskCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Worktask.
func (c *WorktaskClient) Update() *WorktaskUpdate {
	mutation := newWorktaskMutation(c.config, OpUpdate)
	return &WorktaskUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *WorktaskClient) UpdateOne(w *Worktask) *WorktaskUpdateOne {
	mutation := newWorktaskMutation(c.config, OpUpdateOne, withWorktask(w))
	return &WorktaskUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *WorktaskClient) UpdateOneID(id int) *WorktaskUpdateOne {
	mutation := newWorktaskMutation(c.config, OpUpdateOne, withWorktaskID(id))
	return &WorktaskUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Worktask.
func (c *WorktaskClient) Delete() *WorktaskDelete {
	mutation := newWorktaskMutation(c.config, OpDelete)
	return &WorktaskDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *WorktaskClient) DeleteOne(w *Worktask) *WorktaskDeleteOne {
	return c.DeleteOneID(w.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *WorktaskClient) DeleteOneID(id int) *WorktaskDeleteOne {
	builder := c.Delete().Where(worktask.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &WorktaskDeleteOne{builder}
}

// Query returns a query builder for Worktask.
func (c *WorktaskClient) Query() *WorktaskQuery {
	return &WorktaskQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeWorktask},
		inters: c.Interceptors(),
	}
}

// Get returns a Worktask entity by its id.
func (c *WorktaskClient) Get(ctx context.Context, id int) (*Worktask, error) {
	return c.Query().Where(worktask.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *WorktaskClient) GetX(ctx context.Context, id int) *Worktask {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryCompany queries the company edge of a Worktask.
func (c *WorktaskClient) QueryCompany(w *Worktask) *CompanyQuery {
	query := (&CompanyClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := w.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(worktask.Table, worktask.FieldID, id),
			sqlgraph.To(company.Table, company.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, worktask.CompanyTable, worktask.CompanyColumn),
		)
		fromV = sqlgraph.Neighbors(w.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryCreatedBy queries the createdBy edge of a Worktask.
func (c *WorktaskClient) QueryCreatedBy(w *Worktask) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := w.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(worktask.Table, worktask.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, worktask.CreatedByTable, worktask.CreatedByColumn),
		)
		fromV = sqlgraph.Neighbors(w.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryAssignedTo queries the assignedTo edge of a Worktask.
func (c *WorktaskClient) QueryAssignedTo(w *Worktask) *EmployeeQuery {
	query := (&EmployeeClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := w.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(worktask.Table, worktask.FieldID, id),
			sqlgraph.To(employee.Table, employee.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, worktask.AssignedToTable, worktask.AssignedToPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(w.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryWorkShifts queries the workShifts edge of a Worktask.
func (c *WorktaskClient) QueryWorkShifts(w *Worktask) *WorkshiftQuery {
	query := (&WorkshiftClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := w.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(worktask.Table, worktask.FieldID, id),
			sqlgraph.To(workshift.Table, workshift.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, worktask.WorkShiftsTable, worktask.WorkShiftsColumn),
		)
		fromV = sqlgraph.Neighbors(w.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryWorkTags queries the workTags edge of a Worktask.
func (c *WorktaskClient) QueryWorkTags(w *Worktask) *WorktagQuery {
	query := (&WorktagClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := w.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(worktask.Table, worktask.FieldID, id),
			sqlgraph.To(worktag.Table, worktag.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, worktask.WorkTagsTable, worktask.WorkTagsPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(w.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *WorktaskClient) Hooks() []Hook {
	hooks := c.hooks.Worktask
	return append(hooks[:len(hooks):len(hooks)], worktask.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *WorktaskClient) Interceptors() []Interceptor {
	return c.inters.Worktask
}

func (c *WorktaskClient) mutate(ctx context.Context, m *WorktaskMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&WorktaskCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&WorktaskUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&WorktaskUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&WorktaskDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown Worktask mutation op: %q", m.Op())
	}
}

// hooks and interceptors per client, for fast access.
type (
	hooks struct {
		AccountingEntry, CashMovement, Company, Customer, Employee, File, Payable,
		Product, ProductMovement, Receivable, Supplier, Token, Treasury, User,
		UserRole, Workshift, Worktag, Worktask []ent.Hook
	}
	inters struct {
		AccountingEntry, CashMovement, Company, Customer, Employee, File, Payable,
		Product, ProductMovement, Receivable, Supplier, Token, Treasury, User,
		UserRole, Workshift, Worktag, Worktask []ent.Interceptor
	}
)
