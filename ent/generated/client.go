// Code generated by ent, DO NOT EDIT.

package generated

import (
	"context"
	"errors"
	"fmt"
	"log"
	"reflect"

	"mazza/ent/generated/migrate"

	"mazza/ent/generated/accountingentry"
	"mazza/ent/generated/company"
	"mazza/ent/generated/customer"
	"mazza/ent/generated/employee"
	"mazza/ent/generated/file"
	"mazza/ent/generated/payable"
	"mazza/ent/generated/product"
	"mazza/ent/generated/project"
	"mazza/ent/generated/projectmilestone"
	"mazza/ent/generated/projecttask"
	"mazza/ent/generated/receivable"
	"mazza/ent/generated/supplier"
	"mazza/ent/generated/token"
	"mazza/ent/generated/treasury"
	"mazza/ent/generated/user"
	"mazza/ent/generated/userrole"
	"mazza/ent/generated/workshift"

	"entgo.io/ent"
	"entgo.io/ent/dialect"
	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"

	stdsql "database/sql"
)

// Client is the client that holds all ent builders.
type Client struct {
	config
	// Schema is the client for creating, migrating and dropping schema.
	Schema *migrate.Schema
	// AccountingEntry is the client for interacting with the AccountingEntry builders.
	AccountingEntry *AccountingEntryClient
	// Company is the client for interacting with the Company builders.
	Company *CompanyClient
	// Customer is the client for interacting with the Customer builders.
	Customer *CustomerClient
	// Employee is the client for interacting with the Employee builders.
	Employee *EmployeeClient
	// File is the client for interacting with the File builders.
	File *FileClient
	// Payable is the client for interacting with the Payable builders.
	Payable *PayableClient
	// Product is the client for interacting with the Product builders.
	Product *ProductClient
	// Project is the client for interacting with the Project builders.
	Project *ProjectClient
	// ProjectMilestone is the client for interacting with the ProjectMilestone builders.
	ProjectMilestone *ProjectMilestoneClient
	// ProjectTask is the client for interacting with the ProjectTask builders.
	ProjectTask *ProjectTaskClient
	// Receivable is the client for interacting with the Receivable builders.
	Receivable *ReceivableClient
	// Supplier is the client for interacting with the Supplier builders.
	Supplier *SupplierClient
	// Token is the client for interacting with the Token builders.
	Token *TokenClient
	// Treasury is the client for interacting with the Treasury builders.
	Treasury *TreasuryClient
	// User is the client for interacting with the User builders.
	User *UserClient
	// UserRole is the client for interacting with the UserRole builders.
	UserRole *UserRoleClient
	// Workshift is the client for interacting with the Workshift builders.
	Workshift *WorkshiftClient
	// additional fields for node api
	tables tables
}

// NewClient creates a new client configured with the given options.
func NewClient(opts ...Option) *Client {
	client := &Client{config: newConfig(opts...)}
	client.init()
	return client
}

func (c *Client) init() {
	c.Schema = migrate.NewSchema(c.driver)
	c.AccountingEntry = NewAccountingEntryClient(c.config)
	c.Company = NewCompanyClient(c.config)
	c.Customer = NewCustomerClient(c.config)
	c.Employee = NewEmployeeClient(c.config)
	c.File = NewFileClient(c.config)
	c.Payable = NewPayableClient(c.config)
	c.Product = NewProductClient(c.config)
	c.Project = NewProjectClient(c.config)
	c.ProjectMilestone = NewProjectMilestoneClient(c.config)
	c.ProjectTask = NewProjectTaskClient(c.config)
	c.Receivable = NewReceivableClient(c.config)
	c.Supplier = NewSupplierClient(c.config)
	c.Token = NewTokenClient(c.config)
	c.Treasury = NewTreasuryClient(c.config)
	c.User = NewUserClient(c.config)
	c.UserRole = NewUserRoleClient(c.config)
	c.Workshift = NewWorkshiftClient(c.config)
}

type (
	// config is the configuration for the client and its builder.
	config struct {
		// driver used for executing database requests.
		driver dialect.Driver
		// debug enable a debug logging.
		debug bool
		// log used for logging on debug mode.
		log func(...any)
		// hooks to execute on mutations.
		hooks *hooks
		// interceptors to execute on queries.
		inters *inters
	}
	// Option function to configure the client.
	Option func(*config)
)

// newConfig creates a new config for the client.
func newConfig(opts ...Option) config {
	cfg := config{log: log.Println, hooks: &hooks{}, inters: &inters{}}
	cfg.options(opts...)
	return cfg
}

// options applies the options on the config object.
func (c *config) options(opts ...Option) {
	for _, opt := range opts {
		opt(c)
	}
	if c.debug {
		c.driver = dialect.Debug(c.driver, c.log)
	}
}

// Debug enables debug logging on the ent.Driver.
func Debug() Option {
	return func(c *config) {
		c.debug = true
	}
}

// Log sets the logging function for debug mode.
func Log(fn func(...any)) Option {
	return func(c *config) {
		c.log = fn
	}
}

// Driver configures the client driver.
func Driver(driver dialect.Driver) Option {
	return func(c *config) {
		c.driver = driver
	}
}

// Open opens a database/sql.DB specified by the driver name and
// the data source name, and returns a new client attached to it.
// Optional parameters can be added for configuring the client.
func Open(driverName, dataSourceName string, options ...Option) (*Client, error) {
	switch driverName {
	case dialect.MySQL, dialect.Postgres, dialect.SQLite:
		drv, err := sql.Open(driverName, dataSourceName)
		if err != nil {
			return nil, err
		}
		return NewClient(append(options, Driver(drv))...), nil
	default:
		return nil, fmt.Errorf("unsupported driver: %q", driverName)
	}
}

// ErrTxStarted is returned when trying to start a new transaction from a transactional client.
var ErrTxStarted = errors.New("generated: cannot start a transaction within a transaction")

// Tx returns a new transactional client. The provided context
// is used until the transaction is committed or rolled back.
func (c *Client) Tx(ctx context.Context) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, ErrTxStarted
	}
	tx, err := newTx(ctx, c.driver)
	if err != nil {
		return nil, fmt.Errorf("generated: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = tx
	return &Tx{
		ctx:              ctx,
		config:           cfg,
		AccountingEntry:  NewAccountingEntryClient(cfg),
		Company:          NewCompanyClient(cfg),
		Customer:         NewCustomerClient(cfg),
		Employee:         NewEmployeeClient(cfg),
		File:             NewFileClient(cfg),
		Payable:          NewPayableClient(cfg),
		Product:          NewProductClient(cfg),
		Project:          NewProjectClient(cfg),
		ProjectMilestone: NewProjectMilestoneClient(cfg),
		ProjectTask:      NewProjectTaskClient(cfg),
		Receivable:       NewReceivableClient(cfg),
		Supplier:         NewSupplierClient(cfg),
		Token:            NewTokenClient(cfg),
		Treasury:         NewTreasuryClient(cfg),
		User:             NewUserClient(cfg),
		UserRole:         NewUserRoleClient(cfg),
		Workshift:        NewWorkshiftClient(cfg),
	}, nil
}

// BeginTx returns a transactional client with specified options.
func (c *Client) BeginTx(ctx context.Context, opts *sql.TxOptions) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, errors.New("ent: cannot start a transaction within a transaction")
	}
	tx, err := c.driver.(interface {
		BeginTx(context.Context, *sql.TxOptions) (dialect.Tx, error)
	}).BeginTx(ctx, opts)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = &txDriver{tx: tx, drv: c.driver}
	return &Tx{
		ctx:              ctx,
		config:           cfg,
		AccountingEntry:  NewAccountingEntryClient(cfg),
		Company:          NewCompanyClient(cfg),
		Customer:         NewCustomerClient(cfg),
		Employee:         NewEmployeeClient(cfg),
		File:             NewFileClient(cfg),
		Payable:          NewPayableClient(cfg),
		Product:          NewProductClient(cfg),
		Project:          NewProjectClient(cfg),
		ProjectMilestone: NewProjectMilestoneClient(cfg),
		ProjectTask:      NewProjectTaskClient(cfg),
		Receivable:       NewReceivableClient(cfg),
		Supplier:         NewSupplierClient(cfg),
		Token:            NewTokenClient(cfg),
		Treasury:         NewTreasuryClient(cfg),
		User:             NewUserClient(cfg),
		UserRole:         NewUserRoleClient(cfg),
		Workshift:        NewWorkshiftClient(cfg),
	}, nil
}

// Debug returns a new debug-client. It's used to get verbose logging on specific operations.
//
//	client.Debug().
//		AccountingEntry.
//		Query().
//		Count(ctx)
func (c *Client) Debug() *Client {
	if c.debug {
		return c
	}
	cfg := c.config
	cfg.driver = dialect.Debug(c.driver, c.log)
	client := &Client{config: cfg}
	client.init()
	return client
}

// Close closes the database connection and prevents new queries from starting.
func (c *Client) Close() error {
	return c.driver.Close()
}

// Use adds the mutation hooks to all the entity clients.
// In order to add hooks to a specific client, call: `client.Node.Use(...)`.
func (c *Client) Use(hooks ...Hook) {
	for _, n := range []interface{ Use(...Hook) }{
		c.AccountingEntry, c.Company, c.Customer, c.Employee, c.File, c.Payable,
		c.Product, c.Project, c.ProjectMilestone, c.ProjectTask, c.Receivable,
		c.Supplier, c.Token, c.Treasury, c.User, c.UserRole, c.Workshift,
	} {
		n.Use(hooks...)
	}
}

// Intercept adds the query interceptors to all the entity clients.
// In order to add interceptors to a specific client, call: `client.Node.Intercept(...)`.
func (c *Client) Intercept(interceptors ...Interceptor) {
	for _, n := range []interface{ Intercept(...Interceptor) }{
		c.AccountingEntry, c.Company, c.Customer, c.Employee, c.File, c.Payable,
		c.Product, c.Project, c.ProjectMilestone, c.ProjectTask, c.Receivable,
		c.Supplier, c.Token, c.Treasury, c.User, c.UserRole, c.Workshift,
	} {
		n.Intercept(interceptors...)
	}
}

// Mutate implements the ent.Mutator interface.
func (c *Client) Mutate(ctx context.Context, m Mutation) (Value, error) {
	switch m := m.(type) {
	case *AccountingEntryMutation:
		return c.AccountingEntry.mutate(ctx, m)
	case *CompanyMutation:
		return c.Company.mutate(ctx, m)
	case *CustomerMutation:
		return c.Customer.mutate(ctx, m)
	case *EmployeeMutation:
		return c.Employee.mutate(ctx, m)
	case *FileMutation:
		return c.File.mutate(ctx, m)
	case *PayableMutation:
		return c.Payable.mutate(ctx, m)
	case *ProductMutation:
		return c.Product.mutate(ctx, m)
	case *ProjectMutation:
		return c.Project.mutate(ctx, m)
	case *ProjectMilestoneMutation:
		return c.ProjectMilestone.mutate(ctx, m)
	case *ProjectTaskMutation:
		return c.ProjectTask.mutate(ctx, m)
	case *ReceivableMutation:
		return c.Receivable.mutate(ctx, m)
	case *SupplierMutation:
		return c.Supplier.mutate(ctx, m)
	case *TokenMutation:
		return c.Token.mutate(ctx, m)
	case *TreasuryMutation:
		return c.Treasury.mutate(ctx, m)
	case *UserMutation:
		return c.User.mutate(ctx, m)
	case *UserRoleMutation:
		return c.UserRole.mutate(ctx, m)
	case *WorkshiftMutation:
		return c.Workshift.mutate(ctx, m)
	default:
		return nil, fmt.Errorf("generated: unknown mutation type %T", m)
	}
}

// AccountingEntryClient is a client for the AccountingEntry schema.
type AccountingEntryClient struct {
	config
}

// NewAccountingEntryClient returns a client for the AccountingEntry from the given config.
func NewAccountingEntryClient(c config) *AccountingEntryClient {
	return &AccountingEntryClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `accountingentry.Hooks(f(g(h())))`.
func (c *AccountingEntryClient) Use(hooks ...Hook) {
	c.hooks.AccountingEntry = append(c.hooks.AccountingEntry, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `accountingentry.Intercept(f(g(h())))`.
func (c *AccountingEntryClient) Intercept(interceptors ...Interceptor) {
	c.inters.AccountingEntry = append(c.inters.AccountingEntry, interceptors...)
}

// Create returns a builder for creating a AccountingEntry entity.
func (c *AccountingEntryClient) Create() *AccountingEntryCreate {
	mutation := newAccountingEntryMutation(c.config, OpCreate)
	return &AccountingEntryCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of AccountingEntry entities.
func (c *AccountingEntryClient) CreateBulk(builders ...*AccountingEntryCreate) *AccountingEntryCreateBulk {
	return &AccountingEntryCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *AccountingEntryClient) MapCreateBulk(slice any, setFunc func(*AccountingEntryCreate, int)) *AccountingEntryCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &AccountingEntryCreateBulk{err: fmt.Errorf("calling to AccountingEntryClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*AccountingEntryCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &AccountingEntryCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for AccountingEntry.
func (c *AccountingEntryClient) Update() *AccountingEntryUpdate {
	mutation := newAccountingEntryMutation(c.config, OpUpdate)
	return &AccountingEntryUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *AccountingEntryClient) UpdateOne(ae *AccountingEntry) *AccountingEntryUpdateOne {
	mutation := newAccountingEntryMutation(c.config, OpUpdateOne, withAccountingEntry(ae))
	return &AccountingEntryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *AccountingEntryClient) UpdateOneID(id int) *AccountingEntryUpdateOne {
	mutation := newAccountingEntryMutation(c.config, OpUpdateOne, withAccountingEntryID(id))
	return &AccountingEntryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for AccountingEntry.
func (c *AccountingEntryClient) Delete() *AccountingEntryDelete {
	mutation := newAccountingEntryMutation(c.config, OpDelete)
	return &AccountingEntryDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *AccountingEntryClient) DeleteOne(ae *AccountingEntry) *AccountingEntryDeleteOne {
	return c.DeleteOneID(ae.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *AccountingEntryClient) DeleteOneID(id int) *AccountingEntryDeleteOne {
	builder := c.Delete().Where(accountingentry.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &AccountingEntryDeleteOne{builder}
}

// Query returns a query builder for AccountingEntry.
func (c *AccountingEntryClient) Query() *AccountingEntryQuery {
	return &AccountingEntryQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeAccountingEntry},
		inters: c.Interceptors(),
	}
}

// Get returns a AccountingEntry entity by its id.
func (c *AccountingEntryClient) Get(ctx context.Context, id int) (*AccountingEntry, error) {
	return c.Query().Where(accountingentry.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *AccountingEntryClient) GetX(ctx context.Context, id int) *AccountingEntry {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryCompany queries the company edge of a AccountingEntry.
func (c *AccountingEntryClient) QueryCompany(ae *AccountingEntry) *CompanyQuery {
	query := (&CompanyClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ae.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(accountingentry.Table, accountingentry.FieldID, id),
			sqlgraph.To(company.Table, company.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, accountingentry.CompanyTable, accountingentry.CompanyColumn),
		)
		fromV = sqlgraph.Neighbors(ae.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryUser queries the user edge of a AccountingEntry.
func (c *AccountingEntryClient) QueryUser(ae *AccountingEntry) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ae.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(accountingentry.Table, accountingentry.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, accountingentry.UserTable, accountingentry.UserColumn),
		)
		fromV = sqlgraph.Neighbors(ae.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *AccountingEntryClient) Hooks() []Hook {
	return c.hooks.AccountingEntry
}

// Interceptors returns the client interceptors.
func (c *AccountingEntryClient) Interceptors() []Interceptor {
	return c.inters.AccountingEntry
}

func (c *AccountingEntryClient) mutate(ctx context.Context, m *AccountingEntryMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&AccountingEntryCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&AccountingEntryUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&AccountingEntryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&AccountingEntryDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown AccountingEntry mutation op: %q", m.Op())
	}
}

// CompanyClient is a client for the Company schema.
type CompanyClient struct {
	config
}

// NewCompanyClient returns a client for the Company from the given config.
func NewCompanyClient(c config) *CompanyClient {
	return &CompanyClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `company.Hooks(f(g(h())))`.
func (c *CompanyClient) Use(hooks ...Hook) {
	c.hooks.Company = append(c.hooks.Company, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `company.Intercept(f(g(h())))`.
func (c *CompanyClient) Intercept(interceptors ...Interceptor) {
	c.inters.Company = append(c.inters.Company, interceptors...)
}

// Create returns a builder for creating a Company entity.
func (c *CompanyClient) Create() *CompanyCreate {
	mutation := newCompanyMutation(c.config, OpCreate)
	return &CompanyCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Company entities.
func (c *CompanyClient) CreateBulk(builders ...*CompanyCreate) *CompanyCreateBulk {
	return &CompanyCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *CompanyClient) MapCreateBulk(slice any, setFunc func(*CompanyCreate, int)) *CompanyCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &CompanyCreateBulk{err: fmt.Errorf("calling to CompanyClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*CompanyCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &CompanyCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Company.
func (c *CompanyClient) Update() *CompanyUpdate {
	mutation := newCompanyMutation(c.config, OpUpdate)
	return &CompanyUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *CompanyClient) UpdateOne(co *Company) *CompanyUpdateOne {
	mutation := newCompanyMutation(c.config, OpUpdateOne, withCompany(co))
	return &CompanyUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *CompanyClient) UpdateOneID(id int) *CompanyUpdateOne {
	mutation := newCompanyMutation(c.config, OpUpdateOne, withCompanyID(id))
	return &CompanyUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Company.
func (c *CompanyClient) Delete() *CompanyDelete {
	mutation := newCompanyMutation(c.config, OpDelete)
	return &CompanyDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *CompanyClient) DeleteOne(co *Company) *CompanyDeleteOne {
	return c.DeleteOneID(co.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *CompanyClient) DeleteOneID(id int) *CompanyDeleteOne {
	builder := c.Delete().Where(company.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &CompanyDeleteOne{builder}
}

// Query returns a query builder for Company.
func (c *CompanyClient) Query() *CompanyQuery {
	return &CompanyQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeCompany},
		inters: c.Interceptors(),
	}
}

// Get returns a Company entity by its id.
func (c *CompanyClient) Get(ctx context.Context, id int) (*Company, error) {
	return c.Query().Where(company.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *CompanyClient) GetX(ctx context.Context, id int) *Company {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryAvailableRoles queries the availableRoles edge of a Company.
func (c *CompanyClient) QueryAvailableRoles(co *Company) *UserRoleQuery {
	query := (&UserRoleClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := co.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(company.Table, company.FieldID, id),
			sqlgraph.To(userrole.Table, userrole.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, company.AvailableRolesTable, company.AvailableRolesColumn),
		)
		fromV = sqlgraph.Neighbors(co.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryAccountingEntries queries the accountingEntries edge of a Company.
func (c *CompanyClient) QueryAccountingEntries(co *Company) *AccountingEntryQuery {
	query := (&AccountingEntryClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := co.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(company.Table, company.FieldID, id),
			sqlgraph.To(accountingentry.Table, accountingentry.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, company.AccountingEntriesTable, company.AccountingEntriesColumn),
		)
		fromV = sqlgraph.Neighbors(co.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryCustomers queries the customers edge of a Company.
func (c *CompanyClient) QueryCustomers(co *Company) *CustomerQuery {
	query := (&CustomerClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := co.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(company.Table, company.FieldID, id),
			sqlgraph.To(customer.Table, customer.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, company.CustomersTable, company.CustomersColumn),
		)
		fromV = sqlgraph.Neighbors(co.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryEmployees queries the employees edge of a Company.
func (c *CompanyClient) QueryEmployees(co *Company) *EmployeeQuery {
	query := (&EmployeeClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := co.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(company.Table, company.FieldID, id),
			sqlgraph.To(employee.Table, employee.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, company.EmployeesTable, company.EmployeesColumn),
		)
		fromV = sqlgraph.Neighbors(co.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryFiles queries the files edge of a Company.
func (c *CompanyClient) QueryFiles(co *Company) *FileQuery {
	query := (&FileClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := co.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(company.Table, company.FieldID, id),
			sqlgraph.To(file.Table, file.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, company.FilesTable, company.FilesColumn),
		)
		fromV = sqlgraph.Neighbors(co.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryProducts queries the products edge of a Company.
func (c *CompanyClient) QueryProducts(co *Company) *ProductQuery {
	query := (&ProductClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := co.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(company.Table, company.FieldID, id),
			sqlgraph.To(product.Table, product.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, company.ProductsTable, company.ProductsColumn),
		)
		fromV = sqlgraph.Neighbors(co.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryProjects queries the projects edge of a Company.
func (c *CompanyClient) QueryProjects(co *Company) *ProjectQuery {
	query := (&ProjectClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := co.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(company.Table, company.FieldID, id),
			sqlgraph.To(project.Table, project.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, company.ProjectsTable, company.ProjectsColumn),
		)
		fromV = sqlgraph.Neighbors(co.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryPayables queries the payables edge of a Company.
func (c *CompanyClient) QueryPayables(co *Company) *PayableQuery {
	query := (&PayableClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := co.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(company.Table, company.FieldID, id),
			sqlgraph.To(payable.Table, payable.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, company.PayablesTable, company.PayablesColumn),
		)
		fromV = sqlgraph.Neighbors(co.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryReceivables queries the receivables edge of a Company.
func (c *CompanyClient) QueryReceivables(co *Company) *ReceivableQuery {
	query := (&ReceivableClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := co.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(company.Table, company.FieldID, id),
			sqlgraph.To(receivable.Table, receivable.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, company.ReceivablesTable, company.ReceivablesColumn),
		)
		fromV = sqlgraph.Neighbors(co.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QuerySuppliers queries the suppliers edge of a Company.
func (c *CompanyClient) QuerySuppliers(co *Company) *SupplierQuery {
	query := (&SupplierClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := co.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(company.Table, company.FieldID, id),
			sqlgraph.To(supplier.Table, supplier.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, company.SuppliersTable, company.SuppliersColumn),
		)
		fromV = sqlgraph.Neighbors(co.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTokens queries the tokens edge of a Company.
func (c *CompanyClient) QueryTokens(co *Company) *TokenQuery {
	query := (&TokenClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := co.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(company.Table, company.FieldID, id),
			sqlgraph.To(token.Table, token.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, company.TokensTable, company.TokensColumn),
		)
		fromV = sqlgraph.Neighbors(co.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTreasuries queries the treasuries edge of a Company.
func (c *CompanyClient) QueryTreasuries(co *Company) *TreasuryQuery {
	query := (&TreasuryClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := co.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(company.Table, company.FieldID, id),
			sqlgraph.To(treasury.Table, treasury.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, company.TreasuriesTable, company.TreasuriesColumn),
		)
		fromV = sqlgraph.Neighbors(co.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryWorkShifts queries the workShifts edge of a Company.
func (c *CompanyClient) QueryWorkShifts(co *Company) *WorkshiftQuery {
	query := (&WorkshiftClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := co.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(company.Table, company.FieldID, id),
			sqlgraph.To(workshift.Table, workshift.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, company.WorkShiftsTable, company.WorkShiftsColumn),
		)
		fromV = sqlgraph.Neighbors(co.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryUsers queries the users edge of a Company.
func (c *CompanyClient) QueryUsers(co *Company) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := co.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(company.Table, company.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, company.UsersTable, company.UsersPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(co.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryDaughterCompanies queries the daughterCompanies edge of a Company.
func (c *CompanyClient) QueryDaughterCompanies(co *Company) *CompanyQuery {
	query := (&CompanyClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := co.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(company.Table, company.FieldID, id),
			sqlgraph.To(company.Table, company.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, company.DaughterCompaniesTable, company.DaughterCompaniesColumn),
		)
		fromV = sqlgraph.Neighbors(co.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryParentCompany queries the parentCompany edge of a Company.
func (c *CompanyClient) QueryParentCompany(co *Company) *CompanyQuery {
	query := (&CompanyClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := co.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(company.Table, company.FieldID, id),
			sqlgraph.To(company.Table, company.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, company.ParentCompanyTable, company.ParentCompanyColumn),
		)
		fromV = sqlgraph.Neighbors(co.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *CompanyClient) Hooks() []Hook {
	return c.hooks.Company
}

// Interceptors returns the client interceptors.
func (c *CompanyClient) Interceptors() []Interceptor {
	return c.inters.Company
}

func (c *CompanyClient) mutate(ctx context.Context, m *CompanyMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&CompanyCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&CompanyUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&CompanyUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&CompanyDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown Company mutation op: %q", m.Op())
	}
}

// CustomerClient is a client for the Customer schema.
type CustomerClient struct {
	config
}

// NewCustomerClient returns a client for the Customer from the given config.
func NewCustomerClient(c config) *CustomerClient {
	return &CustomerClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `customer.Hooks(f(g(h())))`.
func (c *CustomerClient) Use(hooks ...Hook) {
	c.hooks.Customer = append(c.hooks.Customer, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `customer.Intercept(f(g(h())))`.
func (c *CustomerClient) Intercept(interceptors ...Interceptor) {
	c.inters.Customer = append(c.inters.Customer, interceptors...)
}

// Create returns a builder for creating a Customer entity.
func (c *CustomerClient) Create() *CustomerCreate {
	mutation := newCustomerMutation(c.config, OpCreate)
	return &CustomerCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Customer entities.
func (c *CustomerClient) CreateBulk(builders ...*CustomerCreate) *CustomerCreateBulk {
	return &CustomerCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *CustomerClient) MapCreateBulk(slice any, setFunc func(*CustomerCreate, int)) *CustomerCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &CustomerCreateBulk{err: fmt.Errorf("calling to CustomerClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*CustomerCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &CustomerCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Customer.
func (c *CustomerClient) Update() *CustomerUpdate {
	mutation := newCustomerMutation(c.config, OpUpdate)
	return &CustomerUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *CustomerClient) UpdateOne(cu *Customer) *CustomerUpdateOne {
	mutation := newCustomerMutation(c.config, OpUpdateOne, withCustomer(cu))
	return &CustomerUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *CustomerClient) UpdateOneID(id int) *CustomerUpdateOne {
	mutation := newCustomerMutation(c.config, OpUpdateOne, withCustomerID(id))
	return &CustomerUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Customer.
func (c *CustomerClient) Delete() *CustomerDelete {
	mutation := newCustomerMutation(c.config, OpDelete)
	return &CustomerDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *CustomerClient) DeleteOne(cu *Customer) *CustomerDeleteOne {
	return c.DeleteOneID(cu.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *CustomerClient) DeleteOneID(id int) *CustomerDeleteOne {
	builder := c.Delete().Where(customer.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &CustomerDeleteOne{builder}
}

// Query returns a query builder for Customer.
func (c *CustomerClient) Query() *CustomerQuery {
	return &CustomerQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeCustomer},
		inters: c.Interceptors(),
	}
}

// Get returns a Customer entity by its id.
func (c *CustomerClient) Get(ctx context.Context, id int) (*Customer, error) {
	return c.Query().Where(customer.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *CustomerClient) GetX(ctx context.Context, id int) *Customer {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryCompany queries the company edge of a Customer.
func (c *CustomerClient) QueryCompany(cu *Customer) *CompanyQuery {
	query := (&CompanyClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := cu.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(customer.Table, customer.FieldID, id),
			sqlgraph.To(company.Table, company.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, customer.CompanyTable, customer.CompanyColumn),
		)
		fromV = sqlgraph.Neighbors(cu.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryReceivables queries the receivables edge of a Customer.
func (c *CustomerClient) QueryReceivables(cu *Customer) *ReceivableQuery {
	query := (&ReceivableClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := cu.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(customer.Table, customer.FieldID, id),
			sqlgraph.To(receivable.Table, receivable.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, customer.ReceivablesTable, customer.ReceivablesColumn),
		)
		fromV = sqlgraph.Neighbors(cu.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *CustomerClient) Hooks() []Hook {
	return c.hooks.Customer
}

// Interceptors returns the client interceptors.
func (c *CustomerClient) Interceptors() []Interceptor {
	return c.inters.Customer
}

func (c *CustomerClient) mutate(ctx context.Context, m *CustomerMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&CustomerCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&CustomerUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&CustomerUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&CustomerDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown Customer mutation op: %q", m.Op())
	}
}

// EmployeeClient is a client for the Employee schema.
type EmployeeClient struct {
	config
}

// NewEmployeeClient returns a client for the Employee from the given config.
func NewEmployeeClient(c config) *EmployeeClient {
	return &EmployeeClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `employee.Hooks(f(g(h())))`.
func (c *EmployeeClient) Use(hooks ...Hook) {
	c.hooks.Employee = append(c.hooks.Employee, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `employee.Intercept(f(g(h())))`.
func (c *EmployeeClient) Intercept(interceptors ...Interceptor) {
	c.inters.Employee = append(c.inters.Employee, interceptors...)
}

// Create returns a builder for creating a Employee entity.
func (c *EmployeeClient) Create() *EmployeeCreate {
	mutation := newEmployeeMutation(c.config, OpCreate)
	return &EmployeeCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Employee entities.
func (c *EmployeeClient) CreateBulk(builders ...*EmployeeCreate) *EmployeeCreateBulk {
	return &EmployeeCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *EmployeeClient) MapCreateBulk(slice any, setFunc func(*EmployeeCreate, int)) *EmployeeCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &EmployeeCreateBulk{err: fmt.Errorf("calling to EmployeeClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*EmployeeCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &EmployeeCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Employee.
func (c *EmployeeClient) Update() *EmployeeUpdate {
	mutation := newEmployeeMutation(c.config, OpUpdate)
	return &EmployeeUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *EmployeeClient) UpdateOne(e *Employee) *EmployeeUpdateOne {
	mutation := newEmployeeMutation(c.config, OpUpdateOne, withEmployee(e))
	return &EmployeeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *EmployeeClient) UpdateOneID(id int) *EmployeeUpdateOne {
	mutation := newEmployeeMutation(c.config, OpUpdateOne, withEmployeeID(id))
	return &EmployeeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Employee.
func (c *EmployeeClient) Delete() *EmployeeDelete {
	mutation := newEmployeeMutation(c.config, OpDelete)
	return &EmployeeDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *EmployeeClient) DeleteOne(e *Employee) *EmployeeDeleteOne {
	return c.DeleteOneID(e.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *EmployeeClient) DeleteOneID(id int) *EmployeeDeleteOne {
	builder := c.Delete().Where(employee.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &EmployeeDeleteOne{builder}
}

// Query returns a query builder for Employee.
func (c *EmployeeClient) Query() *EmployeeQuery {
	return &EmployeeQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeEmployee},
		inters: c.Interceptors(),
	}
}

// Get returns a Employee entity by its id.
func (c *EmployeeClient) Get(ctx context.Context, id int) (*Employee, error) {
	return c.Query().Where(employee.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *EmployeeClient) GetX(ctx context.Context, id int) *Employee {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryCompany queries the company edge of a Employee.
func (c *EmployeeClient) QueryCompany(e *Employee) *CompanyQuery {
	query := (&CompanyClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := e.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(employee.Table, employee.FieldID, id),
			sqlgraph.To(company.Table, company.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, employee.CompanyTable, employee.CompanyColumn),
		)
		fromV = sqlgraph.Neighbors(e.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryUser queries the user edge of a Employee.
func (c *EmployeeClient) QueryUser(e *Employee) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := e.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(employee.Table, employee.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, true, employee.UserTable, employee.UserColumn),
		)
		fromV = sqlgraph.Neighbors(e.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *EmployeeClient) Hooks() []Hook {
	return c.hooks.Employee
}

// Interceptors returns the client interceptors.
func (c *EmployeeClient) Interceptors() []Interceptor {
	return c.inters.Employee
}

func (c *EmployeeClient) mutate(ctx context.Context, m *EmployeeMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&EmployeeCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&EmployeeUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&EmployeeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&EmployeeDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown Employee mutation op: %q", m.Op())
	}
}

// FileClient is a client for the File schema.
type FileClient struct {
	config
}

// NewFileClient returns a client for the File from the given config.
func NewFileClient(c config) *FileClient {
	return &FileClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `file.Hooks(f(g(h())))`.
func (c *FileClient) Use(hooks ...Hook) {
	c.hooks.File = append(c.hooks.File, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `file.Intercept(f(g(h())))`.
func (c *FileClient) Intercept(interceptors ...Interceptor) {
	c.inters.File = append(c.inters.File, interceptors...)
}

// Create returns a builder for creating a File entity.
func (c *FileClient) Create() *FileCreate {
	mutation := newFileMutation(c.config, OpCreate)
	return &FileCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of File entities.
func (c *FileClient) CreateBulk(builders ...*FileCreate) *FileCreateBulk {
	return &FileCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *FileClient) MapCreateBulk(slice any, setFunc func(*FileCreate, int)) *FileCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &FileCreateBulk{err: fmt.Errorf("calling to FileClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*FileCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &FileCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for File.
func (c *FileClient) Update() *FileUpdate {
	mutation := newFileMutation(c.config, OpUpdate)
	return &FileUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *FileClient) UpdateOne(f *File) *FileUpdateOne {
	mutation := newFileMutation(c.config, OpUpdateOne, withFile(f))
	return &FileUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *FileClient) UpdateOneID(id int) *FileUpdateOne {
	mutation := newFileMutation(c.config, OpUpdateOne, withFileID(id))
	return &FileUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for File.
func (c *FileClient) Delete() *FileDelete {
	mutation := newFileMutation(c.config, OpDelete)
	return &FileDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *FileClient) DeleteOne(f *File) *FileDeleteOne {
	return c.DeleteOneID(f.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *FileClient) DeleteOneID(id int) *FileDeleteOne {
	builder := c.Delete().Where(file.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &FileDeleteOne{builder}
}

// Query returns a query builder for File.
func (c *FileClient) Query() *FileQuery {
	return &FileQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeFile},
		inters: c.Interceptors(),
	}
}

// Get returns a File entity by its id.
func (c *FileClient) Get(ctx context.Context, id int) (*File, error) {
	return c.Query().Where(file.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *FileClient) GetX(ctx context.Context, id int) *File {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryCompany queries the company edge of a File.
func (c *FileClient) QueryCompany(f *File) *CompanyQuery {
	query := (&CompanyClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := f.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(file.Table, file.FieldID, id),
			sqlgraph.To(company.Table, company.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, file.CompanyTable, file.CompanyColumn),
		)
		fromV = sqlgraph.Neighbors(f.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *FileClient) Hooks() []Hook {
	return c.hooks.File
}

// Interceptors returns the client interceptors.
func (c *FileClient) Interceptors() []Interceptor {
	return c.inters.File
}

func (c *FileClient) mutate(ctx context.Context, m *FileMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&FileCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&FileUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&FileUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&FileDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown File mutation op: %q", m.Op())
	}
}

// PayableClient is a client for the Payable schema.
type PayableClient struct {
	config
}

// NewPayableClient returns a client for the Payable from the given config.
func NewPayableClient(c config) *PayableClient {
	return &PayableClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `payable.Hooks(f(g(h())))`.
func (c *PayableClient) Use(hooks ...Hook) {
	c.hooks.Payable = append(c.hooks.Payable, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `payable.Intercept(f(g(h())))`.
func (c *PayableClient) Intercept(interceptors ...Interceptor) {
	c.inters.Payable = append(c.inters.Payable, interceptors...)
}

// Create returns a builder for creating a Payable entity.
func (c *PayableClient) Create() *PayableCreate {
	mutation := newPayableMutation(c.config, OpCreate)
	return &PayableCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Payable entities.
func (c *PayableClient) CreateBulk(builders ...*PayableCreate) *PayableCreateBulk {
	return &PayableCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *PayableClient) MapCreateBulk(slice any, setFunc func(*PayableCreate, int)) *PayableCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &PayableCreateBulk{err: fmt.Errorf("calling to PayableClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*PayableCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &PayableCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Payable.
func (c *PayableClient) Update() *PayableUpdate {
	mutation := newPayableMutation(c.config, OpUpdate)
	return &PayableUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *PayableClient) UpdateOne(pa *Payable) *PayableUpdateOne {
	mutation := newPayableMutation(c.config, OpUpdateOne, withPayable(pa))
	return &PayableUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *PayableClient) UpdateOneID(id int) *PayableUpdateOne {
	mutation := newPayableMutation(c.config, OpUpdateOne, withPayableID(id))
	return &PayableUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Payable.
func (c *PayableClient) Delete() *PayableDelete {
	mutation := newPayableMutation(c.config, OpDelete)
	return &PayableDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *PayableClient) DeleteOne(pa *Payable) *PayableDeleteOne {
	return c.DeleteOneID(pa.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *PayableClient) DeleteOneID(id int) *PayableDeleteOne {
	builder := c.Delete().Where(payable.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &PayableDeleteOne{builder}
}

// Query returns a query builder for Payable.
func (c *PayableClient) Query() *PayableQuery {
	return &PayableQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypePayable},
		inters: c.Interceptors(),
	}
}

// Get returns a Payable entity by its id.
func (c *PayableClient) Get(ctx context.Context, id int) (*Payable, error) {
	return c.Query().Where(payable.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *PayableClient) GetX(ctx context.Context, id int) *Payable {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryCompany queries the company edge of a Payable.
func (c *PayableClient) QueryCompany(pa *Payable) *CompanyQuery {
	query := (&CompanyClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pa.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(payable.Table, payable.FieldID, id),
			sqlgraph.To(company.Table, company.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, payable.CompanyTable, payable.CompanyColumn),
		)
		fromV = sqlgraph.Neighbors(pa.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *PayableClient) Hooks() []Hook {
	return c.hooks.Payable
}

// Interceptors returns the client interceptors.
func (c *PayableClient) Interceptors() []Interceptor {
	return c.inters.Payable
}

func (c *PayableClient) mutate(ctx context.Context, m *PayableMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&PayableCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&PayableUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&PayableUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&PayableDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown Payable mutation op: %q", m.Op())
	}
}

// ProductClient is a client for the Product schema.
type ProductClient struct {
	config
}

// NewProductClient returns a client for the Product from the given config.
func NewProductClient(c config) *ProductClient {
	return &ProductClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `product.Hooks(f(g(h())))`.
func (c *ProductClient) Use(hooks ...Hook) {
	c.hooks.Product = append(c.hooks.Product, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `product.Intercept(f(g(h())))`.
func (c *ProductClient) Intercept(interceptors ...Interceptor) {
	c.inters.Product = append(c.inters.Product, interceptors...)
}

// Create returns a builder for creating a Product entity.
func (c *ProductClient) Create() *ProductCreate {
	mutation := newProductMutation(c.config, OpCreate)
	return &ProductCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Product entities.
func (c *ProductClient) CreateBulk(builders ...*ProductCreate) *ProductCreateBulk {
	return &ProductCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ProductClient) MapCreateBulk(slice any, setFunc func(*ProductCreate, int)) *ProductCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ProductCreateBulk{err: fmt.Errorf("calling to ProductClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ProductCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ProductCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Product.
func (c *ProductClient) Update() *ProductUpdate {
	mutation := newProductMutation(c.config, OpUpdate)
	return &ProductUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ProductClient) UpdateOne(pr *Product) *ProductUpdateOne {
	mutation := newProductMutation(c.config, OpUpdateOne, withProduct(pr))
	return &ProductUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ProductClient) UpdateOneID(id int) *ProductUpdateOne {
	mutation := newProductMutation(c.config, OpUpdateOne, withProductID(id))
	return &ProductUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Product.
func (c *ProductClient) Delete() *ProductDelete {
	mutation := newProductMutation(c.config, OpDelete)
	return &ProductDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ProductClient) DeleteOne(pr *Product) *ProductDeleteOne {
	return c.DeleteOneID(pr.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ProductClient) DeleteOneID(id int) *ProductDeleteOne {
	builder := c.Delete().Where(product.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ProductDeleteOne{builder}
}

// Query returns a query builder for Product.
func (c *ProductClient) Query() *ProductQuery {
	return &ProductQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeProduct},
		inters: c.Interceptors(),
	}
}

// Get returns a Product entity by its id.
func (c *ProductClient) Get(ctx context.Context, id int) (*Product, error) {
	return c.Query().Where(product.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ProductClient) GetX(ctx context.Context, id int) *Product {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryCompany queries the company edge of a Product.
func (c *ProductClient) QueryCompany(pr *Product) *CompanyQuery {
	query := (&CompanyClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pr.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(product.Table, product.FieldID, id),
			sqlgraph.To(company.Table, company.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, product.CompanyTable, product.CompanyColumn),
		)
		fromV = sqlgraph.Neighbors(pr.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ProductClient) Hooks() []Hook {
	return c.hooks.Product
}

// Interceptors returns the client interceptors.
func (c *ProductClient) Interceptors() []Interceptor {
	return c.inters.Product
}

func (c *ProductClient) mutate(ctx context.Context, m *ProductMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ProductCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ProductUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ProductUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ProductDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown Product mutation op: %q", m.Op())
	}
}

// ProjectClient is a client for the Project schema.
type ProjectClient struct {
	config
}

// NewProjectClient returns a client for the Project from the given config.
func NewProjectClient(c config) *ProjectClient {
	return &ProjectClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `project.Hooks(f(g(h())))`.
func (c *ProjectClient) Use(hooks ...Hook) {
	c.hooks.Project = append(c.hooks.Project, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `project.Intercept(f(g(h())))`.
func (c *ProjectClient) Intercept(interceptors ...Interceptor) {
	c.inters.Project = append(c.inters.Project, interceptors...)
}

// Create returns a builder for creating a Project entity.
func (c *ProjectClient) Create() *ProjectCreate {
	mutation := newProjectMutation(c.config, OpCreate)
	return &ProjectCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Project entities.
func (c *ProjectClient) CreateBulk(builders ...*ProjectCreate) *ProjectCreateBulk {
	return &ProjectCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ProjectClient) MapCreateBulk(slice any, setFunc func(*ProjectCreate, int)) *ProjectCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ProjectCreateBulk{err: fmt.Errorf("calling to ProjectClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ProjectCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ProjectCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Project.
func (c *ProjectClient) Update() *ProjectUpdate {
	mutation := newProjectMutation(c.config, OpUpdate)
	return &ProjectUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ProjectClient) UpdateOne(pr *Project) *ProjectUpdateOne {
	mutation := newProjectMutation(c.config, OpUpdateOne, withProject(pr))
	return &ProjectUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ProjectClient) UpdateOneID(id int) *ProjectUpdateOne {
	mutation := newProjectMutation(c.config, OpUpdateOne, withProjectID(id))
	return &ProjectUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Project.
func (c *ProjectClient) Delete() *ProjectDelete {
	mutation := newProjectMutation(c.config, OpDelete)
	return &ProjectDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ProjectClient) DeleteOne(pr *Project) *ProjectDeleteOne {
	return c.DeleteOneID(pr.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ProjectClient) DeleteOneID(id int) *ProjectDeleteOne {
	builder := c.Delete().Where(project.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ProjectDeleteOne{builder}
}

// Query returns a query builder for Project.
func (c *ProjectClient) Query() *ProjectQuery {
	return &ProjectQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeProject},
		inters: c.Interceptors(),
	}
}

// Get returns a Project entity by its id.
func (c *ProjectClient) Get(ctx context.Context, id int) (*Project, error) {
	return c.Query().Where(project.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ProjectClient) GetX(ctx context.Context, id int) *Project {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryCompany queries the company edge of a Project.
func (c *ProjectClient) QueryCompany(pr *Project) *CompanyQuery {
	query := (&CompanyClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pr.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(project.Table, project.FieldID, id),
			sqlgraph.To(company.Table, company.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, project.CompanyTable, project.CompanyColumn),
		)
		fromV = sqlgraph.Neighbors(pr.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryCreatedBy queries the createdBy edge of a Project.
func (c *ProjectClient) QueryCreatedBy(pr *Project) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pr.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(project.Table, project.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, project.CreatedByTable, project.CreatedByColumn),
		)
		fromV = sqlgraph.Neighbors(pr.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryLeader queries the leader edge of a Project.
func (c *ProjectClient) QueryLeader(pr *Project) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pr.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(project.Table, project.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, project.LeaderTable, project.LeaderColumn),
		)
		fromV = sqlgraph.Neighbors(pr.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTasks queries the tasks edge of a Project.
func (c *ProjectClient) QueryTasks(pr *Project) *ProjectTaskQuery {
	query := (&ProjectTaskClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pr.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(project.Table, project.FieldID, id),
			sqlgraph.To(projecttask.Table, projecttask.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, project.TasksTable, project.TasksColumn),
		)
		fromV = sqlgraph.Neighbors(pr.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryMilestones queries the milestones edge of a Project.
func (c *ProjectClient) QueryMilestones(pr *Project) *ProjectMilestoneQuery {
	query := (&ProjectMilestoneClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pr.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(project.Table, project.FieldID, id),
			sqlgraph.To(projectmilestone.Table, projectmilestone.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, project.MilestonesTable, project.MilestonesColumn),
		)
		fromV = sqlgraph.Neighbors(pr.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ProjectClient) Hooks() []Hook {
	return c.hooks.Project
}

// Interceptors returns the client interceptors.
func (c *ProjectClient) Interceptors() []Interceptor {
	return c.inters.Project
}

func (c *ProjectClient) mutate(ctx context.Context, m *ProjectMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ProjectCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ProjectUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ProjectUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ProjectDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown Project mutation op: %q", m.Op())
	}
}

// ProjectMilestoneClient is a client for the ProjectMilestone schema.
type ProjectMilestoneClient struct {
	config
}

// NewProjectMilestoneClient returns a client for the ProjectMilestone from the given config.
func NewProjectMilestoneClient(c config) *ProjectMilestoneClient {
	return &ProjectMilestoneClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `projectmilestone.Hooks(f(g(h())))`.
func (c *ProjectMilestoneClient) Use(hooks ...Hook) {
	c.hooks.ProjectMilestone = append(c.hooks.ProjectMilestone, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `projectmilestone.Intercept(f(g(h())))`.
func (c *ProjectMilestoneClient) Intercept(interceptors ...Interceptor) {
	c.inters.ProjectMilestone = append(c.inters.ProjectMilestone, interceptors...)
}

// Create returns a builder for creating a ProjectMilestone entity.
func (c *ProjectMilestoneClient) Create() *ProjectMilestoneCreate {
	mutation := newProjectMilestoneMutation(c.config, OpCreate)
	return &ProjectMilestoneCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of ProjectMilestone entities.
func (c *ProjectMilestoneClient) CreateBulk(builders ...*ProjectMilestoneCreate) *ProjectMilestoneCreateBulk {
	return &ProjectMilestoneCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ProjectMilestoneClient) MapCreateBulk(slice any, setFunc func(*ProjectMilestoneCreate, int)) *ProjectMilestoneCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ProjectMilestoneCreateBulk{err: fmt.Errorf("calling to ProjectMilestoneClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ProjectMilestoneCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ProjectMilestoneCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for ProjectMilestone.
func (c *ProjectMilestoneClient) Update() *ProjectMilestoneUpdate {
	mutation := newProjectMilestoneMutation(c.config, OpUpdate)
	return &ProjectMilestoneUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ProjectMilestoneClient) UpdateOne(pm *ProjectMilestone) *ProjectMilestoneUpdateOne {
	mutation := newProjectMilestoneMutation(c.config, OpUpdateOne, withProjectMilestone(pm))
	return &ProjectMilestoneUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ProjectMilestoneClient) UpdateOneID(id int) *ProjectMilestoneUpdateOne {
	mutation := newProjectMilestoneMutation(c.config, OpUpdateOne, withProjectMilestoneID(id))
	return &ProjectMilestoneUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for ProjectMilestone.
func (c *ProjectMilestoneClient) Delete() *ProjectMilestoneDelete {
	mutation := newProjectMilestoneMutation(c.config, OpDelete)
	return &ProjectMilestoneDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ProjectMilestoneClient) DeleteOne(pm *ProjectMilestone) *ProjectMilestoneDeleteOne {
	return c.DeleteOneID(pm.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ProjectMilestoneClient) DeleteOneID(id int) *ProjectMilestoneDeleteOne {
	builder := c.Delete().Where(projectmilestone.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ProjectMilestoneDeleteOne{builder}
}

// Query returns a query builder for ProjectMilestone.
func (c *ProjectMilestoneClient) Query() *ProjectMilestoneQuery {
	return &ProjectMilestoneQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeProjectMilestone},
		inters: c.Interceptors(),
	}
}

// Get returns a ProjectMilestone entity by its id.
func (c *ProjectMilestoneClient) Get(ctx context.Context, id int) (*ProjectMilestone, error) {
	return c.Query().Where(projectmilestone.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ProjectMilestoneClient) GetX(ctx context.Context, id int) *ProjectMilestone {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryProject queries the project edge of a ProjectMilestone.
func (c *ProjectMilestoneClient) QueryProject(pm *ProjectMilestone) *ProjectQuery {
	query := (&ProjectClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pm.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(projectmilestone.Table, projectmilestone.FieldID, id),
			sqlgraph.To(project.Table, project.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, projectmilestone.ProjectTable, projectmilestone.ProjectColumn),
		)
		fromV = sqlgraph.Neighbors(pm.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ProjectMilestoneClient) Hooks() []Hook {
	return c.hooks.ProjectMilestone
}

// Interceptors returns the client interceptors.
func (c *ProjectMilestoneClient) Interceptors() []Interceptor {
	return c.inters.ProjectMilestone
}

func (c *ProjectMilestoneClient) mutate(ctx context.Context, m *ProjectMilestoneMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ProjectMilestoneCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ProjectMilestoneUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ProjectMilestoneUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ProjectMilestoneDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown ProjectMilestone mutation op: %q", m.Op())
	}
}

// ProjectTaskClient is a client for the ProjectTask schema.
type ProjectTaskClient struct {
	config
}

// NewProjectTaskClient returns a client for the ProjectTask from the given config.
func NewProjectTaskClient(c config) *ProjectTaskClient {
	return &ProjectTaskClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `projecttask.Hooks(f(g(h())))`.
func (c *ProjectTaskClient) Use(hooks ...Hook) {
	c.hooks.ProjectTask = append(c.hooks.ProjectTask, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `projecttask.Intercept(f(g(h())))`.
func (c *ProjectTaskClient) Intercept(interceptors ...Interceptor) {
	c.inters.ProjectTask = append(c.inters.ProjectTask, interceptors...)
}

// Create returns a builder for creating a ProjectTask entity.
func (c *ProjectTaskClient) Create() *ProjectTaskCreate {
	mutation := newProjectTaskMutation(c.config, OpCreate)
	return &ProjectTaskCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of ProjectTask entities.
func (c *ProjectTaskClient) CreateBulk(builders ...*ProjectTaskCreate) *ProjectTaskCreateBulk {
	return &ProjectTaskCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ProjectTaskClient) MapCreateBulk(slice any, setFunc func(*ProjectTaskCreate, int)) *ProjectTaskCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ProjectTaskCreateBulk{err: fmt.Errorf("calling to ProjectTaskClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ProjectTaskCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ProjectTaskCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for ProjectTask.
func (c *ProjectTaskClient) Update() *ProjectTaskUpdate {
	mutation := newProjectTaskMutation(c.config, OpUpdate)
	return &ProjectTaskUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ProjectTaskClient) UpdateOne(pt *ProjectTask) *ProjectTaskUpdateOne {
	mutation := newProjectTaskMutation(c.config, OpUpdateOne, withProjectTask(pt))
	return &ProjectTaskUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ProjectTaskClient) UpdateOneID(id int) *ProjectTaskUpdateOne {
	mutation := newProjectTaskMutation(c.config, OpUpdateOne, withProjectTaskID(id))
	return &ProjectTaskUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for ProjectTask.
func (c *ProjectTaskClient) Delete() *ProjectTaskDelete {
	mutation := newProjectTaskMutation(c.config, OpDelete)
	return &ProjectTaskDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ProjectTaskClient) DeleteOne(pt *ProjectTask) *ProjectTaskDeleteOne {
	return c.DeleteOneID(pt.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ProjectTaskClient) DeleteOneID(id int) *ProjectTaskDeleteOne {
	builder := c.Delete().Where(projecttask.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ProjectTaskDeleteOne{builder}
}

// Query returns a query builder for ProjectTask.
func (c *ProjectTaskClient) Query() *ProjectTaskQuery {
	return &ProjectTaskQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeProjectTask},
		inters: c.Interceptors(),
	}
}

// Get returns a ProjectTask entity by its id.
func (c *ProjectTaskClient) Get(ctx context.Context, id int) (*ProjectTask, error) {
	return c.Query().Where(projecttask.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ProjectTaskClient) GetX(ctx context.Context, id int) *ProjectTask {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryProject queries the project edge of a ProjectTask.
func (c *ProjectTaskClient) QueryProject(pt *ProjectTask) *ProjectQuery {
	query := (&ProjectClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pt.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(projecttask.Table, projecttask.FieldID, id),
			sqlgraph.To(project.Table, project.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, projecttask.ProjectTable, projecttask.ProjectColumn),
		)
		fromV = sqlgraph.Neighbors(pt.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryAssignee queries the assignee edge of a ProjectTask.
func (c *ProjectTaskClient) QueryAssignee(pt *ProjectTask) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pt.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(projecttask.Table, projecttask.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, projecttask.AssigneeTable, projecttask.AssigneeColumn),
		)
		fromV = sqlgraph.Neighbors(pt.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryParticipants queries the participants edge of a ProjectTask.
func (c *ProjectTaskClient) QueryParticipants(pt *ProjectTask) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pt.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(projecttask.Table, projecttask.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, projecttask.ParticipantsTable, projecttask.ParticipantsPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(pt.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryCreatedBy queries the createdBy edge of a ProjectTask.
func (c *ProjectTaskClient) QueryCreatedBy(pt *ProjectTask) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pt.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(projecttask.Table, projecttask.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, projecttask.CreatedByTable, projecttask.CreatedByColumn),
		)
		fromV = sqlgraph.Neighbors(pt.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryWorkShifts queries the workShifts edge of a ProjectTask.
func (c *ProjectTaskClient) QueryWorkShifts(pt *ProjectTask) *WorkshiftQuery {
	query := (&WorkshiftClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pt.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(projecttask.Table, projecttask.FieldID, id),
			sqlgraph.To(workshift.Table, workshift.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, projecttask.WorkShiftsTable, projecttask.WorkShiftsColumn),
		)
		fromV = sqlgraph.Neighbors(pt.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ProjectTaskClient) Hooks() []Hook {
	hooks := c.hooks.ProjectTask
	return append(hooks[:len(hooks):len(hooks)], projecttask.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *ProjectTaskClient) Interceptors() []Interceptor {
	return c.inters.ProjectTask
}

func (c *ProjectTaskClient) mutate(ctx context.Context, m *ProjectTaskMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ProjectTaskCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ProjectTaskUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ProjectTaskUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ProjectTaskDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown ProjectTask mutation op: %q", m.Op())
	}
}

// ReceivableClient is a client for the Receivable schema.
type ReceivableClient struct {
	config
}

// NewReceivableClient returns a client for the Receivable from the given config.
func NewReceivableClient(c config) *ReceivableClient {
	return &ReceivableClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `receivable.Hooks(f(g(h())))`.
func (c *ReceivableClient) Use(hooks ...Hook) {
	c.hooks.Receivable = append(c.hooks.Receivable, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `receivable.Intercept(f(g(h())))`.
func (c *ReceivableClient) Intercept(interceptors ...Interceptor) {
	c.inters.Receivable = append(c.inters.Receivable, interceptors...)
}

// Create returns a builder for creating a Receivable entity.
func (c *ReceivableClient) Create() *ReceivableCreate {
	mutation := newReceivableMutation(c.config, OpCreate)
	return &ReceivableCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Receivable entities.
func (c *ReceivableClient) CreateBulk(builders ...*ReceivableCreate) *ReceivableCreateBulk {
	return &ReceivableCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ReceivableClient) MapCreateBulk(slice any, setFunc func(*ReceivableCreate, int)) *ReceivableCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ReceivableCreateBulk{err: fmt.Errorf("calling to ReceivableClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ReceivableCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ReceivableCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Receivable.
func (c *ReceivableClient) Update() *ReceivableUpdate {
	mutation := newReceivableMutation(c.config, OpUpdate)
	return &ReceivableUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ReceivableClient) UpdateOne(r *Receivable) *ReceivableUpdateOne {
	mutation := newReceivableMutation(c.config, OpUpdateOne, withReceivable(r))
	return &ReceivableUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ReceivableClient) UpdateOneID(id int) *ReceivableUpdateOne {
	mutation := newReceivableMutation(c.config, OpUpdateOne, withReceivableID(id))
	return &ReceivableUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Receivable.
func (c *ReceivableClient) Delete() *ReceivableDelete {
	mutation := newReceivableMutation(c.config, OpDelete)
	return &ReceivableDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ReceivableClient) DeleteOne(r *Receivable) *ReceivableDeleteOne {
	return c.DeleteOneID(r.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ReceivableClient) DeleteOneID(id int) *ReceivableDeleteOne {
	builder := c.Delete().Where(receivable.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ReceivableDeleteOne{builder}
}

// Query returns a query builder for Receivable.
func (c *ReceivableClient) Query() *ReceivableQuery {
	return &ReceivableQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeReceivable},
		inters: c.Interceptors(),
	}
}

// Get returns a Receivable entity by its id.
func (c *ReceivableClient) Get(ctx context.Context, id int) (*Receivable, error) {
	return c.Query().Where(receivable.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ReceivableClient) GetX(ctx context.Context, id int) *Receivable {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryCompany queries the company edge of a Receivable.
func (c *ReceivableClient) QueryCompany(r *Receivable) *CompanyQuery {
	query := (&CompanyClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := r.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(receivable.Table, receivable.FieldID, id),
			sqlgraph.To(company.Table, company.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, receivable.CompanyTable, receivable.CompanyColumn),
		)
		fromV = sqlgraph.Neighbors(r.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ReceivableClient) Hooks() []Hook {
	return c.hooks.Receivable
}

// Interceptors returns the client interceptors.
func (c *ReceivableClient) Interceptors() []Interceptor {
	return c.inters.Receivable
}

func (c *ReceivableClient) mutate(ctx context.Context, m *ReceivableMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ReceivableCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ReceivableUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ReceivableUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ReceivableDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown Receivable mutation op: %q", m.Op())
	}
}

// SupplierClient is a client for the Supplier schema.
type SupplierClient struct {
	config
}

// NewSupplierClient returns a client for the Supplier from the given config.
func NewSupplierClient(c config) *SupplierClient {
	return &SupplierClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `supplier.Hooks(f(g(h())))`.
func (c *SupplierClient) Use(hooks ...Hook) {
	c.hooks.Supplier = append(c.hooks.Supplier, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `supplier.Intercept(f(g(h())))`.
func (c *SupplierClient) Intercept(interceptors ...Interceptor) {
	c.inters.Supplier = append(c.inters.Supplier, interceptors...)
}

// Create returns a builder for creating a Supplier entity.
func (c *SupplierClient) Create() *SupplierCreate {
	mutation := newSupplierMutation(c.config, OpCreate)
	return &SupplierCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Supplier entities.
func (c *SupplierClient) CreateBulk(builders ...*SupplierCreate) *SupplierCreateBulk {
	return &SupplierCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *SupplierClient) MapCreateBulk(slice any, setFunc func(*SupplierCreate, int)) *SupplierCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &SupplierCreateBulk{err: fmt.Errorf("calling to SupplierClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*SupplierCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &SupplierCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Supplier.
func (c *SupplierClient) Update() *SupplierUpdate {
	mutation := newSupplierMutation(c.config, OpUpdate)
	return &SupplierUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *SupplierClient) UpdateOne(s *Supplier) *SupplierUpdateOne {
	mutation := newSupplierMutation(c.config, OpUpdateOne, withSupplier(s))
	return &SupplierUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *SupplierClient) UpdateOneID(id int) *SupplierUpdateOne {
	mutation := newSupplierMutation(c.config, OpUpdateOne, withSupplierID(id))
	return &SupplierUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Supplier.
func (c *SupplierClient) Delete() *SupplierDelete {
	mutation := newSupplierMutation(c.config, OpDelete)
	return &SupplierDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *SupplierClient) DeleteOne(s *Supplier) *SupplierDeleteOne {
	return c.DeleteOneID(s.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *SupplierClient) DeleteOneID(id int) *SupplierDeleteOne {
	builder := c.Delete().Where(supplier.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &SupplierDeleteOne{builder}
}

// Query returns a query builder for Supplier.
func (c *SupplierClient) Query() *SupplierQuery {
	return &SupplierQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeSupplier},
		inters: c.Interceptors(),
	}
}

// Get returns a Supplier entity by its id.
func (c *SupplierClient) Get(ctx context.Context, id int) (*Supplier, error) {
	return c.Query().Where(supplier.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *SupplierClient) GetX(ctx context.Context, id int) *Supplier {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryCompany queries the company edge of a Supplier.
func (c *SupplierClient) QueryCompany(s *Supplier) *CompanyQuery {
	query := (&CompanyClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := s.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(supplier.Table, supplier.FieldID, id),
			sqlgraph.To(company.Table, company.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, supplier.CompanyTable, supplier.CompanyColumn),
		)
		fromV = sqlgraph.Neighbors(s.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryPayables queries the payables edge of a Supplier.
func (c *SupplierClient) QueryPayables(s *Supplier) *PayableQuery {
	query := (&PayableClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := s.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(supplier.Table, supplier.FieldID, id),
			sqlgraph.To(payable.Table, payable.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, supplier.PayablesTable, supplier.PayablesColumn),
		)
		fromV = sqlgraph.Neighbors(s.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *SupplierClient) Hooks() []Hook {
	return c.hooks.Supplier
}

// Interceptors returns the client interceptors.
func (c *SupplierClient) Interceptors() []Interceptor {
	return c.inters.Supplier
}

func (c *SupplierClient) mutate(ctx context.Context, m *SupplierMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&SupplierCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&SupplierUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&SupplierUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&SupplierDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown Supplier mutation op: %q", m.Op())
	}
}

// TokenClient is a client for the Token schema.
type TokenClient struct {
	config
}

// NewTokenClient returns a client for the Token from the given config.
func NewTokenClient(c config) *TokenClient {
	return &TokenClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `token.Hooks(f(g(h())))`.
func (c *TokenClient) Use(hooks ...Hook) {
	c.hooks.Token = append(c.hooks.Token, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `token.Intercept(f(g(h())))`.
func (c *TokenClient) Intercept(interceptors ...Interceptor) {
	c.inters.Token = append(c.inters.Token, interceptors...)
}

// Create returns a builder for creating a Token entity.
func (c *TokenClient) Create() *TokenCreate {
	mutation := newTokenMutation(c.config, OpCreate)
	return &TokenCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Token entities.
func (c *TokenClient) CreateBulk(builders ...*TokenCreate) *TokenCreateBulk {
	return &TokenCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *TokenClient) MapCreateBulk(slice any, setFunc func(*TokenCreate, int)) *TokenCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &TokenCreateBulk{err: fmt.Errorf("calling to TokenClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*TokenCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &TokenCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Token.
func (c *TokenClient) Update() *TokenUpdate {
	mutation := newTokenMutation(c.config, OpUpdate)
	return &TokenUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *TokenClient) UpdateOne(t *Token) *TokenUpdateOne {
	mutation := newTokenMutation(c.config, OpUpdateOne, withToken(t))
	return &TokenUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *TokenClient) UpdateOneID(id int) *TokenUpdateOne {
	mutation := newTokenMutation(c.config, OpUpdateOne, withTokenID(id))
	return &TokenUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Token.
func (c *TokenClient) Delete() *TokenDelete {
	mutation := newTokenMutation(c.config, OpDelete)
	return &TokenDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *TokenClient) DeleteOne(t *Token) *TokenDeleteOne {
	return c.DeleteOneID(t.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *TokenClient) DeleteOneID(id int) *TokenDeleteOne {
	builder := c.Delete().Where(token.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &TokenDeleteOne{builder}
}

// Query returns a query builder for Token.
func (c *TokenClient) Query() *TokenQuery {
	return &TokenQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeToken},
		inters: c.Interceptors(),
	}
}

// Get returns a Token entity by its id.
func (c *TokenClient) Get(ctx context.Context, id int) (*Token, error) {
	return c.Query().Where(token.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *TokenClient) GetX(ctx context.Context, id int) *Token {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryCompany queries the company edge of a Token.
func (c *TokenClient) QueryCompany(t *Token) *CompanyQuery {
	query := (&CompanyClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := t.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(token.Table, token.FieldID, id),
			sqlgraph.To(company.Table, company.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, token.CompanyTable, token.CompanyColumn),
		)
		fromV = sqlgraph.Neighbors(t.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryUser queries the user edge of a Token.
func (c *TokenClient) QueryUser(t *Token) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := t.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(token.Table, token.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, token.UserTable, token.UserColumn),
		)
		fromV = sqlgraph.Neighbors(t.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *TokenClient) Hooks() []Hook {
	return c.hooks.Token
}

// Interceptors returns the client interceptors.
func (c *TokenClient) Interceptors() []Interceptor {
	return c.inters.Token
}

func (c *TokenClient) mutate(ctx context.Context, m *TokenMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&TokenCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&TokenUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&TokenUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&TokenDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown Token mutation op: %q", m.Op())
	}
}

// TreasuryClient is a client for the Treasury schema.
type TreasuryClient struct {
	config
}

// NewTreasuryClient returns a client for the Treasury from the given config.
func NewTreasuryClient(c config) *TreasuryClient {
	return &TreasuryClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `treasury.Hooks(f(g(h())))`.
func (c *TreasuryClient) Use(hooks ...Hook) {
	c.hooks.Treasury = append(c.hooks.Treasury, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `treasury.Intercept(f(g(h())))`.
func (c *TreasuryClient) Intercept(interceptors ...Interceptor) {
	c.inters.Treasury = append(c.inters.Treasury, interceptors...)
}

// Create returns a builder for creating a Treasury entity.
func (c *TreasuryClient) Create() *TreasuryCreate {
	mutation := newTreasuryMutation(c.config, OpCreate)
	return &TreasuryCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Treasury entities.
func (c *TreasuryClient) CreateBulk(builders ...*TreasuryCreate) *TreasuryCreateBulk {
	return &TreasuryCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *TreasuryClient) MapCreateBulk(slice any, setFunc func(*TreasuryCreate, int)) *TreasuryCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &TreasuryCreateBulk{err: fmt.Errorf("calling to TreasuryClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*TreasuryCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &TreasuryCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Treasury.
func (c *TreasuryClient) Update() *TreasuryUpdate {
	mutation := newTreasuryMutation(c.config, OpUpdate)
	return &TreasuryUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *TreasuryClient) UpdateOne(t *Treasury) *TreasuryUpdateOne {
	mutation := newTreasuryMutation(c.config, OpUpdateOne, withTreasury(t))
	return &TreasuryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *TreasuryClient) UpdateOneID(id int) *TreasuryUpdateOne {
	mutation := newTreasuryMutation(c.config, OpUpdateOne, withTreasuryID(id))
	return &TreasuryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Treasury.
func (c *TreasuryClient) Delete() *TreasuryDelete {
	mutation := newTreasuryMutation(c.config, OpDelete)
	return &TreasuryDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *TreasuryClient) DeleteOne(t *Treasury) *TreasuryDeleteOne {
	return c.DeleteOneID(t.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *TreasuryClient) DeleteOneID(id int) *TreasuryDeleteOne {
	builder := c.Delete().Where(treasury.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &TreasuryDeleteOne{builder}
}

// Query returns a query builder for Treasury.
func (c *TreasuryClient) Query() *TreasuryQuery {
	return &TreasuryQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeTreasury},
		inters: c.Interceptors(),
	}
}

// Get returns a Treasury entity by its id.
func (c *TreasuryClient) Get(ctx context.Context, id int) (*Treasury, error) {
	return c.Query().Where(treasury.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *TreasuryClient) GetX(ctx context.Context, id int) *Treasury {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryCompany queries the company edge of a Treasury.
func (c *TreasuryClient) QueryCompany(t *Treasury) *CompanyQuery {
	query := (&CompanyClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := t.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(treasury.Table, treasury.FieldID, id),
			sqlgraph.To(company.Table, company.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, treasury.CompanyTable, treasury.CompanyColumn),
		)
		fromV = sqlgraph.Neighbors(t.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *TreasuryClient) Hooks() []Hook {
	return c.hooks.Treasury
}

// Interceptors returns the client interceptors.
func (c *TreasuryClient) Interceptors() []Interceptor {
	return c.inters.Treasury
}

func (c *TreasuryClient) mutate(ctx context.Context, m *TreasuryMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&TreasuryCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&TreasuryUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&TreasuryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&TreasuryDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown Treasury mutation op: %q", m.Op())
	}
}

// UserClient is a client for the User schema.
type UserClient struct {
	config
}

// NewUserClient returns a client for the User from the given config.
func NewUserClient(c config) *UserClient {
	return &UserClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `user.Hooks(f(g(h())))`.
func (c *UserClient) Use(hooks ...Hook) {
	c.hooks.User = append(c.hooks.User, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `user.Intercept(f(g(h())))`.
func (c *UserClient) Intercept(interceptors ...Interceptor) {
	c.inters.User = append(c.inters.User, interceptors...)
}

// Create returns a builder for creating a User entity.
func (c *UserClient) Create() *UserCreate {
	mutation := newUserMutation(c.config, OpCreate)
	return &UserCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of User entities.
func (c *UserClient) CreateBulk(builders ...*UserCreate) *UserCreateBulk {
	return &UserCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *UserClient) MapCreateBulk(slice any, setFunc func(*UserCreate, int)) *UserCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &UserCreateBulk{err: fmt.Errorf("calling to UserClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*UserCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &UserCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for User.
func (c *UserClient) Update() *UserUpdate {
	mutation := newUserMutation(c.config, OpUpdate)
	return &UserUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *UserClient) UpdateOne(u *User) *UserUpdateOne {
	mutation := newUserMutation(c.config, OpUpdateOne, withUser(u))
	return &UserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *UserClient) UpdateOneID(id int) *UserUpdateOne {
	mutation := newUserMutation(c.config, OpUpdateOne, withUserID(id))
	return &UserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for User.
func (c *UserClient) Delete() *UserDelete {
	mutation := newUserMutation(c.config, OpDelete)
	return &UserDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *UserClient) DeleteOne(u *User) *UserDeleteOne {
	return c.DeleteOneID(u.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *UserClient) DeleteOneID(id int) *UserDeleteOne {
	builder := c.Delete().Where(user.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &UserDeleteOne{builder}
}

// Query returns a query builder for User.
func (c *UserClient) Query() *UserQuery {
	return &UserQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeUser},
		inters: c.Interceptors(),
	}
}

// Get returns a User entity by its id.
func (c *UserClient) Get(ctx context.Context, id int) (*User, error) {
	return c.Query().Where(user.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *UserClient) GetX(ctx context.Context, id int) *User {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryAccountingEntries queries the accountingEntries edge of a User.
func (c *UserClient) QueryAccountingEntries(u *User) *AccountingEntryQuery {
	query := (&AccountingEntryClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(accountingentry.Table, accountingentry.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.AccountingEntriesTable, user.AccountingEntriesColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryCompany queries the company edge of a User.
func (c *UserClient) QueryCompany(u *User) *CompanyQuery {
	query := (&CompanyClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(company.Table, company.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, user.CompanyTable, user.CompanyPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryAssignedRoles queries the assignedRoles edge of a User.
func (c *UserClient) QueryAssignedRoles(u *User) *UserRoleQuery {
	query := (&UserRoleClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(userrole.Table, userrole.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, user.AssignedRolesTable, user.AssignedRolesPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QuerySubordinates queries the subordinates edge of a User.
func (c *UserClient) QuerySubordinates(u *User) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.SubordinatesTable, user.SubordinatesColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryLeader queries the leader edge of a User.
func (c *UserClient) QueryLeader(u *User) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, user.LeaderTable, user.LeaderColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryEmployee queries the employee edge of a User.
func (c *UserClient) QueryEmployee(u *User) *EmployeeQuery {
	query := (&EmployeeClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(employee.Table, employee.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, user.EmployeeTable, user.EmployeeColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryCreatedProjects queries the createdProjects edge of a User.
func (c *UserClient) QueryCreatedProjects(u *User) *ProjectQuery {
	query := (&ProjectClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(project.Table, project.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.CreatedProjectsTable, user.CreatedProjectsColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryLeaderedProjects queries the leaderedProjects edge of a User.
func (c *UserClient) QueryLeaderedProjects(u *User) *ProjectQuery {
	query := (&ProjectClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(project.Table, project.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.LeaderedProjectsTable, user.LeaderedProjectsColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryAssignedProjectTasks queries the assignedProjectTasks edge of a User.
func (c *UserClient) QueryAssignedProjectTasks(u *User) *ProjectTaskQuery {
	query := (&ProjectTaskClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(projecttask.Table, projecttask.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.AssignedProjectTasksTable, user.AssignedProjectTasksColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryParticipatedProjectTasks queries the participatedProjectTasks edge of a User.
func (c *UserClient) QueryParticipatedProjectTasks(u *User) *ProjectTaskQuery {
	query := (&ProjectTaskClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(projecttask.Table, projecttask.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, user.ParticipatedProjectTasksTable, user.ParticipatedProjectTasksPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryCreatedTasks queries the createdTasks edge of a User.
func (c *UserClient) QueryCreatedTasks(u *User) *ProjectTaskQuery {
	query := (&ProjectTaskClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(projecttask.Table, projecttask.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.CreatedTasksTable, user.CreatedTasksColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTokens queries the tokens edge of a User.
func (c *UserClient) QueryTokens(u *User) *TokenQuery {
	query := (&TokenClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(token.Table, token.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.TokensTable, user.TokensColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryApprovedWorkShifts queries the approvedWorkShifts edge of a User.
func (c *UserClient) QueryApprovedWorkShifts(u *User) *WorkshiftQuery {
	query := (&WorkshiftClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(workshift.Table, workshift.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.ApprovedWorkShiftsTable, user.ApprovedWorkShiftsColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryWorkShifts queries the workShifts edge of a User.
func (c *UserClient) QueryWorkShifts(u *User) *WorkshiftQuery {
	query := (&WorkshiftClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(workshift.Table, workshift.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.WorkShiftsTable, user.WorkShiftsColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *UserClient) Hooks() []Hook {
	return c.hooks.User
}

// Interceptors returns the client interceptors.
func (c *UserClient) Interceptors() []Interceptor {
	return c.inters.User
}

func (c *UserClient) mutate(ctx context.Context, m *UserMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&UserCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&UserUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&UserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&UserDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown User mutation op: %q", m.Op())
	}
}

// UserRoleClient is a client for the UserRole schema.
type UserRoleClient struct {
	config
}

// NewUserRoleClient returns a client for the UserRole from the given config.
func NewUserRoleClient(c config) *UserRoleClient {
	return &UserRoleClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `userrole.Hooks(f(g(h())))`.
func (c *UserRoleClient) Use(hooks ...Hook) {
	c.hooks.UserRole = append(c.hooks.UserRole, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `userrole.Intercept(f(g(h())))`.
func (c *UserRoleClient) Intercept(interceptors ...Interceptor) {
	c.inters.UserRole = append(c.inters.UserRole, interceptors...)
}

// Create returns a builder for creating a UserRole entity.
func (c *UserRoleClient) Create() *UserRoleCreate {
	mutation := newUserRoleMutation(c.config, OpCreate)
	return &UserRoleCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of UserRole entities.
func (c *UserRoleClient) CreateBulk(builders ...*UserRoleCreate) *UserRoleCreateBulk {
	return &UserRoleCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *UserRoleClient) MapCreateBulk(slice any, setFunc func(*UserRoleCreate, int)) *UserRoleCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &UserRoleCreateBulk{err: fmt.Errorf("calling to UserRoleClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*UserRoleCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &UserRoleCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for UserRole.
func (c *UserRoleClient) Update() *UserRoleUpdate {
	mutation := newUserRoleMutation(c.config, OpUpdate)
	return &UserRoleUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *UserRoleClient) UpdateOne(ur *UserRole) *UserRoleUpdateOne {
	mutation := newUserRoleMutation(c.config, OpUpdateOne, withUserRole(ur))
	return &UserRoleUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *UserRoleClient) UpdateOneID(id int) *UserRoleUpdateOne {
	mutation := newUserRoleMutation(c.config, OpUpdateOne, withUserRoleID(id))
	return &UserRoleUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for UserRole.
func (c *UserRoleClient) Delete() *UserRoleDelete {
	mutation := newUserRoleMutation(c.config, OpDelete)
	return &UserRoleDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *UserRoleClient) DeleteOne(ur *UserRole) *UserRoleDeleteOne {
	return c.DeleteOneID(ur.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *UserRoleClient) DeleteOneID(id int) *UserRoleDeleteOne {
	builder := c.Delete().Where(userrole.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &UserRoleDeleteOne{builder}
}

// Query returns a query builder for UserRole.
func (c *UserRoleClient) Query() *UserRoleQuery {
	return &UserRoleQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeUserRole},
		inters: c.Interceptors(),
	}
}

// Get returns a UserRole entity by its id.
func (c *UserRoleClient) Get(ctx context.Context, id int) (*UserRole, error) {
	return c.Query().Where(userrole.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *UserRoleClient) GetX(ctx context.Context, id int) *UserRole {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryCompany queries the company edge of a UserRole.
func (c *UserRoleClient) QueryCompany(ur *UserRole) *CompanyQuery {
	query := (&CompanyClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ur.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(userrole.Table, userrole.FieldID, id),
			sqlgraph.To(company.Table, company.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, userrole.CompanyTable, userrole.CompanyColumn),
		)
		fromV = sqlgraph.Neighbors(ur.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryUser queries the user edge of a UserRole.
func (c *UserRoleClient) QueryUser(ur *UserRole) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ur.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(userrole.Table, userrole.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, userrole.UserTable, userrole.UserPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(ur.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *UserRoleClient) Hooks() []Hook {
	return c.hooks.UserRole
}

// Interceptors returns the client interceptors.
func (c *UserRoleClient) Interceptors() []Interceptor {
	return c.inters.UserRole
}

func (c *UserRoleClient) mutate(ctx context.Context, m *UserRoleMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&UserRoleCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&UserRoleUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&UserRoleUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&UserRoleDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown UserRole mutation op: %q", m.Op())
	}
}

// WorkshiftClient is a client for the Workshift schema.
type WorkshiftClient struct {
	config
}

// NewWorkshiftClient returns a client for the Workshift from the given config.
func NewWorkshiftClient(c config) *WorkshiftClient {
	return &WorkshiftClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `workshift.Hooks(f(g(h())))`.
func (c *WorkshiftClient) Use(hooks ...Hook) {
	c.hooks.Workshift = append(c.hooks.Workshift, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `workshift.Intercept(f(g(h())))`.
func (c *WorkshiftClient) Intercept(interceptors ...Interceptor) {
	c.inters.Workshift = append(c.inters.Workshift, interceptors...)
}

// Create returns a builder for creating a Workshift entity.
func (c *WorkshiftClient) Create() *WorkshiftCreate {
	mutation := newWorkshiftMutation(c.config, OpCreate)
	return &WorkshiftCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Workshift entities.
func (c *WorkshiftClient) CreateBulk(builders ...*WorkshiftCreate) *WorkshiftCreateBulk {
	return &WorkshiftCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *WorkshiftClient) MapCreateBulk(slice any, setFunc func(*WorkshiftCreate, int)) *WorkshiftCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &WorkshiftCreateBulk{err: fmt.Errorf("calling to WorkshiftClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*WorkshiftCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &WorkshiftCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Workshift.
func (c *WorkshiftClient) Update() *WorkshiftUpdate {
	mutation := newWorkshiftMutation(c.config, OpUpdate)
	return &WorkshiftUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *WorkshiftClient) UpdateOne(w *Workshift) *WorkshiftUpdateOne {
	mutation := newWorkshiftMutation(c.config, OpUpdateOne, withWorkshift(w))
	return &WorkshiftUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *WorkshiftClient) UpdateOneID(id int) *WorkshiftUpdateOne {
	mutation := newWorkshiftMutation(c.config, OpUpdateOne, withWorkshiftID(id))
	return &WorkshiftUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Workshift.
func (c *WorkshiftClient) Delete() *WorkshiftDelete {
	mutation := newWorkshiftMutation(c.config, OpDelete)
	return &WorkshiftDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *WorkshiftClient) DeleteOne(w *Workshift) *WorkshiftDeleteOne {
	return c.DeleteOneID(w.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *WorkshiftClient) DeleteOneID(id int) *WorkshiftDeleteOne {
	builder := c.Delete().Where(workshift.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &WorkshiftDeleteOne{builder}
}

// Query returns a query builder for Workshift.
func (c *WorkshiftClient) Query() *WorkshiftQuery {
	return &WorkshiftQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeWorkshift},
		inters: c.Interceptors(),
	}
}

// Get returns a Workshift entity by its id.
func (c *WorkshiftClient) Get(ctx context.Context, id int) (*Workshift, error) {
	return c.Query().Where(workshift.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *WorkshiftClient) GetX(ctx context.Context, id int) *Workshift {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryCompany queries the company edge of a Workshift.
func (c *WorkshiftClient) QueryCompany(w *Workshift) *CompanyQuery {
	query := (&CompanyClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := w.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(workshift.Table, workshift.FieldID, id),
			sqlgraph.To(company.Table, company.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, workshift.CompanyTable, workshift.CompanyColumn),
		)
		fromV = sqlgraph.Neighbors(w.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryUser queries the user edge of a Workshift.
func (c *WorkshiftClient) QueryUser(w *Workshift) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := w.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(workshift.Table, workshift.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, workshift.UserTable, workshift.UserColumn),
		)
		fromV = sqlgraph.Neighbors(w.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryApprovedBy queries the approvedBy edge of a Workshift.
func (c *WorkshiftClient) QueryApprovedBy(w *Workshift) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := w.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(workshift.Table, workshift.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, workshift.ApprovedByTable, workshift.ApprovedByColumn),
		)
		fromV = sqlgraph.Neighbors(w.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTask queries the task edge of a Workshift.
func (c *WorkshiftClient) QueryTask(w *Workshift) *ProjectTaskQuery {
	query := (&ProjectTaskClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := w.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(workshift.Table, workshift.FieldID, id),
			sqlgraph.To(projecttask.Table, projecttask.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, workshift.TaskTable, workshift.TaskColumn),
		)
		fromV = sqlgraph.Neighbors(w.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryEditRequest queries the editRequest edge of a Workshift.
func (c *WorkshiftClient) QueryEditRequest(w *Workshift) *WorkshiftQuery {
	query := (&WorkshiftClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := w.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(workshift.Table, workshift.FieldID, id),
			sqlgraph.To(workshift.Table, workshift.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, workshift.EditRequestTable, workshift.EditRequestColumn),
		)
		fromV = sqlgraph.Neighbors(w.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryWorkShift queries the workShift edge of a Workshift.
func (c *WorkshiftClient) QueryWorkShift(w *Workshift) *WorkshiftQuery {
	query := (&WorkshiftClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := w.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(workshift.Table, workshift.FieldID, id),
			sqlgraph.To(workshift.Table, workshift.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, true, workshift.WorkShiftTable, workshift.WorkShiftColumn),
		)
		fromV = sqlgraph.Neighbors(w.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *WorkshiftClient) Hooks() []Hook {
	hooks := c.hooks.Workshift
	return append(hooks[:len(hooks):len(hooks)], workshift.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *WorkshiftClient) Interceptors() []Interceptor {
	return c.inters.Workshift
}

func (c *WorkshiftClient) mutate(ctx context.Context, m *WorkshiftMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&WorkshiftCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&WorkshiftUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&WorkshiftUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&WorkshiftDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown Workshift mutation op: %q", m.Op())
	}
}

// hooks and interceptors per client, for fast access.
type (
	hooks struct {
		AccountingEntry, Company, Customer, Employee, File, Payable, Product, Project,
		ProjectMilestone, ProjectTask, Receivable, Supplier, Token, Treasury, User,
		UserRole, Workshift []ent.Hook
	}
	inters struct {
		AccountingEntry, Company, Customer, Employee, File, Payable, Product, Project,
		ProjectMilestone, ProjectTask, Receivable, Supplier, Token, Treasury, User,
		UserRole, Workshift []ent.Interceptor
	}
)

// ExecContext allows calling the underlying ExecContext method of the driver if it is supported by it.
// See, database/sql#DB.ExecContext for more information.
func (c *config) ExecContext(ctx context.Context, query string, args ...any) (stdsql.Result, error) {
	ex, ok := c.driver.(interface {
		ExecContext(context.Context, string, ...any) (stdsql.Result, error)
	})
	if !ok {
		return nil, fmt.Errorf("Driver.ExecContext is not supported")
	}
	return ex.ExecContext(ctx, query, args...)
}

// QueryContext allows calling the underlying QueryContext method of the driver if it is supported by it.
// See, database/sql#DB.QueryContext for more information.
func (c *config) QueryContext(ctx context.Context, query string, args ...any) (*stdsql.Rows, error) {
	q, ok := c.driver.(interface {
		QueryContext(context.Context, string, ...any) (*stdsql.Rows, error)
	})
	if !ok {
		return nil, fmt.Errorf("Driver.QueryContext is not supported")
	}
	return q.QueryContext(ctx, query, args...)
}
