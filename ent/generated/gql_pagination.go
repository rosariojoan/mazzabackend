// Code generated by ent, DO NOT EDIT.

package generated

import (
	"context"
	"errors"
	"fmt"
	"io"
	"mazza/ent/generated/accountingentry"
	"mazza/ent/generated/company"
	"mazza/ent/generated/companydocument"
	"mazza/ent/generated/customer"
	"mazza/ent/generated/employee"
	"mazza/ent/generated/file"
	"mazza/ent/generated/inventory"
	"mazza/ent/generated/inventorymovement"
	"mazza/ent/generated/invoice"
	"mazza/ent/generated/membersignuptoken"
	"mazza/ent/generated/payable"
	"mazza/ent/generated/product"
	"mazza/ent/generated/project"
	"mazza/ent/generated/projectmilestone"
	"mazza/ent/generated/projecttask"
	"mazza/ent/generated/receivable"
	"mazza/ent/generated/supplier"
	"mazza/ent/generated/token"
	"mazza/ent/generated/treasury"
	"mazza/ent/generated/user"
	"mazza/ent/generated/userrole"
	"mazza/ent/generated/workshift"
	"strconv"

	"entgo.io/contrib/entgql"
	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/99designs/gqlgen/graphql"
	"github.com/99designs/gqlgen/graphql/errcode"
	"github.com/vektah/gqlparser/v2/gqlerror"
)

// Common entgql types.
type (
	Cursor         = entgql.Cursor[int]
	PageInfo       = entgql.PageInfo[int]
	OrderDirection = entgql.OrderDirection
)

func orderFunc(o OrderDirection, field string) func(*sql.Selector) {
	if o == entgql.OrderDirectionDesc {
		return Desc(field)
	}
	return Asc(field)
}

const errInvalidPagination = "INVALID_PAGINATION"

func validateFirstLast(first, last *int) (err *gqlerror.Error) {
	switch {
	case first != nil && last != nil:
		err = &gqlerror.Error{
			Message: "Passing both `first` and `last` to paginate a connection is not supported.",
		}
	case first != nil && *first < 0:
		err = &gqlerror.Error{
			Message: "`first` on a connection cannot be less than zero.",
		}
		errcode.Set(err, errInvalidPagination)
	case last != nil && *last < 0:
		err = &gqlerror.Error{
			Message: "`last` on a connection cannot be less than zero.",
		}
		errcode.Set(err, errInvalidPagination)
	}
	return err
}

func collectedField(ctx context.Context, path ...string) *graphql.CollectedField {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return nil
	}
	field := fc.Field
	oc := graphql.GetOperationContext(ctx)
walk:
	for _, name := range path {
		for _, f := range graphql.CollectFields(oc, field.Selections, nil) {
			if f.Alias == name {
				field = f
				continue walk
			}
		}
		return nil
	}
	return &field
}

func hasCollectedField(ctx context.Context, path ...string) bool {
	if graphql.GetFieldContext(ctx) == nil {
		return true
	}
	return collectedField(ctx, path...) != nil
}

const (
	edgesField      = "edges"
	nodeField       = "node"
	pageInfoField   = "pageInfo"
	totalCountField = "totalCount"
)

func paginateLimit(first, last *int) int {
	var limit int
	if first != nil {
		limit = *first + 1
	} else if last != nil {
		limit = *last + 1
	}
	return limit
}

// AccountingEntryEdge is the edge representation of AccountingEntry.
type AccountingEntryEdge struct {
	Node   *AccountingEntry `json:"node"`
	Cursor Cursor           `json:"cursor"`
}

// AccountingEntryConnection is the connection containing edges to AccountingEntry.
type AccountingEntryConnection struct {
	Edges      []*AccountingEntryEdge `json:"edges"`
	PageInfo   PageInfo               `json:"pageInfo"`
	TotalCount int                    `json:"totalCount"`
}

func (c *AccountingEntryConnection) build(nodes []*AccountingEntry, pager *accountingentryPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *AccountingEntry
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *AccountingEntry {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *AccountingEntry {
			return nodes[i]
		}
	}
	c.Edges = make([]*AccountingEntryEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &AccountingEntryEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// AccountingEntryPaginateOption enables pagination customization.
type AccountingEntryPaginateOption func(*accountingentryPager) error

// WithAccountingEntryOrder configures pagination ordering.
func WithAccountingEntryOrder(order []*AccountingEntryOrder) AccountingEntryPaginateOption {
	return func(pager *accountingentryPager) error {
		for _, o := range order {
			if err := o.Direction.Validate(); err != nil {
				return err
			}
		}
		pager.order = append(pager.order, order...)
		return nil
	}
}

// WithAccountingEntryFilter configures pagination filter.
func WithAccountingEntryFilter(filter func(*AccountingEntryQuery) (*AccountingEntryQuery, error)) AccountingEntryPaginateOption {
	return func(pager *accountingentryPager) error {
		if filter == nil {
			return errors.New("AccountingEntryQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type accountingentryPager struct {
	reverse bool
	order   []*AccountingEntryOrder
	filter  func(*AccountingEntryQuery) (*AccountingEntryQuery, error)
}

func newAccountingEntryPager(opts []AccountingEntryPaginateOption, reverse bool) (*accountingentryPager, error) {
	pager := &accountingentryPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	for i, o := range pager.order {
		if i > 0 && o.Field == pager.order[i-1].Field {
			return nil, fmt.Errorf("duplicate order direction %q", o.Direction)
		}
	}
	return pager, nil
}

func (p *accountingentryPager) applyFilter(query *AccountingEntryQuery) (*AccountingEntryQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *accountingentryPager) toCursor(ae *AccountingEntry) Cursor {
	cs := make([]any, 0, len(p.order))
	for _, o := range p.order {
		cs = append(cs, o.Field.toCursor(ae).Value)
	}
	return Cursor{ID: ae.ID, Value: cs}
}

func (p *accountingentryPager) applyCursors(query *AccountingEntryQuery, after, before *Cursor) (*AccountingEntryQuery, error) {
	idDirection := entgql.OrderDirectionAsc
	if p.reverse {
		idDirection = entgql.OrderDirectionDesc
	}
	fields, directions := make([]string, 0, len(p.order)), make([]OrderDirection, 0, len(p.order))
	for _, o := range p.order {
		fields = append(fields, o.Field.column)
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		directions = append(directions, direction)
	}
	predicates, err := entgql.MultiCursorsPredicate(after, before, &entgql.MultiCursorsOptions{
		FieldID:     DefaultAccountingEntryOrder.Field.column,
		DirectionID: idDirection,
		Fields:      fields,
		Directions:  directions,
	})
	if err != nil {
		return nil, err
	}
	for _, predicate := range predicates {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *accountingentryPager) applyOrder(query *AccountingEntryQuery) *AccountingEntryQuery {
	var defaultOrdered bool
	for _, o := range p.order {
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(o.Field.toTerm(direction.OrderTermOption()))
		if o.Field.column == DefaultAccountingEntryOrder.Field.column {
			defaultOrdered = true
		}
		if len(query.ctx.Fields) > 0 {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	if !defaultOrdered {
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(DefaultAccountingEntryOrder.Field.toTerm(direction.OrderTermOption()))
	}
	return query
}

func (p *accountingentryPager) orderExpr(query *AccountingEntryQuery) sql.Querier {
	if len(query.ctx.Fields) > 0 {
		for _, o := range p.order {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		for _, o := range p.order {
			direction := o.Direction
			if p.reverse {
				direction = direction.Reverse()
			}
			b.Ident(o.Field.column).Pad().WriteString(string(direction))
			b.Comma()
		}
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		b.Ident(DefaultAccountingEntryOrder.Field.column).Pad().WriteString(string(direction))
	})
}

// Paginate executes the query and returns a relay based cursor connection to AccountingEntry.
func (ae *AccountingEntryQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...AccountingEntryPaginateOption,
) (*AccountingEntryConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newAccountingEntryPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if ae, err = pager.applyFilter(ae); err != nil {
		return nil, err
	}
	conn := &AccountingEntryConnection{Edges: []*AccountingEntryEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = ae.Clone().Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if ae, err = pager.applyCursors(ae, after, before); err != nil {
		return nil, err
	}
	if limit := paginateLimit(first, last); limit != 0 {
		ae.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := ae.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	ae = pager.applyOrder(ae)
	nodes, err := ae.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// AccountingEntryOrderFieldCreatedAt orders AccountingEntry by createdAt.
	AccountingEntryOrderFieldCreatedAt = &AccountingEntryOrderField{
		Value: func(ae *AccountingEntry) (ent.Value, error) {
			return ae.CreatedAt, nil
		},
		column: accountingentry.FieldCreatedAt,
		toTerm: accountingentry.ByCreatedAt,
		toCursor: func(ae *AccountingEntry) Cursor {
			return Cursor{
				ID:    ae.ID,
				Value: ae.CreatedAt,
			}
		},
	}
	// AccountingEntryOrderFieldUpdatedAt orders AccountingEntry by updatedAt.
	AccountingEntryOrderFieldUpdatedAt = &AccountingEntryOrderField{
		Value: func(ae *AccountingEntry) (ent.Value, error) {
			return ae.UpdatedAt, nil
		},
		column: accountingentry.FieldUpdatedAt,
		toTerm: accountingentry.ByUpdatedAt,
		toCursor: func(ae *AccountingEntry) Cursor {
			return Cursor{
				ID:    ae.ID,
				Value: ae.UpdatedAt,
			}
		},
	}
	// AccountingEntryOrderFieldGroup orders AccountingEntry by group.
	AccountingEntryOrderFieldGroup = &AccountingEntryOrderField{
		Value: func(ae *AccountingEntry) (ent.Value, error) {
			return ae.Group, nil
		},
		column: accountingentry.FieldGroup,
		toTerm: accountingentry.ByGroup,
		toCursor: func(ae *AccountingEntry) Cursor {
			return Cursor{
				ID:    ae.ID,
				Value: ae.Group,
			}
		},
	}
	// AccountingEntryOrderFieldDate orders AccountingEntry by date.
	AccountingEntryOrderFieldDate = &AccountingEntryOrderField{
		Value: func(ae *AccountingEntry) (ent.Value, error) {
			return ae.Date, nil
		},
		column: accountingentry.FieldDate,
		toTerm: accountingentry.ByDate,
		toCursor: func(ae *AccountingEntry) Cursor {
			return Cursor{
				ID:    ae.ID,
				Value: ae.Date,
			}
		},
	}
	// AccountingEntryOrderFieldAccount orders AccountingEntry by account.
	AccountingEntryOrderFieldAccount = &AccountingEntryOrderField{
		Value: func(ae *AccountingEntry) (ent.Value, error) {
			return ae.Account, nil
		},
		column: accountingentry.FieldAccount,
		toTerm: accountingentry.ByAccount,
		toCursor: func(ae *AccountingEntry) Cursor {
			return Cursor{
				ID:    ae.ID,
				Value: ae.Account,
			}
		},
	}
	// AccountingEntryOrderFieldAmount orders AccountingEntry by amount.
	AccountingEntryOrderFieldAmount = &AccountingEntryOrderField{
		Value: func(ae *AccountingEntry) (ent.Value, error) {
			return ae.Amount, nil
		},
		column: accountingentry.FieldAmount,
		toTerm: accountingentry.ByAmount,
		toCursor: func(ae *AccountingEntry) Cursor {
			return Cursor{
				ID:    ae.ID,
				Value: ae.Amount,
			}
		},
	}
	// AccountingEntryOrderFieldDescription orders AccountingEntry by description.
	AccountingEntryOrderFieldDescription = &AccountingEntryOrderField{
		Value: func(ae *AccountingEntry) (ent.Value, error) {
			return ae.Description, nil
		},
		column: accountingentry.FieldDescription,
		toTerm: accountingentry.ByDescription,
		toCursor: func(ae *AccountingEntry) Cursor {
			return Cursor{
				ID:    ae.ID,
				Value: ae.Description,
			}
		},
	}
	// AccountingEntryOrderFieldAccountType orders AccountingEntry by accountType.
	AccountingEntryOrderFieldAccountType = &AccountingEntryOrderField{
		Value: func(ae *AccountingEntry) (ent.Value, error) {
			return ae.AccountType, nil
		},
		column: accountingentry.FieldAccountType,
		toTerm: accountingentry.ByAccountType,
		toCursor: func(ae *AccountingEntry) Cursor {
			return Cursor{
				ID:    ae.ID,
				Value: ae.AccountType,
			}
		},
	}
	// AccountingEntryOrderFieldCategory orders AccountingEntry by category.
	AccountingEntryOrderFieldCategory = &AccountingEntryOrderField{
		Value: func(ae *AccountingEntry) (ent.Value, error) {
			return ae.Category, nil
		},
		column: accountingentry.FieldCategory,
		toTerm: accountingentry.ByCategory,
		toCursor: func(ae *AccountingEntry) Cursor {
			return Cursor{
				ID:    ae.ID,
				Value: ae.Category,
			}
		},
	}
	// AccountingEntryOrderFieldIsDebit orders AccountingEntry by isDebit.
	AccountingEntryOrderFieldIsDebit = &AccountingEntryOrderField{
		Value: func(ae *AccountingEntry) (ent.Value, error) {
			return ae.IsDebit, nil
		},
		column: accountingentry.FieldIsDebit,
		toTerm: accountingentry.ByIsDebit,
		toCursor: func(ae *AccountingEntry) Cursor {
			return Cursor{
				ID:    ae.ID,
				Value: ae.IsDebit,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f AccountingEntryOrderField) String() string {
	var str string
	switch f.column {
	case AccountingEntryOrderFieldCreatedAt.column:
		str = "CREATED_AT"
	case AccountingEntryOrderFieldUpdatedAt.column:
		str = "UPDATED_AT"
	case AccountingEntryOrderFieldGroup.column:
		str = "GROUP"
	case AccountingEntryOrderFieldDate.column:
		str = "DATE"
	case AccountingEntryOrderFieldAccount.column:
		str = "ACCOUNT"
	case AccountingEntryOrderFieldAmount.column:
		str = "AMOUNT"
	case AccountingEntryOrderFieldDescription.column:
		str = "DESCRIPTION"
	case AccountingEntryOrderFieldAccountType.column:
		str = "ACCOUNTTYPE"
	case AccountingEntryOrderFieldCategory.column:
		str = "CATEGORY"
	case AccountingEntryOrderFieldIsDebit.column:
		str = "ISDEBIT"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f AccountingEntryOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *AccountingEntryOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("AccountingEntryOrderField %T must be a string", v)
	}
	switch str {
	case "CREATED_AT":
		*f = *AccountingEntryOrderFieldCreatedAt
	case "UPDATED_AT":
		*f = *AccountingEntryOrderFieldUpdatedAt
	case "GROUP":
		*f = *AccountingEntryOrderFieldGroup
	case "DATE":
		*f = *AccountingEntryOrderFieldDate
	case "ACCOUNT":
		*f = *AccountingEntryOrderFieldAccount
	case "AMOUNT":
		*f = *AccountingEntryOrderFieldAmount
	case "DESCRIPTION":
		*f = *AccountingEntryOrderFieldDescription
	case "ACCOUNTTYPE":
		*f = *AccountingEntryOrderFieldAccountType
	case "CATEGORY":
		*f = *AccountingEntryOrderFieldCategory
	case "ISDEBIT":
		*f = *AccountingEntryOrderFieldIsDebit
	default:
		return fmt.Errorf("%s is not a valid AccountingEntryOrderField", str)
	}
	return nil
}

// AccountingEntryOrderField defines the ordering field of AccountingEntry.
type AccountingEntryOrderField struct {
	// Value extracts the ordering value from the given AccountingEntry.
	Value    func(*AccountingEntry) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) accountingentry.OrderOption
	toCursor func(*AccountingEntry) Cursor
}

// AccountingEntryOrder defines the ordering of AccountingEntry.
type AccountingEntryOrder struct {
	Direction OrderDirection             `json:"direction"`
	Field     *AccountingEntryOrderField `json:"field"`
}

// DefaultAccountingEntryOrder is the default ordering of AccountingEntry.
var DefaultAccountingEntryOrder = &AccountingEntryOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &AccountingEntryOrderField{
		Value: func(ae *AccountingEntry) (ent.Value, error) {
			return ae.ID, nil
		},
		column: accountingentry.FieldID,
		toTerm: accountingentry.ByID,
		toCursor: func(ae *AccountingEntry) Cursor {
			return Cursor{ID: ae.ID}
		},
	},
}

// ToEdge converts AccountingEntry into AccountingEntryEdge.
func (ae *AccountingEntry) ToEdge(order *AccountingEntryOrder) *AccountingEntryEdge {
	if order == nil {
		order = DefaultAccountingEntryOrder
	}
	return &AccountingEntryEdge{
		Node:   ae,
		Cursor: order.Field.toCursor(ae),
	}
}

// CompanyEdge is the edge representation of Company.
type CompanyEdge struct {
	Node   *Company `json:"node"`
	Cursor Cursor   `json:"cursor"`
}

// CompanyConnection is the connection containing edges to Company.
type CompanyConnection struct {
	Edges      []*CompanyEdge `json:"edges"`
	PageInfo   PageInfo       `json:"pageInfo"`
	TotalCount int            `json:"totalCount"`
}

func (c *CompanyConnection) build(nodes []*Company, pager *companyPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *Company
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Company {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Company {
			return nodes[i]
		}
	}
	c.Edges = make([]*CompanyEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &CompanyEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// CompanyPaginateOption enables pagination customization.
type CompanyPaginateOption func(*companyPager) error

// WithCompanyOrder configures pagination ordering.
func WithCompanyOrder(order *CompanyOrder) CompanyPaginateOption {
	if order == nil {
		order = DefaultCompanyOrder
	}
	o := *order
	return func(pager *companyPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultCompanyOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithCompanyFilter configures pagination filter.
func WithCompanyFilter(filter func(*CompanyQuery) (*CompanyQuery, error)) CompanyPaginateOption {
	return func(pager *companyPager) error {
		if filter == nil {
			return errors.New("CompanyQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type companyPager struct {
	reverse bool
	order   *CompanyOrder
	filter  func(*CompanyQuery) (*CompanyQuery, error)
}

func newCompanyPager(opts []CompanyPaginateOption, reverse bool) (*companyPager, error) {
	pager := &companyPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultCompanyOrder
	}
	return pager, nil
}

func (p *companyPager) applyFilter(query *CompanyQuery) (*CompanyQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *companyPager) toCursor(c *Company) Cursor {
	return p.order.Field.toCursor(c)
}

func (p *companyPager) applyCursors(query *CompanyQuery, after, before *Cursor) (*CompanyQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultCompanyOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *companyPager) applyOrder(query *CompanyQuery) *CompanyQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultCompanyOrder.Field {
		query = query.Order(DefaultCompanyOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *companyPager) orderExpr(query *CompanyQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultCompanyOrder.Field {
			b.Comma().Ident(DefaultCompanyOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to Company.
func (c *CompanyQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...CompanyPaginateOption,
) (*CompanyConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newCompanyPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if c, err = pager.applyFilter(c); err != nil {
		return nil, err
	}
	conn := &CompanyConnection{Edges: []*CompanyEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = c.Clone().Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if c, err = pager.applyCursors(c, after, before); err != nil {
		return nil, err
	}
	if limit := paginateLimit(first, last); limit != 0 {
		c.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := c.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	c = pager.applyOrder(c)
	nodes, err := c.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// CompanyOrderFieldCreatedAt orders Company by createdAt.
	CompanyOrderFieldCreatedAt = &CompanyOrderField{
		Value: func(c *Company) (ent.Value, error) {
			return c.CreatedAt, nil
		},
		column: company.FieldCreatedAt,
		toTerm: company.ByCreatedAt,
		toCursor: func(c *Company) Cursor {
			return Cursor{
				ID:    c.ID,
				Value: c.CreatedAt,
			}
		},
	}
	// CompanyOrderFieldUpdatedAt orders Company by updatedAt.
	CompanyOrderFieldUpdatedAt = &CompanyOrderField{
		Value: func(c *Company) (ent.Value, error) {
			return c.UpdatedAt, nil
		},
		column: company.FieldUpdatedAt,
		toTerm: company.ByUpdatedAt,
		toCursor: func(c *Company) Cursor {
			return Cursor{
				ID:    c.ID,
				Value: c.UpdatedAt,
			}
		},
	}
	// CompanyOrderFieldCity orders Company by city.
	CompanyOrderFieldCity = &CompanyOrderField{
		Value: func(c *Company) (ent.Value, error) {
			return c.City, nil
		},
		column: company.FieldCity,
		toTerm: company.ByCity,
		toCursor: func(c *Company) Cursor {
			return Cursor{
				ID:    c.ID,
				Value: c.City,
			}
		},
	}
	// CompanyOrderFieldCountry orders Company by country.
	CompanyOrderFieldCountry = &CompanyOrderField{
		Value: func(c *Company) (ent.Value, error) {
			return c.Country, nil
		},
		column: company.FieldCountry,
		toTerm: company.ByCountry,
		toCursor: func(c *Company) Cursor {
			return Cursor{
				ID:    c.ID,
				Value: c.Country,
			}
		},
	}
	// CompanyOrderFieldEstablishedAt orders Company by establishedAt.
	CompanyOrderFieldEstablishedAt = &CompanyOrderField{
		Value: func(c *Company) (ent.Value, error) {
			return c.EstablishedAt, nil
		},
		column: company.FieldEstablishedAt,
		toTerm: company.ByEstablishedAt,
		toCursor: func(c *Company) Cursor {
			return Cursor{
				ID:    c.ID,
				Value: c.EstablishedAt,
			}
		},
	}
	// CompanyOrderFieldName orders Company by name.
	CompanyOrderFieldName = &CompanyOrderField{
		Value: func(c *Company) (ent.Value, error) {
			return c.Name, nil
		},
		column: company.FieldName,
		toTerm: company.ByName,
		toCursor: func(c *Company) Cursor {
			return Cursor{
				ID:    c.ID,
				Value: c.Name,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f CompanyOrderField) String() string {
	var str string
	switch f.column {
	case CompanyOrderFieldCreatedAt.column:
		str = "CREATED_AT"
	case CompanyOrderFieldUpdatedAt.column:
		str = "UPDATED_AT"
	case CompanyOrderFieldCity.column:
		str = "CITY"
	case CompanyOrderFieldCountry.column:
		str = "COUNTRY"
	case CompanyOrderFieldEstablishedAt.column:
		str = "ESTABLISHEDAT"
	case CompanyOrderFieldName.column:
		str = "NAME"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f CompanyOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *CompanyOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("CompanyOrderField %T must be a string", v)
	}
	switch str {
	case "CREATED_AT":
		*f = *CompanyOrderFieldCreatedAt
	case "UPDATED_AT":
		*f = *CompanyOrderFieldUpdatedAt
	case "CITY":
		*f = *CompanyOrderFieldCity
	case "COUNTRY":
		*f = *CompanyOrderFieldCountry
	case "ESTABLISHEDAT":
		*f = *CompanyOrderFieldEstablishedAt
	case "NAME":
		*f = *CompanyOrderFieldName
	default:
		return fmt.Errorf("%s is not a valid CompanyOrderField", str)
	}
	return nil
}

// CompanyOrderField defines the ordering field of Company.
type CompanyOrderField struct {
	// Value extracts the ordering value from the given Company.
	Value    func(*Company) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) company.OrderOption
	toCursor func(*Company) Cursor
}

// CompanyOrder defines the ordering of Company.
type CompanyOrder struct {
	Direction OrderDirection     `json:"direction"`
	Field     *CompanyOrderField `json:"field"`
}

// DefaultCompanyOrder is the default ordering of Company.
var DefaultCompanyOrder = &CompanyOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &CompanyOrderField{
		Value: func(c *Company) (ent.Value, error) {
			return c.ID, nil
		},
		column: company.FieldID,
		toTerm: company.ByID,
		toCursor: func(c *Company) Cursor {
			return Cursor{ID: c.ID}
		},
	},
}

// ToEdge converts Company into CompanyEdge.
func (c *Company) ToEdge(order *CompanyOrder) *CompanyEdge {
	if order == nil {
		order = DefaultCompanyOrder
	}
	return &CompanyEdge{
		Node:   c,
		Cursor: order.Field.toCursor(c),
	}
}

// CompanyDocumentEdge is the edge representation of CompanyDocument.
type CompanyDocumentEdge struct {
	Node   *CompanyDocument `json:"node"`
	Cursor Cursor           `json:"cursor"`
}

// CompanyDocumentConnection is the connection containing edges to CompanyDocument.
type CompanyDocumentConnection struct {
	Edges      []*CompanyDocumentEdge `json:"edges"`
	PageInfo   PageInfo               `json:"pageInfo"`
	TotalCount int                    `json:"totalCount"`
}

func (c *CompanyDocumentConnection) build(nodes []*CompanyDocument, pager *companydocumentPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *CompanyDocument
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *CompanyDocument {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *CompanyDocument {
			return nodes[i]
		}
	}
	c.Edges = make([]*CompanyDocumentEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &CompanyDocumentEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// CompanyDocumentPaginateOption enables pagination customization.
type CompanyDocumentPaginateOption func(*companydocumentPager) error

// WithCompanyDocumentOrder configures pagination ordering.
func WithCompanyDocumentOrder(order []*CompanyDocumentOrder) CompanyDocumentPaginateOption {
	return func(pager *companydocumentPager) error {
		for _, o := range order {
			if err := o.Direction.Validate(); err != nil {
				return err
			}
		}
		pager.order = append(pager.order, order...)
		return nil
	}
}

// WithCompanyDocumentFilter configures pagination filter.
func WithCompanyDocumentFilter(filter func(*CompanyDocumentQuery) (*CompanyDocumentQuery, error)) CompanyDocumentPaginateOption {
	return func(pager *companydocumentPager) error {
		if filter == nil {
			return errors.New("CompanyDocumentQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type companydocumentPager struct {
	reverse bool
	order   []*CompanyDocumentOrder
	filter  func(*CompanyDocumentQuery) (*CompanyDocumentQuery, error)
}

func newCompanyDocumentPager(opts []CompanyDocumentPaginateOption, reverse bool) (*companydocumentPager, error) {
	pager := &companydocumentPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	for i, o := range pager.order {
		if i > 0 && o.Field == pager.order[i-1].Field {
			return nil, fmt.Errorf("duplicate order direction %q", o.Direction)
		}
	}
	return pager, nil
}

func (p *companydocumentPager) applyFilter(query *CompanyDocumentQuery) (*CompanyDocumentQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *companydocumentPager) toCursor(cd *CompanyDocument) Cursor {
	cs := make([]any, 0, len(p.order))
	for _, o := range p.order {
		cs = append(cs, o.Field.toCursor(cd).Value)
	}
	return Cursor{ID: cd.ID, Value: cs}
}

func (p *companydocumentPager) applyCursors(query *CompanyDocumentQuery, after, before *Cursor) (*CompanyDocumentQuery, error) {
	idDirection := entgql.OrderDirectionAsc
	if p.reverse {
		idDirection = entgql.OrderDirectionDesc
	}
	fields, directions := make([]string, 0, len(p.order)), make([]OrderDirection, 0, len(p.order))
	for _, o := range p.order {
		fields = append(fields, o.Field.column)
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		directions = append(directions, direction)
	}
	predicates, err := entgql.MultiCursorsPredicate(after, before, &entgql.MultiCursorsOptions{
		FieldID:     DefaultCompanyDocumentOrder.Field.column,
		DirectionID: idDirection,
		Fields:      fields,
		Directions:  directions,
	})
	if err != nil {
		return nil, err
	}
	for _, predicate := range predicates {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *companydocumentPager) applyOrder(query *CompanyDocumentQuery) *CompanyDocumentQuery {
	var defaultOrdered bool
	for _, o := range p.order {
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(o.Field.toTerm(direction.OrderTermOption()))
		if o.Field.column == DefaultCompanyDocumentOrder.Field.column {
			defaultOrdered = true
		}
		if len(query.ctx.Fields) > 0 {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	if !defaultOrdered {
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(DefaultCompanyDocumentOrder.Field.toTerm(direction.OrderTermOption()))
	}
	return query
}

func (p *companydocumentPager) orderExpr(query *CompanyDocumentQuery) sql.Querier {
	if len(query.ctx.Fields) > 0 {
		for _, o := range p.order {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		for _, o := range p.order {
			direction := o.Direction
			if p.reverse {
				direction = direction.Reverse()
			}
			b.Ident(o.Field.column).Pad().WriteString(string(direction))
			b.Comma()
		}
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		b.Ident(DefaultCompanyDocumentOrder.Field.column).Pad().WriteString(string(direction))
	})
}

// Paginate executes the query and returns a relay based cursor connection to CompanyDocument.
func (cd *CompanyDocumentQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...CompanyDocumentPaginateOption,
) (*CompanyDocumentConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newCompanyDocumentPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if cd, err = pager.applyFilter(cd); err != nil {
		return nil, err
	}
	conn := &CompanyDocumentConnection{Edges: []*CompanyDocumentEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = cd.Clone().Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if cd, err = pager.applyCursors(cd, after, before); err != nil {
		return nil, err
	}
	if limit := paginateLimit(first, last); limit != 0 {
		cd.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := cd.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	cd = pager.applyOrder(cd)
	nodes, err := cd.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// CompanyDocumentOrderFieldCreatedAt orders CompanyDocument by createdAt.
	CompanyDocumentOrderFieldCreatedAt = &CompanyDocumentOrderField{
		Value: func(cd *CompanyDocument) (ent.Value, error) {
			return cd.CreatedAt, nil
		},
		column: companydocument.FieldCreatedAt,
		toTerm: companydocument.ByCreatedAt,
		toCursor: func(cd *CompanyDocument) Cursor {
			return Cursor{
				ID:    cd.ID,
				Value: cd.CreatedAt,
			}
		},
	}
	// CompanyDocumentOrderFieldUpdatedAt orders CompanyDocument by updatedAt.
	CompanyDocumentOrderFieldUpdatedAt = &CompanyDocumentOrderField{
		Value: func(cd *CompanyDocument) (ent.Value, error) {
			return cd.UpdatedAt, nil
		},
		column: companydocument.FieldUpdatedAt,
		toTerm: companydocument.ByUpdatedAt,
		toCursor: func(cd *CompanyDocument) Cursor {
			return Cursor{
				ID:    cd.ID,
				Value: cd.UpdatedAt,
			}
		},
	}
	// CompanyDocumentOrderFieldCategory orders CompanyDocument by category.
	CompanyDocumentOrderFieldCategory = &CompanyDocumentOrderField{
		Value: func(cd *CompanyDocument) (ent.Value, error) {
			return cd.Category, nil
		},
		column: companydocument.FieldCategory,
		toTerm: companydocument.ByCategory,
		toCursor: func(cd *CompanyDocument) Cursor {
			return Cursor{
				ID:    cd.ID,
				Value: cd.Category,
			}
		},
	}
	// CompanyDocumentOrderFieldStatus orders CompanyDocument by status.
	CompanyDocumentOrderFieldStatus = &CompanyDocumentOrderField{
		Value: func(cd *CompanyDocument) (ent.Value, error) {
			return cd.Status, nil
		},
		column: companydocument.FieldStatus,
		toTerm: companydocument.ByStatus,
		toCursor: func(cd *CompanyDocument) Cursor {
			return Cursor{
				ID:    cd.ID,
				Value: cd.Status,
			}
		},
	}
	// CompanyDocumentOrderFieldExpiryDate orders CompanyDocument by expiryDate.
	CompanyDocumentOrderFieldExpiryDate = &CompanyDocumentOrderField{
		Value: func(cd *CompanyDocument) (ent.Value, error) {
			return cd.ExpiryDate, nil
		},
		column: companydocument.FieldExpiryDate,
		toTerm: companydocument.ByExpiryDate,
		toCursor: func(cd *CompanyDocument) Cursor {
			return Cursor{
				ID:    cd.ID,
				Value: cd.ExpiryDate,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f CompanyDocumentOrderField) String() string {
	var str string
	switch f.column {
	case CompanyDocumentOrderFieldCreatedAt.column:
		str = "CREATED_AT"
	case CompanyDocumentOrderFieldUpdatedAt.column:
		str = "UPDATED_AT"
	case CompanyDocumentOrderFieldCategory.column:
		str = "CATEGORY"
	case CompanyDocumentOrderFieldStatus.column:
		str = "STATUS"
	case CompanyDocumentOrderFieldExpiryDate.column:
		str = "EXPIRY_DATE"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f CompanyDocumentOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *CompanyDocumentOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("CompanyDocumentOrderField %T must be a string", v)
	}
	switch str {
	case "CREATED_AT":
		*f = *CompanyDocumentOrderFieldCreatedAt
	case "UPDATED_AT":
		*f = *CompanyDocumentOrderFieldUpdatedAt
	case "CATEGORY":
		*f = *CompanyDocumentOrderFieldCategory
	case "STATUS":
		*f = *CompanyDocumentOrderFieldStatus
	case "EXPIRY_DATE":
		*f = *CompanyDocumentOrderFieldExpiryDate
	default:
		return fmt.Errorf("%s is not a valid CompanyDocumentOrderField", str)
	}
	return nil
}

// CompanyDocumentOrderField defines the ordering field of CompanyDocument.
type CompanyDocumentOrderField struct {
	// Value extracts the ordering value from the given CompanyDocument.
	Value    func(*CompanyDocument) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) companydocument.OrderOption
	toCursor func(*CompanyDocument) Cursor
}

// CompanyDocumentOrder defines the ordering of CompanyDocument.
type CompanyDocumentOrder struct {
	Direction OrderDirection             `json:"direction"`
	Field     *CompanyDocumentOrderField `json:"field"`
}

// DefaultCompanyDocumentOrder is the default ordering of CompanyDocument.
var DefaultCompanyDocumentOrder = &CompanyDocumentOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &CompanyDocumentOrderField{
		Value: func(cd *CompanyDocument) (ent.Value, error) {
			return cd.ID, nil
		},
		column: companydocument.FieldID,
		toTerm: companydocument.ByID,
		toCursor: func(cd *CompanyDocument) Cursor {
			return Cursor{ID: cd.ID}
		},
	},
}

// ToEdge converts CompanyDocument into CompanyDocumentEdge.
func (cd *CompanyDocument) ToEdge(order *CompanyDocumentOrder) *CompanyDocumentEdge {
	if order == nil {
		order = DefaultCompanyDocumentOrder
	}
	return &CompanyDocumentEdge{
		Node:   cd,
		Cursor: order.Field.toCursor(cd),
	}
}

// CustomerEdge is the edge representation of Customer.
type CustomerEdge struct {
	Node   *Customer `json:"node"`
	Cursor Cursor    `json:"cursor"`
}

// CustomerConnection is the connection containing edges to Customer.
type CustomerConnection struct {
	Edges      []*CustomerEdge `json:"edges"`
	PageInfo   PageInfo        `json:"pageInfo"`
	TotalCount int             `json:"totalCount"`
}

func (c *CustomerConnection) build(nodes []*Customer, pager *customerPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *Customer
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Customer {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Customer {
			return nodes[i]
		}
	}
	c.Edges = make([]*CustomerEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &CustomerEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// CustomerPaginateOption enables pagination customization.
type CustomerPaginateOption func(*customerPager) error

// WithCustomerOrder configures pagination ordering.
func WithCustomerOrder(order []*CustomerOrder) CustomerPaginateOption {
	return func(pager *customerPager) error {
		for _, o := range order {
			if err := o.Direction.Validate(); err != nil {
				return err
			}
		}
		pager.order = append(pager.order, order...)
		return nil
	}
}

// WithCustomerFilter configures pagination filter.
func WithCustomerFilter(filter func(*CustomerQuery) (*CustomerQuery, error)) CustomerPaginateOption {
	return func(pager *customerPager) error {
		if filter == nil {
			return errors.New("CustomerQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type customerPager struct {
	reverse bool
	order   []*CustomerOrder
	filter  func(*CustomerQuery) (*CustomerQuery, error)
}

func newCustomerPager(opts []CustomerPaginateOption, reverse bool) (*customerPager, error) {
	pager := &customerPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	for i, o := range pager.order {
		if i > 0 && o.Field == pager.order[i-1].Field {
			return nil, fmt.Errorf("duplicate order direction %q", o.Direction)
		}
	}
	return pager, nil
}

func (p *customerPager) applyFilter(query *CustomerQuery) (*CustomerQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *customerPager) toCursor(c *Customer) Cursor {
	cs := make([]any, 0, len(p.order))
	for _, o := range p.order {
		cs = append(cs, o.Field.toCursor(c).Value)
	}
	return Cursor{ID: c.ID, Value: cs}
}

func (p *customerPager) applyCursors(query *CustomerQuery, after, before *Cursor) (*CustomerQuery, error) {
	idDirection := entgql.OrderDirectionAsc
	if p.reverse {
		idDirection = entgql.OrderDirectionDesc
	}
	fields, directions := make([]string, 0, len(p.order)), make([]OrderDirection, 0, len(p.order))
	for _, o := range p.order {
		fields = append(fields, o.Field.column)
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		directions = append(directions, direction)
	}
	predicates, err := entgql.MultiCursorsPredicate(after, before, &entgql.MultiCursorsOptions{
		FieldID:     DefaultCustomerOrder.Field.column,
		DirectionID: idDirection,
		Fields:      fields,
		Directions:  directions,
	})
	if err != nil {
		return nil, err
	}
	for _, predicate := range predicates {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *customerPager) applyOrder(query *CustomerQuery) *CustomerQuery {
	var defaultOrdered bool
	for _, o := range p.order {
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(o.Field.toTerm(direction.OrderTermOption()))
		if o.Field.column == DefaultCustomerOrder.Field.column {
			defaultOrdered = true
		}
		if len(query.ctx.Fields) > 0 {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	if !defaultOrdered {
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(DefaultCustomerOrder.Field.toTerm(direction.OrderTermOption()))
	}
	return query
}

func (p *customerPager) orderExpr(query *CustomerQuery) sql.Querier {
	if len(query.ctx.Fields) > 0 {
		for _, o := range p.order {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		for _, o := range p.order {
			direction := o.Direction
			if p.reverse {
				direction = direction.Reverse()
			}
			b.Ident(o.Field.column).Pad().WriteString(string(direction))
			b.Comma()
		}
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		b.Ident(DefaultCustomerOrder.Field.column).Pad().WriteString(string(direction))
	})
}

// Paginate executes the query and returns a relay based cursor connection to Customer.
func (c *CustomerQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...CustomerPaginateOption,
) (*CustomerConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newCustomerPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if c, err = pager.applyFilter(c); err != nil {
		return nil, err
	}
	conn := &CustomerConnection{Edges: []*CustomerEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = c.Clone().Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if c, err = pager.applyCursors(c, after, before); err != nil {
		return nil, err
	}
	if limit := paginateLimit(first, last); limit != 0 {
		c.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := c.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	c = pager.applyOrder(c)
	nodes, err := c.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// CustomerOrderFieldCreatedAt orders Customer by createdAt.
	CustomerOrderFieldCreatedAt = &CustomerOrderField{
		Value: func(c *Customer) (ent.Value, error) {
			return c.CreatedAt, nil
		},
		column: customer.FieldCreatedAt,
		toTerm: customer.ByCreatedAt,
		toCursor: func(c *Customer) Cursor {
			return Cursor{
				ID:    c.ID,
				Value: c.CreatedAt,
			}
		},
	}
	// CustomerOrderFieldUpdatedAt orders Customer by updatedAt.
	CustomerOrderFieldUpdatedAt = &CustomerOrderField{
		Value: func(c *Customer) (ent.Value, error) {
			return c.UpdatedAt, nil
		},
		column: customer.FieldUpdatedAt,
		toTerm: customer.ByUpdatedAt,
		toCursor: func(c *Customer) Cursor {
			return Cursor{
				ID:    c.ID,
				Value: c.UpdatedAt,
			}
		},
	}
	// CustomerOrderFieldCity orders Customer by city.
	CustomerOrderFieldCity = &CustomerOrderField{
		Value: func(c *Customer) (ent.Value, error) {
			return c.City, nil
		},
		column: customer.FieldCity,
		toTerm: customer.ByCity,
		toCursor: func(c *Customer) Cursor {
			return Cursor{
				ID:    c.ID,
				Value: c.City,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f CustomerOrderField) String() string {
	var str string
	switch f.column {
	case CustomerOrderFieldCreatedAt.column:
		str = "CREATED_AT"
	case CustomerOrderFieldUpdatedAt.column:
		str = "UPDATED_AT"
	case CustomerOrderFieldCity.column:
		str = "CITY"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f CustomerOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *CustomerOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("CustomerOrderField %T must be a string", v)
	}
	switch str {
	case "CREATED_AT":
		*f = *CustomerOrderFieldCreatedAt
	case "UPDATED_AT":
		*f = *CustomerOrderFieldUpdatedAt
	case "CITY":
		*f = *CustomerOrderFieldCity
	default:
		return fmt.Errorf("%s is not a valid CustomerOrderField", str)
	}
	return nil
}

// CustomerOrderField defines the ordering field of Customer.
type CustomerOrderField struct {
	// Value extracts the ordering value from the given Customer.
	Value    func(*Customer) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) customer.OrderOption
	toCursor func(*Customer) Cursor
}

// CustomerOrder defines the ordering of Customer.
type CustomerOrder struct {
	Direction OrderDirection      `json:"direction"`
	Field     *CustomerOrderField `json:"field"`
}

// DefaultCustomerOrder is the default ordering of Customer.
var DefaultCustomerOrder = &CustomerOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &CustomerOrderField{
		Value: func(c *Customer) (ent.Value, error) {
			return c.ID, nil
		},
		column: customer.FieldID,
		toTerm: customer.ByID,
		toCursor: func(c *Customer) Cursor {
			return Cursor{ID: c.ID}
		},
	},
}

// ToEdge converts Customer into CustomerEdge.
func (c *Customer) ToEdge(order *CustomerOrder) *CustomerEdge {
	if order == nil {
		order = DefaultCustomerOrder
	}
	return &CustomerEdge{
		Node:   c,
		Cursor: order.Field.toCursor(c),
	}
}

// EmployeeEdge is the edge representation of Employee.
type EmployeeEdge struct {
	Node   *Employee `json:"node"`
	Cursor Cursor    `json:"cursor"`
}

// EmployeeConnection is the connection containing edges to Employee.
type EmployeeConnection struct {
	Edges      []*EmployeeEdge `json:"edges"`
	PageInfo   PageInfo        `json:"pageInfo"`
	TotalCount int             `json:"totalCount"`
}

func (c *EmployeeConnection) build(nodes []*Employee, pager *employeePager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *Employee
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Employee {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Employee {
			return nodes[i]
		}
	}
	c.Edges = make([]*EmployeeEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &EmployeeEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// EmployeePaginateOption enables pagination customization.
type EmployeePaginateOption func(*employeePager) error

// WithEmployeeOrder configures pagination ordering.
func WithEmployeeOrder(order *EmployeeOrder) EmployeePaginateOption {
	if order == nil {
		order = DefaultEmployeeOrder
	}
	o := *order
	return func(pager *employeePager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultEmployeeOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithEmployeeFilter configures pagination filter.
func WithEmployeeFilter(filter func(*EmployeeQuery) (*EmployeeQuery, error)) EmployeePaginateOption {
	return func(pager *employeePager) error {
		if filter == nil {
			return errors.New("EmployeeQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type employeePager struct {
	reverse bool
	order   *EmployeeOrder
	filter  func(*EmployeeQuery) (*EmployeeQuery, error)
}

func newEmployeePager(opts []EmployeePaginateOption, reverse bool) (*employeePager, error) {
	pager := &employeePager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultEmployeeOrder
	}
	return pager, nil
}

func (p *employeePager) applyFilter(query *EmployeeQuery) (*EmployeeQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *employeePager) toCursor(e *Employee) Cursor {
	return p.order.Field.toCursor(e)
}

func (p *employeePager) applyCursors(query *EmployeeQuery, after, before *Cursor) (*EmployeeQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultEmployeeOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *employeePager) applyOrder(query *EmployeeQuery) *EmployeeQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultEmployeeOrder.Field {
		query = query.Order(DefaultEmployeeOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *employeePager) orderExpr(query *EmployeeQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultEmployeeOrder.Field {
			b.Comma().Ident(DefaultEmployeeOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to Employee.
func (e *EmployeeQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...EmployeePaginateOption,
) (*EmployeeConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newEmployeePager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if e, err = pager.applyFilter(e); err != nil {
		return nil, err
	}
	conn := &EmployeeConnection{Edges: []*EmployeeEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = e.Clone().Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if e, err = pager.applyCursors(e, after, before); err != nil {
		return nil, err
	}
	if limit := paginateLimit(first, last); limit != 0 {
		e.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := e.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	e = pager.applyOrder(e)
	nodes, err := e.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// EmployeeOrderFieldCreatedAt orders Employee by createdAt.
	EmployeeOrderFieldCreatedAt = &EmployeeOrderField{
		Value: func(e *Employee) (ent.Value, error) {
			return e.CreatedAt, nil
		},
		column: employee.FieldCreatedAt,
		toTerm: employee.ByCreatedAt,
		toCursor: func(e *Employee) Cursor {
			return Cursor{
				ID:    e.ID,
				Value: e.CreatedAt,
			}
		},
	}
	// EmployeeOrderFieldUpdatedAt orders Employee by updatedAt.
	EmployeeOrderFieldUpdatedAt = &EmployeeOrderField{
		Value: func(e *Employee) (ent.Value, error) {
			return e.UpdatedAt, nil
		},
		column: employee.FieldUpdatedAt,
		toTerm: employee.ByUpdatedAt,
		toCursor: func(e *Employee) Cursor {
			return Cursor{
				ID:    e.ID,
				Value: e.UpdatedAt,
			}
		},
	}
	// EmployeeOrderFieldGender orders Employee by gender.
	EmployeeOrderFieldGender = &EmployeeOrderField{
		Value: func(e *Employee) (ent.Value, error) {
			return e.Gender, nil
		},
		column: employee.FieldGender,
		toTerm: employee.ByGender,
		toCursor: func(e *Employee) Cursor {
			return Cursor{
				ID:    e.ID,
				Value: e.Gender,
			}
		},
	}
	// EmployeeOrderFieldStatus orders Employee by status.
	EmployeeOrderFieldStatus = &EmployeeOrderField{
		Value: func(e *Employee) (ent.Value, error) {
			return e.Status, nil
		},
		column: employee.FieldStatus,
		toTerm: employee.ByStatus,
		toCursor: func(e *Employee) Cursor {
			return Cursor{
				ID:    e.ID,
				Value: e.Status,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f EmployeeOrderField) String() string {
	var str string
	switch f.column {
	case EmployeeOrderFieldCreatedAt.column:
		str = "CREATED_AT"
	case EmployeeOrderFieldUpdatedAt.column:
		str = "UPDATED_AT"
	case EmployeeOrderFieldGender.column:
		str = "GENDER"
	case EmployeeOrderFieldStatus.column:
		str = "STATUS"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f EmployeeOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *EmployeeOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("EmployeeOrderField %T must be a string", v)
	}
	switch str {
	case "CREATED_AT":
		*f = *EmployeeOrderFieldCreatedAt
	case "UPDATED_AT":
		*f = *EmployeeOrderFieldUpdatedAt
	case "GENDER":
		*f = *EmployeeOrderFieldGender
	case "STATUS":
		*f = *EmployeeOrderFieldStatus
	default:
		return fmt.Errorf("%s is not a valid EmployeeOrderField", str)
	}
	return nil
}

// EmployeeOrderField defines the ordering field of Employee.
type EmployeeOrderField struct {
	// Value extracts the ordering value from the given Employee.
	Value    func(*Employee) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) employee.OrderOption
	toCursor func(*Employee) Cursor
}

// EmployeeOrder defines the ordering of Employee.
type EmployeeOrder struct {
	Direction OrderDirection      `json:"direction"`
	Field     *EmployeeOrderField `json:"field"`
}

// DefaultEmployeeOrder is the default ordering of Employee.
var DefaultEmployeeOrder = &EmployeeOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &EmployeeOrderField{
		Value: func(e *Employee) (ent.Value, error) {
			return e.ID, nil
		},
		column: employee.FieldID,
		toTerm: employee.ByID,
		toCursor: func(e *Employee) Cursor {
			return Cursor{ID: e.ID}
		},
	},
}

// ToEdge converts Employee into EmployeeEdge.
func (e *Employee) ToEdge(order *EmployeeOrder) *EmployeeEdge {
	if order == nil {
		order = DefaultEmployeeOrder
	}
	return &EmployeeEdge{
		Node:   e,
		Cursor: order.Field.toCursor(e),
	}
}

// FileEdge is the edge representation of File.
type FileEdge struct {
	Node   *File  `json:"node"`
	Cursor Cursor `json:"cursor"`
}

// FileConnection is the connection containing edges to File.
type FileConnection struct {
	Edges      []*FileEdge `json:"edges"`
	PageInfo   PageInfo    `json:"pageInfo"`
	TotalCount int         `json:"totalCount"`
}

func (c *FileConnection) build(nodes []*File, pager *filePager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *File
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *File {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *File {
			return nodes[i]
		}
	}
	c.Edges = make([]*FileEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &FileEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// FilePaginateOption enables pagination customization.
type FilePaginateOption func(*filePager) error

// WithFileOrder configures pagination ordering.
func WithFileOrder(order *FileOrder) FilePaginateOption {
	if order == nil {
		order = DefaultFileOrder
	}
	o := *order
	return func(pager *filePager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultFileOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithFileFilter configures pagination filter.
func WithFileFilter(filter func(*FileQuery) (*FileQuery, error)) FilePaginateOption {
	return func(pager *filePager) error {
		if filter == nil {
			return errors.New("FileQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type filePager struct {
	reverse bool
	order   *FileOrder
	filter  func(*FileQuery) (*FileQuery, error)
}

func newFilePager(opts []FilePaginateOption, reverse bool) (*filePager, error) {
	pager := &filePager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultFileOrder
	}
	return pager, nil
}

func (p *filePager) applyFilter(query *FileQuery) (*FileQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *filePager) toCursor(f *File) Cursor {
	return p.order.Field.toCursor(f)
}

func (p *filePager) applyCursors(query *FileQuery, after, before *Cursor) (*FileQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultFileOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *filePager) applyOrder(query *FileQuery) *FileQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultFileOrder.Field {
		query = query.Order(DefaultFileOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *filePager) orderExpr(query *FileQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultFileOrder.Field {
			b.Comma().Ident(DefaultFileOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to File.
func (f *FileQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...FilePaginateOption,
) (*FileConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newFilePager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if f, err = pager.applyFilter(f); err != nil {
		return nil, err
	}
	conn := &FileConnection{Edges: []*FileEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = f.Clone().Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if f, err = pager.applyCursors(f, after, before); err != nil {
		return nil, err
	}
	if limit := paginateLimit(first, last); limit != 0 {
		f.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := f.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	f = pager.applyOrder(f)
	nodes, err := f.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// FileOrderFieldCreatedAt orders File by createdAt.
	FileOrderFieldCreatedAt = &FileOrderField{
		Value: func(f *File) (ent.Value, error) {
			return f.CreatedAt, nil
		},
		column: file.FieldCreatedAt,
		toTerm: file.ByCreatedAt,
		toCursor: func(f *File) Cursor {
			return Cursor{
				ID:    f.ID,
				Value: f.CreatedAt,
			}
		},
	}
	// FileOrderFieldUpdatedAt orders File by updatedAt.
	FileOrderFieldUpdatedAt = &FileOrderField{
		Value: func(f *File) (ent.Value, error) {
			return f.UpdatedAt, nil
		},
		column: file.FieldUpdatedAt,
		toTerm: file.ByUpdatedAt,
		toCursor: func(f *File) Cursor {
			return Cursor{
				ID:    f.ID,
				Value: f.UpdatedAt,
			}
		},
	}
	// FileOrderFieldCategory orders File by category.
	FileOrderFieldCategory = &FileOrderField{
		Value: func(f *File) (ent.Value, error) {
			return f.Category, nil
		},
		column: file.FieldCategory,
		toTerm: file.ByCategory,
		toCursor: func(f *File) Cursor {
			return Cursor{
				ID:    f.ID,
				Value: f.Category,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f FileOrderField) String() string {
	var str string
	switch f.column {
	case FileOrderFieldCreatedAt.column:
		str = "CREATED_AT"
	case FileOrderFieldUpdatedAt.column:
		str = "UPDATED_AT"
	case FileOrderFieldCategory.column:
		str = "CATEGORY"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f FileOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *FileOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("FileOrderField %T must be a string", v)
	}
	switch str {
	case "CREATED_AT":
		*f = *FileOrderFieldCreatedAt
	case "UPDATED_AT":
		*f = *FileOrderFieldUpdatedAt
	case "CATEGORY":
		*f = *FileOrderFieldCategory
	default:
		return fmt.Errorf("%s is not a valid FileOrderField", str)
	}
	return nil
}

// FileOrderField defines the ordering field of File.
type FileOrderField struct {
	// Value extracts the ordering value from the given File.
	Value    func(*File) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) file.OrderOption
	toCursor func(*File) Cursor
}

// FileOrder defines the ordering of File.
type FileOrder struct {
	Direction OrderDirection  `json:"direction"`
	Field     *FileOrderField `json:"field"`
}

// DefaultFileOrder is the default ordering of File.
var DefaultFileOrder = &FileOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &FileOrderField{
		Value: func(f *File) (ent.Value, error) {
			return f.ID, nil
		},
		column: file.FieldID,
		toTerm: file.ByID,
		toCursor: func(f *File) Cursor {
			return Cursor{ID: f.ID}
		},
	},
}

// ToEdge converts File into FileEdge.
func (f *File) ToEdge(order *FileOrder) *FileEdge {
	if order == nil {
		order = DefaultFileOrder
	}
	return &FileEdge{
		Node:   f,
		Cursor: order.Field.toCursor(f),
	}
}

// InventoryEdge is the edge representation of Inventory.
type InventoryEdge struct {
	Node   *Inventory `json:"node"`
	Cursor Cursor     `json:"cursor"`
}

// InventoryConnection is the connection containing edges to Inventory.
type InventoryConnection struct {
	Edges      []*InventoryEdge `json:"edges"`
	PageInfo   PageInfo         `json:"pageInfo"`
	TotalCount int              `json:"totalCount"`
}

func (c *InventoryConnection) build(nodes []*Inventory, pager *inventoryPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *Inventory
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Inventory {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Inventory {
			return nodes[i]
		}
	}
	c.Edges = make([]*InventoryEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &InventoryEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// InventoryPaginateOption enables pagination customization.
type InventoryPaginateOption func(*inventoryPager) error

// WithInventoryOrder configures pagination ordering.
func WithInventoryOrder(order []*InventoryOrder) InventoryPaginateOption {
	return func(pager *inventoryPager) error {
		for _, o := range order {
			if err := o.Direction.Validate(); err != nil {
				return err
			}
		}
		pager.order = append(pager.order, order...)
		return nil
	}
}

// WithInventoryFilter configures pagination filter.
func WithInventoryFilter(filter func(*InventoryQuery) (*InventoryQuery, error)) InventoryPaginateOption {
	return func(pager *inventoryPager) error {
		if filter == nil {
			return errors.New("InventoryQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type inventoryPager struct {
	reverse bool
	order   []*InventoryOrder
	filter  func(*InventoryQuery) (*InventoryQuery, error)
}

func newInventoryPager(opts []InventoryPaginateOption, reverse bool) (*inventoryPager, error) {
	pager := &inventoryPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	for i, o := range pager.order {
		if i > 0 && o.Field == pager.order[i-1].Field {
			return nil, fmt.Errorf("duplicate order direction %q", o.Direction)
		}
	}
	return pager, nil
}

func (p *inventoryPager) applyFilter(query *InventoryQuery) (*InventoryQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *inventoryPager) toCursor(i *Inventory) Cursor {
	cs := make([]any, 0, len(p.order))
	for _, o := range p.order {
		cs = append(cs, o.Field.toCursor(i).Value)
	}
	return Cursor{ID: i.ID, Value: cs}
}

func (p *inventoryPager) applyCursors(query *InventoryQuery, after, before *Cursor) (*InventoryQuery, error) {
	idDirection := entgql.OrderDirectionAsc
	if p.reverse {
		idDirection = entgql.OrderDirectionDesc
	}
	fields, directions := make([]string, 0, len(p.order)), make([]OrderDirection, 0, len(p.order))
	for _, o := range p.order {
		fields = append(fields, o.Field.column)
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		directions = append(directions, direction)
	}
	predicates, err := entgql.MultiCursorsPredicate(after, before, &entgql.MultiCursorsOptions{
		FieldID:     DefaultInventoryOrder.Field.column,
		DirectionID: idDirection,
		Fields:      fields,
		Directions:  directions,
	})
	if err != nil {
		return nil, err
	}
	for _, predicate := range predicates {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *inventoryPager) applyOrder(query *InventoryQuery) *InventoryQuery {
	var defaultOrdered bool
	for _, o := range p.order {
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(o.Field.toTerm(direction.OrderTermOption()))
		if o.Field.column == DefaultInventoryOrder.Field.column {
			defaultOrdered = true
		}
		if len(query.ctx.Fields) > 0 {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	if !defaultOrdered {
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(DefaultInventoryOrder.Field.toTerm(direction.OrderTermOption()))
	}
	return query
}

func (p *inventoryPager) orderExpr(query *InventoryQuery) sql.Querier {
	if len(query.ctx.Fields) > 0 {
		for _, o := range p.order {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		for _, o := range p.order {
			direction := o.Direction
			if p.reverse {
				direction = direction.Reverse()
			}
			b.Ident(o.Field.column).Pad().WriteString(string(direction))
			b.Comma()
		}
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		b.Ident(DefaultInventoryOrder.Field.column).Pad().WriteString(string(direction))
	})
}

// Paginate executes the query and returns a relay based cursor connection to Inventory.
func (i *InventoryQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...InventoryPaginateOption,
) (*InventoryConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newInventoryPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if i, err = pager.applyFilter(i); err != nil {
		return nil, err
	}
	conn := &InventoryConnection{Edges: []*InventoryEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = i.Clone().Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if i, err = pager.applyCursors(i, after, before); err != nil {
		return nil, err
	}
	if limit := paginateLimit(first, last); limit != 0 {
		i.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := i.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	i = pager.applyOrder(i)
	nodes, err := i.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// InventoryOrderFieldCreatedAt orders Inventory by createdAt.
	InventoryOrderFieldCreatedAt = &InventoryOrderField{
		Value: func(i *Inventory) (ent.Value, error) {
			return i.CreatedAt, nil
		},
		column: inventory.FieldCreatedAt,
		toTerm: inventory.ByCreatedAt,
		toCursor: func(i *Inventory) Cursor {
			return Cursor{
				ID:    i.ID,
				Value: i.CreatedAt,
			}
		},
	}
	// InventoryOrderFieldUpdatedAt orders Inventory by updatedAt.
	InventoryOrderFieldUpdatedAt = &InventoryOrderField{
		Value: func(i *Inventory) (ent.Value, error) {
			return i.UpdatedAt, nil
		},
		column: inventory.FieldUpdatedAt,
		toTerm: inventory.ByUpdatedAt,
		toCursor: func(i *Inventory) Cursor {
			return Cursor{
				ID:    i.ID,
				Value: i.UpdatedAt,
			}
		},
	}
	// InventoryOrderFieldCategory orders Inventory by category.
	InventoryOrderFieldCategory = &InventoryOrderField{
		Value: func(i *Inventory) (ent.Value, error) {
			return i.Category, nil
		},
		column: inventory.FieldCategory,
		toTerm: inventory.ByCategory,
		toCursor: func(i *Inventory) Cursor {
			return Cursor{
				ID:    i.ID,
				Value: i.Category,
			}
		},
	}
	// InventoryOrderFieldCurrentValue orders Inventory by currentValue.
	InventoryOrderFieldCurrentValue = &InventoryOrderField{
		Value: func(i *Inventory) (ent.Value, error) {
			return i.CurrentValue, nil
		},
		column: inventory.FieldCurrentValue,
		toTerm: inventory.ByCurrentValue,
		toCursor: func(i *Inventory) Cursor {
			return Cursor{
				ID:    i.ID,
				Value: i.CurrentValue,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f InventoryOrderField) String() string {
	var str string
	switch f.column {
	case InventoryOrderFieldCreatedAt.column:
		str = "CREATED_AT"
	case InventoryOrderFieldUpdatedAt.column:
		str = "UPDATED_AT"
	case InventoryOrderFieldCategory.column:
		str = "CATEGORY"
	case InventoryOrderFieldCurrentValue.column:
		str = "CURRENT_VALUE"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f InventoryOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *InventoryOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("InventoryOrderField %T must be a string", v)
	}
	switch str {
	case "CREATED_AT":
		*f = *InventoryOrderFieldCreatedAt
	case "UPDATED_AT":
		*f = *InventoryOrderFieldUpdatedAt
	case "CATEGORY":
		*f = *InventoryOrderFieldCategory
	case "CURRENT_VALUE":
		*f = *InventoryOrderFieldCurrentValue
	default:
		return fmt.Errorf("%s is not a valid InventoryOrderField", str)
	}
	return nil
}

// InventoryOrderField defines the ordering field of Inventory.
type InventoryOrderField struct {
	// Value extracts the ordering value from the given Inventory.
	Value    func(*Inventory) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) inventory.OrderOption
	toCursor func(*Inventory) Cursor
}

// InventoryOrder defines the ordering of Inventory.
type InventoryOrder struct {
	Direction OrderDirection       `json:"direction"`
	Field     *InventoryOrderField `json:"field"`
}

// DefaultInventoryOrder is the default ordering of Inventory.
var DefaultInventoryOrder = &InventoryOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &InventoryOrderField{
		Value: func(i *Inventory) (ent.Value, error) {
			return i.ID, nil
		},
		column: inventory.FieldID,
		toTerm: inventory.ByID,
		toCursor: func(i *Inventory) Cursor {
			return Cursor{ID: i.ID}
		},
	},
}

// ToEdge converts Inventory into InventoryEdge.
func (i *Inventory) ToEdge(order *InventoryOrder) *InventoryEdge {
	if order == nil {
		order = DefaultInventoryOrder
	}
	return &InventoryEdge{
		Node:   i,
		Cursor: order.Field.toCursor(i),
	}
}

// InventoryMovementEdge is the edge representation of InventoryMovement.
type InventoryMovementEdge struct {
	Node   *InventoryMovement `json:"node"`
	Cursor Cursor             `json:"cursor"`
}

// InventoryMovementConnection is the connection containing edges to InventoryMovement.
type InventoryMovementConnection struct {
	Edges      []*InventoryMovementEdge `json:"edges"`
	PageInfo   PageInfo                 `json:"pageInfo"`
	TotalCount int                      `json:"totalCount"`
}

func (c *InventoryMovementConnection) build(nodes []*InventoryMovement, pager *inventorymovementPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *InventoryMovement
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *InventoryMovement {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *InventoryMovement {
			return nodes[i]
		}
	}
	c.Edges = make([]*InventoryMovementEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &InventoryMovementEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// InventoryMovementPaginateOption enables pagination customization.
type InventoryMovementPaginateOption func(*inventorymovementPager) error

// WithInventoryMovementOrder configures pagination ordering.
func WithInventoryMovementOrder(order []*InventoryMovementOrder) InventoryMovementPaginateOption {
	return func(pager *inventorymovementPager) error {
		for _, o := range order {
			if err := o.Direction.Validate(); err != nil {
				return err
			}
		}
		pager.order = append(pager.order, order...)
		return nil
	}
}

// WithInventoryMovementFilter configures pagination filter.
func WithInventoryMovementFilter(filter func(*InventoryMovementQuery) (*InventoryMovementQuery, error)) InventoryMovementPaginateOption {
	return func(pager *inventorymovementPager) error {
		if filter == nil {
			return errors.New("InventoryMovementQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type inventorymovementPager struct {
	reverse bool
	order   []*InventoryMovementOrder
	filter  func(*InventoryMovementQuery) (*InventoryMovementQuery, error)
}

func newInventoryMovementPager(opts []InventoryMovementPaginateOption, reverse bool) (*inventorymovementPager, error) {
	pager := &inventorymovementPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	for i, o := range pager.order {
		if i > 0 && o.Field == pager.order[i-1].Field {
			return nil, fmt.Errorf("duplicate order direction %q", o.Direction)
		}
	}
	return pager, nil
}

func (p *inventorymovementPager) applyFilter(query *InventoryMovementQuery) (*InventoryMovementQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *inventorymovementPager) toCursor(im *InventoryMovement) Cursor {
	cs := make([]any, 0, len(p.order))
	for _, o := range p.order {
		cs = append(cs, o.Field.toCursor(im).Value)
	}
	return Cursor{ID: im.ID, Value: cs}
}

func (p *inventorymovementPager) applyCursors(query *InventoryMovementQuery, after, before *Cursor) (*InventoryMovementQuery, error) {
	idDirection := entgql.OrderDirectionAsc
	if p.reverse {
		idDirection = entgql.OrderDirectionDesc
	}
	fields, directions := make([]string, 0, len(p.order)), make([]OrderDirection, 0, len(p.order))
	for _, o := range p.order {
		fields = append(fields, o.Field.column)
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		directions = append(directions, direction)
	}
	predicates, err := entgql.MultiCursorsPredicate(after, before, &entgql.MultiCursorsOptions{
		FieldID:     DefaultInventoryMovementOrder.Field.column,
		DirectionID: idDirection,
		Fields:      fields,
		Directions:  directions,
	})
	if err != nil {
		return nil, err
	}
	for _, predicate := range predicates {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *inventorymovementPager) applyOrder(query *InventoryMovementQuery) *InventoryMovementQuery {
	var defaultOrdered bool
	for _, o := range p.order {
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(o.Field.toTerm(direction.OrderTermOption()))
		if o.Field.column == DefaultInventoryMovementOrder.Field.column {
			defaultOrdered = true
		}
		if len(query.ctx.Fields) > 0 {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	if !defaultOrdered {
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(DefaultInventoryMovementOrder.Field.toTerm(direction.OrderTermOption()))
	}
	return query
}

func (p *inventorymovementPager) orderExpr(query *InventoryMovementQuery) sql.Querier {
	if len(query.ctx.Fields) > 0 {
		for _, o := range p.order {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		for _, o := range p.order {
			direction := o.Direction
			if p.reverse {
				direction = direction.Reverse()
			}
			b.Ident(o.Field.column).Pad().WriteString(string(direction))
			b.Comma()
		}
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		b.Ident(DefaultInventoryMovementOrder.Field.column).Pad().WriteString(string(direction))
	})
}

// Paginate executes the query and returns a relay based cursor connection to InventoryMovement.
func (im *InventoryMovementQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...InventoryMovementPaginateOption,
) (*InventoryMovementConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newInventoryMovementPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if im, err = pager.applyFilter(im); err != nil {
		return nil, err
	}
	conn := &InventoryMovementConnection{Edges: []*InventoryMovementEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = im.Clone().Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if im, err = pager.applyCursors(im, after, before); err != nil {
		return nil, err
	}
	if limit := paginateLimit(first, last); limit != 0 {
		im.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := im.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	im = pager.applyOrder(im)
	nodes, err := im.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// InventoryMovementOrderFieldCreatedAt orders InventoryMovement by createdAt.
	InventoryMovementOrderFieldCreatedAt = &InventoryMovementOrderField{
		Value: func(im *InventoryMovement) (ent.Value, error) {
			return im.CreatedAt, nil
		},
		column: inventorymovement.FieldCreatedAt,
		toTerm: inventorymovement.ByCreatedAt,
		toCursor: func(im *InventoryMovement) Cursor {
			return Cursor{
				ID:    im.ID,
				Value: im.CreatedAt,
			}
		},
	}
	// InventoryMovementOrderFieldUpdatedAt orders InventoryMovement by updatedAt.
	InventoryMovementOrderFieldUpdatedAt = &InventoryMovementOrderField{
		Value: func(im *InventoryMovement) (ent.Value, error) {
			return im.UpdatedAt, nil
		},
		column: inventorymovement.FieldUpdatedAt,
		toTerm: inventorymovement.ByUpdatedAt,
		toCursor: func(im *InventoryMovement) Cursor {
			return Cursor{
				ID:    im.ID,
				Value: im.UpdatedAt,
			}
		},
	}
	// InventoryMovementOrderFieldCategory orders InventoryMovement by category.
	InventoryMovementOrderFieldCategory = &InventoryMovementOrderField{
		Value: func(im *InventoryMovement) (ent.Value, error) {
			return im.Category, nil
		},
		column: inventorymovement.FieldCategory,
		toTerm: inventorymovement.ByCategory,
		toCursor: func(im *InventoryMovement) Cursor {
			return Cursor{
				ID:    im.ID,
				Value: im.Category,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f InventoryMovementOrderField) String() string {
	var str string
	switch f.column {
	case InventoryMovementOrderFieldCreatedAt.column:
		str = "CREATED_AT"
	case InventoryMovementOrderFieldUpdatedAt.column:
		str = "UPDATED_AT"
	case InventoryMovementOrderFieldCategory.column:
		str = "CATEGORY"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f InventoryMovementOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *InventoryMovementOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("InventoryMovementOrderField %T must be a string", v)
	}
	switch str {
	case "CREATED_AT":
		*f = *InventoryMovementOrderFieldCreatedAt
	case "UPDATED_AT":
		*f = *InventoryMovementOrderFieldUpdatedAt
	case "CATEGORY":
		*f = *InventoryMovementOrderFieldCategory
	default:
		return fmt.Errorf("%s is not a valid InventoryMovementOrderField", str)
	}
	return nil
}

// InventoryMovementOrderField defines the ordering field of InventoryMovement.
type InventoryMovementOrderField struct {
	// Value extracts the ordering value from the given InventoryMovement.
	Value    func(*InventoryMovement) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) inventorymovement.OrderOption
	toCursor func(*InventoryMovement) Cursor
}

// InventoryMovementOrder defines the ordering of InventoryMovement.
type InventoryMovementOrder struct {
	Direction OrderDirection               `json:"direction"`
	Field     *InventoryMovementOrderField `json:"field"`
}

// DefaultInventoryMovementOrder is the default ordering of InventoryMovement.
var DefaultInventoryMovementOrder = &InventoryMovementOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &InventoryMovementOrderField{
		Value: func(im *InventoryMovement) (ent.Value, error) {
			return im.ID, nil
		},
		column: inventorymovement.FieldID,
		toTerm: inventorymovement.ByID,
		toCursor: func(im *InventoryMovement) Cursor {
			return Cursor{ID: im.ID}
		},
	},
}

// ToEdge converts InventoryMovement into InventoryMovementEdge.
func (im *InventoryMovement) ToEdge(order *InventoryMovementOrder) *InventoryMovementEdge {
	if order == nil {
		order = DefaultInventoryMovementOrder
	}
	return &InventoryMovementEdge{
		Node:   im,
		Cursor: order.Field.toCursor(im),
	}
}

// InvoiceEdge is the edge representation of Invoice.
type InvoiceEdge struct {
	Node   *Invoice `json:"node"`
	Cursor Cursor   `json:"cursor"`
}

// InvoiceConnection is the connection containing edges to Invoice.
type InvoiceConnection struct {
	Edges      []*InvoiceEdge `json:"edges"`
	PageInfo   PageInfo       `json:"pageInfo"`
	TotalCount int            `json:"totalCount"`
}

func (c *InvoiceConnection) build(nodes []*Invoice, pager *invoicePager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *Invoice
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Invoice {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Invoice {
			return nodes[i]
		}
	}
	c.Edges = make([]*InvoiceEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &InvoiceEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// InvoicePaginateOption enables pagination customization.
type InvoicePaginateOption func(*invoicePager) error

// WithInvoiceOrder configures pagination ordering.
func WithInvoiceOrder(order []*InvoiceOrder) InvoicePaginateOption {
	return func(pager *invoicePager) error {
		for _, o := range order {
			if err := o.Direction.Validate(); err != nil {
				return err
			}
		}
		pager.order = append(pager.order, order...)
		return nil
	}
}

// WithInvoiceFilter configures pagination filter.
func WithInvoiceFilter(filter func(*InvoiceQuery) (*InvoiceQuery, error)) InvoicePaginateOption {
	return func(pager *invoicePager) error {
		if filter == nil {
			return errors.New("InvoiceQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type invoicePager struct {
	reverse bool
	order   []*InvoiceOrder
	filter  func(*InvoiceQuery) (*InvoiceQuery, error)
}

func newInvoicePager(opts []InvoicePaginateOption, reverse bool) (*invoicePager, error) {
	pager := &invoicePager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	for i, o := range pager.order {
		if i > 0 && o.Field == pager.order[i-1].Field {
			return nil, fmt.Errorf("duplicate order direction %q", o.Direction)
		}
	}
	return pager, nil
}

func (p *invoicePager) applyFilter(query *InvoiceQuery) (*InvoiceQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *invoicePager) toCursor(i *Invoice) Cursor {
	cs := make([]any, 0, len(p.order))
	for _, o := range p.order {
		cs = append(cs, o.Field.toCursor(i).Value)
	}
	return Cursor{ID: i.ID, Value: cs}
}

func (p *invoicePager) applyCursors(query *InvoiceQuery, after, before *Cursor) (*InvoiceQuery, error) {
	idDirection := entgql.OrderDirectionAsc
	if p.reverse {
		idDirection = entgql.OrderDirectionDesc
	}
	fields, directions := make([]string, 0, len(p.order)), make([]OrderDirection, 0, len(p.order))
	for _, o := range p.order {
		fields = append(fields, o.Field.column)
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		directions = append(directions, direction)
	}
	predicates, err := entgql.MultiCursorsPredicate(after, before, &entgql.MultiCursorsOptions{
		FieldID:     DefaultInvoiceOrder.Field.column,
		DirectionID: idDirection,
		Fields:      fields,
		Directions:  directions,
	})
	if err != nil {
		return nil, err
	}
	for _, predicate := range predicates {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *invoicePager) applyOrder(query *InvoiceQuery) *InvoiceQuery {
	var defaultOrdered bool
	for _, o := range p.order {
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(o.Field.toTerm(direction.OrderTermOption()))
		if o.Field.column == DefaultInvoiceOrder.Field.column {
			defaultOrdered = true
		}
		if len(query.ctx.Fields) > 0 {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	if !defaultOrdered {
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(DefaultInvoiceOrder.Field.toTerm(direction.OrderTermOption()))
	}
	return query
}

func (p *invoicePager) orderExpr(query *InvoiceQuery) sql.Querier {
	if len(query.ctx.Fields) > 0 {
		for _, o := range p.order {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		for _, o := range p.order {
			direction := o.Direction
			if p.reverse {
				direction = direction.Reverse()
			}
			b.Ident(o.Field.column).Pad().WriteString(string(direction))
			b.Comma()
		}
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		b.Ident(DefaultInvoiceOrder.Field.column).Pad().WriteString(string(direction))
	})
}

// Paginate executes the query and returns a relay based cursor connection to Invoice.
func (i *InvoiceQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...InvoicePaginateOption,
) (*InvoiceConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newInvoicePager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if i, err = pager.applyFilter(i); err != nil {
		return nil, err
	}
	conn := &InvoiceConnection{Edges: []*InvoiceEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = i.Clone().Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if i, err = pager.applyCursors(i, after, before); err != nil {
		return nil, err
	}
	if limit := paginateLimit(first, last); limit != 0 {
		i.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := i.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	i = pager.applyOrder(i)
	nodes, err := i.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// InvoiceOrderFieldCreatedAt orders Invoice by createdAt.
	InvoiceOrderFieldCreatedAt = &InvoiceOrderField{
		Value: func(i *Invoice) (ent.Value, error) {
			return i.CreatedAt, nil
		},
		column: invoice.FieldCreatedAt,
		toTerm: invoice.ByCreatedAt,
		toCursor: func(i *Invoice) Cursor {
			return Cursor{
				ID:    i.ID,
				Value: i.CreatedAt,
			}
		},
	}
	// InvoiceOrderFieldUpdatedAt orders Invoice by updatedAt.
	InvoiceOrderFieldUpdatedAt = &InvoiceOrderField{
		Value: func(i *Invoice) (ent.Value, error) {
			return i.UpdatedAt, nil
		},
		column: invoice.FieldUpdatedAt,
		toTerm: invoice.ByUpdatedAt,
		toCursor: func(i *Invoice) Cursor {
			return Cursor{
				ID:    i.ID,
				Value: i.UpdatedAt,
			}
		},
	}
	// InvoiceOrderFieldIssueDate orders Invoice by issueDate.
	InvoiceOrderFieldIssueDate = &InvoiceOrderField{
		Value: func(i *Invoice) (ent.Value, error) {
			return i.IssueDate, nil
		},
		column: invoice.FieldIssueDate,
		toTerm: invoice.ByIssueDate,
		toCursor: func(i *Invoice) Cursor {
			return Cursor{
				ID:    i.ID,
				Value: i.IssueDate,
			}
		},
	}
	// InvoiceOrderFieldDueDate orders Invoice by dueDate.
	InvoiceOrderFieldDueDate = &InvoiceOrderField{
		Value: func(i *Invoice) (ent.Value, error) {
			return i.DueDate, nil
		},
		column: invoice.FieldDueDate,
		toTerm: invoice.ByDueDate,
		toCursor: func(i *Invoice) Cursor {
			return Cursor{
				ID:    i.ID,
				Value: i.DueDate,
			}
		},
	}
	// InvoiceOrderFieldPaidAt orders Invoice by paidAt.
	InvoiceOrderFieldPaidAt = &InvoiceOrderField{
		Value: func(i *Invoice) (ent.Value, error) {
			return i.PaidAt, nil
		},
		column: invoice.FieldPaidAt,
		toTerm: invoice.ByPaidAt,
		toCursor: func(i *Invoice) Cursor {
			return Cursor{
				ID:    i.ID,
				Value: i.PaidAt,
			}
		},
	}
	// InvoiceOrderFieldStatus orders Invoice by status.
	InvoiceOrderFieldStatus = &InvoiceOrderField{
		Value: func(i *Invoice) (ent.Value, error) {
			return i.Status, nil
		},
		column: invoice.FieldStatus,
		toTerm: invoice.ByStatus,
		toCursor: func(i *Invoice) Cursor {
			return Cursor{
				ID:    i.ID,
				Value: i.Status,
			}
		},
	}
	// InvoiceOrderFieldTotal orders Invoice by total.
	InvoiceOrderFieldTotal = &InvoiceOrderField{
		Value: func(i *Invoice) (ent.Value, error) {
			return i.Total, nil
		},
		column: invoice.FieldTotal,
		toTerm: invoice.ByTotal,
		toCursor: func(i *Invoice) Cursor {
			return Cursor{
				ID:    i.ID,
				Value: i.Total,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f InvoiceOrderField) String() string {
	var str string
	switch f.column {
	case InvoiceOrderFieldCreatedAt.column:
		str = "CREATED_AT"
	case InvoiceOrderFieldUpdatedAt.column:
		str = "UPDATED_AT"
	case InvoiceOrderFieldIssueDate.column:
		str = "ISSUE_DATE"
	case InvoiceOrderFieldDueDate.column:
		str = "DUE_DATE"
	case InvoiceOrderFieldPaidAt.column:
		str = "PAID_AT"
	case InvoiceOrderFieldStatus.column:
		str = "STATUS"
	case InvoiceOrderFieldTotal.column:
		str = "TOTAL"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f InvoiceOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *InvoiceOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("InvoiceOrderField %T must be a string", v)
	}
	switch str {
	case "CREATED_AT":
		*f = *InvoiceOrderFieldCreatedAt
	case "UPDATED_AT":
		*f = *InvoiceOrderFieldUpdatedAt
	case "ISSUE_DATE":
		*f = *InvoiceOrderFieldIssueDate
	case "DUE_DATE":
		*f = *InvoiceOrderFieldDueDate
	case "PAID_AT":
		*f = *InvoiceOrderFieldPaidAt
	case "STATUS":
		*f = *InvoiceOrderFieldStatus
	case "TOTAL":
		*f = *InvoiceOrderFieldTotal
	default:
		return fmt.Errorf("%s is not a valid InvoiceOrderField", str)
	}
	return nil
}

// InvoiceOrderField defines the ordering field of Invoice.
type InvoiceOrderField struct {
	// Value extracts the ordering value from the given Invoice.
	Value    func(*Invoice) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) invoice.OrderOption
	toCursor func(*Invoice) Cursor
}

// InvoiceOrder defines the ordering of Invoice.
type InvoiceOrder struct {
	Direction OrderDirection     `json:"direction"`
	Field     *InvoiceOrderField `json:"field"`
}

// DefaultInvoiceOrder is the default ordering of Invoice.
var DefaultInvoiceOrder = &InvoiceOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &InvoiceOrderField{
		Value: func(i *Invoice) (ent.Value, error) {
			return i.ID, nil
		},
		column: invoice.FieldID,
		toTerm: invoice.ByID,
		toCursor: func(i *Invoice) Cursor {
			return Cursor{ID: i.ID}
		},
	},
}

// ToEdge converts Invoice into InvoiceEdge.
func (i *Invoice) ToEdge(order *InvoiceOrder) *InvoiceEdge {
	if order == nil {
		order = DefaultInvoiceOrder
	}
	return &InvoiceEdge{
		Node:   i,
		Cursor: order.Field.toCursor(i),
	}
}

// MemberSignupTokenEdge is the edge representation of MemberSignupToken.
type MemberSignupTokenEdge struct {
	Node   *MemberSignupToken `json:"node"`
	Cursor Cursor             `json:"cursor"`
}

// MemberSignupTokenConnection is the connection containing edges to MemberSignupToken.
type MemberSignupTokenConnection struct {
	Edges      []*MemberSignupTokenEdge `json:"edges"`
	PageInfo   PageInfo                 `json:"pageInfo"`
	TotalCount int                      `json:"totalCount"`
}

func (c *MemberSignupTokenConnection) build(nodes []*MemberSignupToken, pager *membersignuptokenPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *MemberSignupToken
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *MemberSignupToken {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *MemberSignupToken {
			return nodes[i]
		}
	}
	c.Edges = make([]*MemberSignupTokenEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &MemberSignupTokenEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// MemberSignupTokenPaginateOption enables pagination customization.
type MemberSignupTokenPaginateOption func(*membersignuptokenPager) error

// WithMemberSignupTokenOrder configures pagination ordering.
func WithMemberSignupTokenOrder(order []*MemberSignupTokenOrder) MemberSignupTokenPaginateOption {
	return func(pager *membersignuptokenPager) error {
		for _, o := range order {
			if err := o.Direction.Validate(); err != nil {
				return err
			}
		}
		pager.order = append(pager.order, order...)
		return nil
	}
}

// WithMemberSignupTokenFilter configures pagination filter.
func WithMemberSignupTokenFilter(filter func(*MemberSignupTokenQuery) (*MemberSignupTokenQuery, error)) MemberSignupTokenPaginateOption {
	return func(pager *membersignuptokenPager) error {
		if filter == nil {
			return errors.New("MemberSignupTokenQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type membersignuptokenPager struct {
	reverse bool
	order   []*MemberSignupTokenOrder
	filter  func(*MemberSignupTokenQuery) (*MemberSignupTokenQuery, error)
}

func newMemberSignupTokenPager(opts []MemberSignupTokenPaginateOption, reverse bool) (*membersignuptokenPager, error) {
	pager := &membersignuptokenPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	for i, o := range pager.order {
		if i > 0 && o.Field == pager.order[i-1].Field {
			return nil, fmt.Errorf("duplicate order direction %q", o.Direction)
		}
	}
	return pager, nil
}

func (p *membersignuptokenPager) applyFilter(query *MemberSignupTokenQuery) (*MemberSignupTokenQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *membersignuptokenPager) toCursor(mst *MemberSignupToken) Cursor {
	cs := make([]any, 0, len(p.order))
	for _, o := range p.order {
		cs = append(cs, o.Field.toCursor(mst).Value)
	}
	return Cursor{ID: mst.ID, Value: cs}
}

func (p *membersignuptokenPager) applyCursors(query *MemberSignupTokenQuery, after, before *Cursor) (*MemberSignupTokenQuery, error) {
	idDirection := entgql.OrderDirectionAsc
	if p.reverse {
		idDirection = entgql.OrderDirectionDesc
	}
	fields, directions := make([]string, 0, len(p.order)), make([]OrderDirection, 0, len(p.order))
	for _, o := range p.order {
		fields = append(fields, o.Field.column)
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		directions = append(directions, direction)
	}
	predicates, err := entgql.MultiCursorsPredicate(after, before, &entgql.MultiCursorsOptions{
		FieldID:     DefaultMemberSignupTokenOrder.Field.column,
		DirectionID: idDirection,
		Fields:      fields,
		Directions:  directions,
	})
	if err != nil {
		return nil, err
	}
	for _, predicate := range predicates {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *membersignuptokenPager) applyOrder(query *MemberSignupTokenQuery) *MemberSignupTokenQuery {
	var defaultOrdered bool
	for _, o := range p.order {
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(o.Field.toTerm(direction.OrderTermOption()))
		if o.Field.column == DefaultMemberSignupTokenOrder.Field.column {
			defaultOrdered = true
		}
		if len(query.ctx.Fields) > 0 {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	if !defaultOrdered {
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(DefaultMemberSignupTokenOrder.Field.toTerm(direction.OrderTermOption()))
	}
	return query
}

func (p *membersignuptokenPager) orderExpr(query *MemberSignupTokenQuery) sql.Querier {
	if len(query.ctx.Fields) > 0 {
		for _, o := range p.order {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		for _, o := range p.order {
			direction := o.Direction
			if p.reverse {
				direction = direction.Reverse()
			}
			b.Ident(o.Field.column).Pad().WriteString(string(direction))
			b.Comma()
		}
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		b.Ident(DefaultMemberSignupTokenOrder.Field.column).Pad().WriteString(string(direction))
	})
}

// Paginate executes the query and returns a relay based cursor connection to MemberSignupToken.
func (mst *MemberSignupTokenQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...MemberSignupTokenPaginateOption,
) (*MemberSignupTokenConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newMemberSignupTokenPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if mst, err = pager.applyFilter(mst); err != nil {
		return nil, err
	}
	conn := &MemberSignupTokenConnection{Edges: []*MemberSignupTokenEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = mst.Clone().Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if mst, err = pager.applyCursors(mst, after, before); err != nil {
		return nil, err
	}
	if limit := paginateLimit(first, last); limit != 0 {
		mst.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := mst.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	mst = pager.applyOrder(mst)
	nodes, err := mst.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// MemberSignupTokenOrderFieldCreatedAt orders MemberSignupToken by createdAt.
	MemberSignupTokenOrderFieldCreatedAt = &MemberSignupTokenOrderField{
		Value: func(mst *MemberSignupToken) (ent.Value, error) {
			return mst.CreatedAt, nil
		},
		column: membersignuptoken.FieldCreatedAt,
		toTerm: membersignuptoken.ByCreatedAt,
		toCursor: func(mst *MemberSignupToken) Cursor {
			return Cursor{
				ID:    mst.ID,
				Value: mst.CreatedAt,
			}
		},
	}
	// MemberSignupTokenOrderFieldUpdatedAt orders MemberSignupToken by updatedAt.
	MemberSignupTokenOrderFieldUpdatedAt = &MemberSignupTokenOrderField{
		Value: func(mst *MemberSignupToken) (ent.Value, error) {
			return mst.UpdatedAt, nil
		},
		column: membersignuptoken.FieldUpdatedAt,
		toTerm: membersignuptoken.ByUpdatedAt,
		toCursor: func(mst *MemberSignupToken) Cursor {
			return Cursor{
				ID:    mst.ID,
				Value: mst.UpdatedAt,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f MemberSignupTokenOrderField) String() string {
	var str string
	switch f.column {
	case MemberSignupTokenOrderFieldCreatedAt.column:
		str = "CREATED_AT"
	case MemberSignupTokenOrderFieldUpdatedAt.column:
		str = "UPDATED_AT"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f MemberSignupTokenOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *MemberSignupTokenOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("MemberSignupTokenOrderField %T must be a string", v)
	}
	switch str {
	case "CREATED_AT":
		*f = *MemberSignupTokenOrderFieldCreatedAt
	case "UPDATED_AT":
		*f = *MemberSignupTokenOrderFieldUpdatedAt
	default:
		return fmt.Errorf("%s is not a valid MemberSignupTokenOrderField", str)
	}
	return nil
}

// MemberSignupTokenOrderField defines the ordering field of MemberSignupToken.
type MemberSignupTokenOrderField struct {
	// Value extracts the ordering value from the given MemberSignupToken.
	Value    func(*MemberSignupToken) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) membersignuptoken.OrderOption
	toCursor func(*MemberSignupToken) Cursor
}

// MemberSignupTokenOrder defines the ordering of MemberSignupToken.
type MemberSignupTokenOrder struct {
	Direction OrderDirection               `json:"direction"`
	Field     *MemberSignupTokenOrderField `json:"field"`
}

// DefaultMemberSignupTokenOrder is the default ordering of MemberSignupToken.
var DefaultMemberSignupTokenOrder = &MemberSignupTokenOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &MemberSignupTokenOrderField{
		Value: func(mst *MemberSignupToken) (ent.Value, error) {
			return mst.ID, nil
		},
		column: membersignuptoken.FieldID,
		toTerm: membersignuptoken.ByID,
		toCursor: func(mst *MemberSignupToken) Cursor {
			return Cursor{ID: mst.ID}
		},
	},
}

// ToEdge converts MemberSignupToken into MemberSignupTokenEdge.
func (mst *MemberSignupToken) ToEdge(order *MemberSignupTokenOrder) *MemberSignupTokenEdge {
	if order == nil {
		order = DefaultMemberSignupTokenOrder
	}
	return &MemberSignupTokenEdge{
		Node:   mst,
		Cursor: order.Field.toCursor(mst),
	}
}

// PayableEdge is the edge representation of Payable.
type PayableEdge struct {
	Node   *Payable `json:"node"`
	Cursor Cursor   `json:"cursor"`
}

// PayableConnection is the connection containing edges to Payable.
type PayableConnection struct {
	Edges      []*PayableEdge `json:"edges"`
	PageInfo   PageInfo       `json:"pageInfo"`
	TotalCount int            `json:"totalCount"`
}

func (c *PayableConnection) build(nodes []*Payable, pager *payablePager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *Payable
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Payable {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Payable {
			return nodes[i]
		}
	}
	c.Edges = make([]*PayableEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &PayableEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// PayablePaginateOption enables pagination customization.
type PayablePaginateOption func(*payablePager) error

// WithPayableOrder configures pagination ordering.
func WithPayableOrder(order []*PayableOrder) PayablePaginateOption {
	return func(pager *payablePager) error {
		for _, o := range order {
			if err := o.Direction.Validate(); err != nil {
				return err
			}
		}
		pager.order = append(pager.order, order...)
		return nil
	}
}

// WithPayableFilter configures pagination filter.
func WithPayableFilter(filter func(*PayableQuery) (*PayableQuery, error)) PayablePaginateOption {
	return func(pager *payablePager) error {
		if filter == nil {
			return errors.New("PayableQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type payablePager struct {
	reverse bool
	order   []*PayableOrder
	filter  func(*PayableQuery) (*PayableQuery, error)
}

func newPayablePager(opts []PayablePaginateOption, reverse bool) (*payablePager, error) {
	pager := &payablePager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	for i, o := range pager.order {
		if i > 0 && o.Field == pager.order[i-1].Field {
			return nil, fmt.Errorf("duplicate order direction %q", o.Direction)
		}
	}
	return pager, nil
}

func (p *payablePager) applyFilter(query *PayableQuery) (*PayableQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *payablePager) toCursor(pa *Payable) Cursor {
	cs := make([]any, 0, len(p.order))
	for _, o := range p.order {
		cs = append(cs, o.Field.toCursor(pa).Value)
	}
	return Cursor{ID: pa.ID, Value: cs}
}

func (p *payablePager) applyCursors(query *PayableQuery, after, before *Cursor) (*PayableQuery, error) {
	idDirection := entgql.OrderDirectionAsc
	if p.reverse {
		idDirection = entgql.OrderDirectionDesc
	}
	fields, directions := make([]string, 0, len(p.order)), make([]OrderDirection, 0, len(p.order))
	for _, o := range p.order {
		fields = append(fields, o.Field.column)
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		directions = append(directions, direction)
	}
	predicates, err := entgql.MultiCursorsPredicate(after, before, &entgql.MultiCursorsOptions{
		FieldID:     DefaultPayableOrder.Field.column,
		DirectionID: idDirection,
		Fields:      fields,
		Directions:  directions,
	})
	if err != nil {
		return nil, err
	}
	for _, predicate := range predicates {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *payablePager) applyOrder(query *PayableQuery) *PayableQuery {
	var defaultOrdered bool
	for _, o := range p.order {
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(o.Field.toTerm(direction.OrderTermOption()))
		if o.Field.column == DefaultPayableOrder.Field.column {
			defaultOrdered = true
		}
		if len(query.ctx.Fields) > 0 {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	if !defaultOrdered {
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(DefaultPayableOrder.Field.toTerm(direction.OrderTermOption()))
	}
	return query
}

func (p *payablePager) orderExpr(query *PayableQuery) sql.Querier {
	if len(query.ctx.Fields) > 0 {
		for _, o := range p.order {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		for _, o := range p.order {
			direction := o.Direction
			if p.reverse {
				direction = direction.Reverse()
			}
			b.Ident(o.Field.column).Pad().WriteString(string(direction))
			b.Comma()
		}
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		b.Ident(DefaultPayableOrder.Field.column).Pad().WriteString(string(direction))
	})
}

// Paginate executes the query and returns a relay based cursor connection to Payable.
func (pa *PayableQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...PayablePaginateOption,
) (*PayableConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newPayablePager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if pa, err = pager.applyFilter(pa); err != nil {
		return nil, err
	}
	conn := &PayableConnection{Edges: []*PayableEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = pa.Clone().Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if pa, err = pager.applyCursors(pa, after, before); err != nil {
		return nil, err
	}
	if limit := paginateLimit(first, last); limit != 0 {
		pa.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := pa.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	pa = pager.applyOrder(pa)
	nodes, err := pa.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// PayableOrderFieldCreatedAt orders Payable by createdAt.
	PayableOrderFieldCreatedAt = &PayableOrderField{
		Value: func(pa *Payable) (ent.Value, error) {
			return pa.CreatedAt, nil
		},
		column: payable.FieldCreatedAt,
		toTerm: payable.ByCreatedAt,
		toCursor: func(pa *Payable) Cursor {
			return Cursor{
				ID:    pa.ID,
				Value: pa.CreatedAt,
			}
		},
	}
	// PayableOrderFieldUpdatedAt orders Payable by updatedAt.
	PayableOrderFieldUpdatedAt = &PayableOrderField{
		Value: func(pa *Payable) (ent.Value, error) {
			return pa.UpdatedAt, nil
		},
		column: payable.FieldUpdatedAt,
		toTerm: payable.ByUpdatedAt,
		toCursor: func(pa *Payable) Cursor {
			return Cursor{
				ID:    pa.ID,
				Value: pa.UpdatedAt,
			}
		},
	}
	// PayableOrderFieldDueDate orders Payable by dueDate.
	PayableOrderFieldDueDate = &PayableOrderField{
		Value: func(pa *Payable) (ent.Value, error) {
			return pa.DueDate, nil
		},
		column: payable.FieldDueDate,
		toTerm: payable.ByDueDate,
		toCursor: func(pa *Payable) Cursor {
			return Cursor{
				ID:    pa.ID,
				Value: pa.DueDate,
			}
		},
	}
	// PayableOrderFieldStatus orders Payable by status.
	PayableOrderFieldStatus = &PayableOrderField{
		Value: func(pa *Payable) (ent.Value, error) {
			return pa.Status, nil
		},
		column: payable.FieldStatus,
		toTerm: payable.ByStatus,
		toCursor: func(pa *Payable) Cursor {
			return Cursor{
				ID:    pa.ID,
				Value: pa.Status,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f PayableOrderField) String() string {
	var str string
	switch f.column {
	case PayableOrderFieldCreatedAt.column:
		str = "CREATED_AT"
	case PayableOrderFieldUpdatedAt.column:
		str = "UPDATED_AT"
	case PayableOrderFieldDueDate.column:
		str = "DUEDATE"
	case PayableOrderFieldStatus.column:
		str = "STATUS"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f PayableOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *PayableOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("PayableOrderField %T must be a string", v)
	}
	switch str {
	case "CREATED_AT":
		*f = *PayableOrderFieldCreatedAt
	case "UPDATED_AT":
		*f = *PayableOrderFieldUpdatedAt
	case "DUEDATE":
		*f = *PayableOrderFieldDueDate
	case "STATUS":
		*f = *PayableOrderFieldStatus
	default:
		return fmt.Errorf("%s is not a valid PayableOrderField", str)
	}
	return nil
}

// PayableOrderField defines the ordering field of Payable.
type PayableOrderField struct {
	// Value extracts the ordering value from the given Payable.
	Value    func(*Payable) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) payable.OrderOption
	toCursor func(*Payable) Cursor
}

// PayableOrder defines the ordering of Payable.
type PayableOrder struct {
	Direction OrderDirection     `json:"direction"`
	Field     *PayableOrderField `json:"field"`
}

// DefaultPayableOrder is the default ordering of Payable.
var DefaultPayableOrder = &PayableOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &PayableOrderField{
		Value: func(pa *Payable) (ent.Value, error) {
			return pa.ID, nil
		},
		column: payable.FieldID,
		toTerm: payable.ByID,
		toCursor: func(pa *Payable) Cursor {
			return Cursor{ID: pa.ID}
		},
	},
}

// ToEdge converts Payable into PayableEdge.
func (pa *Payable) ToEdge(order *PayableOrder) *PayableEdge {
	if order == nil {
		order = DefaultPayableOrder
	}
	return &PayableEdge{
		Node:   pa,
		Cursor: order.Field.toCursor(pa),
	}
}

// ProductEdge is the edge representation of Product.
type ProductEdge struct {
	Node   *Product `json:"node"`
	Cursor Cursor   `json:"cursor"`
}

// ProductConnection is the connection containing edges to Product.
type ProductConnection struct {
	Edges      []*ProductEdge `json:"edges"`
	PageInfo   PageInfo       `json:"pageInfo"`
	TotalCount int            `json:"totalCount"`
}

func (c *ProductConnection) build(nodes []*Product, pager *productPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *Product
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Product {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Product {
			return nodes[i]
		}
	}
	c.Edges = make([]*ProductEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &ProductEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// ProductPaginateOption enables pagination customization.
type ProductPaginateOption func(*productPager) error

// WithProductOrder configures pagination ordering.
func WithProductOrder(order *ProductOrder) ProductPaginateOption {
	if order == nil {
		order = DefaultProductOrder
	}
	o := *order
	return func(pager *productPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultProductOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithProductFilter configures pagination filter.
func WithProductFilter(filter func(*ProductQuery) (*ProductQuery, error)) ProductPaginateOption {
	return func(pager *productPager) error {
		if filter == nil {
			return errors.New("ProductQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type productPager struct {
	reverse bool
	order   *ProductOrder
	filter  func(*ProductQuery) (*ProductQuery, error)
}

func newProductPager(opts []ProductPaginateOption, reverse bool) (*productPager, error) {
	pager := &productPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultProductOrder
	}
	return pager, nil
}

func (p *productPager) applyFilter(query *ProductQuery) (*ProductQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *productPager) toCursor(pr *Product) Cursor {
	return p.order.Field.toCursor(pr)
}

func (p *productPager) applyCursors(query *ProductQuery, after, before *Cursor) (*ProductQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultProductOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *productPager) applyOrder(query *ProductQuery) *ProductQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultProductOrder.Field {
		query = query.Order(DefaultProductOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *productPager) orderExpr(query *ProductQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultProductOrder.Field {
			b.Comma().Ident(DefaultProductOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to Product.
func (pr *ProductQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...ProductPaginateOption,
) (*ProductConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newProductPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if pr, err = pager.applyFilter(pr); err != nil {
		return nil, err
	}
	conn := &ProductConnection{Edges: []*ProductEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = pr.Clone().Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if pr, err = pager.applyCursors(pr, after, before); err != nil {
		return nil, err
	}
	if limit := paginateLimit(first, last); limit != 0 {
		pr.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := pr.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	pr = pager.applyOrder(pr)
	nodes, err := pr.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// ProductOrderFieldCreatedAt orders Product by createdAt.
	ProductOrderFieldCreatedAt = &ProductOrderField{
		Value: func(pr *Product) (ent.Value, error) {
			return pr.CreatedAt, nil
		},
		column: product.FieldCreatedAt,
		toTerm: product.ByCreatedAt,
		toCursor: func(pr *Product) Cursor {
			return Cursor{
				ID:    pr.ID,
				Value: pr.CreatedAt,
			}
		},
	}
	// ProductOrderFieldUpdatedAt orders Product by updatedAt.
	ProductOrderFieldUpdatedAt = &ProductOrderField{
		Value: func(pr *Product) (ent.Value, error) {
			return pr.UpdatedAt, nil
		},
		column: product.FieldUpdatedAt,
		toTerm: product.ByUpdatedAt,
		toCursor: func(pr *Product) Cursor {
			return Cursor{
				ID:    pr.ID,
				Value: pr.UpdatedAt,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f ProductOrderField) String() string {
	var str string
	switch f.column {
	case ProductOrderFieldCreatedAt.column:
		str = "CREATED_AT"
	case ProductOrderFieldUpdatedAt.column:
		str = "UPDATED_AT"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f ProductOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *ProductOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("ProductOrderField %T must be a string", v)
	}
	switch str {
	case "CREATED_AT":
		*f = *ProductOrderFieldCreatedAt
	case "UPDATED_AT":
		*f = *ProductOrderFieldUpdatedAt
	default:
		return fmt.Errorf("%s is not a valid ProductOrderField", str)
	}
	return nil
}

// ProductOrderField defines the ordering field of Product.
type ProductOrderField struct {
	// Value extracts the ordering value from the given Product.
	Value    func(*Product) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) product.OrderOption
	toCursor func(*Product) Cursor
}

// ProductOrder defines the ordering of Product.
type ProductOrder struct {
	Direction OrderDirection     `json:"direction"`
	Field     *ProductOrderField `json:"field"`
}

// DefaultProductOrder is the default ordering of Product.
var DefaultProductOrder = &ProductOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &ProductOrderField{
		Value: func(pr *Product) (ent.Value, error) {
			return pr.ID, nil
		},
		column: product.FieldID,
		toTerm: product.ByID,
		toCursor: func(pr *Product) Cursor {
			return Cursor{ID: pr.ID}
		},
	},
}

// ToEdge converts Product into ProductEdge.
func (pr *Product) ToEdge(order *ProductOrder) *ProductEdge {
	if order == nil {
		order = DefaultProductOrder
	}
	return &ProductEdge{
		Node:   pr,
		Cursor: order.Field.toCursor(pr),
	}
}

// ProjectEdge is the edge representation of Project.
type ProjectEdge struct {
	Node   *Project `json:"node"`
	Cursor Cursor   `json:"cursor"`
}

// ProjectConnection is the connection containing edges to Project.
type ProjectConnection struct {
	Edges      []*ProjectEdge `json:"edges"`
	PageInfo   PageInfo       `json:"pageInfo"`
	TotalCount int            `json:"totalCount"`
}

func (c *ProjectConnection) build(nodes []*Project, pager *projectPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *Project
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Project {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Project {
			return nodes[i]
		}
	}
	c.Edges = make([]*ProjectEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &ProjectEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// ProjectPaginateOption enables pagination customization.
type ProjectPaginateOption func(*projectPager) error

// WithProjectOrder configures pagination ordering.
func WithProjectOrder(order []*ProjectOrder) ProjectPaginateOption {
	return func(pager *projectPager) error {
		for _, o := range order {
			if err := o.Direction.Validate(); err != nil {
				return err
			}
		}
		pager.order = append(pager.order, order...)
		return nil
	}
}

// WithProjectFilter configures pagination filter.
func WithProjectFilter(filter func(*ProjectQuery) (*ProjectQuery, error)) ProjectPaginateOption {
	return func(pager *projectPager) error {
		if filter == nil {
			return errors.New("ProjectQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type projectPager struct {
	reverse bool
	order   []*ProjectOrder
	filter  func(*ProjectQuery) (*ProjectQuery, error)
}

func newProjectPager(opts []ProjectPaginateOption, reverse bool) (*projectPager, error) {
	pager := &projectPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	for i, o := range pager.order {
		if i > 0 && o.Field == pager.order[i-1].Field {
			return nil, fmt.Errorf("duplicate order direction %q", o.Direction)
		}
	}
	return pager, nil
}

func (p *projectPager) applyFilter(query *ProjectQuery) (*ProjectQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *projectPager) toCursor(pr *Project) Cursor {
	cs := make([]any, 0, len(p.order))
	for _, o := range p.order {
		cs = append(cs, o.Field.toCursor(pr).Value)
	}
	return Cursor{ID: pr.ID, Value: cs}
}

func (p *projectPager) applyCursors(query *ProjectQuery, after, before *Cursor) (*ProjectQuery, error) {
	idDirection := entgql.OrderDirectionAsc
	if p.reverse {
		idDirection = entgql.OrderDirectionDesc
	}
	fields, directions := make([]string, 0, len(p.order)), make([]OrderDirection, 0, len(p.order))
	for _, o := range p.order {
		fields = append(fields, o.Field.column)
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		directions = append(directions, direction)
	}
	predicates, err := entgql.MultiCursorsPredicate(after, before, &entgql.MultiCursorsOptions{
		FieldID:     DefaultProjectOrder.Field.column,
		DirectionID: idDirection,
		Fields:      fields,
		Directions:  directions,
	})
	if err != nil {
		return nil, err
	}
	for _, predicate := range predicates {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *projectPager) applyOrder(query *ProjectQuery) *ProjectQuery {
	var defaultOrdered bool
	for _, o := range p.order {
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(o.Field.toTerm(direction.OrderTermOption()))
		if o.Field.column == DefaultProjectOrder.Field.column {
			defaultOrdered = true
		}
		if len(query.ctx.Fields) > 0 {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	if !defaultOrdered {
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(DefaultProjectOrder.Field.toTerm(direction.OrderTermOption()))
	}
	return query
}

func (p *projectPager) orderExpr(query *ProjectQuery) sql.Querier {
	if len(query.ctx.Fields) > 0 {
		for _, o := range p.order {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		for _, o := range p.order {
			direction := o.Direction
			if p.reverse {
				direction = direction.Reverse()
			}
			b.Ident(o.Field.column).Pad().WriteString(string(direction))
			b.Comma()
		}
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		b.Ident(DefaultProjectOrder.Field.column).Pad().WriteString(string(direction))
	})
}

// Paginate executes the query and returns a relay based cursor connection to Project.
func (pr *ProjectQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...ProjectPaginateOption,
) (*ProjectConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newProjectPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if pr, err = pager.applyFilter(pr); err != nil {
		return nil, err
	}
	conn := &ProjectConnection{Edges: []*ProjectEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = pr.Clone().Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if pr, err = pager.applyCursors(pr, after, before); err != nil {
		return nil, err
	}
	if limit := paginateLimit(first, last); limit != 0 {
		pr.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := pr.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	pr = pager.applyOrder(pr)
	nodes, err := pr.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// ProjectOrderFieldCreatedAt orders Project by createdAt.
	ProjectOrderFieldCreatedAt = &ProjectOrderField{
		Value: func(pr *Project) (ent.Value, error) {
			return pr.CreatedAt, nil
		},
		column: project.FieldCreatedAt,
		toTerm: project.ByCreatedAt,
		toCursor: func(pr *Project) Cursor {
			return Cursor{
				ID:    pr.ID,
				Value: pr.CreatedAt,
			}
		},
	}
	// ProjectOrderFieldUpdatedAt orders Project by updatedAt.
	ProjectOrderFieldUpdatedAt = &ProjectOrderField{
		Value: func(pr *Project) (ent.Value, error) {
			return pr.UpdatedAt, nil
		},
		column: project.FieldUpdatedAt,
		toTerm: project.ByUpdatedAt,
		toCursor: func(pr *Project) Cursor {
			return Cursor{
				ID:    pr.ID,
				Value: pr.UpdatedAt,
			}
		},
	}
	// ProjectOrderFieldStartDate orders Project by startDate.
	ProjectOrderFieldStartDate = &ProjectOrderField{
		Value: func(pr *Project) (ent.Value, error) {
			return pr.StartDate, nil
		},
		column: project.FieldStartDate,
		toTerm: project.ByStartDate,
		toCursor: func(pr *Project) Cursor {
			return Cursor{
				ID:    pr.ID,
				Value: pr.StartDate,
			}
		},
	}
	// ProjectOrderFieldEndDate orders Project by endDate.
	ProjectOrderFieldEndDate = &ProjectOrderField{
		Value: func(pr *Project) (ent.Value, error) {
			return pr.EndDate, nil
		},
		column: project.FieldEndDate,
		toTerm: project.ByEndDate,
		toCursor: func(pr *Project) Cursor {
			return Cursor{
				ID:    pr.ID,
				Value: pr.EndDate,
			}
		},
	}
	// ProjectOrderFieldStatus orders Project by status.
	ProjectOrderFieldStatus = &ProjectOrderField{
		Value: func(pr *Project) (ent.Value, error) {
			return pr.Status, nil
		},
		column: project.FieldStatus,
		toTerm: project.ByStatus,
		toCursor: func(pr *Project) Cursor {
			return Cursor{
				ID:    pr.ID,
				Value: pr.Status,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f ProjectOrderField) String() string {
	var str string
	switch f.column {
	case ProjectOrderFieldCreatedAt.column:
		str = "CREATED_AT"
	case ProjectOrderFieldUpdatedAt.column:
		str = "UPDATED_AT"
	case ProjectOrderFieldStartDate.column:
		str = "START_DATE"
	case ProjectOrderFieldEndDate.column:
		str = "END_DATE"
	case ProjectOrderFieldStatus.column:
		str = "STATUS"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f ProjectOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *ProjectOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("ProjectOrderField %T must be a string", v)
	}
	switch str {
	case "CREATED_AT":
		*f = *ProjectOrderFieldCreatedAt
	case "UPDATED_AT":
		*f = *ProjectOrderFieldUpdatedAt
	case "START_DATE":
		*f = *ProjectOrderFieldStartDate
	case "END_DATE":
		*f = *ProjectOrderFieldEndDate
	case "STATUS":
		*f = *ProjectOrderFieldStatus
	default:
		return fmt.Errorf("%s is not a valid ProjectOrderField", str)
	}
	return nil
}

// ProjectOrderField defines the ordering field of Project.
type ProjectOrderField struct {
	// Value extracts the ordering value from the given Project.
	Value    func(*Project) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) project.OrderOption
	toCursor func(*Project) Cursor
}

// ProjectOrder defines the ordering of Project.
type ProjectOrder struct {
	Direction OrderDirection     `json:"direction"`
	Field     *ProjectOrderField `json:"field"`
}

// DefaultProjectOrder is the default ordering of Project.
var DefaultProjectOrder = &ProjectOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &ProjectOrderField{
		Value: func(pr *Project) (ent.Value, error) {
			return pr.ID, nil
		},
		column: project.FieldID,
		toTerm: project.ByID,
		toCursor: func(pr *Project) Cursor {
			return Cursor{ID: pr.ID}
		},
	},
}

// ToEdge converts Project into ProjectEdge.
func (pr *Project) ToEdge(order *ProjectOrder) *ProjectEdge {
	if order == nil {
		order = DefaultProjectOrder
	}
	return &ProjectEdge{
		Node:   pr,
		Cursor: order.Field.toCursor(pr),
	}
}

// ProjectMilestoneEdge is the edge representation of ProjectMilestone.
type ProjectMilestoneEdge struct {
	Node   *ProjectMilestone `json:"node"`
	Cursor Cursor            `json:"cursor"`
}

// ProjectMilestoneConnection is the connection containing edges to ProjectMilestone.
type ProjectMilestoneConnection struct {
	Edges      []*ProjectMilestoneEdge `json:"edges"`
	PageInfo   PageInfo                `json:"pageInfo"`
	TotalCount int                     `json:"totalCount"`
}

func (c *ProjectMilestoneConnection) build(nodes []*ProjectMilestone, pager *projectmilestonePager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *ProjectMilestone
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *ProjectMilestone {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *ProjectMilestone {
			return nodes[i]
		}
	}
	c.Edges = make([]*ProjectMilestoneEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &ProjectMilestoneEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// ProjectMilestonePaginateOption enables pagination customization.
type ProjectMilestonePaginateOption func(*projectmilestonePager) error

// WithProjectMilestoneOrder configures pagination ordering.
func WithProjectMilestoneOrder(order *ProjectMilestoneOrder) ProjectMilestonePaginateOption {
	if order == nil {
		order = DefaultProjectMilestoneOrder
	}
	o := *order
	return func(pager *projectmilestonePager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultProjectMilestoneOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithProjectMilestoneFilter configures pagination filter.
func WithProjectMilestoneFilter(filter func(*ProjectMilestoneQuery) (*ProjectMilestoneQuery, error)) ProjectMilestonePaginateOption {
	return func(pager *projectmilestonePager) error {
		if filter == nil {
			return errors.New("ProjectMilestoneQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type projectmilestonePager struct {
	reverse bool
	order   *ProjectMilestoneOrder
	filter  func(*ProjectMilestoneQuery) (*ProjectMilestoneQuery, error)
}

func newProjectMilestonePager(opts []ProjectMilestonePaginateOption, reverse bool) (*projectmilestonePager, error) {
	pager := &projectmilestonePager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultProjectMilestoneOrder
	}
	return pager, nil
}

func (p *projectmilestonePager) applyFilter(query *ProjectMilestoneQuery) (*ProjectMilestoneQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *projectmilestonePager) toCursor(pm *ProjectMilestone) Cursor {
	return p.order.Field.toCursor(pm)
}

func (p *projectmilestonePager) applyCursors(query *ProjectMilestoneQuery, after, before *Cursor) (*ProjectMilestoneQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultProjectMilestoneOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *projectmilestonePager) applyOrder(query *ProjectMilestoneQuery) *ProjectMilestoneQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultProjectMilestoneOrder.Field {
		query = query.Order(DefaultProjectMilestoneOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *projectmilestonePager) orderExpr(query *ProjectMilestoneQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultProjectMilestoneOrder.Field {
			b.Comma().Ident(DefaultProjectMilestoneOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to ProjectMilestone.
func (pm *ProjectMilestoneQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...ProjectMilestonePaginateOption,
) (*ProjectMilestoneConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newProjectMilestonePager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if pm, err = pager.applyFilter(pm); err != nil {
		return nil, err
	}
	conn := &ProjectMilestoneConnection{Edges: []*ProjectMilestoneEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = pm.Clone().Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if pm, err = pager.applyCursors(pm, after, before); err != nil {
		return nil, err
	}
	if limit := paginateLimit(first, last); limit != 0 {
		pm.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := pm.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	pm = pager.applyOrder(pm)
	nodes, err := pm.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// ProjectMilestoneOrderField defines the ordering field of ProjectMilestone.
type ProjectMilestoneOrderField struct {
	// Value extracts the ordering value from the given ProjectMilestone.
	Value    func(*ProjectMilestone) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) projectmilestone.OrderOption
	toCursor func(*ProjectMilestone) Cursor
}

// ProjectMilestoneOrder defines the ordering of ProjectMilestone.
type ProjectMilestoneOrder struct {
	Direction OrderDirection              `json:"direction"`
	Field     *ProjectMilestoneOrderField `json:"field"`
}

// DefaultProjectMilestoneOrder is the default ordering of ProjectMilestone.
var DefaultProjectMilestoneOrder = &ProjectMilestoneOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &ProjectMilestoneOrderField{
		Value: func(pm *ProjectMilestone) (ent.Value, error) {
			return pm.ID, nil
		},
		column: projectmilestone.FieldID,
		toTerm: projectmilestone.ByID,
		toCursor: func(pm *ProjectMilestone) Cursor {
			return Cursor{ID: pm.ID}
		},
	},
}

// ToEdge converts ProjectMilestone into ProjectMilestoneEdge.
func (pm *ProjectMilestone) ToEdge(order *ProjectMilestoneOrder) *ProjectMilestoneEdge {
	if order == nil {
		order = DefaultProjectMilestoneOrder
	}
	return &ProjectMilestoneEdge{
		Node:   pm,
		Cursor: order.Field.toCursor(pm),
	}
}

// ProjectTaskEdge is the edge representation of ProjectTask.
type ProjectTaskEdge struct {
	Node   *ProjectTask `json:"node"`
	Cursor Cursor       `json:"cursor"`
}

// ProjectTaskConnection is the connection containing edges to ProjectTask.
type ProjectTaskConnection struct {
	Edges      []*ProjectTaskEdge `json:"edges"`
	PageInfo   PageInfo           `json:"pageInfo"`
	TotalCount int                `json:"totalCount"`
}

func (c *ProjectTaskConnection) build(nodes []*ProjectTask, pager *projecttaskPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *ProjectTask
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *ProjectTask {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *ProjectTask {
			return nodes[i]
		}
	}
	c.Edges = make([]*ProjectTaskEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &ProjectTaskEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// ProjectTaskPaginateOption enables pagination customization.
type ProjectTaskPaginateOption func(*projecttaskPager) error

// WithProjectTaskOrder configures pagination ordering.
func WithProjectTaskOrder(order []*ProjectTaskOrder) ProjectTaskPaginateOption {
	return func(pager *projecttaskPager) error {
		for _, o := range order {
			if err := o.Direction.Validate(); err != nil {
				return err
			}
		}
		pager.order = append(pager.order, order...)
		return nil
	}
}

// WithProjectTaskFilter configures pagination filter.
func WithProjectTaskFilter(filter func(*ProjectTaskQuery) (*ProjectTaskQuery, error)) ProjectTaskPaginateOption {
	return func(pager *projecttaskPager) error {
		if filter == nil {
			return errors.New("ProjectTaskQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type projecttaskPager struct {
	reverse bool
	order   []*ProjectTaskOrder
	filter  func(*ProjectTaskQuery) (*ProjectTaskQuery, error)
}

func newProjectTaskPager(opts []ProjectTaskPaginateOption, reverse bool) (*projecttaskPager, error) {
	pager := &projecttaskPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	for i, o := range pager.order {
		if i > 0 && o.Field == pager.order[i-1].Field {
			return nil, fmt.Errorf("duplicate order direction %q", o.Direction)
		}
	}
	return pager, nil
}

func (p *projecttaskPager) applyFilter(query *ProjectTaskQuery) (*ProjectTaskQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *projecttaskPager) toCursor(pt *ProjectTask) Cursor {
	cs := make([]any, 0, len(p.order))
	for _, o := range p.order {
		cs = append(cs, o.Field.toCursor(pt).Value)
	}
	return Cursor{ID: pt.ID, Value: cs}
}

func (p *projecttaskPager) applyCursors(query *ProjectTaskQuery, after, before *Cursor) (*ProjectTaskQuery, error) {
	idDirection := entgql.OrderDirectionAsc
	if p.reverse {
		idDirection = entgql.OrderDirectionDesc
	}
	fields, directions := make([]string, 0, len(p.order)), make([]OrderDirection, 0, len(p.order))
	for _, o := range p.order {
		fields = append(fields, o.Field.column)
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		directions = append(directions, direction)
	}
	predicates, err := entgql.MultiCursorsPredicate(after, before, &entgql.MultiCursorsOptions{
		FieldID:     DefaultProjectTaskOrder.Field.column,
		DirectionID: idDirection,
		Fields:      fields,
		Directions:  directions,
	})
	if err != nil {
		return nil, err
	}
	for _, predicate := range predicates {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *projecttaskPager) applyOrder(query *ProjectTaskQuery) *ProjectTaskQuery {
	var defaultOrdered bool
	for _, o := range p.order {
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(o.Field.toTerm(direction.OrderTermOption()))
		if o.Field.column == DefaultProjectTaskOrder.Field.column {
			defaultOrdered = true
		}
		if len(query.ctx.Fields) > 0 {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	if !defaultOrdered {
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(DefaultProjectTaskOrder.Field.toTerm(direction.OrderTermOption()))
	}
	return query
}

func (p *projecttaskPager) orderExpr(query *ProjectTaskQuery) sql.Querier {
	if len(query.ctx.Fields) > 0 {
		for _, o := range p.order {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		for _, o := range p.order {
			direction := o.Direction
			if p.reverse {
				direction = direction.Reverse()
			}
			b.Ident(o.Field.column).Pad().WriteString(string(direction))
			b.Comma()
		}
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		b.Ident(DefaultProjectTaskOrder.Field.column).Pad().WriteString(string(direction))
	})
}

// Paginate executes the query and returns a relay based cursor connection to ProjectTask.
func (pt *ProjectTaskQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...ProjectTaskPaginateOption,
) (*ProjectTaskConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newProjectTaskPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if pt, err = pager.applyFilter(pt); err != nil {
		return nil, err
	}
	conn := &ProjectTaskConnection{Edges: []*ProjectTaskEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = pt.Clone().Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if pt, err = pager.applyCursors(pt, after, before); err != nil {
		return nil, err
	}
	if limit := paginateLimit(first, last); limit != 0 {
		pt.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := pt.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	pt = pager.applyOrder(pt)
	nodes, err := pt.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// ProjectTaskOrderFieldDueDate orders ProjectTask by dueDate.
	ProjectTaskOrderFieldDueDate = &ProjectTaskOrderField{
		Value: func(pt *ProjectTask) (ent.Value, error) {
			return pt.DueDate, nil
		},
		column: projecttask.FieldDueDate,
		toTerm: projecttask.ByDueDate,
		toCursor: func(pt *ProjectTask) Cursor {
			return Cursor{
				ID:    pt.ID,
				Value: pt.DueDate,
			}
		},
	}
	// ProjectTaskOrderFieldStartDate orders ProjectTask by startDate.
	ProjectTaskOrderFieldStartDate = &ProjectTaskOrderField{
		Value: func(pt *ProjectTask) (ent.Value, error) {
			return pt.StartDate, nil
		},
		column: projecttask.FieldStartDate,
		toTerm: projecttask.ByStartDate,
		toCursor: func(pt *ProjectTask) Cursor {
			return Cursor{
				ID:    pt.ID,
				Value: pt.StartDate,
			}
		},
	}
	// ProjectTaskOrderFieldEndDate orders ProjectTask by endDate.
	ProjectTaskOrderFieldEndDate = &ProjectTaskOrderField{
		Value: func(pt *ProjectTask) (ent.Value, error) {
			return pt.EndDate, nil
		},
		column: projecttask.FieldEndDate,
		toTerm: projecttask.ByEndDate,
		toCursor: func(pt *ProjectTask) Cursor {
			return Cursor{
				ID:    pt.ID,
				Value: pt.EndDate,
			}
		},
	}
	// ProjectTaskOrderFieldStatus orders ProjectTask by status.
	ProjectTaskOrderFieldStatus = &ProjectTaskOrderField{
		Value: func(pt *ProjectTask) (ent.Value, error) {
			return pt.Status, nil
		},
		column: projecttask.FieldStatus,
		toTerm: projecttask.ByStatus,
		toCursor: func(pt *ProjectTask) Cursor {
			return Cursor{
				ID:    pt.ID,
				Value: pt.Status,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f ProjectTaskOrderField) String() string {
	var str string
	switch f.column {
	case ProjectTaskOrderFieldDueDate.column:
		str = "DUE_DATE"
	case ProjectTaskOrderFieldStartDate.column:
		str = "START_DATE"
	case ProjectTaskOrderFieldEndDate.column:
		str = "END_DATE"
	case ProjectTaskOrderFieldStatus.column:
		str = "STATUS"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f ProjectTaskOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *ProjectTaskOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("ProjectTaskOrderField %T must be a string", v)
	}
	switch str {
	case "DUE_DATE":
		*f = *ProjectTaskOrderFieldDueDate
	case "START_DATE":
		*f = *ProjectTaskOrderFieldStartDate
	case "END_DATE":
		*f = *ProjectTaskOrderFieldEndDate
	case "STATUS":
		*f = *ProjectTaskOrderFieldStatus
	default:
		return fmt.Errorf("%s is not a valid ProjectTaskOrderField", str)
	}
	return nil
}

// ProjectTaskOrderField defines the ordering field of ProjectTask.
type ProjectTaskOrderField struct {
	// Value extracts the ordering value from the given ProjectTask.
	Value    func(*ProjectTask) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) projecttask.OrderOption
	toCursor func(*ProjectTask) Cursor
}

// ProjectTaskOrder defines the ordering of ProjectTask.
type ProjectTaskOrder struct {
	Direction OrderDirection         `json:"direction"`
	Field     *ProjectTaskOrderField `json:"field"`
}

// DefaultProjectTaskOrder is the default ordering of ProjectTask.
var DefaultProjectTaskOrder = &ProjectTaskOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &ProjectTaskOrderField{
		Value: func(pt *ProjectTask) (ent.Value, error) {
			return pt.ID, nil
		},
		column: projecttask.FieldID,
		toTerm: projecttask.ByID,
		toCursor: func(pt *ProjectTask) Cursor {
			return Cursor{ID: pt.ID}
		},
	},
}

// ToEdge converts ProjectTask into ProjectTaskEdge.
func (pt *ProjectTask) ToEdge(order *ProjectTaskOrder) *ProjectTaskEdge {
	if order == nil {
		order = DefaultProjectTaskOrder
	}
	return &ProjectTaskEdge{
		Node:   pt,
		Cursor: order.Field.toCursor(pt),
	}
}

// ReceivableEdge is the edge representation of Receivable.
type ReceivableEdge struct {
	Node   *Receivable `json:"node"`
	Cursor Cursor      `json:"cursor"`
}

// ReceivableConnection is the connection containing edges to Receivable.
type ReceivableConnection struct {
	Edges      []*ReceivableEdge `json:"edges"`
	PageInfo   PageInfo          `json:"pageInfo"`
	TotalCount int               `json:"totalCount"`
}

func (c *ReceivableConnection) build(nodes []*Receivable, pager *receivablePager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *Receivable
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Receivable {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Receivable {
			return nodes[i]
		}
	}
	c.Edges = make([]*ReceivableEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &ReceivableEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// ReceivablePaginateOption enables pagination customization.
type ReceivablePaginateOption func(*receivablePager) error

// WithReceivableOrder configures pagination ordering.
func WithReceivableOrder(order []*ReceivableOrder) ReceivablePaginateOption {
	return func(pager *receivablePager) error {
		for _, o := range order {
			if err := o.Direction.Validate(); err != nil {
				return err
			}
		}
		pager.order = append(pager.order, order...)
		return nil
	}
}

// WithReceivableFilter configures pagination filter.
func WithReceivableFilter(filter func(*ReceivableQuery) (*ReceivableQuery, error)) ReceivablePaginateOption {
	return func(pager *receivablePager) error {
		if filter == nil {
			return errors.New("ReceivableQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type receivablePager struct {
	reverse bool
	order   []*ReceivableOrder
	filter  func(*ReceivableQuery) (*ReceivableQuery, error)
}

func newReceivablePager(opts []ReceivablePaginateOption, reverse bool) (*receivablePager, error) {
	pager := &receivablePager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	for i, o := range pager.order {
		if i > 0 && o.Field == pager.order[i-1].Field {
			return nil, fmt.Errorf("duplicate order direction %q", o.Direction)
		}
	}
	return pager, nil
}

func (p *receivablePager) applyFilter(query *ReceivableQuery) (*ReceivableQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *receivablePager) toCursor(r *Receivable) Cursor {
	cs := make([]any, 0, len(p.order))
	for _, o := range p.order {
		cs = append(cs, o.Field.toCursor(r).Value)
	}
	return Cursor{ID: r.ID, Value: cs}
}

func (p *receivablePager) applyCursors(query *ReceivableQuery, after, before *Cursor) (*ReceivableQuery, error) {
	idDirection := entgql.OrderDirectionAsc
	if p.reverse {
		idDirection = entgql.OrderDirectionDesc
	}
	fields, directions := make([]string, 0, len(p.order)), make([]OrderDirection, 0, len(p.order))
	for _, o := range p.order {
		fields = append(fields, o.Field.column)
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		directions = append(directions, direction)
	}
	predicates, err := entgql.MultiCursorsPredicate(after, before, &entgql.MultiCursorsOptions{
		FieldID:     DefaultReceivableOrder.Field.column,
		DirectionID: idDirection,
		Fields:      fields,
		Directions:  directions,
	})
	if err != nil {
		return nil, err
	}
	for _, predicate := range predicates {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *receivablePager) applyOrder(query *ReceivableQuery) *ReceivableQuery {
	var defaultOrdered bool
	for _, o := range p.order {
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(o.Field.toTerm(direction.OrderTermOption()))
		if o.Field.column == DefaultReceivableOrder.Field.column {
			defaultOrdered = true
		}
		if len(query.ctx.Fields) > 0 {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	if !defaultOrdered {
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(DefaultReceivableOrder.Field.toTerm(direction.OrderTermOption()))
	}
	return query
}

func (p *receivablePager) orderExpr(query *ReceivableQuery) sql.Querier {
	if len(query.ctx.Fields) > 0 {
		for _, o := range p.order {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		for _, o := range p.order {
			direction := o.Direction
			if p.reverse {
				direction = direction.Reverse()
			}
			b.Ident(o.Field.column).Pad().WriteString(string(direction))
			b.Comma()
		}
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		b.Ident(DefaultReceivableOrder.Field.column).Pad().WriteString(string(direction))
	})
}

// Paginate executes the query and returns a relay based cursor connection to Receivable.
func (r *ReceivableQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...ReceivablePaginateOption,
) (*ReceivableConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newReceivablePager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if r, err = pager.applyFilter(r); err != nil {
		return nil, err
	}
	conn := &ReceivableConnection{Edges: []*ReceivableEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = r.Clone().Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if r, err = pager.applyCursors(r, after, before); err != nil {
		return nil, err
	}
	if limit := paginateLimit(first, last); limit != 0 {
		r.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := r.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	r = pager.applyOrder(r)
	nodes, err := r.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// ReceivableOrderFieldCreatedAt orders Receivable by createdAt.
	ReceivableOrderFieldCreatedAt = &ReceivableOrderField{
		Value: func(r *Receivable) (ent.Value, error) {
			return r.CreatedAt, nil
		},
		column: receivable.FieldCreatedAt,
		toTerm: receivable.ByCreatedAt,
		toCursor: func(r *Receivable) Cursor {
			return Cursor{
				ID:    r.ID,
				Value: r.CreatedAt,
			}
		},
	}
	// ReceivableOrderFieldUpdatedAt orders Receivable by updatedAt.
	ReceivableOrderFieldUpdatedAt = &ReceivableOrderField{
		Value: func(r *Receivable) (ent.Value, error) {
			return r.UpdatedAt, nil
		},
		column: receivable.FieldUpdatedAt,
		toTerm: receivable.ByUpdatedAt,
		toCursor: func(r *Receivable) Cursor {
			return Cursor{
				ID:    r.ID,
				Value: r.UpdatedAt,
			}
		},
	}
	// ReceivableOrderFieldDueDate orders Receivable by dueDate.
	ReceivableOrderFieldDueDate = &ReceivableOrderField{
		Value: func(r *Receivable) (ent.Value, error) {
			return r.DueDate, nil
		},
		column: receivable.FieldDueDate,
		toTerm: receivable.ByDueDate,
		toCursor: func(r *Receivable) Cursor {
			return Cursor{
				ID:    r.ID,
				Value: r.DueDate,
			}
		},
	}
	// ReceivableOrderFieldStatus orders Receivable by status.
	ReceivableOrderFieldStatus = &ReceivableOrderField{
		Value: func(r *Receivable) (ent.Value, error) {
			return r.Status, nil
		},
		column: receivable.FieldStatus,
		toTerm: receivable.ByStatus,
		toCursor: func(r *Receivable) Cursor {
			return Cursor{
				ID:    r.ID,
				Value: r.Status,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f ReceivableOrderField) String() string {
	var str string
	switch f.column {
	case ReceivableOrderFieldCreatedAt.column:
		str = "CREATED_AT"
	case ReceivableOrderFieldUpdatedAt.column:
		str = "UPDATED_AT"
	case ReceivableOrderFieldDueDate.column:
		str = "DUEDATE"
	case ReceivableOrderFieldStatus.column:
		str = "STATUS"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f ReceivableOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *ReceivableOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("ReceivableOrderField %T must be a string", v)
	}
	switch str {
	case "CREATED_AT":
		*f = *ReceivableOrderFieldCreatedAt
	case "UPDATED_AT":
		*f = *ReceivableOrderFieldUpdatedAt
	case "DUEDATE":
		*f = *ReceivableOrderFieldDueDate
	case "STATUS":
		*f = *ReceivableOrderFieldStatus
	default:
		return fmt.Errorf("%s is not a valid ReceivableOrderField", str)
	}
	return nil
}

// ReceivableOrderField defines the ordering field of Receivable.
type ReceivableOrderField struct {
	// Value extracts the ordering value from the given Receivable.
	Value    func(*Receivable) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) receivable.OrderOption
	toCursor func(*Receivable) Cursor
}

// ReceivableOrder defines the ordering of Receivable.
type ReceivableOrder struct {
	Direction OrderDirection        `json:"direction"`
	Field     *ReceivableOrderField `json:"field"`
}

// DefaultReceivableOrder is the default ordering of Receivable.
var DefaultReceivableOrder = &ReceivableOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &ReceivableOrderField{
		Value: func(r *Receivable) (ent.Value, error) {
			return r.ID, nil
		},
		column: receivable.FieldID,
		toTerm: receivable.ByID,
		toCursor: func(r *Receivable) Cursor {
			return Cursor{ID: r.ID}
		},
	},
}

// ToEdge converts Receivable into ReceivableEdge.
func (r *Receivable) ToEdge(order *ReceivableOrder) *ReceivableEdge {
	if order == nil {
		order = DefaultReceivableOrder
	}
	return &ReceivableEdge{
		Node:   r,
		Cursor: order.Field.toCursor(r),
	}
}

// SupplierEdge is the edge representation of Supplier.
type SupplierEdge struct {
	Node   *Supplier `json:"node"`
	Cursor Cursor    `json:"cursor"`
}

// SupplierConnection is the connection containing edges to Supplier.
type SupplierConnection struct {
	Edges      []*SupplierEdge `json:"edges"`
	PageInfo   PageInfo        `json:"pageInfo"`
	TotalCount int             `json:"totalCount"`
}

func (c *SupplierConnection) build(nodes []*Supplier, pager *supplierPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *Supplier
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Supplier {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Supplier {
			return nodes[i]
		}
	}
	c.Edges = make([]*SupplierEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &SupplierEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// SupplierPaginateOption enables pagination customization.
type SupplierPaginateOption func(*supplierPager) error

// WithSupplierOrder configures pagination ordering.
func WithSupplierOrder(order *SupplierOrder) SupplierPaginateOption {
	if order == nil {
		order = DefaultSupplierOrder
	}
	o := *order
	return func(pager *supplierPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultSupplierOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithSupplierFilter configures pagination filter.
func WithSupplierFilter(filter func(*SupplierQuery) (*SupplierQuery, error)) SupplierPaginateOption {
	return func(pager *supplierPager) error {
		if filter == nil {
			return errors.New("SupplierQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type supplierPager struct {
	reverse bool
	order   *SupplierOrder
	filter  func(*SupplierQuery) (*SupplierQuery, error)
}

func newSupplierPager(opts []SupplierPaginateOption, reverse bool) (*supplierPager, error) {
	pager := &supplierPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultSupplierOrder
	}
	return pager, nil
}

func (p *supplierPager) applyFilter(query *SupplierQuery) (*SupplierQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *supplierPager) toCursor(s *Supplier) Cursor {
	return p.order.Field.toCursor(s)
}

func (p *supplierPager) applyCursors(query *SupplierQuery, after, before *Cursor) (*SupplierQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultSupplierOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *supplierPager) applyOrder(query *SupplierQuery) *SupplierQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultSupplierOrder.Field {
		query = query.Order(DefaultSupplierOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *supplierPager) orderExpr(query *SupplierQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultSupplierOrder.Field {
			b.Comma().Ident(DefaultSupplierOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to Supplier.
func (s *SupplierQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...SupplierPaginateOption,
) (*SupplierConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newSupplierPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if s, err = pager.applyFilter(s); err != nil {
		return nil, err
	}
	conn := &SupplierConnection{Edges: []*SupplierEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = s.Clone().Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if s, err = pager.applyCursors(s, after, before); err != nil {
		return nil, err
	}
	if limit := paginateLimit(first, last); limit != 0 {
		s.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := s.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	s = pager.applyOrder(s)
	nodes, err := s.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// SupplierOrderFieldCreatedAt orders Supplier by createdAt.
	SupplierOrderFieldCreatedAt = &SupplierOrderField{
		Value: func(s *Supplier) (ent.Value, error) {
			return s.CreatedAt, nil
		},
		column: supplier.FieldCreatedAt,
		toTerm: supplier.ByCreatedAt,
		toCursor: func(s *Supplier) Cursor {
			return Cursor{
				ID:    s.ID,
				Value: s.CreatedAt,
			}
		},
	}
	// SupplierOrderFieldUpdatedAt orders Supplier by updatedAt.
	SupplierOrderFieldUpdatedAt = &SupplierOrderField{
		Value: func(s *Supplier) (ent.Value, error) {
			return s.UpdatedAt, nil
		},
		column: supplier.FieldUpdatedAt,
		toTerm: supplier.ByUpdatedAt,
		toCursor: func(s *Supplier) Cursor {
			return Cursor{
				ID:    s.ID,
				Value: s.UpdatedAt,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f SupplierOrderField) String() string {
	var str string
	switch f.column {
	case SupplierOrderFieldCreatedAt.column:
		str = "CREATED_AT"
	case SupplierOrderFieldUpdatedAt.column:
		str = "UPDATED_AT"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f SupplierOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *SupplierOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("SupplierOrderField %T must be a string", v)
	}
	switch str {
	case "CREATED_AT":
		*f = *SupplierOrderFieldCreatedAt
	case "UPDATED_AT":
		*f = *SupplierOrderFieldUpdatedAt
	default:
		return fmt.Errorf("%s is not a valid SupplierOrderField", str)
	}
	return nil
}

// SupplierOrderField defines the ordering field of Supplier.
type SupplierOrderField struct {
	// Value extracts the ordering value from the given Supplier.
	Value    func(*Supplier) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) supplier.OrderOption
	toCursor func(*Supplier) Cursor
}

// SupplierOrder defines the ordering of Supplier.
type SupplierOrder struct {
	Direction OrderDirection      `json:"direction"`
	Field     *SupplierOrderField `json:"field"`
}

// DefaultSupplierOrder is the default ordering of Supplier.
var DefaultSupplierOrder = &SupplierOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &SupplierOrderField{
		Value: func(s *Supplier) (ent.Value, error) {
			return s.ID, nil
		},
		column: supplier.FieldID,
		toTerm: supplier.ByID,
		toCursor: func(s *Supplier) Cursor {
			return Cursor{ID: s.ID}
		},
	},
}

// ToEdge converts Supplier into SupplierEdge.
func (s *Supplier) ToEdge(order *SupplierOrder) *SupplierEdge {
	if order == nil {
		order = DefaultSupplierOrder
	}
	return &SupplierEdge{
		Node:   s,
		Cursor: order.Field.toCursor(s),
	}
}

// TokenEdge is the edge representation of Token.
type TokenEdge struct {
	Node   *Token `json:"node"`
	Cursor Cursor `json:"cursor"`
}

// TokenConnection is the connection containing edges to Token.
type TokenConnection struct {
	Edges      []*TokenEdge `json:"edges"`
	PageInfo   PageInfo     `json:"pageInfo"`
	TotalCount int          `json:"totalCount"`
}

func (c *TokenConnection) build(nodes []*Token, pager *tokenPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *Token
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Token {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Token {
			return nodes[i]
		}
	}
	c.Edges = make([]*TokenEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &TokenEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// TokenPaginateOption enables pagination customization.
type TokenPaginateOption func(*tokenPager) error

// WithTokenOrder configures pagination ordering.
func WithTokenOrder(order *TokenOrder) TokenPaginateOption {
	if order == nil {
		order = DefaultTokenOrder
	}
	o := *order
	return func(pager *tokenPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultTokenOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithTokenFilter configures pagination filter.
func WithTokenFilter(filter func(*TokenQuery) (*TokenQuery, error)) TokenPaginateOption {
	return func(pager *tokenPager) error {
		if filter == nil {
			return errors.New("TokenQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type tokenPager struct {
	reverse bool
	order   *TokenOrder
	filter  func(*TokenQuery) (*TokenQuery, error)
}

func newTokenPager(opts []TokenPaginateOption, reverse bool) (*tokenPager, error) {
	pager := &tokenPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultTokenOrder
	}
	return pager, nil
}

func (p *tokenPager) applyFilter(query *TokenQuery) (*TokenQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *tokenPager) toCursor(t *Token) Cursor {
	return p.order.Field.toCursor(t)
}

func (p *tokenPager) applyCursors(query *TokenQuery, after, before *Cursor) (*TokenQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultTokenOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *tokenPager) applyOrder(query *TokenQuery) *TokenQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultTokenOrder.Field {
		query = query.Order(DefaultTokenOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *tokenPager) orderExpr(query *TokenQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultTokenOrder.Field {
			b.Comma().Ident(DefaultTokenOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to Token.
func (t *TokenQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...TokenPaginateOption,
) (*TokenConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newTokenPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if t, err = pager.applyFilter(t); err != nil {
		return nil, err
	}
	conn := &TokenConnection{Edges: []*TokenEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = t.Clone().Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if t, err = pager.applyCursors(t, after, before); err != nil {
		return nil, err
	}
	if limit := paginateLimit(first, last); limit != 0 {
		t.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := t.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	t = pager.applyOrder(t)
	nodes, err := t.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// TokenOrderField defines the ordering field of Token.
type TokenOrderField struct {
	// Value extracts the ordering value from the given Token.
	Value    func(*Token) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) token.OrderOption
	toCursor func(*Token) Cursor
}

// TokenOrder defines the ordering of Token.
type TokenOrder struct {
	Direction OrderDirection   `json:"direction"`
	Field     *TokenOrderField `json:"field"`
}

// DefaultTokenOrder is the default ordering of Token.
var DefaultTokenOrder = &TokenOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &TokenOrderField{
		Value: func(t *Token) (ent.Value, error) {
			return t.ID, nil
		},
		column: token.FieldID,
		toTerm: token.ByID,
		toCursor: func(t *Token) Cursor {
			return Cursor{ID: t.ID}
		},
	},
}

// ToEdge converts Token into TokenEdge.
func (t *Token) ToEdge(order *TokenOrder) *TokenEdge {
	if order == nil {
		order = DefaultTokenOrder
	}
	return &TokenEdge{
		Node:   t,
		Cursor: order.Field.toCursor(t),
	}
}

// TreasuryEdge is the edge representation of Treasury.
type TreasuryEdge struct {
	Node   *Treasury `json:"node"`
	Cursor Cursor    `json:"cursor"`
}

// TreasuryConnection is the connection containing edges to Treasury.
type TreasuryConnection struct {
	Edges      []*TreasuryEdge `json:"edges"`
	PageInfo   PageInfo        `json:"pageInfo"`
	TotalCount int             `json:"totalCount"`
}

func (c *TreasuryConnection) build(nodes []*Treasury, pager *treasuryPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *Treasury
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Treasury {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Treasury {
			return nodes[i]
		}
	}
	c.Edges = make([]*TreasuryEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &TreasuryEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// TreasuryPaginateOption enables pagination customization.
type TreasuryPaginateOption func(*treasuryPager) error

// WithTreasuryOrder configures pagination ordering.
func WithTreasuryOrder(order *TreasuryOrder) TreasuryPaginateOption {
	if order == nil {
		order = DefaultTreasuryOrder
	}
	o := *order
	return func(pager *treasuryPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultTreasuryOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithTreasuryFilter configures pagination filter.
func WithTreasuryFilter(filter func(*TreasuryQuery) (*TreasuryQuery, error)) TreasuryPaginateOption {
	return func(pager *treasuryPager) error {
		if filter == nil {
			return errors.New("TreasuryQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type treasuryPager struct {
	reverse bool
	order   *TreasuryOrder
	filter  func(*TreasuryQuery) (*TreasuryQuery, error)
}

func newTreasuryPager(opts []TreasuryPaginateOption, reverse bool) (*treasuryPager, error) {
	pager := &treasuryPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultTreasuryOrder
	}
	return pager, nil
}

func (p *treasuryPager) applyFilter(query *TreasuryQuery) (*TreasuryQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *treasuryPager) toCursor(t *Treasury) Cursor {
	return p.order.Field.toCursor(t)
}

func (p *treasuryPager) applyCursors(query *TreasuryQuery, after, before *Cursor) (*TreasuryQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultTreasuryOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *treasuryPager) applyOrder(query *TreasuryQuery) *TreasuryQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultTreasuryOrder.Field {
		query = query.Order(DefaultTreasuryOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *treasuryPager) orderExpr(query *TreasuryQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultTreasuryOrder.Field {
			b.Comma().Ident(DefaultTreasuryOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to Treasury.
func (t *TreasuryQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...TreasuryPaginateOption,
) (*TreasuryConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newTreasuryPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if t, err = pager.applyFilter(t); err != nil {
		return nil, err
	}
	conn := &TreasuryConnection{Edges: []*TreasuryEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = t.Clone().Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if t, err = pager.applyCursors(t, after, before); err != nil {
		return nil, err
	}
	if limit := paginateLimit(first, last); limit != 0 {
		t.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := t.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	t = pager.applyOrder(t)
	nodes, err := t.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// TreasuryOrderFieldCreatedAt orders Treasury by createdAt.
	TreasuryOrderFieldCreatedAt = &TreasuryOrderField{
		Value: func(t *Treasury) (ent.Value, error) {
			return t.CreatedAt, nil
		},
		column: treasury.FieldCreatedAt,
		toTerm: treasury.ByCreatedAt,
		toCursor: func(t *Treasury) Cursor {
			return Cursor{
				ID:    t.ID,
				Value: t.CreatedAt,
			}
		},
	}
	// TreasuryOrderFieldUpdatedAt orders Treasury by updatedAt.
	TreasuryOrderFieldUpdatedAt = &TreasuryOrderField{
		Value: func(t *Treasury) (ent.Value, error) {
			return t.UpdatedAt, nil
		},
		column: treasury.FieldUpdatedAt,
		toTerm: treasury.ByUpdatedAt,
		toCursor: func(t *Treasury) Cursor {
			return Cursor{
				ID:    t.ID,
				Value: t.UpdatedAt,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f TreasuryOrderField) String() string {
	var str string
	switch f.column {
	case TreasuryOrderFieldCreatedAt.column:
		str = "CREATED_AT"
	case TreasuryOrderFieldUpdatedAt.column:
		str = "UPDATED_AT"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f TreasuryOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *TreasuryOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("TreasuryOrderField %T must be a string", v)
	}
	switch str {
	case "CREATED_AT":
		*f = *TreasuryOrderFieldCreatedAt
	case "UPDATED_AT":
		*f = *TreasuryOrderFieldUpdatedAt
	default:
		return fmt.Errorf("%s is not a valid TreasuryOrderField", str)
	}
	return nil
}

// TreasuryOrderField defines the ordering field of Treasury.
type TreasuryOrderField struct {
	// Value extracts the ordering value from the given Treasury.
	Value    func(*Treasury) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) treasury.OrderOption
	toCursor func(*Treasury) Cursor
}

// TreasuryOrder defines the ordering of Treasury.
type TreasuryOrder struct {
	Direction OrderDirection      `json:"direction"`
	Field     *TreasuryOrderField `json:"field"`
}

// DefaultTreasuryOrder is the default ordering of Treasury.
var DefaultTreasuryOrder = &TreasuryOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &TreasuryOrderField{
		Value: func(t *Treasury) (ent.Value, error) {
			return t.ID, nil
		},
		column: treasury.FieldID,
		toTerm: treasury.ByID,
		toCursor: func(t *Treasury) Cursor {
			return Cursor{ID: t.ID}
		},
	},
}

// ToEdge converts Treasury into TreasuryEdge.
func (t *Treasury) ToEdge(order *TreasuryOrder) *TreasuryEdge {
	if order == nil {
		order = DefaultTreasuryOrder
	}
	return &TreasuryEdge{
		Node:   t,
		Cursor: order.Field.toCursor(t),
	}
}

// UserEdge is the edge representation of User.
type UserEdge struct {
	Node   *User  `json:"node"`
	Cursor Cursor `json:"cursor"`
}

// UserConnection is the connection containing edges to User.
type UserConnection struct {
	Edges      []*UserEdge `json:"edges"`
	PageInfo   PageInfo    `json:"pageInfo"`
	TotalCount int         `json:"totalCount"`
}

func (c *UserConnection) build(nodes []*User, pager *userPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *User
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *User {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *User {
			return nodes[i]
		}
	}
	c.Edges = make([]*UserEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &UserEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// UserPaginateOption enables pagination customization.
type UserPaginateOption func(*userPager) error

// WithUserOrder configures pagination ordering.
func WithUserOrder(order *UserOrder) UserPaginateOption {
	if order == nil {
		order = DefaultUserOrder
	}
	o := *order
	return func(pager *userPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultUserOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithUserFilter configures pagination filter.
func WithUserFilter(filter func(*UserQuery) (*UserQuery, error)) UserPaginateOption {
	return func(pager *userPager) error {
		if filter == nil {
			return errors.New("UserQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type userPager struct {
	reverse bool
	order   *UserOrder
	filter  func(*UserQuery) (*UserQuery, error)
}

func newUserPager(opts []UserPaginateOption, reverse bool) (*userPager, error) {
	pager := &userPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultUserOrder
	}
	return pager, nil
}

func (p *userPager) applyFilter(query *UserQuery) (*UserQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *userPager) toCursor(u *User) Cursor {
	return p.order.Field.toCursor(u)
}

func (p *userPager) applyCursors(query *UserQuery, after, before *Cursor) (*UserQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultUserOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *userPager) applyOrder(query *UserQuery) *UserQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultUserOrder.Field {
		query = query.Order(DefaultUserOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *userPager) orderExpr(query *UserQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultUserOrder.Field {
			b.Comma().Ident(DefaultUserOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to User.
func (u *UserQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...UserPaginateOption,
) (*UserConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newUserPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if u, err = pager.applyFilter(u); err != nil {
		return nil, err
	}
	conn := &UserConnection{Edges: []*UserEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = u.Clone().Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if u, err = pager.applyCursors(u, after, before); err != nil {
		return nil, err
	}
	if limit := paginateLimit(first, last); limit != 0 {
		u.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := u.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	u = pager.applyOrder(u)
	nodes, err := u.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// UserOrderFieldCreatedAt orders User by createdAt.
	UserOrderFieldCreatedAt = &UserOrderField{
		Value: func(u *User) (ent.Value, error) {
			return u.CreatedAt, nil
		},
		column: user.FieldCreatedAt,
		toTerm: user.ByCreatedAt,
		toCursor: func(u *User) Cursor {
			return Cursor{
				ID:    u.ID,
				Value: u.CreatedAt,
			}
		},
	}
	// UserOrderFieldUpdatedAt orders User by updatedAt.
	UserOrderFieldUpdatedAt = &UserOrderField{
		Value: func(u *User) (ent.Value, error) {
			return u.UpdatedAt, nil
		},
		column: user.FieldUpdatedAt,
		toTerm: user.ByUpdatedAt,
		toCursor: func(u *User) Cursor {
			return Cursor{
				ID:    u.ID,
				Value: u.UpdatedAt,
			}
		},
	}
	// UserOrderFieldName orders User by name.
	UserOrderFieldName = &UserOrderField{
		Value: func(u *User) (ent.Value, error) {
			return u.Name, nil
		},
		column: user.FieldName,
		toTerm: user.ByName,
		toCursor: func(u *User) Cursor {
			return Cursor{
				ID:    u.ID,
				Value: u.Name,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f UserOrderField) String() string {
	var str string
	switch f.column {
	case UserOrderFieldCreatedAt.column:
		str = "CREATED_AT"
	case UserOrderFieldUpdatedAt.column:
		str = "UPDATED_AT"
	case UserOrderFieldName.column:
		str = "NAME"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f UserOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *UserOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("UserOrderField %T must be a string", v)
	}
	switch str {
	case "CREATED_AT":
		*f = *UserOrderFieldCreatedAt
	case "UPDATED_AT":
		*f = *UserOrderFieldUpdatedAt
	case "NAME":
		*f = *UserOrderFieldName
	default:
		return fmt.Errorf("%s is not a valid UserOrderField", str)
	}
	return nil
}

// UserOrderField defines the ordering field of User.
type UserOrderField struct {
	// Value extracts the ordering value from the given User.
	Value    func(*User) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) user.OrderOption
	toCursor func(*User) Cursor
}

// UserOrder defines the ordering of User.
type UserOrder struct {
	Direction OrderDirection  `json:"direction"`
	Field     *UserOrderField `json:"field"`
}

// DefaultUserOrder is the default ordering of User.
var DefaultUserOrder = &UserOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &UserOrderField{
		Value: func(u *User) (ent.Value, error) {
			return u.ID, nil
		},
		column: user.FieldID,
		toTerm: user.ByID,
		toCursor: func(u *User) Cursor {
			return Cursor{ID: u.ID}
		},
	},
}

// ToEdge converts User into UserEdge.
func (u *User) ToEdge(order *UserOrder) *UserEdge {
	if order == nil {
		order = DefaultUserOrder
	}
	return &UserEdge{
		Node:   u,
		Cursor: order.Field.toCursor(u),
	}
}

// UserRoleEdge is the edge representation of UserRole.
type UserRoleEdge struct {
	Node   *UserRole `json:"node"`
	Cursor Cursor    `json:"cursor"`
}

// UserRoleConnection is the connection containing edges to UserRole.
type UserRoleConnection struct {
	Edges      []*UserRoleEdge `json:"edges"`
	PageInfo   PageInfo        `json:"pageInfo"`
	TotalCount int             `json:"totalCount"`
}

func (c *UserRoleConnection) build(nodes []*UserRole, pager *userrolePager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *UserRole
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *UserRole {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *UserRole {
			return nodes[i]
		}
	}
	c.Edges = make([]*UserRoleEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &UserRoleEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// UserRolePaginateOption enables pagination customization.
type UserRolePaginateOption func(*userrolePager) error

// WithUserRoleOrder configures pagination ordering.
func WithUserRoleOrder(order *UserRoleOrder) UserRolePaginateOption {
	if order == nil {
		order = DefaultUserRoleOrder
	}
	o := *order
	return func(pager *userrolePager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultUserRoleOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithUserRoleFilter configures pagination filter.
func WithUserRoleFilter(filter func(*UserRoleQuery) (*UserRoleQuery, error)) UserRolePaginateOption {
	return func(pager *userrolePager) error {
		if filter == nil {
			return errors.New("UserRoleQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type userrolePager struct {
	reverse bool
	order   *UserRoleOrder
	filter  func(*UserRoleQuery) (*UserRoleQuery, error)
}

func newUserRolePager(opts []UserRolePaginateOption, reverse bool) (*userrolePager, error) {
	pager := &userrolePager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultUserRoleOrder
	}
	return pager, nil
}

func (p *userrolePager) applyFilter(query *UserRoleQuery) (*UserRoleQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *userrolePager) toCursor(ur *UserRole) Cursor {
	return p.order.Field.toCursor(ur)
}

func (p *userrolePager) applyCursors(query *UserRoleQuery, after, before *Cursor) (*UserRoleQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultUserRoleOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *userrolePager) applyOrder(query *UserRoleQuery) *UserRoleQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultUserRoleOrder.Field {
		query = query.Order(DefaultUserRoleOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *userrolePager) orderExpr(query *UserRoleQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultUserRoleOrder.Field {
			b.Comma().Ident(DefaultUserRoleOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to UserRole.
func (ur *UserRoleQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...UserRolePaginateOption,
) (*UserRoleConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newUserRolePager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if ur, err = pager.applyFilter(ur); err != nil {
		return nil, err
	}
	conn := &UserRoleConnection{Edges: []*UserRoleEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = ur.Clone().Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if ur, err = pager.applyCursors(ur, after, before); err != nil {
		return nil, err
	}
	if limit := paginateLimit(first, last); limit != 0 {
		ur.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := ur.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	ur = pager.applyOrder(ur)
	nodes, err := ur.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// UserRoleOrderFieldRole orders UserRole by role.
	UserRoleOrderFieldRole = &UserRoleOrderField{
		Value: func(ur *UserRole) (ent.Value, error) {
			return ur.Role, nil
		},
		column: userrole.FieldRole,
		toTerm: userrole.ByRole,
		toCursor: func(ur *UserRole) Cursor {
			return Cursor{
				ID:    ur.ID,
				Value: ur.Role,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f UserRoleOrderField) String() string {
	var str string
	switch f.column {
	case UserRoleOrderFieldRole.column:
		str = "ROLES"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f UserRoleOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *UserRoleOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("UserRoleOrderField %T must be a string", v)
	}
	switch str {
	case "ROLES":
		*f = *UserRoleOrderFieldRole
	default:
		return fmt.Errorf("%s is not a valid UserRoleOrderField", str)
	}
	return nil
}

// UserRoleOrderField defines the ordering field of UserRole.
type UserRoleOrderField struct {
	// Value extracts the ordering value from the given UserRole.
	Value    func(*UserRole) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) userrole.OrderOption
	toCursor func(*UserRole) Cursor
}

// UserRoleOrder defines the ordering of UserRole.
type UserRoleOrder struct {
	Direction OrderDirection      `json:"direction"`
	Field     *UserRoleOrderField `json:"field"`
}

// DefaultUserRoleOrder is the default ordering of UserRole.
var DefaultUserRoleOrder = &UserRoleOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &UserRoleOrderField{
		Value: func(ur *UserRole) (ent.Value, error) {
			return ur.ID, nil
		},
		column: userrole.FieldID,
		toTerm: userrole.ByID,
		toCursor: func(ur *UserRole) Cursor {
			return Cursor{ID: ur.ID}
		},
	},
}

// ToEdge converts UserRole into UserRoleEdge.
func (ur *UserRole) ToEdge(order *UserRoleOrder) *UserRoleEdge {
	if order == nil {
		order = DefaultUserRoleOrder
	}
	return &UserRoleEdge{
		Node:   ur,
		Cursor: order.Field.toCursor(ur),
	}
}

// WorkshiftEdge is the edge representation of Workshift.
type WorkshiftEdge struct {
	Node   *Workshift `json:"node"`
	Cursor Cursor     `json:"cursor"`
}

// WorkshiftConnection is the connection containing edges to Workshift.
type WorkshiftConnection struct {
	Edges      []*WorkshiftEdge `json:"edges"`
	PageInfo   PageInfo         `json:"pageInfo"`
	TotalCount int              `json:"totalCount"`
}

func (c *WorkshiftConnection) build(nodes []*Workshift, pager *workshiftPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *Workshift
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Workshift {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Workshift {
			return nodes[i]
		}
	}
	c.Edges = make([]*WorkshiftEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &WorkshiftEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// WorkshiftPaginateOption enables pagination customization.
type WorkshiftPaginateOption func(*workshiftPager) error

// WithWorkshiftOrder configures pagination ordering.
func WithWorkshiftOrder(order []*WorkshiftOrder) WorkshiftPaginateOption {
	return func(pager *workshiftPager) error {
		for _, o := range order {
			if err := o.Direction.Validate(); err != nil {
				return err
			}
		}
		pager.order = append(pager.order, order...)
		return nil
	}
}

// WithWorkshiftFilter configures pagination filter.
func WithWorkshiftFilter(filter func(*WorkshiftQuery) (*WorkshiftQuery, error)) WorkshiftPaginateOption {
	return func(pager *workshiftPager) error {
		if filter == nil {
			return errors.New("WorkshiftQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type workshiftPager struct {
	reverse bool
	order   []*WorkshiftOrder
	filter  func(*WorkshiftQuery) (*WorkshiftQuery, error)
}

func newWorkshiftPager(opts []WorkshiftPaginateOption, reverse bool) (*workshiftPager, error) {
	pager := &workshiftPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	for i, o := range pager.order {
		if i > 0 && o.Field == pager.order[i-1].Field {
			return nil, fmt.Errorf("duplicate order direction %q", o.Direction)
		}
	}
	return pager, nil
}

func (p *workshiftPager) applyFilter(query *WorkshiftQuery) (*WorkshiftQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *workshiftPager) toCursor(w *Workshift) Cursor {
	cs := make([]any, 0, len(p.order))
	for _, o := range p.order {
		cs = append(cs, o.Field.toCursor(w).Value)
	}
	return Cursor{ID: w.ID, Value: cs}
}

func (p *workshiftPager) applyCursors(query *WorkshiftQuery, after, before *Cursor) (*WorkshiftQuery, error) {
	idDirection := entgql.OrderDirectionAsc
	if p.reverse {
		idDirection = entgql.OrderDirectionDesc
	}
	fields, directions := make([]string, 0, len(p.order)), make([]OrderDirection, 0, len(p.order))
	for _, o := range p.order {
		fields = append(fields, o.Field.column)
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		directions = append(directions, direction)
	}
	predicates, err := entgql.MultiCursorsPredicate(after, before, &entgql.MultiCursorsOptions{
		FieldID:     DefaultWorkshiftOrder.Field.column,
		DirectionID: idDirection,
		Fields:      fields,
		Directions:  directions,
	})
	if err != nil {
		return nil, err
	}
	for _, predicate := range predicates {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *workshiftPager) applyOrder(query *WorkshiftQuery) *WorkshiftQuery {
	var defaultOrdered bool
	for _, o := range p.order {
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(o.Field.toTerm(direction.OrderTermOption()))
		if o.Field.column == DefaultWorkshiftOrder.Field.column {
			defaultOrdered = true
		}
		if len(query.ctx.Fields) > 0 {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	if !defaultOrdered {
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(DefaultWorkshiftOrder.Field.toTerm(direction.OrderTermOption()))
	}
	return query
}

func (p *workshiftPager) orderExpr(query *WorkshiftQuery) sql.Querier {
	if len(query.ctx.Fields) > 0 {
		for _, o := range p.order {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		for _, o := range p.order {
			direction := o.Direction
			if p.reverse {
				direction = direction.Reverse()
			}
			b.Ident(o.Field.column).Pad().WriteString(string(direction))
			b.Comma()
		}
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		b.Ident(DefaultWorkshiftOrder.Field.column).Pad().WriteString(string(direction))
	})
}

// Paginate executes the query and returns a relay based cursor connection to Workshift.
func (w *WorkshiftQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...WorkshiftPaginateOption,
) (*WorkshiftConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newWorkshiftPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if w, err = pager.applyFilter(w); err != nil {
		return nil, err
	}
	conn := &WorkshiftConnection{Edges: []*WorkshiftEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = w.Clone().Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if w, err = pager.applyCursors(w, after, before); err != nil {
		return nil, err
	}
	if limit := paginateLimit(first, last); limit != 0 {
		w.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := w.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	w = pager.applyOrder(w)
	nodes, err := w.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// WorkshiftOrderFieldCreatedAt orders Workshift by createdAt.
	WorkshiftOrderFieldCreatedAt = &WorkshiftOrderField{
		Value: func(w *Workshift) (ent.Value, error) {
			return w.CreatedAt, nil
		},
		column: workshift.FieldCreatedAt,
		toTerm: workshift.ByCreatedAt,
		toCursor: func(w *Workshift) Cursor {
			return Cursor{
				ID:    w.ID,
				Value: w.CreatedAt,
			}
		},
	}
	// WorkshiftOrderFieldUpdatedAt orders Workshift by updatedAt.
	WorkshiftOrderFieldUpdatedAt = &WorkshiftOrderField{
		Value: func(w *Workshift) (ent.Value, error) {
			return w.UpdatedAt, nil
		},
		column: workshift.FieldUpdatedAt,
		toTerm: workshift.ByUpdatedAt,
		toCursor: func(w *Workshift) Cursor {
			return Cursor{
				ID:    w.ID,
				Value: w.UpdatedAt,
			}
		},
	}
	// WorkshiftOrderFieldApprovedAt orders Workshift by approvedAt.
	WorkshiftOrderFieldApprovedAt = &WorkshiftOrderField{
		Value: func(w *Workshift) (ent.Value, error) {
			return w.ApprovedAt, nil
		},
		column: workshift.FieldApprovedAt,
		toTerm: workshift.ByApprovedAt,
		toCursor: func(w *Workshift) Cursor {
			return Cursor{
				ID:    w.ID,
				Value: w.ApprovedAt,
			}
		},
	}
	// WorkshiftOrderFieldClockIn orders Workshift by clockIn.
	WorkshiftOrderFieldClockIn = &WorkshiftOrderField{
		Value: func(w *Workshift) (ent.Value, error) {
			return w.ClockIn, nil
		},
		column: workshift.FieldClockIn,
		toTerm: workshift.ByClockIn,
		toCursor: func(w *Workshift) Cursor {
			return Cursor{
				ID:    w.ID,
				Value: w.ClockIn,
			}
		},
	}
	// WorkshiftOrderFieldClockOut orders Workshift by clockOut.
	WorkshiftOrderFieldClockOut = &WorkshiftOrderField{
		Value: func(w *Workshift) (ent.Value, error) {
			return w.ClockOut, nil
		},
		column: workshift.FieldClockOut,
		toTerm: workshift.ByClockOut,
		toCursor: func(w *Workshift) Cursor {
			return Cursor{
				ID:    w.ID,
				Value: w.ClockOut,
			}
		},
	}
	// WorkshiftOrderFieldStatus orders Workshift by status.
	WorkshiftOrderFieldStatus = &WorkshiftOrderField{
		Value: func(w *Workshift) (ent.Value, error) {
			return w.Status, nil
		},
		column: workshift.FieldStatus,
		toTerm: workshift.ByStatus,
		toCursor: func(w *Workshift) Cursor {
			return Cursor{
				ID:    w.ID,
				Value: w.Status,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f WorkshiftOrderField) String() string {
	var str string
	switch f.column {
	case WorkshiftOrderFieldCreatedAt.column:
		str = "CREATED_AT"
	case WorkshiftOrderFieldUpdatedAt.column:
		str = "UPDATED_AT"
	case WorkshiftOrderFieldApprovedAt.column:
		str = "APPROVED_AT"
	case WorkshiftOrderFieldClockIn.column:
		str = "CLOCK_IN"
	case WorkshiftOrderFieldClockOut.column:
		str = "CLOCK_OUT"
	case WorkshiftOrderFieldStatus.column:
		str = "STATUS"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f WorkshiftOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *WorkshiftOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("WorkshiftOrderField %T must be a string", v)
	}
	switch str {
	case "CREATED_AT":
		*f = *WorkshiftOrderFieldCreatedAt
	case "UPDATED_AT":
		*f = *WorkshiftOrderFieldUpdatedAt
	case "APPROVED_AT":
		*f = *WorkshiftOrderFieldApprovedAt
	case "CLOCK_IN":
		*f = *WorkshiftOrderFieldClockIn
	case "CLOCK_OUT":
		*f = *WorkshiftOrderFieldClockOut
	case "STATUS":
		*f = *WorkshiftOrderFieldStatus
	default:
		return fmt.Errorf("%s is not a valid WorkshiftOrderField", str)
	}
	return nil
}

// WorkshiftOrderField defines the ordering field of Workshift.
type WorkshiftOrderField struct {
	// Value extracts the ordering value from the given Workshift.
	Value    func(*Workshift) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) workshift.OrderOption
	toCursor func(*Workshift) Cursor
}

// WorkshiftOrder defines the ordering of Workshift.
type WorkshiftOrder struct {
	Direction OrderDirection       `json:"direction"`
	Field     *WorkshiftOrderField `json:"field"`
}

// DefaultWorkshiftOrder is the default ordering of Workshift.
var DefaultWorkshiftOrder = &WorkshiftOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &WorkshiftOrderField{
		Value: func(w *Workshift) (ent.Value, error) {
			return w.ID, nil
		},
		column: workshift.FieldID,
		toTerm: workshift.ByID,
		toCursor: func(w *Workshift) Cursor {
			return Cursor{ID: w.ID}
		},
	},
}

// ToEdge converts Workshift into WorkshiftEdge.
func (w *Workshift) ToEdge(order *WorkshiftOrder) *WorkshiftEdge {
	if order == nil {
		order = DefaultWorkshiftOrder
	}
	return &WorkshiftEdge{
		Node:   w,
		Cursor: order.Field.toCursor(w),
	}
}
