// Code generated by ent, DO NOT EDIT.

package generated

import (
	"context"
	"errors"
	"fmt"
	"io"
	"mazza/ent/generated/accountingentry"
	"mazza/ent/generated/company"
	"mazza/ent/generated/customer"
	"mazza/ent/generated/employee"
	"mazza/ent/generated/file"
	"mazza/ent/generated/payable"
	"mazza/ent/generated/product"
	"mazza/ent/generated/project"
	"mazza/ent/generated/projectmilestone"
	"mazza/ent/generated/projecttask"
	"mazza/ent/generated/receivable"
	"mazza/ent/generated/supplier"
	"mazza/ent/generated/token"
	"mazza/ent/generated/treasury"
	"mazza/ent/generated/user"
	"mazza/ent/generated/userrole"
	"mazza/ent/generated/workshift"
	"strconv"

	"entgo.io/contrib/entgql"
	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/99designs/gqlgen/graphql"
	"github.com/99designs/gqlgen/graphql/errcode"
	"github.com/vektah/gqlparser/v2/gqlerror"
)

// Common entgql types.
type (
	Cursor         = entgql.Cursor[int]
	PageInfo       = entgql.PageInfo[int]
	OrderDirection = entgql.OrderDirection
)

func orderFunc(o OrderDirection, field string) func(*sql.Selector) {
	if o == entgql.OrderDirectionDesc {
		return Desc(field)
	}
	return Asc(field)
}

const errInvalidPagination = "INVALID_PAGINATION"

func validateFirstLast(first, last *int) (err *gqlerror.Error) {
	switch {
	case first != nil && last != nil:
		err = &gqlerror.Error{
			Message: "Passing both `first` and `last` to paginate a connection is not supported.",
		}
	case first != nil && *first < 0:
		err = &gqlerror.Error{
			Message: "`first` on a connection cannot be less than zero.",
		}
		errcode.Set(err, errInvalidPagination)
	case last != nil && *last < 0:
		err = &gqlerror.Error{
			Message: "`last` on a connection cannot be less than zero.",
		}
		errcode.Set(err, errInvalidPagination)
	}
	return err
}

func collectedField(ctx context.Context, path ...string) *graphql.CollectedField {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return nil
	}
	field := fc.Field
	oc := graphql.GetOperationContext(ctx)
walk:
	for _, name := range path {
		for _, f := range graphql.CollectFields(oc, field.Selections, nil) {
			if f.Alias == name {
				field = f
				continue walk
			}
		}
		return nil
	}
	return &field
}

func hasCollectedField(ctx context.Context, path ...string) bool {
	if graphql.GetFieldContext(ctx) == nil {
		return true
	}
	return collectedField(ctx, path...) != nil
}

const (
	edgesField      = "edges"
	nodeField       = "node"
	pageInfoField   = "pageInfo"
	totalCountField = "totalCount"
)

func paginateLimit(first, last *int) int {
	var limit int
	if first != nil {
		limit = *first + 1
	} else if last != nil {
		limit = *last + 1
	}
	return limit
}

// AccountingEntryEdge is the edge representation of AccountingEntry.
type AccountingEntryEdge struct {
	Node   *AccountingEntry `json:"node"`
	Cursor Cursor           `json:"cursor"`
}

// AccountingEntryConnection is the connection containing edges to AccountingEntry.
type AccountingEntryConnection struct {
	Edges      []*AccountingEntryEdge `json:"edges"`
	PageInfo   PageInfo               `json:"pageInfo"`
	TotalCount int                    `json:"totalCount"`
}

func (c *AccountingEntryConnection) build(nodes []*AccountingEntry, pager *accountingentryPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *AccountingEntry
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *AccountingEntry {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *AccountingEntry {
			return nodes[i]
		}
	}
	c.Edges = make([]*AccountingEntryEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &AccountingEntryEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// AccountingEntryPaginateOption enables pagination customization.
type AccountingEntryPaginateOption func(*accountingentryPager) error

// WithAccountingEntryOrder configures pagination ordering.
func WithAccountingEntryOrder(order *AccountingEntryOrder) AccountingEntryPaginateOption {
	if order == nil {
		order = DefaultAccountingEntryOrder
	}
	o := *order
	return func(pager *accountingentryPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultAccountingEntryOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithAccountingEntryFilter configures pagination filter.
func WithAccountingEntryFilter(filter func(*AccountingEntryQuery) (*AccountingEntryQuery, error)) AccountingEntryPaginateOption {
	return func(pager *accountingentryPager) error {
		if filter == nil {
			return errors.New("AccountingEntryQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type accountingentryPager struct {
	reverse bool
	order   *AccountingEntryOrder
	filter  func(*AccountingEntryQuery) (*AccountingEntryQuery, error)
}

func newAccountingEntryPager(opts []AccountingEntryPaginateOption, reverse bool) (*accountingentryPager, error) {
	pager := &accountingentryPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultAccountingEntryOrder
	}
	return pager, nil
}

func (p *accountingentryPager) applyFilter(query *AccountingEntryQuery) (*AccountingEntryQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *accountingentryPager) toCursor(ae *AccountingEntry) Cursor {
	return p.order.Field.toCursor(ae)
}

func (p *accountingentryPager) applyCursors(query *AccountingEntryQuery, after, before *Cursor) (*AccountingEntryQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultAccountingEntryOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *accountingentryPager) applyOrder(query *AccountingEntryQuery) *AccountingEntryQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultAccountingEntryOrder.Field {
		query = query.Order(DefaultAccountingEntryOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *accountingentryPager) orderExpr(query *AccountingEntryQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultAccountingEntryOrder.Field {
			b.Comma().Ident(DefaultAccountingEntryOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to AccountingEntry.
func (ae *AccountingEntryQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...AccountingEntryPaginateOption,
) (*AccountingEntryConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newAccountingEntryPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if ae, err = pager.applyFilter(ae); err != nil {
		return nil, err
	}
	conn := &AccountingEntryConnection{Edges: []*AccountingEntryEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = ae.Clone().Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if ae, err = pager.applyCursors(ae, after, before); err != nil {
		return nil, err
	}
	if limit := paginateLimit(first, last); limit != 0 {
		ae.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := ae.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	ae = pager.applyOrder(ae)
	nodes, err := ae.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// AccountingEntryOrderFieldDate orders AccountingEntry by date.
	AccountingEntryOrderFieldDate = &AccountingEntryOrderField{
		Value: func(ae *AccountingEntry) (ent.Value, error) {
			return ae.Date, nil
		},
		column: accountingentry.FieldDate,
		toTerm: accountingentry.ByDate,
		toCursor: func(ae *AccountingEntry) Cursor {
			return Cursor{
				ID:    ae.ID,
				Value: ae.Date,
			}
		},
	}
	// AccountingEntryOrderFieldAccount orders AccountingEntry by account.
	AccountingEntryOrderFieldAccount = &AccountingEntryOrderField{
		Value: func(ae *AccountingEntry) (ent.Value, error) {
			return ae.Account, nil
		},
		column: accountingentry.FieldAccount,
		toTerm: accountingentry.ByAccount,
		toCursor: func(ae *AccountingEntry) Cursor {
			return Cursor{
				ID:    ae.ID,
				Value: ae.Account,
			}
		},
	}
	// AccountingEntryOrderFieldAmount orders AccountingEntry by amount.
	AccountingEntryOrderFieldAmount = &AccountingEntryOrderField{
		Value: func(ae *AccountingEntry) (ent.Value, error) {
			return ae.Amount, nil
		},
		column: accountingentry.FieldAmount,
		toTerm: accountingentry.ByAmount,
		toCursor: func(ae *AccountingEntry) Cursor {
			return Cursor{
				ID:    ae.ID,
				Value: ae.Amount,
			}
		},
	}
	// AccountingEntryOrderFieldDescription orders AccountingEntry by description.
	AccountingEntryOrderFieldDescription = &AccountingEntryOrderField{
		Value: func(ae *AccountingEntry) (ent.Value, error) {
			return ae.Description, nil
		},
		column: accountingentry.FieldDescription,
		toTerm: accountingentry.ByDescription,
		toCursor: func(ae *AccountingEntry) Cursor {
			return Cursor{
				ID:    ae.ID,
				Value: ae.Description,
			}
		},
	}
	// AccountingEntryOrderFieldAccountType orders AccountingEntry by accountType.
	AccountingEntryOrderFieldAccountType = &AccountingEntryOrderField{
		Value: func(ae *AccountingEntry) (ent.Value, error) {
			return ae.AccountType, nil
		},
		column: accountingentry.FieldAccountType,
		toTerm: accountingentry.ByAccountType,
		toCursor: func(ae *AccountingEntry) Cursor {
			return Cursor{
				ID:    ae.ID,
				Value: ae.AccountType,
			}
		},
	}
	// AccountingEntryOrderFieldIsDebit orders AccountingEntry by isDebit.
	AccountingEntryOrderFieldIsDebit = &AccountingEntryOrderField{
		Value: func(ae *AccountingEntry) (ent.Value, error) {
			return ae.IsDebit, nil
		},
		column: accountingentry.FieldIsDebit,
		toTerm: accountingentry.ByIsDebit,
		toCursor: func(ae *AccountingEntry) Cursor {
			return Cursor{
				ID:    ae.ID,
				Value: ae.IsDebit,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f AccountingEntryOrderField) String() string {
	var str string
	switch f.column {
	case AccountingEntryOrderFieldDate.column:
		str = "DATE"
	case AccountingEntryOrderFieldAccount.column:
		str = "ACCOUNT"
	case AccountingEntryOrderFieldAmount.column:
		str = "AMOUNT"
	case AccountingEntryOrderFieldDescription.column:
		str = "DESCRIPTION"
	case AccountingEntryOrderFieldAccountType.column:
		str = "ACCOUNTTYPE"
	case AccountingEntryOrderFieldIsDebit.column:
		str = "ISDEBIT"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f AccountingEntryOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *AccountingEntryOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("AccountingEntryOrderField %T must be a string", v)
	}
	switch str {
	case "DATE":
		*f = *AccountingEntryOrderFieldDate
	case "ACCOUNT":
		*f = *AccountingEntryOrderFieldAccount
	case "AMOUNT":
		*f = *AccountingEntryOrderFieldAmount
	case "DESCRIPTION":
		*f = *AccountingEntryOrderFieldDescription
	case "ACCOUNTTYPE":
		*f = *AccountingEntryOrderFieldAccountType
	case "ISDEBIT":
		*f = *AccountingEntryOrderFieldIsDebit
	default:
		return fmt.Errorf("%s is not a valid AccountingEntryOrderField", str)
	}
	return nil
}

// AccountingEntryOrderField defines the ordering field of AccountingEntry.
type AccountingEntryOrderField struct {
	// Value extracts the ordering value from the given AccountingEntry.
	Value    func(*AccountingEntry) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) accountingentry.OrderOption
	toCursor func(*AccountingEntry) Cursor
}

// AccountingEntryOrder defines the ordering of AccountingEntry.
type AccountingEntryOrder struct {
	Direction OrderDirection             `json:"direction"`
	Field     *AccountingEntryOrderField `json:"field"`
}

// DefaultAccountingEntryOrder is the default ordering of AccountingEntry.
var DefaultAccountingEntryOrder = &AccountingEntryOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &AccountingEntryOrderField{
		Value: func(ae *AccountingEntry) (ent.Value, error) {
			return ae.ID, nil
		},
		column: accountingentry.FieldID,
		toTerm: accountingentry.ByID,
		toCursor: func(ae *AccountingEntry) Cursor {
			return Cursor{ID: ae.ID}
		},
	},
}

// ToEdge converts AccountingEntry into AccountingEntryEdge.
func (ae *AccountingEntry) ToEdge(order *AccountingEntryOrder) *AccountingEntryEdge {
	if order == nil {
		order = DefaultAccountingEntryOrder
	}
	return &AccountingEntryEdge{
		Node:   ae,
		Cursor: order.Field.toCursor(ae),
	}
}

// CompanyEdge is the edge representation of Company.
type CompanyEdge struct {
	Node   *Company `json:"node"`
	Cursor Cursor   `json:"cursor"`
}

// CompanyConnection is the connection containing edges to Company.
type CompanyConnection struct {
	Edges      []*CompanyEdge `json:"edges"`
	PageInfo   PageInfo       `json:"pageInfo"`
	TotalCount int            `json:"totalCount"`
}

func (c *CompanyConnection) build(nodes []*Company, pager *companyPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *Company
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Company {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Company {
			return nodes[i]
		}
	}
	c.Edges = make([]*CompanyEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &CompanyEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// CompanyPaginateOption enables pagination customization.
type CompanyPaginateOption func(*companyPager) error

// WithCompanyOrder configures pagination ordering.
func WithCompanyOrder(order *CompanyOrder) CompanyPaginateOption {
	if order == nil {
		order = DefaultCompanyOrder
	}
	o := *order
	return func(pager *companyPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultCompanyOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithCompanyFilter configures pagination filter.
func WithCompanyFilter(filter func(*CompanyQuery) (*CompanyQuery, error)) CompanyPaginateOption {
	return func(pager *companyPager) error {
		if filter == nil {
			return errors.New("CompanyQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type companyPager struct {
	reverse bool
	order   *CompanyOrder
	filter  func(*CompanyQuery) (*CompanyQuery, error)
}

func newCompanyPager(opts []CompanyPaginateOption, reverse bool) (*companyPager, error) {
	pager := &companyPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultCompanyOrder
	}
	return pager, nil
}

func (p *companyPager) applyFilter(query *CompanyQuery) (*CompanyQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *companyPager) toCursor(c *Company) Cursor {
	return p.order.Field.toCursor(c)
}

func (p *companyPager) applyCursors(query *CompanyQuery, after, before *Cursor) (*CompanyQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultCompanyOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *companyPager) applyOrder(query *CompanyQuery) *CompanyQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultCompanyOrder.Field {
		query = query.Order(DefaultCompanyOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *companyPager) orderExpr(query *CompanyQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultCompanyOrder.Field {
			b.Comma().Ident(DefaultCompanyOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to Company.
func (c *CompanyQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...CompanyPaginateOption,
) (*CompanyConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newCompanyPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if c, err = pager.applyFilter(c); err != nil {
		return nil, err
	}
	conn := &CompanyConnection{Edges: []*CompanyEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = c.Clone().Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if c, err = pager.applyCursors(c, after, before); err != nil {
		return nil, err
	}
	if limit := paginateLimit(first, last); limit != 0 {
		c.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := c.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	c = pager.applyOrder(c)
	nodes, err := c.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// CompanyOrderFieldCity orders Company by city.
	CompanyOrderFieldCity = &CompanyOrderField{
		Value: func(c *Company) (ent.Value, error) {
			return c.City, nil
		},
		column: company.FieldCity,
		toTerm: company.ByCity,
		toCursor: func(c *Company) Cursor {
			return Cursor{
				ID:    c.ID,
				Value: c.City,
			}
		},
	}
	// CompanyOrderFieldCountry orders Company by country.
	CompanyOrderFieldCountry = &CompanyOrderField{
		Value: func(c *Company) (ent.Value, error) {
			return c.Country, nil
		},
		column: company.FieldCountry,
		toTerm: company.ByCountry,
		toCursor: func(c *Company) Cursor {
			return Cursor{
				ID:    c.ID,
				Value: c.Country,
			}
		},
	}
	// CompanyOrderFieldEstablishedAt orders Company by establishedAt.
	CompanyOrderFieldEstablishedAt = &CompanyOrderField{
		Value: func(c *Company) (ent.Value, error) {
			return c.EstablishedAt, nil
		},
		column: company.FieldEstablishedAt,
		toTerm: company.ByEstablishedAt,
		toCursor: func(c *Company) Cursor {
			return Cursor{
				ID:    c.ID,
				Value: c.EstablishedAt,
			}
		},
	}
	// CompanyOrderFieldName orders Company by name.
	CompanyOrderFieldName = &CompanyOrderField{
		Value: func(c *Company) (ent.Value, error) {
			return c.Name, nil
		},
		column: company.FieldName,
		toTerm: company.ByName,
		toCursor: func(c *Company) Cursor {
			return Cursor{
				ID:    c.ID,
				Value: c.Name,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f CompanyOrderField) String() string {
	var str string
	switch f.column {
	case CompanyOrderFieldCity.column:
		str = "CITY"
	case CompanyOrderFieldCountry.column:
		str = "COUNTRY"
	case CompanyOrderFieldEstablishedAt.column:
		str = "ESTABLISHEDAT"
	case CompanyOrderFieldName.column:
		str = "NAME"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f CompanyOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *CompanyOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("CompanyOrderField %T must be a string", v)
	}
	switch str {
	case "CITY":
		*f = *CompanyOrderFieldCity
	case "COUNTRY":
		*f = *CompanyOrderFieldCountry
	case "ESTABLISHEDAT":
		*f = *CompanyOrderFieldEstablishedAt
	case "NAME":
		*f = *CompanyOrderFieldName
	default:
		return fmt.Errorf("%s is not a valid CompanyOrderField", str)
	}
	return nil
}

// CompanyOrderField defines the ordering field of Company.
type CompanyOrderField struct {
	// Value extracts the ordering value from the given Company.
	Value    func(*Company) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) company.OrderOption
	toCursor func(*Company) Cursor
}

// CompanyOrder defines the ordering of Company.
type CompanyOrder struct {
	Direction OrderDirection     `json:"direction"`
	Field     *CompanyOrderField `json:"field"`
}

// DefaultCompanyOrder is the default ordering of Company.
var DefaultCompanyOrder = &CompanyOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &CompanyOrderField{
		Value: func(c *Company) (ent.Value, error) {
			return c.ID, nil
		},
		column: company.FieldID,
		toTerm: company.ByID,
		toCursor: func(c *Company) Cursor {
			return Cursor{ID: c.ID}
		},
	},
}

// ToEdge converts Company into CompanyEdge.
func (c *Company) ToEdge(order *CompanyOrder) *CompanyEdge {
	if order == nil {
		order = DefaultCompanyOrder
	}
	return &CompanyEdge{
		Node:   c,
		Cursor: order.Field.toCursor(c),
	}
}

// CustomerEdge is the edge representation of Customer.
type CustomerEdge struct {
	Node   *Customer `json:"node"`
	Cursor Cursor    `json:"cursor"`
}

// CustomerConnection is the connection containing edges to Customer.
type CustomerConnection struct {
	Edges      []*CustomerEdge `json:"edges"`
	PageInfo   PageInfo        `json:"pageInfo"`
	TotalCount int             `json:"totalCount"`
}

func (c *CustomerConnection) build(nodes []*Customer, pager *customerPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *Customer
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Customer {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Customer {
			return nodes[i]
		}
	}
	c.Edges = make([]*CustomerEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &CustomerEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// CustomerPaginateOption enables pagination customization.
type CustomerPaginateOption func(*customerPager) error

// WithCustomerOrder configures pagination ordering.
func WithCustomerOrder(order []*CustomerOrder) CustomerPaginateOption {
	return func(pager *customerPager) error {
		for _, o := range order {
			if err := o.Direction.Validate(); err != nil {
				return err
			}
		}
		pager.order = append(pager.order, order...)
		return nil
	}
}

// WithCustomerFilter configures pagination filter.
func WithCustomerFilter(filter func(*CustomerQuery) (*CustomerQuery, error)) CustomerPaginateOption {
	return func(pager *customerPager) error {
		if filter == nil {
			return errors.New("CustomerQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type customerPager struct {
	reverse bool
	order   []*CustomerOrder
	filter  func(*CustomerQuery) (*CustomerQuery, error)
}

func newCustomerPager(opts []CustomerPaginateOption, reverse bool) (*customerPager, error) {
	pager := &customerPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	for i, o := range pager.order {
		if i > 0 && o.Field == pager.order[i-1].Field {
			return nil, fmt.Errorf("duplicate order direction %q", o.Direction)
		}
	}
	return pager, nil
}

func (p *customerPager) applyFilter(query *CustomerQuery) (*CustomerQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *customerPager) toCursor(c *Customer) Cursor {
	cs := make([]any, 0, len(p.order))
	for _, o := range p.order {
		cs = append(cs, o.Field.toCursor(c).Value)
	}
	return Cursor{ID: c.ID, Value: cs}
}

func (p *customerPager) applyCursors(query *CustomerQuery, after, before *Cursor) (*CustomerQuery, error) {
	idDirection := entgql.OrderDirectionAsc
	if p.reverse {
		idDirection = entgql.OrderDirectionDesc
	}
	fields, directions := make([]string, 0, len(p.order)), make([]OrderDirection, 0, len(p.order))
	for _, o := range p.order {
		fields = append(fields, o.Field.column)
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		directions = append(directions, direction)
	}
	predicates, err := entgql.MultiCursorsPredicate(after, before, &entgql.MultiCursorsOptions{
		FieldID:     DefaultCustomerOrder.Field.column,
		DirectionID: idDirection,
		Fields:      fields,
		Directions:  directions,
	})
	if err != nil {
		return nil, err
	}
	for _, predicate := range predicates {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *customerPager) applyOrder(query *CustomerQuery) *CustomerQuery {
	var defaultOrdered bool
	for _, o := range p.order {
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(o.Field.toTerm(direction.OrderTermOption()))
		if o.Field.column == DefaultCustomerOrder.Field.column {
			defaultOrdered = true
		}
		if len(query.ctx.Fields) > 0 {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	if !defaultOrdered {
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(DefaultCustomerOrder.Field.toTerm(direction.OrderTermOption()))
	}
	return query
}

func (p *customerPager) orderExpr(query *CustomerQuery) sql.Querier {
	if len(query.ctx.Fields) > 0 {
		for _, o := range p.order {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		for _, o := range p.order {
			direction := o.Direction
			if p.reverse {
				direction = direction.Reverse()
			}
			b.Ident(o.Field.column).Pad().WriteString(string(direction))
			b.Comma()
		}
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		b.Ident(DefaultCustomerOrder.Field.column).Pad().WriteString(string(direction))
	})
}

// Paginate executes the query and returns a relay based cursor connection to Customer.
func (c *CustomerQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...CustomerPaginateOption,
) (*CustomerConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newCustomerPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if c, err = pager.applyFilter(c); err != nil {
		return nil, err
	}
	conn := &CustomerConnection{Edges: []*CustomerEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = c.Clone().Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if c, err = pager.applyCursors(c, after, before); err != nil {
		return nil, err
	}
	if limit := paginateLimit(first, last); limit != 0 {
		c.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := c.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	c = pager.applyOrder(c)
	nodes, err := c.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// CustomerOrderFieldCity orders Customer by city.
	CustomerOrderFieldCity = &CustomerOrderField{
		Value: func(c *Customer) (ent.Value, error) {
			return c.City, nil
		},
		column: customer.FieldCity,
		toTerm: customer.ByCity,
		toCursor: func(c *Customer) Cursor {
			return Cursor{
				ID:    c.ID,
				Value: c.City,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f CustomerOrderField) String() string {
	var str string
	switch f.column {
	case CustomerOrderFieldCity.column:
		str = "CITY"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f CustomerOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *CustomerOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("CustomerOrderField %T must be a string", v)
	}
	switch str {
	case "CITY":
		*f = *CustomerOrderFieldCity
	default:
		return fmt.Errorf("%s is not a valid CustomerOrderField", str)
	}
	return nil
}

// CustomerOrderField defines the ordering field of Customer.
type CustomerOrderField struct {
	// Value extracts the ordering value from the given Customer.
	Value    func(*Customer) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) customer.OrderOption
	toCursor func(*Customer) Cursor
}

// CustomerOrder defines the ordering of Customer.
type CustomerOrder struct {
	Direction OrderDirection      `json:"direction"`
	Field     *CustomerOrderField `json:"field"`
}

// DefaultCustomerOrder is the default ordering of Customer.
var DefaultCustomerOrder = &CustomerOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &CustomerOrderField{
		Value: func(c *Customer) (ent.Value, error) {
			return c.ID, nil
		},
		column: customer.FieldID,
		toTerm: customer.ByID,
		toCursor: func(c *Customer) Cursor {
			return Cursor{ID: c.ID}
		},
	},
}

// ToEdge converts Customer into CustomerEdge.
func (c *Customer) ToEdge(order *CustomerOrder) *CustomerEdge {
	if order == nil {
		order = DefaultCustomerOrder
	}
	return &CustomerEdge{
		Node:   c,
		Cursor: order.Field.toCursor(c),
	}
}

// EmployeeEdge is the edge representation of Employee.
type EmployeeEdge struct {
	Node   *Employee `json:"node"`
	Cursor Cursor    `json:"cursor"`
}

// EmployeeConnection is the connection containing edges to Employee.
type EmployeeConnection struct {
	Edges      []*EmployeeEdge `json:"edges"`
	PageInfo   PageInfo        `json:"pageInfo"`
	TotalCount int             `json:"totalCount"`
}

func (c *EmployeeConnection) build(nodes []*Employee, pager *employeePager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *Employee
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Employee {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Employee {
			return nodes[i]
		}
	}
	c.Edges = make([]*EmployeeEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &EmployeeEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// EmployeePaginateOption enables pagination customization.
type EmployeePaginateOption func(*employeePager) error

// WithEmployeeOrder configures pagination ordering.
func WithEmployeeOrder(order *EmployeeOrder) EmployeePaginateOption {
	if order == nil {
		order = DefaultEmployeeOrder
	}
	o := *order
	return func(pager *employeePager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultEmployeeOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithEmployeeFilter configures pagination filter.
func WithEmployeeFilter(filter func(*EmployeeQuery) (*EmployeeQuery, error)) EmployeePaginateOption {
	return func(pager *employeePager) error {
		if filter == nil {
			return errors.New("EmployeeQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type employeePager struct {
	reverse bool
	order   *EmployeeOrder
	filter  func(*EmployeeQuery) (*EmployeeQuery, error)
}

func newEmployeePager(opts []EmployeePaginateOption, reverse bool) (*employeePager, error) {
	pager := &employeePager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultEmployeeOrder
	}
	return pager, nil
}

func (p *employeePager) applyFilter(query *EmployeeQuery) (*EmployeeQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *employeePager) toCursor(e *Employee) Cursor {
	return p.order.Field.toCursor(e)
}

func (p *employeePager) applyCursors(query *EmployeeQuery, after, before *Cursor) (*EmployeeQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultEmployeeOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *employeePager) applyOrder(query *EmployeeQuery) *EmployeeQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultEmployeeOrder.Field {
		query = query.Order(DefaultEmployeeOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *employeePager) orderExpr(query *EmployeeQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultEmployeeOrder.Field {
			b.Comma().Ident(DefaultEmployeeOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to Employee.
func (e *EmployeeQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...EmployeePaginateOption,
) (*EmployeeConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newEmployeePager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if e, err = pager.applyFilter(e); err != nil {
		return nil, err
	}
	conn := &EmployeeConnection{Edges: []*EmployeeEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = e.Clone().Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if e, err = pager.applyCursors(e, after, before); err != nil {
		return nil, err
	}
	if limit := paginateLimit(first, last); limit != 0 {
		e.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := e.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	e = pager.applyOrder(e)
	nodes, err := e.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// EmployeeOrderField defines the ordering field of Employee.
type EmployeeOrderField struct {
	// Value extracts the ordering value from the given Employee.
	Value    func(*Employee) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) employee.OrderOption
	toCursor func(*Employee) Cursor
}

// EmployeeOrder defines the ordering of Employee.
type EmployeeOrder struct {
	Direction OrderDirection      `json:"direction"`
	Field     *EmployeeOrderField `json:"field"`
}

// DefaultEmployeeOrder is the default ordering of Employee.
var DefaultEmployeeOrder = &EmployeeOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &EmployeeOrderField{
		Value: func(e *Employee) (ent.Value, error) {
			return e.ID, nil
		},
		column: employee.FieldID,
		toTerm: employee.ByID,
		toCursor: func(e *Employee) Cursor {
			return Cursor{ID: e.ID}
		},
	},
}

// ToEdge converts Employee into EmployeeEdge.
func (e *Employee) ToEdge(order *EmployeeOrder) *EmployeeEdge {
	if order == nil {
		order = DefaultEmployeeOrder
	}
	return &EmployeeEdge{
		Node:   e,
		Cursor: order.Field.toCursor(e),
	}
}

// FileEdge is the edge representation of File.
type FileEdge struct {
	Node   *File  `json:"node"`
	Cursor Cursor `json:"cursor"`
}

// FileConnection is the connection containing edges to File.
type FileConnection struct {
	Edges      []*FileEdge `json:"edges"`
	PageInfo   PageInfo    `json:"pageInfo"`
	TotalCount int         `json:"totalCount"`
}

func (c *FileConnection) build(nodes []*File, pager *filePager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *File
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *File {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *File {
			return nodes[i]
		}
	}
	c.Edges = make([]*FileEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &FileEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// FilePaginateOption enables pagination customization.
type FilePaginateOption func(*filePager) error

// WithFileOrder configures pagination ordering.
func WithFileOrder(order *FileOrder) FilePaginateOption {
	if order == nil {
		order = DefaultFileOrder
	}
	o := *order
	return func(pager *filePager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultFileOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithFileFilter configures pagination filter.
func WithFileFilter(filter func(*FileQuery) (*FileQuery, error)) FilePaginateOption {
	return func(pager *filePager) error {
		if filter == nil {
			return errors.New("FileQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type filePager struct {
	reverse bool
	order   *FileOrder
	filter  func(*FileQuery) (*FileQuery, error)
}

func newFilePager(opts []FilePaginateOption, reverse bool) (*filePager, error) {
	pager := &filePager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultFileOrder
	}
	return pager, nil
}

func (p *filePager) applyFilter(query *FileQuery) (*FileQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *filePager) toCursor(f *File) Cursor {
	return p.order.Field.toCursor(f)
}

func (p *filePager) applyCursors(query *FileQuery, after, before *Cursor) (*FileQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultFileOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *filePager) applyOrder(query *FileQuery) *FileQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultFileOrder.Field {
		query = query.Order(DefaultFileOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *filePager) orderExpr(query *FileQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultFileOrder.Field {
			b.Comma().Ident(DefaultFileOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to File.
func (f *FileQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...FilePaginateOption,
) (*FileConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newFilePager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if f, err = pager.applyFilter(f); err != nil {
		return nil, err
	}
	conn := &FileConnection{Edges: []*FileEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = f.Clone().Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if f, err = pager.applyCursors(f, after, before); err != nil {
		return nil, err
	}
	if limit := paginateLimit(first, last); limit != 0 {
		f.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := f.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	f = pager.applyOrder(f)
	nodes, err := f.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// FileOrderFieldCategory orders File by category.
	FileOrderFieldCategory = &FileOrderField{
		Value: func(f *File) (ent.Value, error) {
			return f.Category, nil
		},
		column: file.FieldCategory,
		toTerm: file.ByCategory,
		toCursor: func(f *File) Cursor {
			return Cursor{
				ID:    f.ID,
				Value: f.Category,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f FileOrderField) String() string {
	var str string
	switch f.column {
	case FileOrderFieldCategory.column:
		str = "CATEGORY"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f FileOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *FileOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("FileOrderField %T must be a string", v)
	}
	switch str {
	case "CATEGORY":
		*f = *FileOrderFieldCategory
	default:
		return fmt.Errorf("%s is not a valid FileOrderField", str)
	}
	return nil
}

// FileOrderField defines the ordering field of File.
type FileOrderField struct {
	// Value extracts the ordering value from the given File.
	Value    func(*File) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) file.OrderOption
	toCursor func(*File) Cursor
}

// FileOrder defines the ordering of File.
type FileOrder struct {
	Direction OrderDirection  `json:"direction"`
	Field     *FileOrderField `json:"field"`
}

// DefaultFileOrder is the default ordering of File.
var DefaultFileOrder = &FileOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &FileOrderField{
		Value: func(f *File) (ent.Value, error) {
			return f.ID, nil
		},
		column: file.FieldID,
		toTerm: file.ByID,
		toCursor: func(f *File) Cursor {
			return Cursor{ID: f.ID}
		},
	},
}

// ToEdge converts File into FileEdge.
func (f *File) ToEdge(order *FileOrder) *FileEdge {
	if order == nil {
		order = DefaultFileOrder
	}
	return &FileEdge{
		Node:   f,
		Cursor: order.Field.toCursor(f),
	}
}

// PayableEdge is the edge representation of Payable.
type PayableEdge struct {
	Node   *Payable `json:"node"`
	Cursor Cursor   `json:"cursor"`
}

// PayableConnection is the connection containing edges to Payable.
type PayableConnection struct {
	Edges      []*PayableEdge `json:"edges"`
	PageInfo   PageInfo       `json:"pageInfo"`
	TotalCount int            `json:"totalCount"`
}

func (c *PayableConnection) build(nodes []*Payable, pager *payablePager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *Payable
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Payable {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Payable {
			return nodes[i]
		}
	}
	c.Edges = make([]*PayableEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &PayableEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// PayablePaginateOption enables pagination customization.
type PayablePaginateOption func(*payablePager) error

// WithPayableOrder configures pagination ordering.
func WithPayableOrder(order *PayableOrder) PayablePaginateOption {
	if order == nil {
		order = DefaultPayableOrder
	}
	o := *order
	return func(pager *payablePager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultPayableOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithPayableFilter configures pagination filter.
func WithPayableFilter(filter func(*PayableQuery) (*PayableQuery, error)) PayablePaginateOption {
	return func(pager *payablePager) error {
		if filter == nil {
			return errors.New("PayableQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type payablePager struct {
	reverse bool
	order   *PayableOrder
	filter  func(*PayableQuery) (*PayableQuery, error)
}

func newPayablePager(opts []PayablePaginateOption, reverse bool) (*payablePager, error) {
	pager := &payablePager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultPayableOrder
	}
	return pager, nil
}

func (p *payablePager) applyFilter(query *PayableQuery) (*PayableQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *payablePager) toCursor(pa *Payable) Cursor {
	return p.order.Field.toCursor(pa)
}

func (p *payablePager) applyCursors(query *PayableQuery, after, before *Cursor) (*PayableQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultPayableOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *payablePager) applyOrder(query *PayableQuery) *PayableQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultPayableOrder.Field {
		query = query.Order(DefaultPayableOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *payablePager) orderExpr(query *PayableQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultPayableOrder.Field {
			b.Comma().Ident(DefaultPayableOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to Payable.
func (pa *PayableQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...PayablePaginateOption,
) (*PayableConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newPayablePager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if pa, err = pager.applyFilter(pa); err != nil {
		return nil, err
	}
	conn := &PayableConnection{Edges: []*PayableEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = pa.Clone().Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if pa, err = pager.applyCursors(pa, after, before); err != nil {
		return nil, err
	}
	if limit := paginateLimit(first, last); limit != 0 {
		pa.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := pa.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	pa = pager.applyOrder(pa)
	nodes, err := pa.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// PayableOrderField defines the ordering field of Payable.
type PayableOrderField struct {
	// Value extracts the ordering value from the given Payable.
	Value    func(*Payable) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) payable.OrderOption
	toCursor func(*Payable) Cursor
}

// PayableOrder defines the ordering of Payable.
type PayableOrder struct {
	Direction OrderDirection     `json:"direction"`
	Field     *PayableOrderField `json:"field"`
}

// DefaultPayableOrder is the default ordering of Payable.
var DefaultPayableOrder = &PayableOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &PayableOrderField{
		Value: func(pa *Payable) (ent.Value, error) {
			return pa.ID, nil
		},
		column: payable.FieldID,
		toTerm: payable.ByID,
		toCursor: func(pa *Payable) Cursor {
			return Cursor{ID: pa.ID}
		},
	},
}

// ToEdge converts Payable into PayableEdge.
func (pa *Payable) ToEdge(order *PayableOrder) *PayableEdge {
	if order == nil {
		order = DefaultPayableOrder
	}
	return &PayableEdge{
		Node:   pa,
		Cursor: order.Field.toCursor(pa),
	}
}

// ProductEdge is the edge representation of Product.
type ProductEdge struct {
	Node   *Product `json:"node"`
	Cursor Cursor   `json:"cursor"`
}

// ProductConnection is the connection containing edges to Product.
type ProductConnection struct {
	Edges      []*ProductEdge `json:"edges"`
	PageInfo   PageInfo       `json:"pageInfo"`
	TotalCount int            `json:"totalCount"`
}

func (c *ProductConnection) build(nodes []*Product, pager *productPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *Product
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Product {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Product {
			return nodes[i]
		}
	}
	c.Edges = make([]*ProductEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &ProductEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// ProductPaginateOption enables pagination customization.
type ProductPaginateOption func(*productPager) error

// WithProductOrder configures pagination ordering.
func WithProductOrder(order *ProductOrder) ProductPaginateOption {
	if order == nil {
		order = DefaultProductOrder
	}
	o := *order
	return func(pager *productPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultProductOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithProductFilter configures pagination filter.
func WithProductFilter(filter func(*ProductQuery) (*ProductQuery, error)) ProductPaginateOption {
	return func(pager *productPager) error {
		if filter == nil {
			return errors.New("ProductQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type productPager struct {
	reverse bool
	order   *ProductOrder
	filter  func(*ProductQuery) (*ProductQuery, error)
}

func newProductPager(opts []ProductPaginateOption, reverse bool) (*productPager, error) {
	pager := &productPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultProductOrder
	}
	return pager, nil
}

func (p *productPager) applyFilter(query *ProductQuery) (*ProductQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *productPager) toCursor(pr *Product) Cursor {
	return p.order.Field.toCursor(pr)
}

func (p *productPager) applyCursors(query *ProductQuery, after, before *Cursor) (*ProductQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultProductOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *productPager) applyOrder(query *ProductQuery) *ProductQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultProductOrder.Field {
		query = query.Order(DefaultProductOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *productPager) orderExpr(query *ProductQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultProductOrder.Field {
			b.Comma().Ident(DefaultProductOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to Product.
func (pr *ProductQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...ProductPaginateOption,
) (*ProductConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newProductPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if pr, err = pager.applyFilter(pr); err != nil {
		return nil, err
	}
	conn := &ProductConnection{Edges: []*ProductEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = pr.Clone().Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if pr, err = pager.applyCursors(pr, after, before); err != nil {
		return nil, err
	}
	if limit := paginateLimit(first, last); limit != 0 {
		pr.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := pr.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	pr = pager.applyOrder(pr)
	nodes, err := pr.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// ProductOrderFieldName orders Product by name.
	ProductOrderFieldName = &ProductOrderField{
		Value: func(pr *Product) (ent.Value, error) {
			return pr.Name, nil
		},
		column: product.FieldName,
		toTerm: product.ByName,
		toCursor: func(pr *Product) Cursor {
			return Cursor{
				ID:    pr.ID,
				Value: pr.Name,
			}
		},
	}
	// ProductOrderFieldCategory orders Product by category.
	ProductOrderFieldCategory = &ProductOrderField{
		Value: func(pr *Product) (ent.Value, error) {
			return pr.Category, nil
		},
		column: product.FieldCategory,
		toTerm: product.ByCategory,
		toCursor: func(pr *Product) Cursor {
			return Cursor{
				ID:    pr.ID,
				Value: pr.Category,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f ProductOrderField) String() string {
	var str string
	switch f.column {
	case ProductOrderFieldName.column:
		str = "NAME"
	case ProductOrderFieldCategory.column:
		str = "CATEGORY"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f ProductOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *ProductOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("ProductOrderField %T must be a string", v)
	}
	switch str {
	case "NAME":
		*f = *ProductOrderFieldName
	case "CATEGORY":
		*f = *ProductOrderFieldCategory
	default:
		return fmt.Errorf("%s is not a valid ProductOrderField", str)
	}
	return nil
}

// ProductOrderField defines the ordering field of Product.
type ProductOrderField struct {
	// Value extracts the ordering value from the given Product.
	Value    func(*Product) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) product.OrderOption
	toCursor func(*Product) Cursor
}

// ProductOrder defines the ordering of Product.
type ProductOrder struct {
	Direction OrderDirection     `json:"direction"`
	Field     *ProductOrderField `json:"field"`
}

// DefaultProductOrder is the default ordering of Product.
var DefaultProductOrder = &ProductOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &ProductOrderField{
		Value: func(pr *Product) (ent.Value, error) {
			return pr.ID, nil
		},
		column: product.FieldID,
		toTerm: product.ByID,
		toCursor: func(pr *Product) Cursor {
			return Cursor{ID: pr.ID}
		},
	},
}

// ToEdge converts Product into ProductEdge.
func (pr *Product) ToEdge(order *ProductOrder) *ProductEdge {
	if order == nil {
		order = DefaultProductOrder
	}
	return &ProductEdge{
		Node:   pr,
		Cursor: order.Field.toCursor(pr),
	}
}

// ProjectEdge is the edge representation of Project.
type ProjectEdge struct {
	Node   *Project `json:"node"`
	Cursor Cursor   `json:"cursor"`
}

// ProjectConnection is the connection containing edges to Project.
type ProjectConnection struct {
	Edges      []*ProjectEdge `json:"edges"`
	PageInfo   PageInfo       `json:"pageInfo"`
	TotalCount int            `json:"totalCount"`
}

func (c *ProjectConnection) build(nodes []*Project, pager *projectPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *Project
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Project {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Project {
			return nodes[i]
		}
	}
	c.Edges = make([]*ProjectEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &ProjectEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// ProjectPaginateOption enables pagination customization.
type ProjectPaginateOption func(*projectPager) error

// WithProjectOrder configures pagination ordering.
func WithProjectOrder(order []*ProjectOrder) ProjectPaginateOption {
	return func(pager *projectPager) error {
		for _, o := range order {
			if err := o.Direction.Validate(); err != nil {
				return err
			}
		}
		pager.order = append(pager.order, order...)
		return nil
	}
}

// WithProjectFilter configures pagination filter.
func WithProjectFilter(filter func(*ProjectQuery) (*ProjectQuery, error)) ProjectPaginateOption {
	return func(pager *projectPager) error {
		if filter == nil {
			return errors.New("ProjectQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type projectPager struct {
	reverse bool
	order   []*ProjectOrder
	filter  func(*ProjectQuery) (*ProjectQuery, error)
}

func newProjectPager(opts []ProjectPaginateOption, reverse bool) (*projectPager, error) {
	pager := &projectPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	for i, o := range pager.order {
		if i > 0 && o.Field == pager.order[i-1].Field {
			return nil, fmt.Errorf("duplicate order direction %q", o.Direction)
		}
	}
	return pager, nil
}

func (p *projectPager) applyFilter(query *ProjectQuery) (*ProjectQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *projectPager) toCursor(pr *Project) Cursor {
	cs := make([]any, 0, len(p.order))
	for _, o := range p.order {
		cs = append(cs, o.Field.toCursor(pr).Value)
	}
	return Cursor{ID: pr.ID, Value: cs}
}

func (p *projectPager) applyCursors(query *ProjectQuery, after, before *Cursor) (*ProjectQuery, error) {
	idDirection := entgql.OrderDirectionAsc
	if p.reverse {
		idDirection = entgql.OrderDirectionDesc
	}
	fields, directions := make([]string, 0, len(p.order)), make([]OrderDirection, 0, len(p.order))
	for _, o := range p.order {
		fields = append(fields, o.Field.column)
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		directions = append(directions, direction)
	}
	predicates, err := entgql.MultiCursorsPredicate(after, before, &entgql.MultiCursorsOptions{
		FieldID:     DefaultProjectOrder.Field.column,
		DirectionID: idDirection,
		Fields:      fields,
		Directions:  directions,
	})
	if err != nil {
		return nil, err
	}
	for _, predicate := range predicates {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *projectPager) applyOrder(query *ProjectQuery) *ProjectQuery {
	var defaultOrdered bool
	for _, o := range p.order {
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(o.Field.toTerm(direction.OrderTermOption()))
		if o.Field.column == DefaultProjectOrder.Field.column {
			defaultOrdered = true
		}
		if len(query.ctx.Fields) > 0 {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	if !defaultOrdered {
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(DefaultProjectOrder.Field.toTerm(direction.OrderTermOption()))
	}
	return query
}

func (p *projectPager) orderExpr(query *ProjectQuery) sql.Querier {
	if len(query.ctx.Fields) > 0 {
		for _, o := range p.order {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		for _, o := range p.order {
			direction := o.Direction
			if p.reverse {
				direction = direction.Reverse()
			}
			b.Ident(o.Field.column).Pad().WriteString(string(direction))
			b.Comma()
		}
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		b.Ident(DefaultProjectOrder.Field.column).Pad().WriteString(string(direction))
	})
}

// Paginate executes the query and returns a relay based cursor connection to Project.
func (pr *ProjectQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...ProjectPaginateOption,
) (*ProjectConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newProjectPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if pr, err = pager.applyFilter(pr); err != nil {
		return nil, err
	}
	conn := &ProjectConnection{Edges: []*ProjectEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = pr.Clone().Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if pr, err = pager.applyCursors(pr, after, before); err != nil {
		return nil, err
	}
	if limit := paginateLimit(first, last); limit != 0 {
		pr.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := pr.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	pr = pager.applyOrder(pr)
	nodes, err := pr.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// ProjectOrderField defines the ordering field of Project.
type ProjectOrderField struct {
	// Value extracts the ordering value from the given Project.
	Value    func(*Project) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) project.OrderOption
	toCursor func(*Project) Cursor
}

// ProjectOrder defines the ordering of Project.
type ProjectOrder struct {
	Direction OrderDirection     `json:"direction"`
	Field     *ProjectOrderField `json:"field"`
}

// DefaultProjectOrder is the default ordering of Project.
var DefaultProjectOrder = &ProjectOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &ProjectOrderField{
		Value: func(pr *Project) (ent.Value, error) {
			return pr.ID, nil
		},
		column: project.FieldID,
		toTerm: project.ByID,
		toCursor: func(pr *Project) Cursor {
			return Cursor{ID: pr.ID}
		},
	},
}

// ToEdge converts Project into ProjectEdge.
func (pr *Project) ToEdge(order *ProjectOrder) *ProjectEdge {
	if order == nil {
		order = DefaultProjectOrder
	}
	return &ProjectEdge{
		Node:   pr,
		Cursor: order.Field.toCursor(pr),
	}
}

// ProjectMilestoneEdge is the edge representation of ProjectMilestone.
type ProjectMilestoneEdge struct {
	Node   *ProjectMilestone `json:"node"`
	Cursor Cursor            `json:"cursor"`
}

// ProjectMilestoneConnection is the connection containing edges to ProjectMilestone.
type ProjectMilestoneConnection struct {
	Edges      []*ProjectMilestoneEdge `json:"edges"`
	PageInfo   PageInfo                `json:"pageInfo"`
	TotalCount int                     `json:"totalCount"`
}

func (c *ProjectMilestoneConnection) build(nodes []*ProjectMilestone, pager *projectmilestonePager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *ProjectMilestone
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *ProjectMilestone {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *ProjectMilestone {
			return nodes[i]
		}
	}
	c.Edges = make([]*ProjectMilestoneEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &ProjectMilestoneEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// ProjectMilestonePaginateOption enables pagination customization.
type ProjectMilestonePaginateOption func(*projectmilestonePager) error

// WithProjectMilestoneOrder configures pagination ordering.
func WithProjectMilestoneOrder(order *ProjectMilestoneOrder) ProjectMilestonePaginateOption {
	if order == nil {
		order = DefaultProjectMilestoneOrder
	}
	o := *order
	return func(pager *projectmilestonePager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultProjectMilestoneOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithProjectMilestoneFilter configures pagination filter.
func WithProjectMilestoneFilter(filter func(*ProjectMilestoneQuery) (*ProjectMilestoneQuery, error)) ProjectMilestonePaginateOption {
	return func(pager *projectmilestonePager) error {
		if filter == nil {
			return errors.New("ProjectMilestoneQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type projectmilestonePager struct {
	reverse bool
	order   *ProjectMilestoneOrder
	filter  func(*ProjectMilestoneQuery) (*ProjectMilestoneQuery, error)
}

func newProjectMilestonePager(opts []ProjectMilestonePaginateOption, reverse bool) (*projectmilestonePager, error) {
	pager := &projectmilestonePager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultProjectMilestoneOrder
	}
	return pager, nil
}

func (p *projectmilestonePager) applyFilter(query *ProjectMilestoneQuery) (*ProjectMilestoneQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *projectmilestonePager) toCursor(pm *ProjectMilestone) Cursor {
	return p.order.Field.toCursor(pm)
}

func (p *projectmilestonePager) applyCursors(query *ProjectMilestoneQuery, after, before *Cursor) (*ProjectMilestoneQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultProjectMilestoneOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *projectmilestonePager) applyOrder(query *ProjectMilestoneQuery) *ProjectMilestoneQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultProjectMilestoneOrder.Field {
		query = query.Order(DefaultProjectMilestoneOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *projectmilestonePager) orderExpr(query *ProjectMilestoneQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultProjectMilestoneOrder.Field {
			b.Comma().Ident(DefaultProjectMilestoneOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to ProjectMilestone.
func (pm *ProjectMilestoneQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...ProjectMilestonePaginateOption,
) (*ProjectMilestoneConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newProjectMilestonePager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if pm, err = pager.applyFilter(pm); err != nil {
		return nil, err
	}
	conn := &ProjectMilestoneConnection{Edges: []*ProjectMilestoneEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = pm.Clone().Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if pm, err = pager.applyCursors(pm, after, before); err != nil {
		return nil, err
	}
	if limit := paginateLimit(first, last); limit != 0 {
		pm.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := pm.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	pm = pager.applyOrder(pm)
	nodes, err := pm.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// ProjectMilestoneOrderField defines the ordering field of ProjectMilestone.
type ProjectMilestoneOrderField struct {
	// Value extracts the ordering value from the given ProjectMilestone.
	Value    func(*ProjectMilestone) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) projectmilestone.OrderOption
	toCursor func(*ProjectMilestone) Cursor
}

// ProjectMilestoneOrder defines the ordering of ProjectMilestone.
type ProjectMilestoneOrder struct {
	Direction OrderDirection              `json:"direction"`
	Field     *ProjectMilestoneOrderField `json:"field"`
}

// DefaultProjectMilestoneOrder is the default ordering of ProjectMilestone.
var DefaultProjectMilestoneOrder = &ProjectMilestoneOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &ProjectMilestoneOrderField{
		Value: func(pm *ProjectMilestone) (ent.Value, error) {
			return pm.ID, nil
		},
		column: projectmilestone.FieldID,
		toTerm: projectmilestone.ByID,
		toCursor: func(pm *ProjectMilestone) Cursor {
			return Cursor{ID: pm.ID}
		},
	},
}

// ToEdge converts ProjectMilestone into ProjectMilestoneEdge.
func (pm *ProjectMilestone) ToEdge(order *ProjectMilestoneOrder) *ProjectMilestoneEdge {
	if order == nil {
		order = DefaultProjectMilestoneOrder
	}
	return &ProjectMilestoneEdge{
		Node:   pm,
		Cursor: order.Field.toCursor(pm),
	}
}

// ProjectTaskEdge is the edge representation of ProjectTask.
type ProjectTaskEdge struct {
	Node   *ProjectTask `json:"node"`
	Cursor Cursor       `json:"cursor"`
}

// ProjectTaskConnection is the connection containing edges to ProjectTask.
type ProjectTaskConnection struct {
	Edges      []*ProjectTaskEdge `json:"edges"`
	PageInfo   PageInfo           `json:"pageInfo"`
	TotalCount int                `json:"totalCount"`
}

func (c *ProjectTaskConnection) build(nodes []*ProjectTask, pager *projecttaskPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *ProjectTask
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *ProjectTask {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *ProjectTask {
			return nodes[i]
		}
	}
	c.Edges = make([]*ProjectTaskEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &ProjectTaskEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// ProjectTaskPaginateOption enables pagination customization.
type ProjectTaskPaginateOption func(*projecttaskPager) error

// WithProjectTaskOrder configures pagination ordering.
func WithProjectTaskOrder(order *ProjectTaskOrder) ProjectTaskPaginateOption {
	if order == nil {
		order = DefaultProjectTaskOrder
	}
	o := *order
	return func(pager *projecttaskPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultProjectTaskOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithProjectTaskFilter configures pagination filter.
func WithProjectTaskFilter(filter func(*ProjectTaskQuery) (*ProjectTaskQuery, error)) ProjectTaskPaginateOption {
	return func(pager *projecttaskPager) error {
		if filter == nil {
			return errors.New("ProjectTaskQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type projecttaskPager struct {
	reverse bool
	order   *ProjectTaskOrder
	filter  func(*ProjectTaskQuery) (*ProjectTaskQuery, error)
}

func newProjectTaskPager(opts []ProjectTaskPaginateOption, reverse bool) (*projecttaskPager, error) {
	pager := &projecttaskPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultProjectTaskOrder
	}
	return pager, nil
}

func (p *projecttaskPager) applyFilter(query *ProjectTaskQuery) (*ProjectTaskQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *projecttaskPager) toCursor(pt *ProjectTask) Cursor {
	return p.order.Field.toCursor(pt)
}

func (p *projecttaskPager) applyCursors(query *ProjectTaskQuery, after, before *Cursor) (*ProjectTaskQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultProjectTaskOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *projecttaskPager) applyOrder(query *ProjectTaskQuery) *ProjectTaskQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultProjectTaskOrder.Field {
		query = query.Order(DefaultProjectTaskOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *projecttaskPager) orderExpr(query *ProjectTaskQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultProjectTaskOrder.Field {
			b.Comma().Ident(DefaultProjectTaskOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to ProjectTask.
func (pt *ProjectTaskQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...ProjectTaskPaginateOption,
) (*ProjectTaskConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newProjectTaskPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if pt, err = pager.applyFilter(pt); err != nil {
		return nil, err
	}
	conn := &ProjectTaskConnection{Edges: []*ProjectTaskEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = pt.Clone().Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if pt, err = pager.applyCursors(pt, after, before); err != nil {
		return nil, err
	}
	if limit := paginateLimit(first, last); limit != 0 {
		pt.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := pt.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	pt = pager.applyOrder(pt)
	nodes, err := pt.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// ProjectTaskOrderFieldDueDate orders ProjectTask by dueDate.
	ProjectTaskOrderFieldDueDate = &ProjectTaskOrderField{
		Value: func(pt *ProjectTask) (ent.Value, error) {
			return pt.DueDate, nil
		},
		column: projecttask.FieldDueDate,
		toTerm: projecttask.ByDueDate,
		toCursor: func(pt *ProjectTask) Cursor {
			return Cursor{
				ID:    pt.ID,
				Value: pt.DueDate,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f ProjectTaskOrderField) String() string {
	var str string
	switch f.column {
	case ProjectTaskOrderFieldDueDate.column:
		str = "DUE_DATE"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f ProjectTaskOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *ProjectTaskOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("ProjectTaskOrderField %T must be a string", v)
	}
	switch str {
	case "DUE_DATE":
		*f = *ProjectTaskOrderFieldDueDate
	default:
		return fmt.Errorf("%s is not a valid ProjectTaskOrderField", str)
	}
	return nil
}

// ProjectTaskOrderField defines the ordering field of ProjectTask.
type ProjectTaskOrderField struct {
	// Value extracts the ordering value from the given ProjectTask.
	Value    func(*ProjectTask) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) projecttask.OrderOption
	toCursor func(*ProjectTask) Cursor
}

// ProjectTaskOrder defines the ordering of ProjectTask.
type ProjectTaskOrder struct {
	Direction OrderDirection         `json:"direction"`
	Field     *ProjectTaskOrderField `json:"field"`
}

// DefaultProjectTaskOrder is the default ordering of ProjectTask.
var DefaultProjectTaskOrder = &ProjectTaskOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &ProjectTaskOrderField{
		Value: func(pt *ProjectTask) (ent.Value, error) {
			return pt.ID, nil
		},
		column: projecttask.FieldID,
		toTerm: projecttask.ByID,
		toCursor: func(pt *ProjectTask) Cursor {
			return Cursor{ID: pt.ID}
		},
	},
}

// ToEdge converts ProjectTask into ProjectTaskEdge.
func (pt *ProjectTask) ToEdge(order *ProjectTaskOrder) *ProjectTaskEdge {
	if order == nil {
		order = DefaultProjectTaskOrder
	}
	return &ProjectTaskEdge{
		Node:   pt,
		Cursor: order.Field.toCursor(pt),
	}
}

// ReceivableEdge is the edge representation of Receivable.
type ReceivableEdge struct {
	Node   *Receivable `json:"node"`
	Cursor Cursor      `json:"cursor"`
}

// ReceivableConnection is the connection containing edges to Receivable.
type ReceivableConnection struct {
	Edges      []*ReceivableEdge `json:"edges"`
	PageInfo   PageInfo          `json:"pageInfo"`
	TotalCount int               `json:"totalCount"`
}

func (c *ReceivableConnection) build(nodes []*Receivable, pager *receivablePager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *Receivable
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Receivable {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Receivable {
			return nodes[i]
		}
	}
	c.Edges = make([]*ReceivableEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &ReceivableEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// ReceivablePaginateOption enables pagination customization.
type ReceivablePaginateOption func(*receivablePager) error

// WithReceivableOrder configures pagination ordering.
func WithReceivableOrder(order []*ReceivableOrder) ReceivablePaginateOption {
	return func(pager *receivablePager) error {
		for _, o := range order {
			if err := o.Direction.Validate(); err != nil {
				return err
			}
		}
		pager.order = append(pager.order, order...)
		return nil
	}
}

// WithReceivableFilter configures pagination filter.
func WithReceivableFilter(filter func(*ReceivableQuery) (*ReceivableQuery, error)) ReceivablePaginateOption {
	return func(pager *receivablePager) error {
		if filter == nil {
			return errors.New("ReceivableQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type receivablePager struct {
	reverse bool
	order   []*ReceivableOrder
	filter  func(*ReceivableQuery) (*ReceivableQuery, error)
}

func newReceivablePager(opts []ReceivablePaginateOption, reverse bool) (*receivablePager, error) {
	pager := &receivablePager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	for i, o := range pager.order {
		if i > 0 && o.Field == pager.order[i-1].Field {
			return nil, fmt.Errorf("duplicate order direction %q", o.Direction)
		}
	}
	return pager, nil
}

func (p *receivablePager) applyFilter(query *ReceivableQuery) (*ReceivableQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *receivablePager) toCursor(r *Receivable) Cursor {
	cs := make([]any, 0, len(p.order))
	for _, o := range p.order {
		cs = append(cs, o.Field.toCursor(r).Value)
	}
	return Cursor{ID: r.ID, Value: cs}
}

func (p *receivablePager) applyCursors(query *ReceivableQuery, after, before *Cursor) (*ReceivableQuery, error) {
	idDirection := entgql.OrderDirectionAsc
	if p.reverse {
		idDirection = entgql.OrderDirectionDesc
	}
	fields, directions := make([]string, 0, len(p.order)), make([]OrderDirection, 0, len(p.order))
	for _, o := range p.order {
		fields = append(fields, o.Field.column)
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		directions = append(directions, direction)
	}
	predicates, err := entgql.MultiCursorsPredicate(after, before, &entgql.MultiCursorsOptions{
		FieldID:     DefaultReceivableOrder.Field.column,
		DirectionID: idDirection,
		Fields:      fields,
		Directions:  directions,
	})
	if err != nil {
		return nil, err
	}
	for _, predicate := range predicates {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *receivablePager) applyOrder(query *ReceivableQuery) *ReceivableQuery {
	var defaultOrdered bool
	for _, o := range p.order {
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(o.Field.toTerm(direction.OrderTermOption()))
		if o.Field.column == DefaultReceivableOrder.Field.column {
			defaultOrdered = true
		}
		if len(query.ctx.Fields) > 0 {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	if !defaultOrdered {
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(DefaultReceivableOrder.Field.toTerm(direction.OrderTermOption()))
	}
	return query
}

func (p *receivablePager) orderExpr(query *ReceivableQuery) sql.Querier {
	if len(query.ctx.Fields) > 0 {
		for _, o := range p.order {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		for _, o := range p.order {
			direction := o.Direction
			if p.reverse {
				direction = direction.Reverse()
			}
			b.Ident(o.Field.column).Pad().WriteString(string(direction))
			b.Comma()
		}
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		b.Ident(DefaultReceivableOrder.Field.column).Pad().WriteString(string(direction))
	})
}

// Paginate executes the query and returns a relay based cursor connection to Receivable.
func (r *ReceivableQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...ReceivablePaginateOption,
) (*ReceivableConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newReceivablePager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if r, err = pager.applyFilter(r); err != nil {
		return nil, err
	}
	conn := &ReceivableConnection{Edges: []*ReceivableEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = r.Clone().Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if r, err = pager.applyCursors(r, after, before); err != nil {
		return nil, err
	}
	if limit := paginateLimit(first, last); limit != 0 {
		r.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := r.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	r = pager.applyOrder(r)
	nodes, err := r.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// ReceivableOrderFieldDaysDue orders Receivable by daysDue.
	ReceivableOrderFieldDaysDue = &ReceivableOrderField{
		Value: func(r *Receivable) (ent.Value, error) {
			return r.DaysDue, nil
		},
		column: receivable.FieldDaysDue,
		toTerm: receivable.ByDaysDue,
		toCursor: func(r *Receivable) Cursor {
			return Cursor{
				ID:    r.ID,
				Value: r.DaysDue,
			}
		},
	}
	// ReceivableOrderFieldStatus orders Receivable by status.
	ReceivableOrderFieldStatus = &ReceivableOrderField{
		Value: func(r *Receivable) (ent.Value, error) {
			return r.Status, nil
		},
		column: receivable.FieldStatus,
		toTerm: receivable.ByStatus,
		toCursor: func(r *Receivable) Cursor {
			return Cursor{
				ID:    r.ID,
				Value: r.Status,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f ReceivableOrderField) String() string {
	var str string
	switch f.column {
	case ReceivableOrderFieldDaysDue.column:
		str = "DAYSDUE"
	case ReceivableOrderFieldStatus.column:
		str = "STATUS"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f ReceivableOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *ReceivableOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("ReceivableOrderField %T must be a string", v)
	}
	switch str {
	case "DAYSDUE":
		*f = *ReceivableOrderFieldDaysDue
	case "STATUS":
		*f = *ReceivableOrderFieldStatus
	default:
		return fmt.Errorf("%s is not a valid ReceivableOrderField", str)
	}
	return nil
}

// ReceivableOrderField defines the ordering field of Receivable.
type ReceivableOrderField struct {
	// Value extracts the ordering value from the given Receivable.
	Value    func(*Receivable) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) receivable.OrderOption
	toCursor func(*Receivable) Cursor
}

// ReceivableOrder defines the ordering of Receivable.
type ReceivableOrder struct {
	Direction OrderDirection        `json:"direction"`
	Field     *ReceivableOrderField `json:"field"`
}

// DefaultReceivableOrder is the default ordering of Receivable.
var DefaultReceivableOrder = &ReceivableOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &ReceivableOrderField{
		Value: func(r *Receivable) (ent.Value, error) {
			return r.ID, nil
		},
		column: receivable.FieldID,
		toTerm: receivable.ByID,
		toCursor: func(r *Receivable) Cursor {
			return Cursor{ID: r.ID}
		},
	},
}

// ToEdge converts Receivable into ReceivableEdge.
func (r *Receivable) ToEdge(order *ReceivableOrder) *ReceivableEdge {
	if order == nil {
		order = DefaultReceivableOrder
	}
	return &ReceivableEdge{
		Node:   r,
		Cursor: order.Field.toCursor(r),
	}
}

// SupplierEdge is the edge representation of Supplier.
type SupplierEdge struct {
	Node   *Supplier `json:"node"`
	Cursor Cursor    `json:"cursor"`
}

// SupplierConnection is the connection containing edges to Supplier.
type SupplierConnection struct {
	Edges      []*SupplierEdge `json:"edges"`
	PageInfo   PageInfo        `json:"pageInfo"`
	TotalCount int             `json:"totalCount"`
}

func (c *SupplierConnection) build(nodes []*Supplier, pager *supplierPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *Supplier
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Supplier {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Supplier {
			return nodes[i]
		}
	}
	c.Edges = make([]*SupplierEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &SupplierEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// SupplierPaginateOption enables pagination customization.
type SupplierPaginateOption func(*supplierPager) error

// WithSupplierOrder configures pagination ordering.
func WithSupplierOrder(order *SupplierOrder) SupplierPaginateOption {
	if order == nil {
		order = DefaultSupplierOrder
	}
	o := *order
	return func(pager *supplierPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultSupplierOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithSupplierFilter configures pagination filter.
func WithSupplierFilter(filter func(*SupplierQuery) (*SupplierQuery, error)) SupplierPaginateOption {
	return func(pager *supplierPager) error {
		if filter == nil {
			return errors.New("SupplierQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type supplierPager struct {
	reverse bool
	order   *SupplierOrder
	filter  func(*SupplierQuery) (*SupplierQuery, error)
}

func newSupplierPager(opts []SupplierPaginateOption, reverse bool) (*supplierPager, error) {
	pager := &supplierPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultSupplierOrder
	}
	return pager, nil
}

func (p *supplierPager) applyFilter(query *SupplierQuery) (*SupplierQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *supplierPager) toCursor(s *Supplier) Cursor {
	return p.order.Field.toCursor(s)
}

func (p *supplierPager) applyCursors(query *SupplierQuery, after, before *Cursor) (*SupplierQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultSupplierOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *supplierPager) applyOrder(query *SupplierQuery) *SupplierQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultSupplierOrder.Field {
		query = query.Order(DefaultSupplierOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *supplierPager) orderExpr(query *SupplierQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultSupplierOrder.Field {
			b.Comma().Ident(DefaultSupplierOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to Supplier.
func (s *SupplierQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...SupplierPaginateOption,
) (*SupplierConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newSupplierPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if s, err = pager.applyFilter(s); err != nil {
		return nil, err
	}
	conn := &SupplierConnection{Edges: []*SupplierEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = s.Clone().Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if s, err = pager.applyCursors(s, after, before); err != nil {
		return nil, err
	}
	if limit := paginateLimit(first, last); limit != 0 {
		s.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := s.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	s = pager.applyOrder(s)
	nodes, err := s.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// SupplierOrderField defines the ordering field of Supplier.
type SupplierOrderField struct {
	// Value extracts the ordering value from the given Supplier.
	Value    func(*Supplier) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) supplier.OrderOption
	toCursor func(*Supplier) Cursor
}

// SupplierOrder defines the ordering of Supplier.
type SupplierOrder struct {
	Direction OrderDirection      `json:"direction"`
	Field     *SupplierOrderField `json:"field"`
}

// DefaultSupplierOrder is the default ordering of Supplier.
var DefaultSupplierOrder = &SupplierOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &SupplierOrderField{
		Value: func(s *Supplier) (ent.Value, error) {
			return s.ID, nil
		},
		column: supplier.FieldID,
		toTerm: supplier.ByID,
		toCursor: func(s *Supplier) Cursor {
			return Cursor{ID: s.ID}
		},
	},
}

// ToEdge converts Supplier into SupplierEdge.
func (s *Supplier) ToEdge(order *SupplierOrder) *SupplierEdge {
	if order == nil {
		order = DefaultSupplierOrder
	}
	return &SupplierEdge{
		Node:   s,
		Cursor: order.Field.toCursor(s),
	}
}

// TokenEdge is the edge representation of Token.
type TokenEdge struct {
	Node   *Token `json:"node"`
	Cursor Cursor `json:"cursor"`
}

// TokenConnection is the connection containing edges to Token.
type TokenConnection struct {
	Edges      []*TokenEdge `json:"edges"`
	PageInfo   PageInfo     `json:"pageInfo"`
	TotalCount int          `json:"totalCount"`
}

func (c *TokenConnection) build(nodes []*Token, pager *tokenPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *Token
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Token {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Token {
			return nodes[i]
		}
	}
	c.Edges = make([]*TokenEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &TokenEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// TokenPaginateOption enables pagination customization.
type TokenPaginateOption func(*tokenPager) error

// WithTokenOrder configures pagination ordering.
func WithTokenOrder(order *TokenOrder) TokenPaginateOption {
	if order == nil {
		order = DefaultTokenOrder
	}
	o := *order
	return func(pager *tokenPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultTokenOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithTokenFilter configures pagination filter.
func WithTokenFilter(filter func(*TokenQuery) (*TokenQuery, error)) TokenPaginateOption {
	return func(pager *tokenPager) error {
		if filter == nil {
			return errors.New("TokenQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type tokenPager struct {
	reverse bool
	order   *TokenOrder
	filter  func(*TokenQuery) (*TokenQuery, error)
}

func newTokenPager(opts []TokenPaginateOption, reverse bool) (*tokenPager, error) {
	pager := &tokenPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultTokenOrder
	}
	return pager, nil
}

func (p *tokenPager) applyFilter(query *TokenQuery) (*TokenQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *tokenPager) toCursor(t *Token) Cursor {
	return p.order.Field.toCursor(t)
}

func (p *tokenPager) applyCursors(query *TokenQuery, after, before *Cursor) (*TokenQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultTokenOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *tokenPager) applyOrder(query *TokenQuery) *TokenQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultTokenOrder.Field {
		query = query.Order(DefaultTokenOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *tokenPager) orderExpr(query *TokenQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultTokenOrder.Field {
			b.Comma().Ident(DefaultTokenOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to Token.
func (t *TokenQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...TokenPaginateOption,
) (*TokenConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newTokenPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if t, err = pager.applyFilter(t); err != nil {
		return nil, err
	}
	conn := &TokenConnection{Edges: []*TokenEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = t.Clone().Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if t, err = pager.applyCursors(t, after, before); err != nil {
		return nil, err
	}
	if limit := paginateLimit(first, last); limit != 0 {
		t.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := t.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	t = pager.applyOrder(t)
	nodes, err := t.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// TokenOrderField defines the ordering field of Token.
type TokenOrderField struct {
	// Value extracts the ordering value from the given Token.
	Value    func(*Token) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) token.OrderOption
	toCursor func(*Token) Cursor
}

// TokenOrder defines the ordering of Token.
type TokenOrder struct {
	Direction OrderDirection   `json:"direction"`
	Field     *TokenOrderField `json:"field"`
}

// DefaultTokenOrder is the default ordering of Token.
var DefaultTokenOrder = &TokenOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &TokenOrderField{
		Value: func(t *Token) (ent.Value, error) {
			return t.ID, nil
		},
		column: token.FieldID,
		toTerm: token.ByID,
		toCursor: func(t *Token) Cursor {
			return Cursor{ID: t.ID}
		},
	},
}

// ToEdge converts Token into TokenEdge.
func (t *Token) ToEdge(order *TokenOrder) *TokenEdge {
	if order == nil {
		order = DefaultTokenOrder
	}
	return &TokenEdge{
		Node:   t,
		Cursor: order.Field.toCursor(t),
	}
}

// TreasuryEdge is the edge representation of Treasury.
type TreasuryEdge struct {
	Node   *Treasury `json:"node"`
	Cursor Cursor    `json:"cursor"`
}

// TreasuryConnection is the connection containing edges to Treasury.
type TreasuryConnection struct {
	Edges      []*TreasuryEdge `json:"edges"`
	PageInfo   PageInfo        `json:"pageInfo"`
	TotalCount int             `json:"totalCount"`
}

func (c *TreasuryConnection) build(nodes []*Treasury, pager *treasuryPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *Treasury
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Treasury {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Treasury {
			return nodes[i]
		}
	}
	c.Edges = make([]*TreasuryEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &TreasuryEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// TreasuryPaginateOption enables pagination customization.
type TreasuryPaginateOption func(*treasuryPager) error

// WithTreasuryOrder configures pagination ordering.
func WithTreasuryOrder(order *TreasuryOrder) TreasuryPaginateOption {
	if order == nil {
		order = DefaultTreasuryOrder
	}
	o := *order
	return func(pager *treasuryPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultTreasuryOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithTreasuryFilter configures pagination filter.
func WithTreasuryFilter(filter func(*TreasuryQuery) (*TreasuryQuery, error)) TreasuryPaginateOption {
	return func(pager *treasuryPager) error {
		if filter == nil {
			return errors.New("TreasuryQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type treasuryPager struct {
	reverse bool
	order   *TreasuryOrder
	filter  func(*TreasuryQuery) (*TreasuryQuery, error)
}

func newTreasuryPager(opts []TreasuryPaginateOption, reverse bool) (*treasuryPager, error) {
	pager := &treasuryPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultTreasuryOrder
	}
	return pager, nil
}

func (p *treasuryPager) applyFilter(query *TreasuryQuery) (*TreasuryQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *treasuryPager) toCursor(t *Treasury) Cursor {
	return p.order.Field.toCursor(t)
}

func (p *treasuryPager) applyCursors(query *TreasuryQuery, after, before *Cursor) (*TreasuryQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultTreasuryOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *treasuryPager) applyOrder(query *TreasuryQuery) *TreasuryQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultTreasuryOrder.Field {
		query = query.Order(DefaultTreasuryOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *treasuryPager) orderExpr(query *TreasuryQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultTreasuryOrder.Field {
			b.Comma().Ident(DefaultTreasuryOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to Treasury.
func (t *TreasuryQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...TreasuryPaginateOption,
) (*TreasuryConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newTreasuryPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if t, err = pager.applyFilter(t); err != nil {
		return nil, err
	}
	conn := &TreasuryConnection{Edges: []*TreasuryEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = t.Clone().Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if t, err = pager.applyCursors(t, after, before); err != nil {
		return nil, err
	}
	if limit := paginateLimit(first, last); limit != 0 {
		t.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := t.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	t = pager.applyOrder(t)
	nodes, err := t.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// TreasuryOrderField defines the ordering field of Treasury.
type TreasuryOrderField struct {
	// Value extracts the ordering value from the given Treasury.
	Value    func(*Treasury) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) treasury.OrderOption
	toCursor func(*Treasury) Cursor
}

// TreasuryOrder defines the ordering of Treasury.
type TreasuryOrder struct {
	Direction OrderDirection      `json:"direction"`
	Field     *TreasuryOrderField `json:"field"`
}

// DefaultTreasuryOrder is the default ordering of Treasury.
var DefaultTreasuryOrder = &TreasuryOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &TreasuryOrderField{
		Value: func(t *Treasury) (ent.Value, error) {
			return t.ID, nil
		},
		column: treasury.FieldID,
		toTerm: treasury.ByID,
		toCursor: func(t *Treasury) Cursor {
			return Cursor{ID: t.ID}
		},
	},
}

// ToEdge converts Treasury into TreasuryEdge.
func (t *Treasury) ToEdge(order *TreasuryOrder) *TreasuryEdge {
	if order == nil {
		order = DefaultTreasuryOrder
	}
	return &TreasuryEdge{
		Node:   t,
		Cursor: order.Field.toCursor(t),
	}
}

// UserEdge is the edge representation of User.
type UserEdge struct {
	Node   *User  `json:"node"`
	Cursor Cursor `json:"cursor"`
}

// UserConnection is the connection containing edges to User.
type UserConnection struct {
	Edges      []*UserEdge `json:"edges"`
	PageInfo   PageInfo    `json:"pageInfo"`
	TotalCount int         `json:"totalCount"`
}

func (c *UserConnection) build(nodes []*User, pager *userPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *User
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *User {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *User {
			return nodes[i]
		}
	}
	c.Edges = make([]*UserEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &UserEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// UserPaginateOption enables pagination customization.
type UserPaginateOption func(*userPager) error

// WithUserOrder configures pagination ordering.
func WithUserOrder(order *UserOrder) UserPaginateOption {
	if order == nil {
		order = DefaultUserOrder
	}
	o := *order
	return func(pager *userPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultUserOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithUserFilter configures pagination filter.
func WithUserFilter(filter func(*UserQuery) (*UserQuery, error)) UserPaginateOption {
	return func(pager *userPager) error {
		if filter == nil {
			return errors.New("UserQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type userPager struct {
	reverse bool
	order   *UserOrder
	filter  func(*UserQuery) (*UserQuery, error)
}

func newUserPager(opts []UserPaginateOption, reverse bool) (*userPager, error) {
	pager := &userPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultUserOrder
	}
	return pager, nil
}

func (p *userPager) applyFilter(query *UserQuery) (*UserQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *userPager) toCursor(u *User) Cursor {
	return p.order.Field.toCursor(u)
}

func (p *userPager) applyCursors(query *UserQuery, after, before *Cursor) (*UserQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultUserOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *userPager) applyOrder(query *UserQuery) *UserQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultUserOrder.Field {
		query = query.Order(DefaultUserOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *userPager) orderExpr(query *UserQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultUserOrder.Field {
			b.Comma().Ident(DefaultUserOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to User.
func (u *UserQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...UserPaginateOption,
) (*UserConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newUserPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if u, err = pager.applyFilter(u); err != nil {
		return nil, err
	}
	conn := &UserConnection{Edges: []*UserEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = u.Clone().Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if u, err = pager.applyCursors(u, after, before); err != nil {
		return nil, err
	}
	if limit := paginateLimit(first, last); limit != 0 {
		u.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := u.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	u = pager.applyOrder(u)
	nodes, err := u.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// UserOrderFieldName orders User by name.
	UserOrderFieldName = &UserOrderField{
		Value: func(u *User) (ent.Value, error) {
			return u.Name, nil
		},
		column: user.FieldName,
		toTerm: user.ByName,
		toCursor: func(u *User) Cursor {
			return Cursor{
				ID:    u.ID,
				Value: u.Name,
			}
		},
	}
	// UserOrderFieldUsername orders User by username.
	UserOrderFieldUsername = &UserOrderField{
		Value: func(u *User) (ent.Value, error) {
			return u.Username, nil
		},
		column: user.FieldUsername,
		toTerm: user.ByUsername,
		toCursor: func(u *User) Cursor {
			return Cursor{
				ID:    u.ID,
				Value: u.Username,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f UserOrderField) String() string {
	var str string
	switch f.column {
	case UserOrderFieldName.column:
		str = "NAME"
	case UserOrderFieldUsername.column:
		str = "USERNAME"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f UserOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *UserOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("UserOrderField %T must be a string", v)
	}
	switch str {
	case "NAME":
		*f = *UserOrderFieldName
	case "USERNAME":
		*f = *UserOrderFieldUsername
	default:
		return fmt.Errorf("%s is not a valid UserOrderField", str)
	}
	return nil
}

// UserOrderField defines the ordering field of User.
type UserOrderField struct {
	// Value extracts the ordering value from the given User.
	Value    func(*User) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) user.OrderOption
	toCursor func(*User) Cursor
}

// UserOrder defines the ordering of User.
type UserOrder struct {
	Direction OrderDirection  `json:"direction"`
	Field     *UserOrderField `json:"field"`
}

// DefaultUserOrder is the default ordering of User.
var DefaultUserOrder = &UserOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &UserOrderField{
		Value: func(u *User) (ent.Value, error) {
			return u.ID, nil
		},
		column: user.FieldID,
		toTerm: user.ByID,
		toCursor: func(u *User) Cursor {
			return Cursor{ID: u.ID}
		},
	},
}

// ToEdge converts User into UserEdge.
func (u *User) ToEdge(order *UserOrder) *UserEdge {
	if order == nil {
		order = DefaultUserOrder
	}
	return &UserEdge{
		Node:   u,
		Cursor: order.Field.toCursor(u),
	}
}

// UserRoleEdge is the edge representation of UserRole.
type UserRoleEdge struct {
	Node   *UserRole `json:"node"`
	Cursor Cursor    `json:"cursor"`
}

// UserRoleConnection is the connection containing edges to UserRole.
type UserRoleConnection struct {
	Edges      []*UserRoleEdge `json:"edges"`
	PageInfo   PageInfo        `json:"pageInfo"`
	TotalCount int             `json:"totalCount"`
}

func (c *UserRoleConnection) build(nodes []*UserRole, pager *userrolePager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *UserRole
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *UserRole {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *UserRole {
			return nodes[i]
		}
	}
	c.Edges = make([]*UserRoleEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &UserRoleEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// UserRolePaginateOption enables pagination customization.
type UserRolePaginateOption func(*userrolePager) error

// WithUserRoleOrder configures pagination ordering.
func WithUserRoleOrder(order *UserRoleOrder) UserRolePaginateOption {
	if order == nil {
		order = DefaultUserRoleOrder
	}
	o := *order
	return func(pager *userrolePager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultUserRoleOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithUserRoleFilter configures pagination filter.
func WithUserRoleFilter(filter func(*UserRoleQuery) (*UserRoleQuery, error)) UserRolePaginateOption {
	return func(pager *userrolePager) error {
		if filter == nil {
			return errors.New("UserRoleQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type userrolePager struct {
	reverse bool
	order   *UserRoleOrder
	filter  func(*UserRoleQuery) (*UserRoleQuery, error)
}

func newUserRolePager(opts []UserRolePaginateOption, reverse bool) (*userrolePager, error) {
	pager := &userrolePager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultUserRoleOrder
	}
	return pager, nil
}

func (p *userrolePager) applyFilter(query *UserRoleQuery) (*UserRoleQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *userrolePager) toCursor(ur *UserRole) Cursor {
	return p.order.Field.toCursor(ur)
}

func (p *userrolePager) applyCursors(query *UserRoleQuery, after, before *Cursor) (*UserRoleQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultUserRoleOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *userrolePager) applyOrder(query *UserRoleQuery) *UserRoleQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultUserRoleOrder.Field {
		query = query.Order(DefaultUserRoleOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *userrolePager) orderExpr(query *UserRoleQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultUserRoleOrder.Field {
			b.Comma().Ident(DefaultUserRoleOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to UserRole.
func (ur *UserRoleQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...UserRolePaginateOption,
) (*UserRoleConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newUserRolePager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if ur, err = pager.applyFilter(ur); err != nil {
		return nil, err
	}
	conn := &UserRoleConnection{Edges: []*UserRoleEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = ur.Clone().Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if ur, err = pager.applyCursors(ur, after, before); err != nil {
		return nil, err
	}
	if limit := paginateLimit(first, last); limit != 0 {
		ur.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := ur.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	ur = pager.applyOrder(ur)
	nodes, err := ur.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// UserRoleOrderFieldRole orders UserRole by role.
	UserRoleOrderFieldRole = &UserRoleOrderField{
		Value: func(ur *UserRole) (ent.Value, error) {
			return ur.Role, nil
		},
		column: userrole.FieldRole,
		toTerm: userrole.ByRole,
		toCursor: func(ur *UserRole) Cursor {
			return Cursor{
				ID:    ur.ID,
				Value: ur.Role,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f UserRoleOrderField) String() string {
	var str string
	switch f.column {
	case UserRoleOrderFieldRole.column:
		str = "ROLES"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f UserRoleOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *UserRoleOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("UserRoleOrderField %T must be a string", v)
	}
	switch str {
	case "ROLES":
		*f = *UserRoleOrderFieldRole
	default:
		return fmt.Errorf("%s is not a valid UserRoleOrderField", str)
	}
	return nil
}

// UserRoleOrderField defines the ordering field of UserRole.
type UserRoleOrderField struct {
	// Value extracts the ordering value from the given UserRole.
	Value    func(*UserRole) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) userrole.OrderOption
	toCursor func(*UserRole) Cursor
}

// UserRoleOrder defines the ordering of UserRole.
type UserRoleOrder struct {
	Direction OrderDirection      `json:"direction"`
	Field     *UserRoleOrderField `json:"field"`
}

// DefaultUserRoleOrder is the default ordering of UserRole.
var DefaultUserRoleOrder = &UserRoleOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &UserRoleOrderField{
		Value: func(ur *UserRole) (ent.Value, error) {
			return ur.ID, nil
		},
		column: userrole.FieldID,
		toTerm: userrole.ByID,
		toCursor: func(ur *UserRole) Cursor {
			return Cursor{ID: ur.ID}
		},
	},
}

// ToEdge converts UserRole into UserRoleEdge.
func (ur *UserRole) ToEdge(order *UserRoleOrder) *UserRoleEdge {
	if order == nil {
		order = DefaultUserRoleOrder
	}
	return &UserRoleEdge{
		Node:   ur,
		Cursor: order.Field.toCursor(ur),
	}
}

// WorkshiftEdge is the edge representation of Workshift.
type WorkshiftEdge struct {
	Node   *Workshift `json:"node"`
	Cursor Cursor     `json:"cursor"`
}

// WorkshiftConnection is the connection containing edges to Workshift.
type WorkshiftConnection struct {
	Edges      []*WorkshiftEdge `json:"edges"`
	PageInfo   PageInfo         `json:"pageInfo"`
	TotalCount int              `json:"totalCount"`
}

func (c *WorkshiftConnection) build(nodes []*Workshift, pager *workshiftPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *Workshift
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Workshift {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Workshift {
			return nodes[i]
		}
	}
	c.Edges = make([]*WorkshiftEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &WorkshiftEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// WorkshiftPaginateOption enables pagination customization.
type WorkshiftPaginateOption func(*workshiftPager) error

// WithWorkshiftOrder configures pagination ordering.
func WithWorkshiftOrder(order []*WorkshiftOrder) WorkshiftPaginateOption {
	return func(pager *workshiftPager) error {
		for _, o := range order {
			if err := o.Direction.Validate(); err != nil {
				return err
			}
		}
		pager.order = append(pager.order, order...)
		return nil
	}
}

// WithWorkshiftFilter configures pagination filter.
func WithWorkshiftFilter(filter func(*WorkshiftQuery) (*WorkshiftQuery, error)) WorkshiftPaginateOption {
	return func(pager *workshiftPager) error {
		if filter == nil {
			return errors.New("WorkshiftQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type workshiftPager struct {
	reverse bool
	order   []*WorkshiftOrder
	filter  func(*WorkshiftQuery) (*WorkshiftQuery, error)
}

func newWorkshiftPager(opts []WorkshiftPaginateOption, reverse bool) (*workshiftPager, error) {
	pager := &workshiftPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	for i, o := range pager.order {
		if i > 0 && o.Field == pager.order[i-1].Field {
			return nil, fmt.Errorf("duplicate order direction %q", o.Direction)
		}
	}
	return pager, nil
}

func (p *workshiftPager) applyFilter(query *WorkshiftQuery) (*WorkshiftQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *workshiftPager) toCursor(w *Workshift) Cursor {
	cs := make([]any, 0, len(p.order))
	for _, o := range p.order {
		cs = append(cs, o.Field.toCursor(w).Value)
	}
	return Cursor{ID: w.ID, Value: cs}
}

func (p *workshiftPager) applyCursors(query *WorkshiftQuery, after, before *Cursor) (*WorkshiftQuery, error) {
	idDirection := entgql.OrderDirectionAsc
	if p.reverse {
		idDirection = entgql.OrderDirectionDesc
	}
	fields, directions := make([]string, 0, len(p.order)), make([]OrderDirection, 0, len(p.order))
	for _, o := range p.order {
		fields = append(fields, o.Field.column)
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		directions = append(directions, direction)
	}
	predicates, err := entgql.MultiCursorsPredicate(after, before, &entgql.MultiCursorsOptions{
		FieldID:     DefaultWorkshiftOrder.Field.column,
		DirectionID: idDirection,
		Fields:      fields,
		Directions:  directions,
	})
	if err != nil {
		return nil, err
	}
	for _, predicate := range predicates {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *workshiftPager) applyOrder(query *WorkshiftQuery) *WorkshiftQuery {
	var defaultOrdered bool
	for _, o := range p.order {
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(o.Field.toTerm(direction.OrderTermOption()))
		if o.Field.column == DefaultWorkshiftOrder.Field.column {
			defaultOrdered = true
		}
		if len(query.ctx.Fields) > 0 {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	if !defaultOrdered {
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(DefaultWorkshiftOrder.Field.toTerm(direction.OrderTermOption()))
	}
	return query
}

func (p *workshiftPager) orderExpr(query *WorkshiftQuery) sql.Querier {
	if len(query.ctx.Fields) > 0 {
		for _, o := range p.order {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		for _, o := range p.order {
			direction := o.Direction
			if p.reverse {
				direction = direction.Reverse()
			}
			b.Ident(o.Field.column).Pad().WriteString(string(direction))
			b.Comma()
		}
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		b.Ident(DefaultWorkshiftOrder.Field.column).Pad().WriteString(string(direction))
	})
}

// Paginate executes the query and returns a relay based cursor connection to Workshift.
func (w *WorkshiftQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...WorkshiftPaginateOption,
) (*WorkshiftConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newWorkshiftPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if w, err = pager.applyFilter(w); err != nil {
		return nil, err
	}
	conn := &WorkshiftConnection{Edges: []*WorkshiftEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = w.Clone().Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if w, err = pager.applyCursors(w, after, before); err != nil {
		return nil, err
	}
	if limit := paginateLimit(first, last); limit != 0 {
		w.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := w.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	w = pager.applyOrder(w)
	nodes, err := w.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// WorkshiftOrderFieldApprovedAt orders Workshift by approvedAt.
	WorkshiftOrderFieldApprovedAt = &WorkshiftOrderField{
		Value: func(w *Workshift) (ent.Value, error) {
			return w.ApprovedAt, nil
		},
		column: workshift.FieldApprovedAt,
		toTerm: workshift.ByApprovedAt,
		toCursor: func(w *Workshift) Cursor {
			return Cursor{
				ID:    w.ID,
				Value: w.ApprovedAt,
			}
		},
	}
	// WorkshiftOrderFieldClockIn orders Workshift by clockIn.
	WorkshiftOrderFieldClockIn = &WorkshiftOrderField{
		Value: func(w *Workshift) (ent.Value, error) {
			return w.ClockIn, nil
		},
		column: workshift.FieldClockIn,
		toTerm: workshift.ByClockIn,
		toCursor: func(w *Workshift) Cursor {
			return Cursor{
				ID:    w.ID,
				Value: w.ClockIn,
			}
		},
	}
	// WorkshiftOrderFieldClockOut orders Workshift by clockOut.
	WorkshiftOrderFieldClockOut = &WorkshiftOrderField{
		Value: func(w *Workshift) (ent.Value, error) {
			return w.ClockOut, nil
		},
		column: workshift.FieldClockOut,
		toTerm: workshift.ByClockOut,
		toCursor: func(w *Workshift) Cursor {
			return Cursor{
				ID:    w.ID,
				Value: w.ClockOut,
			}
		},
	}
	// WorkshiftOrderFieldStatus orders Workshift by status.
	WorkshiftOrderFieldStatus = &WorkshiftOrderField{
		Value: func(w *Workshift) (ent.Value, error) {
			return w.Status, nil
		},
		column: workshift.FieldStatus,
		toTerm: workshift.ByStatus,
		toCursor: func(w *Workshift) Cursor {
			return Cursor{
				ID:    w.ID,
				Value: w.Status,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f WorkshiftOrderField) String() string {
	var str string
	switch f.column {
	case WorkshiftOrderFieldApprovedAt.column:
		str = "APPROVED_AT"
	case WorkshiftOrderFieldClockIn.column:
		str = "CLOCK_IN"
	case WorkshiftOrderFieldClockOut.column:
		str = "CLOCK_OUT"
	case WorkshiftOrderFieldStatus.column:
		str = "STATUS"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f WorkshiftOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *WorkshiftOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("WorkshiftOrderField %T must be a string", v)
	}
	switch str {
	case "APPROVED_AT":
		*f = *WorkshiftOrderFieldApprovedAt
	case "CLOCK_IN":
		*f = *WorkshiftOrderFieldClockIn
	case "CLOCK_OUT":
		*f = *WorkshiftOrderFieldClockOut
	case "STATUS":
		*f = *WorkshiftOrderFieldStatus
	default:
		return fmt.Errorf("%s is not a valid WorkshiftOrderField", str)
	}
	return nil
}

// WorkshiftOrderField defines the ordering field of Workshift.
type WorkshiftOrderField struct {
	// Value extracts the ordering value from the given Workshift.
	Value    func(*Workshift) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) workshift.OrderOption
	toCursor func(*Workshift) Cursor
}

// WorkshiftOrder defines the ordering of Workshift.
type WorkshiftOrder struct {
	Direction OrderDirection       `json:"direction"`
	Field     *WorkshiftOrderField `json:"field"`
}

// DefaultWorkshiftOrder is the default ordering of Workshift.
var DefaultWorkshiftOrder = &WorkshiftOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &WorkshiftOrderField{
		Value: func(w *Workshift) (ent.Value, error) {
			return w.ID, nil
		},
		column: workshift.FieldID,
		toTerm: workshift.ByID,
		toCursor: func(w *Workshift) Cursor {
			return Cursor{ID: w.ID}
		},
	},
}

// ToEdge converts Workshift into WorkshiftEdge.
func (w *Workshift) ToEdge(order *WorkshiftOrder) *WorkshiftEdge {
	if order == nil {
		order = DefaultWorkshiftOrder
	}
	return &WorkshiftEdge{
		Node:   w,
		Cursor: order.Field.toCursor(w),
	}
}
