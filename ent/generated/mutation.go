// Code generated by ent, DO NOT EDIT.

package generated

import (
	"context"
	"errors"
	"fmt"
	"mazza/ent/generated/accountingentry"
	"mazza/ent/generated/company"
	"mazza/ent/generated/companydocument"
	"mazza/ent/generated/customer"
	"mazza/ent/generated/employee"
	"mazza/ent/generated/file"
	"mazza/ent/generated/inventory"
	"mazza/ent/generated/inventorymovement"
	"mazza/ent/generated/invoice"
	"mazza/ent/generated/loan"
	"mazza/ent/generated/loanschedule"
	"mazza/ent/generated/membersignuptoken"
	"mazza/ent/generated/payable"
	"mazza/ent/generated/predicate"
	"mazza/ent/generated/product"
	"mazza/ent/generated/project"
	"mazza/ent/generated/projectmilestone"
	"mazza/ent/generated/projecttask"
	"mazza/ent/generated/receivable"
	"mazza/ent/generated/supplier"
	"mazza/ent/generated/token"
	"mazza/ent/generated/treasury"
	"mazza/ent/generated/user"
	"mazza/ent/generated/userrole"
	"mazza/ent/generated/workshift"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeAccountingEntry   = "AccountingEntry"
	TypeCalendar          = "Calendar"
	TypeCompany           = "Company"
	TypeCompanyDocument   = "CompanyDocument"
	TypeCustomer          = "Customer"
	TypeEmployee          = "Employee"
	TypeFile              = "File"
	TypeInventory         = "Inventory"
	TypeInventoryMovement = "InventoryMovement"
	TypeInvoice           = "Invoice"
	TypeLoan              = "Loan"
	TypeLoanSchedule      = "LoanSchedule"
	TypeMemberSignupToken = "MemberSignupToken"
	TypePayable           = "Payable"
	TypeProduct           = "Product"
	TypeProject           = "Project"
	TypeProjectMilestone  = "ProjectMilestone"
	TypeProjectTask       = "ProjectTask"
	TypeReceivable        = "Receivable"
	TypeSupplier          = "Supplier"
	TypeToken             = "Token"
	TypeTreasury          = "Treasury"
	TypeUser              = "User"
	TypeUserRole          = "UserRole"
	TypeWorkshift         = "Workshift"
)

// AccountingEntryMutation represents an operation that mutates the AccountingEntry nodes in the graph.
type AccountingEntryMutation struct {
	config
	op                   Op
	typ                  string
	id                   *int
	created_at           *time.Time
	updated_at           *time.Time
	deleted_at           *time.Time
	number               *int
	addnumber            *int
	group                *int
	addgroup             *int
	date                 *time.Time
	account              *string
	label                *string
	amount               *float64
	addamount            *float64
	description          *string
	account_type         *accountingentry.AccountType
	category             *string
	main                 *string
	is_debit             *bool
	is_reversal          *bool
	reversed             *bool
	clearedFields        map[string]struct{}
	company              *int
	clearedcompany       bool
	user                 *int
	cleareduser          bool
	loan                 *int
	clearedloan          bool
	loanSchedules        map[int]struct{}
	removedloanSchedules map[int]struct{}
	clearedloanSchedules bool
	done                 bool
	oldValue             func(context.Context) (*AccountingEntry, error)
	predicates           []predicate.AccountingEntry
}

var _ ent.Mutation = (*AccountingEntryMutation)(nil)

// accountingentryOption allows management of the mutation configuration using functional options.
type accountingentryOption func(*AccountingEntryMutation)

// newAccountingEntryMutation creates new mutation for the AccountingEntry entity.
func newAccountingEntryMutation(c config, op Op, opts ...accountingentryOption) *AccountingEntryMutation {
	m := &AccountingEntryMutation{
		config:        c,
		op:            op,
		typ:           TypeAccountingEntry,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAccountingEntryID sets the ID field of the mutation.
func withAccountingEntryID(id int) accountingentryOption {
	return func(m *AccountingEntryMutation) {
		var (
			err   error
			once  sync.Once
			value *AccountingEntry
		)
		m.oldValue = func(ctx context.Context) (*AccountingEntry, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AccountingEntry.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAccountingEntry sets the old AccountingEntry of the mutation.
func withAccountingEntry(node *AccountingEntry) accountingentryOption {
	return func(m *AccountingEntryMutation) {
		m.oldValue = func(context.Context) (*AccountingEntry, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AccountingEntryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AccountingEntryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("generated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AccountingEntryMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AccountingEntryMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AccountingEntry.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *AccountingEntryMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AccountingEntryMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the AccountingEntry entity.
// If the AccountingEntry object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountingEntryMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AccountingEntryMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *AccountingEntryMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *AccountingEntryMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the AccountingEntry entity.
// If the AccountingEntry object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountingEntryMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *AccountingEntryMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *AccountingEntryMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *AccountingEntryMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the AccountingEntry entity.
// If the AccountingEntry object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountingEntryMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *AccountingEntryMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[accountingentry.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *AccountingEntryMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[accountingentry.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *AccountingEntryMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, accountingentry.FieldDeletedAt)
}

// SetNumber sets the "number" field.
func (m *AccountingEntryMutation) SetNumber(i int) {
	m.number = &i
	m.addnumber = nil
}

// Number returns the value of the "number" field in the mutation.
func (m *AccountingEntryMutation) Number() (r int, exists bool) {
	v := m.number
	if v == nil {
		return
	}
	return *v, true
}

// OldNumber returns the old "number" field's value of the AccountingEntry entity.
// If the AccountingEntry object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountingEntryMutation) OldNumber(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNumber: %w", err)
	}
	return oldValue.Number, nil
}

// AddNumber adds i to the "number" field.
func (m *AccountingEntryMutation) AddNumber(i int) {
	if m.addnumber != nil {
		*m.addnumber += i
	} else {
		m.addnumber = &i
	}
}

// AddedNumber returns the value that was added to the "number" field in this mutation.
func (m *AccountingEntryMutation) AddedNumber() (r int, exists bool) {
	v := m.addnumber
	if v == nil {
		return
	}
	return *v, true
}

// ResetNumber resets all changes to the "number" field.
func (m *AccountingEntryMutation) ResetNumber() {
	m.number = nil
	m.addnumber = nil
}

// SetGroup sets the "group" field.
func (m *AccountingEntryMutation) SetGroup(i int) {
	m.group = &i
	m.addgroup = nil
}

// Group returns the value of the "group" field in the mutation.
func (m *AccountingEntryMutation) Group() (r int, exists bool) {
	v := m.group
	if v == nil {
		return
	}
	return *v, true
}

// OldGroup returns the old "group" field's value of the AccountingEntry entity.
// If the AccountingEntry object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountingEntryMutation) OldGroup(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGroup is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGroup requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGroup: %w", err)
	}
	return oldValue.Group, nil
}

// AddGroup adds i to the "group" field.
func (m *AccountingEntryMutation) AddGroup(i int) {
	if m.addgroup != nil {
		*m.addgroup += i
	} else {
		m.addgroup = &i
	}
}

// AddedGroup returns the value that was added to the "group" field in this mutation.
func (m *AccountingEntryMutation) AddedGroup() (r int, exists bool) {
	v := m.addgroup
	if v == nil {
		return
	}
	return *v, true
}

// ResetGroup resets all changes to the "group" field.
func (m *AccountingEntryMutation) ResetGroup() {
	m.group = nil
	m.addgroup = nil
}

// SetDate sets the "date" field.
func (m *AccountingEntryMutation) SetDate(t time.Time) {
	m.date = &t
}

// Date returns the value of the "date" field in the mutation.
func (m *AccountingEntryMutation) Date() (r time.Time, exists bool) {
	v := m.date
	if v == nil {
		return
	}
	return *v, true
}

// OldDate returns the old "date" field's value of the AccountingEntry entity.
// If the AccountingEntry object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountingEntryMutation) OldDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDate: %w", err)
	}
	return oldValue.Date, nil
}

// ResetDate resets all changes to the "date" field.
func (m *AccountingEntryMutation) ResetDate() {
	m.date = nil
}

// SetAccount sets the "account" field.
func (m *AccountingEntryMutation) SetAccount(s string) {
	m.account = &s
}

// Account returns the value of the "account" field in the mutation.
func (m *AccountingEntryMutation) Account() (r string, exists bool) {
	v := m.account
	if v == nil {
		return
	}
	return *v, true
}

// OldAccount returns the old "account" field's value of the AccountingEntry entity.
// If the AccountingEntry object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountingEntryMutation) OldAccount(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAccount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAccount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAccount: %w", err)
	}
	return oldValue.Account, nil
}

// ResetAccount resets all changes to the "account" field.
func (m *AccountingEntryMutation) ResetAccount() {
	m.account = nil
}

// SetLabel sets the "label" field.
func (m *AccountingEntryMutation) SetLabel(s string) {
	m.label = &s
}

// Label returns the value of the "label" field in the mutation.
func (m *AccountingEntryMutation) Label() (r string, exists bool) {
	v := m.label
	if v == nil {
		return
	}
	return *v, true
}

// OldLabel returns the old "label" field's value of the AccountingEntry entity.
// If the AccountingEntry object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountingEntryMutation) OldLabel(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLabel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLabel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLabel: %w", err)
	}
	return oldValue.Label, nil
}

// ResetLabel resets all changes to the "label" field.
func (m *AccountingEntryMutation) ResetLabel() {
	m.label = nil
}

// SetAmount sets the "amount" field.
func (m *AccountingEntryMutation) SetAmount(f float64) {
	m.amount = &f
	m.addamount = nil
}

// Amount returns the value of the "amount" field in the mutation.
func (m *AccountingEntryMutation) Amount() (r float64, exists bool) {
	v := m.amount
	if v == nil {
		return
	}
	return *v, true
}

// OldAmount returns the old "amount" field's value of the AccountingEntry entity.
// If the AccountingEntry object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountingEntryMutation) OldAmount(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAmount: %w", err)
	}
	return oldValue.Amount, nil
}

// AddAmount adds f to the "amount" field.
func (m *AccountingEntryMutation) AddAmount(f float64) {
	if m.addamount != nil {
		*m.addamount += f
	} else {
		m.addamount = &f
	}
}

// AddedAmount returns the value that was added to the "amount" field in this mutation.
func (m *AccountingEntryMutation) AddedAmount() (r float64, exists bool) {
	v := m.addamount
	if v == nil {
		return
	}
	return *v, true
}

// ResetAmount resets all changes to the "amount" field.
func (m *AccountingEntryMutation) ResetAmount() {
	m.amount = nil
	m.addamount = nil
}

// SetDescription sets the "description" field.
func (m *AccountingEntryMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *AccountingEntryMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the AccountingEntry entity.
// If the AccountingEntry object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountingEntryMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *AccountingEntryMutation) ResetDescription() {
	m.description = nil
}

// SetAccountType sets the "account_type" field.
func (m *AccountingEntryMutation) SetAccountType(at accountingentry.AccountType) {
	m.account_type = &at
}

// AccountType returns the value of the "account_type" field in the mutation.
func (m *AccountingEntryMutation) AccountType() (r accountingentry.AccountType, exists bool) {
	v := m.account_type
	if v == nil {
		return
	}
	return *v, true
}

// OldAccountType returns the old "account_type" field's value of the AccountingEntry entity.
// If the AccountingEntry object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountingEntryMutation) OldAccountType(ctx context.Context) (v accountingentry.AccountType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAccountType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAccountType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAccountType: %w", err)
	}
	return oldValue.AccountType, nil
}

// ResetAccountType resets all changes to the "account_type" field.
func (m *AccountingEntryMutation) ResetAccountType() {
	m.account_type = nil
}

// SetCategory sets the "category" field.
func (m *AccountingEntryMutation) SetCategory(s string) {
	m.category = &s
}

// Category returns the value of the "category" field in the mutation.
func (m *AccountingEntryMutation) Category() (r string, exists bool) {
	v := m.category
	if v == nil {
		return
	}
	return *v, true
}

// OldCategory returns the old "category" field's value of the AccountingEntry entity.
// If the AccountingEntry object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountingEntryMutation) OldCategory(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCategory is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCategory requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCategory: %w", err)
	}
	return oldValue.Category, nil
}

// ResetCategory resets all changes to the "category" field.
func (m *AccountingEntryMutation) ResetCategory() {
	m.category = nil
}

// SetMain sets the "main" field.
func (m *AccountingEntryMutation) SetMain(s string) {
	m.main = &s
}

// Main returns the value of the "main" field in the mutation.
func (m *AccountingEntryMutation) Main() (r string, exists bool) {
	v := m.main
	if v == nil {
		return
	}
	return *v, true
}

// OldMain returns the old "main" field's value of the AccountingEntry entity.
// If the AccountingEntry object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountingEntryMutation) OldMain(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMain is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMain requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMain: %w", err)
	}
	return oldValue.Main, nil
}

// ResetMain resets all changes to the "main" field.
func (m *AccountingEntryMutation) ResetMain() {
	m.main = nil
}

// SetIsDebit sets the "is_debit" field.
func (m *AccountingEntryMutation) SetIsDebit(b bool) {
	m.is_debit = &b
}

// IsDebit returns the value of the "is_debit" field in the mutation.
func (m *AccountingEntryMutation) IsDebit() (r bool, exists bool) {
	v := m.is_debit
	if v == nil {
		return
	}
	return *v, true
}

// OldIsDebit returns the old "is_debit" field's value of the AccountingEntry entity.
// If the AccountingEntry object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountingEntryMutation) OldIsDebit(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsDebit is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsDebit requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsDebit: %w", err)
	}
	return oldValue.IsDebit, nil
}

// ResetIsDebit resets all changes to the "is_debit" field.
func (m *AccountingEntryMutation) ResetIsDebit() {
	m.is_debit = nil
}

// SetIsReversal sets the "is_reversal" field.
func (m *AccountingEntryMutation) SetIsReversal(b bool) {
	m.is_reversal = &b
}

// IsReversal returns the value of the "is_reversal" field in the mutation.
func (m *AccountingEntryMutation) IsReversal() (r bool, exists bool) {
	v := m.is_reversal
	if v == nil {
		return
	}
	return *v, true
}

// OldIsReversal returns the old "is_reversal" field's value of the AccountingEntry entity.
// If the AccountingEntry object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountingEntryMutation) OldIsReversal(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsReversal is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsReversal requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsReversal: %w", err)
	}
	return oldValue.IsReversal, nil
}

// ResetIsReversal resets all changes to the "is_reversal" field.
func (m *AccountingEntryMutation) ResetIsReversal() {
	m.is_reversal = nil
}

// SetReversed sets the "reversed" field.
func (m *AccountingEntryMutation) SetReversed(b bool) {
	m.reversed = &b
}

// Reversed returns the value of the "reversed" field in the mutation.
func (m *AccountingEntryMutation) Reversed() (r bool, exists bool) {
	v := m.reversed
	if v == nil {
		return
	}
	return *v, true
}

// OldReversed returns the old "reversed" field's value of the AccountingEntry entity.
// If the AccountingEntry object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountingEntryMutation) OldReversed(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReversed is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReversed requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReversed: %w", err)
	}
	return oldValue.Reversed, nil
}

// ResetReversed resets all changes to the "reversed" field.
func (m *AccountingEntryMutation) ResetReversed() {
	m.reversed = nil
}

// SetCompanyID sets the "company" edge to the Company entity by id.
func (m *AccountingEntryMutation) SetCompanyID(id int) {
	m.company = &id
}

// ClearCompany clears the "company" edge to the Company entity.
func (m *AccountingEntryMutation) ClearCompany() {
	m.clearedcompany = true
}

// CompanyCleared reports if the "company" edge to the Company entity was cleared.
func (m *AccountingEntryMutation) CompanyCleared() bool {
	return m.clearedcompany
}

// CompanyID returns the "company" edge ID in the mutation.
func (m *AccountingEntryMutation) CompanyID() (id int, exists bool) {
	if m.company != nil {
		return *m.company, true
	}
	return
}

// CompanyIDs returns the "company" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CompanyID instead. It exists only for internal usage by the builders.
func (m *AccountingEntryMutation) CompanyIDs() (ids []int) {
	if id := m.company; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCompany resets all changes to the "company" edge.
func (m *AccountingEntryMutation) ResetCompany() {
	m.company = nil
	m.clearedcompany = false
}

// SetUserID sets the "user" edge to the User entity by id.
func (m *AccountingEntryMutation) SetUserID(id int) {
	m.user = &id
}

// ClearUser clears the "user" edge to the User entity.
func (m *AccountingEntryMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *AccountingEntryMutation) UserCleared() bool {
	return m.cleareduser
}

// UserID returns the "user" edge ID in the mutation.
func (m *AccountingEntryMutation) UserID() (id int, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *AccountingEntryMutation) UserIDs() (ids []int) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *AccountingEntryMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// SetLoanID sets the "loan" edge to the Loan entity by id.
func (m *AccountingEntryMutation) SetLoanID(id int) {
	m.loan = &id
}

// ClearLoan clears the "loan" edge to the Loan entity.
func (m *AccountingEntryMutation) ClearLoan() {
	m.clearedloan = true
}

// LoanCleared reports if the "loan" edge to the Loan entity was cleared.
func (m *AccountingEntryMutation) LoanCleared() bool {
	return m.clearedloan
}

// LoanID returns the "loan" edge ID in the mutation.
func (m *AccountingEntryMutation) LoanID() (id int, exists bool) {
	if m.loan != nil {
		return *m.loan, true
	}
	return
}

// LoanIDs returns the "loan" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// LoanID instead. It exists only for internal usage by the builders.
func (m *AccountingEntryMutation) LoanIDs() (ids []int) {
	if id := m.loan; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetLoan resets all changes to the "loan" edge.
func (m *AccountingEntryMutation) ResetLoan() {
	m.loan = nil
	m.clearedloan = false
}

// AddLoanScheduleIDs adds the "loanSchedules" edge to the LoanSchedule entity by ids.
func (m *AccountingEntryMutation) AddLoanScheduleIDs(ids ...int) {
	if m.loanSchedules == nil {
		m.loanSchedules = make(map[int]struct{})
	}
	for i := range ids {
		m.loanSchedules[ids[i]] = struct{}{}
	}
}

// ClearLoanSchedules clears the "loanSchedules" edge to the LoanSchedule entity.
func (m *AccountingEntryMutation) ClearLoanSchedules() {
	m.clearedloanSchedules = true
}

// LoanSchedulesCleared reports if the "loanSchedules" edge to the LoanSchedule entity was cleared.
func (m *AccountingEntryMutation) LoanSchedulesCleared() bool {
	return m.clearedloanSchedules
}

// RemoveLoanScheduleIDs removes the "loanSchedules" edge to the LoanSchedule entity by IDs.
func (m *AccountingEntryMutation) RemoveLoanScheduleIDs(ids ...int) {
	if m.removedloanSchedules == nil {
		m.removedloanSchedules = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.loanSchedules, ids[i])
		m.removedloanSchedules[ids[i]] = struct{}{}
	}
}

// RemovedLoanSchedules returns the removed IDs of the "loanSchedules" edge to the LoanSchedule entity.
func (m *AccountingEntryMutation) RemovedLoanSchedulesIDs() (ids []int) {
	for id := range m.removedloanSchedules {
		ids = append(ids, id)
	}
	return
}

// LoanSchedulesIDs returns the "loanSchedules" edge IDs in the mutation.
func (m *AccountingEntryMutation) LoanSchedulesIDs() (ids []int) {
	for id := range m.loanSchedules {
		ids = append(ids, id)
	}
	return
}

// ResetLoanSchedules resets all changes to the "loanSchedules" edge.
func (m *AccountingEntryMutation) ResetLoanSchedules() {
	m.loanSchedules = nil
	m.clearedloanSchedules = false
	m.removedloanSchedules = nil
}

// Where appends a list predicates to the AccountingEntryMutation builder.
func (m *AccountingEntryMutation) Where(ps ...predicate.AccountingEntry) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AccountingEntryMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AccountingEntryMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.AccountingEntry, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AccountingEntryMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AccountingEntryMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (AccountingEntry).
func (m *AccountingEntryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AccountingEntryMutation) Fields() []string {
	fields := make([]string, 0, 16)
	if m.created_at != nil {
		fields = append(fields, accountingentry.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, accountingentry.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, accountingentry.FieldDeletedAt)
	}
	if m.number != nil {
		fields = append(fields, accountingentry.FieldNumber)
	}
	if m.group != nil {
		fields = append(fields, accountingentry.FieldGroup)
	}
	if m.date != nil {
		fields = append(fields, accountingentry.FieldDate)
	}
	if m.account != nil {
		fields = append(fields, accountingentry.FieldAccount)
	}
	if m.label != nil {
		fields = append(fields, accountingentry.FieldLabel)
	}
	if m.amount != nil {
		fields = append(fields, accountingentry.FieldAmount)
	}
	if m.description != nil {
		fields = append(fields, accountingentry.FieldDescription)
	}
	if m.account_type != nil {
		fields = append(fields, accountingentry.FieldAccountType)
	}
	if m.category != nil {
		fields = append(fields, accountingentry.FieldCategory)
	}
	if m.main != nil {
		fields = append(fields, accountingentry.FieldMain)
	}
	if m.is_debit != nil {
		fields = append(fields, accountingentry.FieldIsDebit)
	}
	if m.is_reversal != nil {
		fields = append(fields, accountingentry.FieldIsReversal)
	}
	if m.reversed != nil {
		fields = append(fields, accountingentry.FieldReversed)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AccountingEntryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case accountingentry.FieldCreatedAt:
		return m.CreatedAt()
	case accountingentry.FieldUpdatedAt:
		return m.UpdatedAt()
	case accountingentry.FieldDeletedAt:
		return m.DeletedAt()
	case accountingentry.FieldNumber:
		return m.Number()
	case accountingentry.FieldGroup:
		return m.Group()
	case accountingentry.FieldDate:
		return m.Date()
	case accountingentry.FieldAccount:
		return m.Account()
	case accountingentry.FieldLabel:
		return m.Label()
	case accountingentry.FieldAmount:
		return m.Amount()
	case accountingentry.FieldDescription:
		return m.Description()
	case accountingentry.FieldAccountType:
		return m.AccountType()
	case accountingentry.FieldCategory:
		return m.Category()
	case accountingentry.FieldMain:
		return m.Main()
	case accountingentry.FieldIsDebit:
		return m.IsDebit()
	case accountingentry.FieldIsReversal:
		return m.IsReversal()
	case accountingentry.FieldReversed:
		return m.Reversed()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AccountingEntryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case accountingentry.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case accountingentry.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case accountingentry.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case accountingentry.FieldNumber:
		return m.OldNumber(ctx)
	case accountingentry.FieldGroup:
		return m.OldGroup(ctx)
	case accountingentry.FieldDate:
		return m.OldDate(ctx)
	case accountingentry.FieldAccount:
		return m.OldAccount(ctx)
	case accountingentry.FieldLabel:
		return m.OldLabel(ctx)
	case accountingentry.FieldAmount:
		return m.OldAmount(ctx)
	case accountingentry.FieldDescription:
		return m.OldDescription(ctx)
	case accountingentry.FieldAccountType:
		return m.OldAccountType(ctx)
	case accountingentry.FieldCategory:
		return m.OldCategory(ctx)
	case accountingentry.FieldMain:
		return m.OldMain(ctx)
	case accountingentry.FieldIsDebit:
		return m.OldIsDebit(ctx)
	case accountingentry.FieldIsReversal:
		return m.OldIsReversal(ctx)
	case accountingentry.FieldReversed:
		return m.OldReversed(ctx)
	}
	return nil, fmt.Errorf("unknown AccountingEntry field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AccountingEntryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case accountingentry.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case accountingentry.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case accountingentry.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case accountingentry.FieldNumber:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNumber(v)
		return nil
	case accountingentry.FieldGroup:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGroup(v)
		return nil
	case accountingentry.FieldDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDate(v)
		return nil
	case accountingentry.FieldAccount:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAccount(v)
		return nil
	case accountingentry.FieldLabel:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLabel(v)
		return nil
	case accountingentry.FieldAmount:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAmount(v)
		return nil
	case accountingentry.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case accountingentry.FieldAccountType:
		v, ok := value.(accountingentry.AccountType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAccountType(v)
		return nil
	case accountingentry.FieldCategory:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCategory(v)
		return nil
	case accountingentry.FieldMain:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMain(v)
		return nil
	case accountingentry.FieldIsDebit:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsDebit(v)
		return nil
	case accountingentry.FieldIsReversal:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsReversal(v)
		return nil
	case accountingentry.FieldReversed:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReversed(v)
		return nil
	}
	return fmt.Errorf("unknown AccountingEntry field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AccountingEntryMutation) AddedFields() []string {
	var fields []string
	if m.addnumber != nil {
		fields = append(fields, accountingentry.FieldNumber)
	}
	if m.addgroup != nil {
		fields = append(fields, accountingentry.FieldGroup)
	}
	if m.addamount != nil {
		fields = append(fields, accountingentry.FieldAmount)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AccountingEntryMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case accountingentry.FieldNumber:
		return m.AddedNumber()
	case accountingentry.FieldGroup:
		return m.AddedGroup()
	case accountingentry.FieldAmount:
		return m.AddedAmount()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AccountingEntryMutation) AddField(name string, value ent.Value) error {
	switch name {
	case accountingentry.FieldNumber:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddNumber(v)
		return nil
	case accountingentry.FieldGroup:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddGroup(v)
		return nil
	case accountingentry.FieldAmount:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAmount(v)
		return nil
	}
	return fmt.Errorf("unknown AccountingEntry numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AccountingEntryMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(accountingentry.FieldDeletedAt) {
		fields = append(fields, accountingentry.FieldDeletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AccountingEntryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AccountingEntryMutation) ClearField(name string) error {
	switch name {
	case accountingentry.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown AccountingEntry nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AccountingEntryMutation) ResetField(name string) error {
	switch name {
	case accountingentry.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case accountingentry.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case accountingentry.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case accountingentry.FieldNumber:
		m.ResetNumber()
		return nil
	case accountingentry.FieldGroup:
		m.ResetGroup()
		return nil
	case accountingentry.FieldDate:
		m.ResetDate()
		return nil
	case accountingentry.FieldAccount:
		m.ResetAccount()
		return nil
	case accountingentry.FieldLabel:
		m.ResetLabel()
		return nil
	case accountingentry.FieldAmount:
		m.ResetAmount()
		return nil
	case accountingentry.FieldDescription:
		m.ResetDescription()
		return nil
	case accountingentry.FieldAccountType:
		m.ResetAccountType()
		return nil
	case accountingentry.FieldCategory:
		m.ResetCategory()
		return nil
	case accountingentry.FieldMain:
		m.ResetMain()
		return nil
	case accountingentry.FieldIsDebit:
		m.ResetIsDebit()
		return nil
	case accountingentry.FieldIsReversal:
		m.ResetIsReversal()
		return nil
	case accountingentry.FieldReversed:
		m.ResetReversed()
		return nil
	}
	return fmt.Errorf("unknown AccountingEntry field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AccountingEntryMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.company != nil {
		edges = append(edges, accountingentry.EdgeCompany)
	}
	if m.user != nil {
		edges = append(edges, accountingentry.EdgeUser)
	}
	if m.loan != nil {
		edges = append(edges, accountingentry.EdgeLoan)
	}
	if m.loanSchedules != nil {
		edges = append(edges, accountingentry.EdgeLoanSchedules)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AccountingEntryMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case accountingentry.EdgeCompany:
		if id := m.company; id != nil {
			return []ent.Value{*id}
		}
	case accountingentry.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case accountingentry.EdgeLoan:
		if id := m.loan; id != nil {
			return []ent.Value{*id}
		}
	case accountingentry.EdgeLoanSchedules:
		ids := make([]ent.Value, 0, len(m.loanSchedules))
		for id := range m.loanSchedules {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AccountingEntryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedloanSchedules != nil {
		edges = append(edges, accountingentry.EdgeLoanSchedules)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AccountingEntryMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case accountingentry.EdgeLoanSchedules:
		ids := make([]ent.Value, 0, len(m.removedloanSchedules))
		for id := range m.removedloanSchedules {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AccountingEntryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedcompany {
		edges = append(edges, accountingentry.EdgeCompany)
	}
	if m.cleareduser {
		edges = append(edges, accountingentry.EdgeUser)
	}
	if m.clearedloan {
		edges = append(edges, accountingentry.EdgeLoan)
	}
	if m.clearedloanSchedules {
		edges = append(edges, accountingentry.EdgeLoanSchedules)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AccountingEntryMutation) EdgeCleared(name string) bool {
	switch name {
	case accountingentry.EdgeCompany:
		return m.clearedcompany
	case accountingentry.EdgeUser:
		return m.cleareduser
	case accountingentry.EdgeLoan:
		return m.clearedloan
	case accountingentry.EdgeLoanSchedules:
		return m.clearedloanSchedules
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AccountingEntryMutation) ClearEdge(name string) error {
	switch name {
	case accountingentry.EdgeCompany:
		m.ClearCompany()
		return nil
	case accountingentry.EdgeUser:
		m.ClearUser()
		return nil
	case accountingentry.EdgeLoan:
		m.ClearLoan()
		return nil
	}
	return fmt.Errorf("unknown AccountingEntry unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AccountingEntryMutation) ResetEdge(name string) error {
	switch name {
	case accountingentry.EdgeCompany:
		m.ResetCompany()
		return nil
	case accountingentry.EdgeUser:
		m.ResetUser()
		return nil
	case accountingentry.EdgeLoan:
		m.ResetLoan()
		return nil
	case accountingentry.EdgeLoanSchedules:
		m.ResetLoanSchedules()
		return nil
	}
	return fmt.Errorf("unknown AccountingEntry edge %s", name)
}

// CalendarMutation represents an operation that mutates the Calendar nodes in the graph.
type CalendarMutation struct {
	config
	op            Op
	typ           string
	id            *int
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Calendar, error)
	predicates    []predicate.Calendar
}

var _ ent.Mutation = (*CalendarMutation)(nil)

// calendarOption allows management of the mutation configuration using functional options.
type calendarOption func(*CalendarMutation)

// newCalendarMutation creates new mutation for the Calendar entity.
func newCalendarMutation(c config, op Op, opts ...calendarOption) *CalendarMutation {
	m := &CalendarMutation{
		config:        c,
		op:            op,
		typ:           TypeCalendar,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCalendarID sets the ID field of the mutation.
func withCalendarID(id int) calendarOption {
	return func(m *CalendarMutation) {
		var (
			err   error
			once  sync.Once
			value *Calendar
		)
		m.oldValue = func(ctx context.Context) (*Calendar, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Calendar.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCalendar sets the old Calendar of the mutation.
func withCalendar(node *Calendar) calendarOption {
	return func(m *CalendarMutation) {
		m.oldValue = func(context.Context) (*Calendar, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CalendarMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CalendarMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("generated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CalendarMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CalendarMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Calendar.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// Where appends a list predicates to the CalendarMutation builder.
func (m *CalendarMutation) Where(ps ...predicate.Calendar) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CalendarMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CalendarMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Calendar, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CalendarMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CalendarMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Calendar).
func (m *CalendarMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CalendarMutation) Fields() []string {
	fields := make([]string, 0, 0)
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CalendarMutation) Field(name string) (ent.Value, bool) {
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CalendarMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	return nil, fmt.Errorf("unknown Calendar field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CalendarMutation) SetField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Calendar field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CalendarMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CalendarMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CalendarMutation) AddField(name string, value ent.Value) error {
	return fmt.Errorf("unknown Calendar numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CalendarMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CalendarMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CalendarMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Calendar nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CalendarMutation) ResetField(name string) error {
	return fmt.Errorf("unknown Calendar field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CalendarMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CalendarMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CalendarMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CalendarMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CalendarMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CalendarMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CalendarMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Calendar unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CalendarMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Calendar edge %s", name)
}

// CompanyMutation represents an operation that mutates the Company nodes in the graph.
type CompanyMutation struct {
	config
	op                          Op
	typ                         string
	id                          *int
	created_at                  *time.Time
	updated_at                  *time.Time
	deleted_at                  *time.Time
	address                     *string
	base_currency               *string
	ceo_name                    *string
	city                        *string
	country                     *string
	established_at              *time.Time
	description                 *string
	email                       *string
	industry                    *string
	last_entry_date             *time.Time
	last_invoice_number         *int32
	addlast_invoice_number      *int32
	logo_URL                    *string
	logo_storage_URI            *string
	name                        *string
	number_employees            *int32
	addnumber_employees         *int32
	phone                       *string
	tax_id                      *string
	vat_rate                    *float64
	addvat_rate                 *float64
	website                     *string
	incomplete_setup            *bool
	clearedFields               map[string]struct{}
	available_roles             map[int]struct{}
	removedavailable_roles      map[int]struct{}
	clearedavailable_roles      bool
	accounting_entries          map[int]struct{}
	removedaccounting_entries   map[int]struct{}
	clearedaccounting_entries   bool
	customers                   map[int]struct{}
	removedcustomers            map[int]struct{}
	clearedcustomers            bool
	documents                   map[int]struct{}
	removeddocuments            map[int]struct{}
	cleareddocuments            bool
	employees                   map[int]struct{}
	removedemployees            map[int]struct{}
	clearedemployees            bool
	files                       map[int]struct{}
	removedfiles                map[int]struct{}
	clearedfiles                bool
	inventory                   map[int]struct{}
	removedinventory            map[int]struct{}
	clearedinventory            bool
	inventory_movements         map[int]struct{}
	removedinventory_movements  map[int]struct{}
	clearedinventory_movements  bool
	invoices                    map[int]struct{}
	removedinvoices             map[int]struct{}
	clearedinvoices             bool
	loans                       map[int]struct{}
	removedloans                map[int]struct{}
	clearedloans                bool
	loan_schedule               map[int]struct{}
	removedloan_schedule        map[int]struct{}
	clearedloan_schedule        bool
	member_signup_tokens        map[int]struct{}
	removedmember_signup_tokens map[int]struct{}
	clearedmember_signup_tokens bool
	products                    map[int]struct{}
	removedproducts             map[int]struct{}
	clearedproducts             bool
	projects                    map[int]struct{}
	removedprojects             map[int]struct{}
	clearedprojects             bool
	payables                    map[int]struct{}
	removedpayables             map[int]struct{}
	clearedpayables             bool
	receivables                 map[int]struct{}
	removedreceivables          map[int]struct{}
	clearedreceivables          bool
	suppliers                   map[int]struct{}
	removedsuppliers            map[int]struct{}
	clearedsuppliers            bool
	tokens                      map[int]struct{}
	removedtokens               map[int]struct{}
	clearedtokens               bool
	treasuries                  map[int]struct{}
	removedtreasuries           map[int]struct{}
	clearedtreasuries           bool
	work_shifts                 map[int]struct{}
	removedwork_shifts          map[int]struct{}
	clearedwork_shifts          bool
	users                       map[int]struct{}
	removedusers                map[int]struct{}
	clearedusers                bool
	daughter_companies          map[int]struct{}
	removeddaughter_companies   map[int]struct{}
	cleareddaughter_companies   bool
	parent_company              *int
	clearedparent_company       bool
	done                        bool
	oldValue                    func(context.Context) (*Company, error)
	predicates                  []predicate.Company
}

var _ ent.Mutation = (*CompanyMutation)(nil)

// companyOption allows management of the mutation configuration using functional options.
type companyOption func(*CompanyMutation)

// newCompanyMutation creates new mutation for the Company entity.
func newCompanyMutation(c config, op Op, opts ...companyOption) *CompanyMutation {
	m := &CompanyMutation{
		config:        c,
		op:            op,
		typ:           TypeCompany,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCompanyID sets the ID field of the mutation.
func withCompanyID(id int) companyOption {
	return func(m *CompanyMutation) {
		var (
			err   error
			once  sync.Once
			value *Company
		)
		m.oldValue = func(ctx context.Context) (*Company, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Company.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCompany sets the old Company of the mutation.
func withCompany(node *Company) companyOption {
	return func(m *CompanyMutation) {
		m.oldValue = func(context.Context) (*Company, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CompanyMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CompanyMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("generated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CompanyMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CompanyMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Company.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *CompanyMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *CompanyMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Company entity.
// If the Company object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CompanyMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *CompanyMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *CompanyMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *CompanyMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Company entity.
// If the Company object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CompanyMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *CompanyMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *CompanyMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *CompanyMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Company entity.
// If the Company object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CompanyMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *CompanyMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[company.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *CompanyMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[company.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *CompanyMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, company.FieldDeletedAt)
}

// SetAddress sets the "address" field.
func (m *CompanyMutation) SetAddress(s string) {
	m.address = &s
}

// Address returns the value of the "address" field in the mutation.
func (m *CompanyMutation) Address() (r string, exists bool) {
	v := m.address
	if v == nil {
		return
	}
	return *v, true
}

// OldAddress returns the old "address" field's value of the Company entity.
// If the Company object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CompanyMutation) OldAddress(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAddress: %w", err)
	}
	return oldValue.Address, nil
}

// ClearAddress clears the value of the "address" field.
func (m *CompanyMutation) ClearAddress() {
	m.address = nil
	m.clearedFields[company.FieldAddress] = struct{}{}
}

// AddressCleared returns if the "address" field was cleared in this mutation.
func (m *CompanyMutation) AddressCleared() bool {
	_, ok := m.clearedFields[company.FieldAddress]
	return ok
}

// ResetAddress resets all changes to the "address" field.
func (m *CompanyMutation) ResetAddress() {
	m.address = nil
	delete(m.clearedFields, company.FieldAddress)
}

// SetBaseCurrency sets the "base_currency" field.
func (m *CompanyMutation) SetBaseCurrency(s string) {
	m.base_currency = &s
}

// BaseCurrency returns the value of the "base_currency" field in the mutation.
func (m *CompanyMutation) BaseCurrency() (r string, exists bool) {
	v := m.base_currency
	if v == nil {
		return
	}
	return *v, true
}

// OldBaseCurrency returns the old "base_currency" field's value of the Company entity.
// If the Company object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CompanyMutation) OldBaseCurrency(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBaseCurrency is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBaseCurrency requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBaseCurrency: %w", err)
	}
	return oldValue.BaseCurrency, nil
}

// ResetBaseCurrency resets all changes to the "base_currency" field.
func (m *CompanyMutation) ResetBaseCurrency() {
	m.base_currency = nil
}

// SetCeoName sets the "ceo_name" field.
func (m *CompanyMutation) SetCeoName(s string) {
	m.ceo_name = &s
}

// CeoName returns the value of the "ceo_name" field in the mutation.
func (m *CompanyMutation) CeoName() (r string, exists bool) {
	v := m.ceo_name
	if v == nil {
		return
	}
	return *v, true
}

// OldCeoName returns the old "ceo_name" field's value of the Company entity.
// If the Company object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CompanyMutation) OldCeoName(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCeoName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCeoName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCeoName: %w", err)
	}
	return oldValue.CeoName, nil
}

// ClearCeoName clears the value of the "ceo_name" field.
func (m *CompanyMutation) ClearCeoName() {
	m.ceo_name = nil
	m.clearedFields[company.FieldCeoName] = struct{}{}
}

// CeoNameCleared returns if the "ceo_name" field was cleared in this mutation.
func (m *CompanyMutation) CeoNameCleared() bool {
	_, ok := m.clearedFields[company.FieldCeoName]
	return ok
}

// ResetCeoName resets all changes to the "ceo_name" field.
func (m *CompanyMutation) ResetCeoName() {
	m.ceo_name = nil
	delete(m.clearedFields, company.FieldCeoName)
}

// SetCity sets the "city" field.
func (m *CompanyMutation) SetCity(s string) {
	m.city = &s
}

// City returns the value of the "city" field in the mutation.
func (m *CompanyMutation) City() (r string, exists bool) {
	v := m.city
	if v == nil {
		return
	}
	return *v, true
}

// OldCity returns the old "city" field's value of the Company entity.
// If the Company object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CompanyMutation) OldCity(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCity: %w", err)
	}
	return oldValue.City, nil
}

// ResetCity resets all changes to the "city" field.
func (m *CompanyMutation) ResetCity() {
	m.city = nil
}

// SetCountry sets the "country" field.
func (m *CompanyMutation) SetCountry(s string) {
	m.country = &s
}

// Country returns the value of the "country" field in the mutation.
func (m *CompanyMutation) Country() (r string, exists bool) {
	v := m.country
	if v == nil {
		return
	}
	return *v, true
}

// OldCountry returns the old "country" field's value of the Company entity.
// If the Company object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CompanyMutation) OldCountry(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCountry is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCountry requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCountry: %w", err)
	}
	return oldValue.Country, nil
}

// ResetCountry resets all changes to the "country" field.
func (m *CompanyMutation) ResetCountry() {
	m.country = nil
}

// SetEstablishedAt sets the "established_at" field.
func (m *CompanyMutation) SetEstablishedAt(t time.Time) {
	m.established_at = &t
}

// EstablishedAt returns the value of the "established_at" field in the mutation.
func (m *CompanyMutation) EstablishedAt() (r time.Time, exists bool) {
	v := m.established_at
	if v == nil {
		return
	}
	return *v, true
}

// OldEstablishedAt returns the old "established_at" field's value of the Company entity.
// If the Company object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CompanyMutation) OldEstablishedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEstablishedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEstablishedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEstablishedAt: %w", err)
	}
	return oldValue.EstablishedAt, nil
}

// ResetEstablishedAt resets all changes to the "established_at" field.
func (m *CompanyMutation) ResetEstablishedAt() {
	m.established_at = nil
}

// SetDescription sets the "description" field.
func (m *CompanyMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *CompanyMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Company entity.
// If the Company object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CompanyMutation) OldDescription(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *CompanyMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[company.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *CompanyMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[company.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *CompanyMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, company.FieldDescription)
}

// SetEmail sets the "email" field.
func (m *CompanyMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *CompanyMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the Company entity.
// If the Company object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CompanyMutation) OldEmail(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ClearEmail clears the value of the "email" field.
func (m *CompanyMutation) ClearEmail() {
	m.email = nil
	m.clearedFields[company.FieldEmail] = struct{}{}
}

// EmailCleared returns if the "email" field was cleared in this mutation.
func (m *CompanyMutation) EmailCleared() bool {
	_, ok := m.clearedFields[company.FieldEmail]
	return ok
}

// ResetEmail resets all changes to the "email" field.
func (m *CompanyMutation) ResetEmail() {
	m.email = nil
	delete(m.clearedFields, company.FieldEmail)
}

// SetIndustry sets the "industry" field.
func (m *CompanyMutation) SetIndustry(s string) {
	m.industry = &s
}

// Industry returns the value of the "industry" field in the mutation.
func (m *CompanyMutation) Industry() (r string, exists bool) {
	v := m.industry
	if v == nil {
		return
	}
	return *v, true
}

// OldIndustry returns the old "industry" field's value of the Company entity.
// If the Company object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CompanyMutation) OldIndustry(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIndustry is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIndustry requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIndustry: %w", err)
	}
	return oldValue.Industry, nil
}

// ClearIndustry clears the value of the "industry" field.
func (m *CompanyMutation) ClearIndustry() {
	m.industry = nil
	m.clearedFields[company.FieldIndustry] = struct{}{}
}

// IndustryCleared returns if the "industry" field was cleared in this mutation.
func (m *CompanyMutation) IndustryCleared() bool {
	_, ok := m.clearedFields[company.FieldIndustry]
	return ok
}

// ResetIndustry resets all changes to the "industry" field.
func (m *CompanyMutation) ResetIndustry() {
	m.industry = nil
	delete(m.clearedFields, company.FieldIndustry)
}

// SetLastEntryDate sets the "last_entry_date" field.
func (m *CompanyMutation) SetLastEntryDate(t time.Time) {
	m.last_entry_date = &t
}

// LastEntryDate returns the value of the "last_entry_date" field in the mutation.
func (m *CompanyMutation) LastEntryDate() (r time.Time, exists bool) {
	v := m.last_entry_date
	if v == nil {
		return
	}
	return *v, true
}

// OldLastEntryDate returns the old "last_entry_date" field's value of the Company entity.
// If the Company object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CompanyMutation) OldLastEntryDate(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastEntryDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastEntryDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastEntryDate: %w", err)
	}
	return oldValue.LastEntryDate, nil
}

// ClearLastEntryDate clears the value of the "last_entry_date" field.
func (m *CompanyMutation) ClearLastEntryDate() {
	m.last_entry_date = nil
	m.clearedFields[company.FieldLastEntryDate] = struct{}{}
}

// LastEntryDateCleared returns if the "last_entry_date" field was cleared in this mutation.
func (m *CompanyMutation) LastEntryDateCleared() bool {
	_, ok := m.clearedFields[company.FieldLastEntryDate]
	return ok
}

// ResetLastEntryDate resets all changes to the "last_entry_date" field.
func (m *CompanyMutation) ResetLastEntryDate() {
	m.last_entry_date = nil
	delete(m.clearedFields, company.FieldLastEntryDate)
}

// SetLastInvoiceNumber sets the "last_invoice_number" field.
func (m *CompanyMutation) SetLastInvoiceNumber(i int32) {
	m.last_invoice_number = &i
	m.addlast_invoice_number = nil
}

// LastInvoiceNumber returns the value of the "last_invoice_number" field in the mutation.
func (m *CompanyMutation) LastInvoiceNumber() (r int32, exists bool) {
	v := m.last_invoice_number
	if v == nil {
		return
	}
	return *v, true
}

// OldLastInvoiceNumber returns the old "last_invoice_number" field's value of the Company entity.
// If the Company object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CompanyMutation) OldLastInvoiceNumber(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastInvoiceNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastInvoiceNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastInvoiceNumber: %w", err)
	}
	return oldValue.LastInvoiceNumber, nil
}

// AddLastInvoiceNumber adds i to the "last_invoice_number" field.
func (m *CompanyMutation) AddLastInvoiceNumber(i int32) {
	if m.addlast_invoice_number != nil {
		*m.addlast_invoice_number += i
	} else {
		m.addlast_invoice_number = &i
	}
}

// AddedLastInvoiceNumber returns the value that was added to the "last_invoice_number" field in this mutation.
func (m *CompanyMutation) AddedLastInvoiceNumber() (r int32, exists bool) {
	v := m.addlast_invoice_number
	if v == nil {
		return
	}
	return *v, true
}

// ClearLastInvoiceNumber clears the value of the "last_invoice_number" field.
func (m *CompanyMutation) ClearLastInvoiceNumber() {
	m.last_invoice_number = nil
	m.addlast_invoice_number = nil
	m.clearedFields[company.FieldLastInvoiceNumber] = struct{}{}
}

// LastInvoiceNumberCleared returns if the "last_invoice_number" field was cleared in this mutation.
func (m *CompanyMutation) LastInvoiceNumberCleared() bool {
	_, ok := m.clearedFields[company.FieldLastInvoiceNumber]
	return ok
}

// ResetLastInvoiceNumber resets all changes to the "last_invoice_number" field.
func (m *CompanyMutation) ResetLastInvoiceNumber() {
	m.last_invoice_number = nil
	m.addlast_invoice_number = nil
	delete(m.clearedFields, company.FieldLastInvoiceNumber)
}

// SetLogoURL sets the "logo_URL" field.
func (m *CompanyMutation) SetLogoURL(s string) {
	m.logo_URL = &s
}

// LogoURL returns the value of the "logo_URL" field in the mutation.
func (m *CompanyMutation) LogoURL() (r string, exists bool) {
	v := m.logo_URL
	if v == nil {
		return
	}
	return *v, true
}

// OldLogoURL returns the old "logo_URL" field's value of the Company entity.
// If the Company object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CompanyMutation) OldLogoURL(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLogoURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLogoURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLogoURL: %w", err)
	}
	return oldValue.LogoURL, nil
}

// ClearLogoURL clears the value of the "logo_URL" field.
func (m *CompanyMutation) ClearLogoURL() {
	m.logo_URL = nil
	m.clearedFields[company.FieldLogoURL] = struct{}{}
}

// LogoURLCleared returns if the "logo_URL" field was cleared in this mutation.
func (m *CompanyMutation) LogoURLCleared() bool {
	_, ok := m.clearedFields[company.FieldLogoURL]
	return ok
}

// ResetLogoURL resets all changes to the "logo_URL" field.
func (m *CompanyMutation) ResetLogoURL() {
	m.logo_URL = nil
	delete(m.clearedFields, company.FieldLogoURL)
}

// SetLogoStorageURI sets the "logo_storage_URI" field.
func (m *CompanyMutation) SetLogoStorageURI(s string) {
	m.logo_storage_URI = &s
}

// LogoStorageURI returns the value of the "logo_storage_URI" field in the mutation.
func (m *CompanyMutation) LogoStorageURI() (r string, exists bool) {
	v := m.logo_storage_URI
	if v == nil {
		return
	}
	return *v, true
}

// OldLogoStorageURI returns the old "logo_storage_URI" field's value of the Company entity.
// If the Company object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CompanyMutation) OldLogoStorageURI(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLogoStorageURI is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLogoStorageURI requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLogoStorageURI: %w", err)
	}
	return oldValue.LogoStorageURI, nil
}

// ClearLogoStorageURI clears the value of the "logo_storage_URI" field.
func (m *CompanyMutation) ClearLogoStorageURI() {
	m.logo_storage_URI = nil
	m.clearedFields[company.FieldLogoStorageURI] = struct{}{}
}

// LogoStorageURICleared returns if the "logo_storage_URI" field was cleared in this mutation.
func (m *CompanyMutation) LogoStorageURICleared() bool {
	_, ok := m.clearedFields[company.FieldLogoStorageURI]
	return ok
}

// ResetLogoStorageURI resets all changes to the "logo_storage_URI" field.
func (m *CompanyMutation) ResetLogoStorageURI() {
	m.logo_storage_URI = nil
	delete(m.clearedFields, company.FieldLogoStorageURI)
}

// SetName sets the "name" field.
func (m *CompanyMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *CompanyMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Company entity.
// If the Company object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CompanyMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *CompanyMutation) ResetName() {
	m.name = nil
}

// SetNumberEmployees sets the "number_employees" field.
func (m *CompanyMutation) SetNumberEmployees(i int32) {
	m.number_employees = &i
	m.addnumber_employees = nil
}

// NumberEmployees returns the value of the "number_employees" field in the mutation.
func (m *CompanyMutation) NumberEmployees() (r int32, exists bool) {
	v := m.number_employees
	if v == nil {
		return
	}
	return *v, true
}

// OldNumberEmployees returns the old "number_employees" field's value of the Company entity.
// If the Company object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CompanyMutation) OldNumberEmployees(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNumberEmployees is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNumberEmployees requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNumberEmployees: %w", err)
	}
	return oldValue.NumberEmployees, nil
}

// AddNumberEmployees adds i to the "number_employees" field.
func (m *CompanyMutation) AddNumberEmployees(i int32) {
	if m.addnumber_employees != nil {
		*m.addnumber_employees += i
	} else {
		m.addnumber_employees = &i
	}
}

// AddedNumberEmployees returns the value that was added to the "number_employees" field in this mutation.
func (m *CompanyMutation) AddedNumberEmployees() (r int32, exists bool) {
	v := m.addnumber_employees
	if v == nil {
		return
	}
	return *v, true
}

// ResetNumberEmployees resets all changes to the "number_employees" field.
func (m *CompanyMutation) ResetNumberEmployees() {
	m.number_employees = nil
	m.addnumber_employees = nil
}

// SetPhone sets the "phone" field.
func (m *CompanyMutation) SetPhone(s string) {
	m.phone = &s
}

// Phone returns the value of the "phone" field in the mutation.
func (m *CompanyMutation) Phone() (r string, exists bool) {
	v := m.phone
	if v == nil {
		return
	}
	return *v, true
}

// OldPhone returns the old "phone" field's value of the Company entity.
// If the Company object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CompanyMutation) OldPhone(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPhone is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPhone requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPhone: %w", err)
	}
	return oldValue.Phone, nil
}

// ClearPhone clears the value of the "phone" field.
func (m *CompanyMutation) ClearPhone() {
	m.phone = nil
	m.clearedFields[company.FieldPhone] = struct{}{}
}

// PhoneCleared returns if the "phone" field was cleared in this mutation.
func (m *CompanyMutation) PhoneCleared() bool {
	_, ok := m.clearedFields[company.FieldPhone]
	return ok
}

// ResetPhone resets all changes to the "phone" field.
func (m *CompanyMutation) ResetPhone() {
	m.phone = nil
	delete(m.clearedFields, company.FieldPhone)
}

// SetTaxID sets the "tax_id" field.
func (m *CompanyMutation) SetTaxID(s string) {
	m.tax_id = &s
}

// TaxID returns the value of the "tax_id" field in the mutation.
func (m *CompanyMutation) TaxID() (r string, exists bool) {
	v := m.tax_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTaxID returns the old "tax_id" field's value of the Company entity.
// If the Company object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CompanyMutation) OldTaxID(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTaxID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTaxID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTaxID: %w", err)
	}
	return oldValue.TaxID, nil
}

// ClearTaxID clears the value of the "tax_id" field.
func (m *CompanyMutation) ClearTaxID() {
	m.tax_id = nil
	m.clearedFields[company.FieldTaxID] = struct{}{}
}

// TaxIDCleared returns if the "tax_id" field was cleared in this mutation.
func (m *CompanyMutation) TaxIDCleared() bool {
	_, ok := m.clearedFields[company.FieldTaxID]
	return ok
}

// ResetTaxID resets all changes to the "tax_id" field.
func (m *CompanyMutation) ResetTaxID() {
	m.tax_id = nil
	delete(m.clearedFields, company.FieldTaxID)
}

// SetVatRate sets the "vat_rate" field.
func (m *CompanyMutation) SetVatRate(f float64) {
	m.vat_rate = &f
	m.addvat_rate = nil
}

// VatRate returns the value of the "vat_rate" field in the mutation.
func (m *CompanyMutation) VatRate() (r float64, exists bool) {
	v := m.vat_rate
	if v == nil {
		return
	}
	return *v, true
}

// OldVatRate returns the old "vat_rate" field's value of the Company entity.
// If the Company object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CompanyMutation) OldVatRate(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVatRate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVatRate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVatRate: %w", err)
	}
	return oldValue.VatRate, nil
}

// AddVatRate adds f to the "vat_rate" field.
func (m *CompanyMutation) AddVatRate(f float64) {
	if m.addvat_rate != nil {
		*m.addvat_rate += f
	} else {
		m.addvat_rate = &f
	}
}

// AddedVatRate returns the value that was added to the "vat_rate" field in this mutation.
func (m *CompanyMutation) AddedVatRate() (r float64, exists bool) {
	v := m.addvat_rate
	if v == nil {
		return
	}
	return *v, true
}

// ResetVatRate resets all changes to the "vat_rate" field.
func (m *CompanyMutation) ResetVatRate() {
	m.vat_rate = nil
	m.addvat_rate = nil
}

// SetWebsite sets the "website" field.
func (m *CompanyMutation) SetWebsite(s string) {
	m.website = &s
}

// Website returns the value of the "website" field in the mutation.
func (m *CompanyMutation) Website() (r string, exists bool) {
	v := m.website
	if v == nil {
		return
	}
	return *v, true
}

// OldWebsite returns the old "website" field's value of the Company entity.
// If the Company object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CompanyMutation) OldWebsite(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWebsite is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWebsite requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWebsite: %w", err)
	}
	return oldValue.Website, nil
}

// ClearWebsite clears the value of the "website" field.
func (m *CompanyMutation) ClearWebsite() {
	m.website = nil
	m.clearedFields[company.FieldWebsite] = struct{}{}
}

// WebsiteCleared returns if the "website" field was cleared in this mutation.
func (m *CompanyMutation) WebsiteCleared() bool {
	_, ok := m.clearedFields[company.FieldWebsite]
	return ok
}

// ResetWebsite resets all changes to the "website" field.
func (m *CompanyMutation) ResetWebsite() {
	m.website = nil
	delete(m.clearedFields, company.FieldWebsite)
}

// SetIncompleteSetup sets the "incomplete_setup" field.
func (m *CompanyMutation) SetIncompleteSetup(b bool) {
	m.incomplete_setup = &b
}

// IncompleteSetup returns the value of the "incomplete_setup" field in the mutation.
func (m *CompanyMutation) IncompleteSetup() (r bool, exists bool) {
	v := m.incomplete_setup
	if v == nil {
		return
	}
	return *v, true
}

// OldIncompleteSetup returns the old "incomplete_setup" field's value of the Company entity.
// If the Company object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CompanyMutation) OldIncompleteSetup(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIncompleteSetup is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIncompleteSetup requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIncompleteSetup: %w", err)
	}
	return oldValue.IncompleteSetup, nil
}

// ClearIncompleteSetup clears the value of the "incomplete_setup" field.
func (m *CompanyMutation) ClearIncompleteSetup() {
	m.incomplete_setup = nil
	m.clearedFields[company.FieldIncompleteSetup] = struct{}{}
}

// IncompleteSetupCleared returns if the "incomplete_setup" field was cleared in this mutation.
func (m *CompanyMutation) IncompleteSetupCleared() bool {
	_, ok := m.clearedFields[company.FieldIncompleteSetup]
	return ok
}

// ResetIncompleteSetup resets all changes to the "incomplete_setup" field.
func (m *CompanyMutation) ResetIncompleteSetup() {
	m.incomplete_setup = nil
	delete(m.clearedFields, company.FieldIncompleteSetup)
}

// AddAvailableRoleIDs adds the "available_roles" edge to the UserRole entity by ids.
func (m *CompanyMutation) AddAvailableRoleIDs(ids ...int) {
	if m.available_roles == nil {
		m.available_roles = make(map[int]struct{})
	}
	for i := range ids {
		m.available_roles[ids[i]] = struct{}{}
	}
}

// ClearAvailableRoles clears the "available_roles" edge to the UserRole entity.
func (m *CompanyMutation) ClearAvailableRoles() {
	m.clearedavailable_roles = true
}

// AvailableRolesCleared reports if the "available_roles" edge to the UserRole entity was cleared.
func (m *CompanyMutation) AvailableRolesCleared() bool {
	return m.clearedavailable_roles
}

// RemoveAvailableRoleIDs removes the "available_roles" edge to the UserRole entity by IDs.
func (m *CompanyMutation) RemoveAvailableRoleIDs(ids ...int) {
	if m.removedavailable_roles == nil {
		m.removedavailable_roles = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.available_roles, ids[i])
		m.removedavailable_roles[ids[i]] = struct{}{}
	}
}

// RemovedAvailableRoles returns the removed IDs of the "available_roles" edge to the UserRole entity.
func (m *CompanyMutation) RemovedAvailableRolesIDs() (ids []int) {
	for id := range m.removedavailable_roles {
		ids = append(ids, id)
	}
	return
}

// AvailableRolesIDs returns the "available_roles" edge IDs in the mutation.
func (m *CompanyMutation) AvailableRolesIDs() (ids []int) {
	for id := range m.available_roles {
		ids = append(ids, id)
	}
	return
}

// ResetAvailableRoles resets all changes to the "available_roles" edge.
func (m *CompanyMutation) ResetAvailableRoles() {
	m.available_roles = nil
	m.clearedavailable_roles = false
	m.removedavailable_roles = nil
}

// AddAccountingEntryIDs adds the "accounting_entries" edge to the AccountingEntry entity by ids.
func (m *CompanyMutation) AddAccountingEntryIDs(ids ...int) {
	if m.accounting_entries == nil {
		m.accounting_entries = make(map[int]struct{})
	}
	for i := range ids {
		m.accounting_entries[ids[i]] = struct{}{}
	}
}

// ClearAccountingEntries clears the "accounting_entries" edge to the AccountingEntry entity.
func (m *CompanyMutation) ClearAccountingEntries() {
	m.clearedaccounting_entries = true
}

// AccountingEntriesCleared reports if the "accounting_entries" edge to the AccountingEntry entity was cleared.
func (m *CompanyMutation) AccountingEntriesCleared() bool {
	return m.clearedaccounting_entries
}

// RemoveAccountingEntryIDs removes the "accounting_entries" edge to the AccountingEntry entity by IDs.
func (m *CompanyMutation) RemoveAccountingEntryIDs(ids ...int) {
	if m.removedaccounting_entries == nil {
		m.removedaccounting_entries = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.accounting_entries, ids[i])
		m.removedaccounting_entries[ids[i]] = struct{}{}
	}
}

// RemovedAccountingEntries returns the removed IDs of the "accounting_entries" edge to the AccountingEntry entity.
func (m *CompanyMutation) RemovedAccountingEntriesIDs() (ids []int) {
	for id := range m.removedaccounting_entries {
		ids = append(ids, id)
	}
	return
}

// AccountingEntriesIDs returns the "accounting_entries" edge IDs in the mutation.
func (m *CompanyMutation) AccountingEntriesIDs() (ids []int) {
	for id := range m.accounting_entries {
		ids = append(ids, id)
	}
	return
}

// ResetAccountingEntries resets all changes to the "accounting_entries" edge.
func (m *CompanyMutation) ResetAccountingEntries() {
	m.accounting_entries = nil
	m.clearedaccounting_entries = false
	m.removedaccounting_entries = nil
}

// AddCustomerIDs adds the "customers" edge to the Customer entity by ids.
func (m *CompanyMutation) AddCustomerIDs(ids ...int) {
	if m.customers == nil {
		m.customers = make(map[int]struct{})
	}
	for i := range ids {
		m.customers[ids[i]] = struct{}{}
	}
}

// ClearCustomers clears the "customers" edge to the Customer entity.
func (m *CompanyMutation) ClearCustomers() {
	m.clearedcustomers = true
}

// CustomersCleared reports if the "customers" edge to the Customer entity was cleared.
func (m *CompanyMutation) CustomersCleared() bool {
	return m.clearedcustomers
}

// RemoveCustomerIDs removes the "customers" edge to the Customer entity by IDs.
func (m *CompanyMutation) RemoveCustomerIDs(ids ...int) {
	if m.removedcustomers == nil {
		m.removedcustomers = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.customers, ids[i])
		m.removedcustomers[ids[i]] = struct{}{}
	}
}

// RemovedCustomers returns the removed IDs of the "customers" edge to the Customer entity.
func (m *CompanyMutation) RemovedCustomersIDs() (ids []int) {
	for id := range m.removedcustomers {
		ids = append(ids, id)
	}
	return
}

// CustomersIDs returns the "customers" edge IDs in the mutation.
func (m *CompanyMutation) CustomersIDs() (ids []int) {
	for id := range m.customers {
		ids = append(ids, id)
	}
	return
}

// ResetCustomers resets all changes to the "customers" edge.
func (m *CompanyMutation) ResetCustomers() {
	m.customers = nil
	m.clearedcustomers = false
	m.removedcustomers = nil
}

// AddDocumentIDs adds the "documents" edge to the CompanyDocument entity by ids.
func (m *CompanyMutation) AddDocumentIDs(ids ...int) {
	if m.documents == nil {
		m.documents = make(map[int]struct{})
	}
	for i := range ids {
		m.documents[ids[i]] = struct{}{}
	}
}

// ClearDocuments clears the "documents" edge to the CompanyDocument entity.
func (m *CompanyMutation) ClearDocuments() {
	m.cleareddocuments = true
}

// DocumentsCleared reports if the "documents" edge to the CompanyDocument entity was cleared.
func (m *CompanyMutation) DocumentsCleared() bool {
	return m.cleareddocuments
}

// RemoveDocumentIDs removes the "documents" edge to the CompanyDocument entity by IDs.
func (m *CompanyMutation) RemoveDocumentIDs(ids ...int) {
	if m.removeddocuments == nil {
		m.removeddocuments = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.documents, ids[i])
		m.removeddocuments[ids[i]] = struct{}{}
	}
}

// RemovedDocuments returns the removed IDs of the "documents" edge to the CompanyDocument entity.
func (m *CompanyMutation) RemovedDocumentsIDs() (ids []int) {
	for id := range m.removeddocuments {
		ids = append(ids, id)
	}
	return
}

// DocumentsIDs returns the "documents" edge IDs in the mutation.
func (m *CompanyMutation) DocumentsIDs() (ids []int) {
	for id := range m.documents {
		ids = append(ids, id)
	}
	return
}

// ResetDocuments resets all changes to the "documents" edge.
func (m *CompanyMutation) ResetDocuments() {
	m.documents = nil
	m.cleareddocuments = false
	m.removeddocuments = nil
}

// AddEmployeeIDs adds the "employees" edge to the Employee entity by ids.
func (m *CompanyMutation) AddEmployeeIDs(ids ...int) {
	if m.employees == nil {
		m.employees = make(map[int]struct{})
	}
	for i := range ids {
		m.employees[ids[i]] = struct{}{}
	}
}

// ClearEmployees clears the "employees" edge to the Employee entity.
func (m *CompanyMutation) ClearEmployees() {
	m.clearedemployees = true
}

// EmployeesCleared reports if the "employees" edge to the Employee entity was cleared.
func (m *CompanyMutation) EmployeesCleared() bool {
	return m.clearedemployees
}

// RemoveEmployeeIDs removes the "employees" edge to the Employee entity by IDs.
func (m *CompanyMutation) RemoveEmployeeIDs(ids ...int) {
	if m.removedemployees == nil {
		m.removedemployees = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.employees, ids[i])
		m.removedemployees[ids[i]] = struct{}{}
	}
}

// RemovedEmployees returns the removed IDs of the "employees" edge to the Employee entity.
func (m *CompanyMutation) RemovedEmployeesIDs() (ids []int) {
	for id := range m.removedemployees {
		ids = append(ids, id)
	}
	return
}

// EmployeesIDs returns the "employees" edge IDs in the mutation.
func (m *CompanyMutation) EmployeesIDs() (ids []int) {
	for id := range m.employees {
		ids = append(ids, id)
	}
	return
}

// ResetEmployees resets all changes to the "employees" edge.
func (m *CompanyMutation) ResetEmployees() {
	m.employees = nil
	m.clearedemployees = false
	m.removedemployees = nil
}

// AddFileIDs adds the "files" edge to the File entity by ids.
func (m *CompanyMutation) AddFileIDs(ids ...int) {
	if m.files == nil {
		m.files = make(map[int]struct{})
	}
	for i := range ids {
		m.files[ids[i]] = struct{}{}
	}
}

// ClearFiles clears the "files" edge to the File entity.
func (m *CompanyMutation) ClearFiles() {
	m.clearedfiles = true
}

// FilesCleared reports if the "files" edge to the File entity was cleared.
func (m *CompanyMutation) FilesCleared() bool {
	return m.clearedfiles
}

// RemoveFileIDs removes the "files" edge to the File entity by IDs.
func (m *CompanyMutation) RemoveFileIDs(ids ...int) {
	if m.removedfiles == nil {
		m.removedfiles = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.files, ids[i])
		m.removedfiles[ids[i]] = struct{}{}
	}
}

// RemovedFiles returns the removed IDs of the "files" edge to the File entity.
func (m *CompanyMutation) RemovedFilesIDs() (ids []int) {
	for id := range m.removedfiles {
		ids = append(ids, id)
	}
	return
}

// FilesIDs returns the "files" edge IDs in the mutation.
func (m *CompanyMutation) FilesIDs() (ids []int) {
	for id := range m.files {
		ids = append(ids, id)
	}
	return
}

// ResetFiles resets all changes to the "files" edge.
func (m *CompanyMutation) ResetFiles() {
	m.files = nil
	m.clearedfiles = false
	m.removedfiles = nil
}

// AddInventoryIDs adds the "inventory" edge to the Inventory entity by ids.
func (m *CompanyMutation) AddInventoryIDs(ids ...int) {
	if m.inventory == nil {
		m.inventory = make(map[int]struct{})
	}
	for i := range ids {
		m.inventory[ids[i]] = struct{}{}
	}
}

// ClearInventory clears the "inventory" edge to the Inventory entity.
func (m *CompanyMutation) ClearInventory() {
	m.clearedinventory = true
}

// InventoryCleared reports if the "inventory" edge to the Inventory entity was cleared.
func (m *CompanyMutation) InventoryCleared() bool {
	return m.clearedinventory
}

// RemoveInventoryIDs removes the "inventory" edge to the Inventory entity by IDs.
func (m *CompanyMutation) RemoveInventoryIDs(ids ...int) {
	if m.removedinventory == nil {
		m.removedinventory = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.inventory, ids[i])
		m.removedinventory[ids[i]] = struct{}{}
	}
}

// RemovedInventory returns the removed IDs of the "inventory" edge to the Inventory entity.
func (m *CompanyMutation) RemovedInventoryIDs() (ids []int) {
	for id := range m.removedinventory {
		ids = append(ids, id)
	}
	return
}

// InventoryIDs returns the "inventory" edge IDs in the mutation.
func (m *CompanyMutation) InventoryIDs() (ids []int) {
	for id := range m.inventory {
		ids = append(ids, id)
	}
	return
}

// ResetInventory resets all changes to the "inventory" edge.
func (m *CompanyMutation) ResetInventory() {
	m.inventory = nil
	m.clearedinventory = false
	m.removedinventory = nil
}

// AddInventoryMovementIDs adds the "inventory_movements" edge to the InventoryMovement entity by ids.
func (m *CompanyMutation) AddInventoryMovementIDs(ids ...int) {
	if m.inventory_movements == nil {
		m.inventory_movements = make(map[int]struct{})
	}
	for i := range ids {
		m.inventory_movements[ids[i]] = struct{}{}
	}
}

// ClearInventoryMovements clears the "inventory_movements" edge to the InventoryMovement entity.
func (m *CompanyMutation) ClearInventoryMovements() {
	m.clearedinventory_movements = true
}

// InventoryMovementsCleared reports if the "inventory_movements" edge to the InventoryMovement entity was cleared.
func (m *CompanyMutation) InventoryMovementsCleared() bool {
	return m.clearedinventory_movements
}

// RemoveInventoryMovementIDs removes the "inventory_movements" edge to the InventoryMovement entity by IDs.
func (m *CompanyMutation) RemoveInventoryMovementIDs(ids ...int) {
	if m.removedinventory_movements == nil {
		m.removedinventory_movements = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.inventory_movements, ids[i])
		m.removedinventory_movements[ids[i]] = struct{}{}
	}
}

// RemovedInventoryMovements returns the removed IDs of the "inventory_movements" edge to the InventoryMovement entity.
func (m *CompanyMutation) RemovedInventoryMovementsIDs() (ids []int) {
	for id := range m.removedinventory_movements {
		ids = append(ids, id)
	}
	return
}

// InventoryMovementsIDs returns the "inventory_movements" edge IDs in the mutation.
func (m *CompanyMutation) InventoryMovementsIDs() (ids []int) {
	for id := range m.inventory_movements {
		ids = append(ids, id)
	}
	return
}

// ResetInventoryMovements resets all changes to the "inventory_movements" edge.
func (m *CompanyMutation) ResetInventoryMovements() {
	m.inventory_movements = nil
	m.clearedinventory_movements = false
	m.removedinventory_movements = nil
}

// AddInvoiceIDs adds the "invoices" edge to the Invoice entity by ids.
func (m *CompanyMutation) AddInvoiceIDs(ids ...int) {
	if m.invoices == nil {
		m.invoices = make(map[int]struct{})
	}
	for i := range ids {
		m.invoices[ids[i]] = struct{}{}
	}
}

// ClearInvoices clears the "invoices" edge to the Invoice entity.
func (m *CompanyMutation) ClearInvoices() {
	m.clearedinvoices = true
}

// InvoicesCleared reports if the "invoices" edge to the Invoice entity was cleared.
func (m *CompanyMutation) InvoicesCleared() bool {
	return m.clearedinvoices
}

// RemoveInvoiceIDs removes the "invoices" edge to the Invoice entity by IDs.
func (m *CompanyMutation) RemoveInvoiceIDs(ids ...int) {
	if m.removedinvoices == nil {
		m.removedinvoices = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.invoices, ids[i])
		m.removedinvoices[ids[i]] = struct{}{}
	}
}

// RemovedInvoices returns the removed IDs of the "invoices" edge to the Invoice entity.
func (m *CompanyMutation) RemovedInvoicesIDs() (ids []int) {
	for id := range m.removedinvoices {
		ids = append(ids, id)
	}
	return
}

// InvoicesIDs returns the "invoices" edge IDs in the mutation.
func (m *CompanyMutation) InvoicesIDs() (ids []int) {
	for id := range m.invoices {
		ids = append(ids, id)
	}
	return
}

// ResetInvoices resets all changes to the "invoices" edge.
func (m *CompanyMutation) ResetInvoices() {
	m.invoices = nil
	m.clearedinvoices = false
	m.removedinvoices = nil
}

// AddLoanIDs adds the "loans" edge to the Loan entity by ids.
func (m *CompanyMutation) AddLoanIDs(ids ...int) {
	if m.loans == nil {
		m.loans = make(map[int]struct{})
	}
	for i := range ids {
		m.loans[ids[i]] = struct{}{}
	}
}

// ClearLoans clears the "loans" edge to the Loan entity.
func (m *CompanyMutation) ClearLoans() {
	m.clearedloans = true
}

// LoansCleared reports if the "loans" edge to the Loan entity was cleared.
func (m *CompanyMutation) LoansCleared() bool {
	return m.clearedloans
}

// RemoveLoanIDs removes the "loans" edge to the Loan entity by IDs.
func (m *CompanyMutation) RemoveLoanIDs(ids ...int) {
	if m.removedloans == nil {
		m.removedloans = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.loans, ids[i])
		m.removedloans[ids[i]] = struct{}{}
	}
}

// RemovedLoans returns the removed IDs of the "loans" edge to the Loan entity.
func (m *CompanyMutation) RemovedLoansIDs() (ids []int) {
	for id := range m.removedloans {
		ids = append(ids, id)
	}
	return
}

// LoansIDs returns the "loans" edge IDs in the mutation.
func (m *CompanyMutation) LoansIDs() (ids []int) {
	for id := range m.loans {
		ids = append(ids, id)
	}
	return
}

// ResetLoans resets all changes to the "loans" edge.
func (m *CompanyMutation) ResetLoans() {
	m.loans = nil
	m.clearedloans = false
	m.removedloans = nil
}

// AddLoanScheduleIDs adds the "loan_schedule" edge to the LoanSchedule entity by ids.
func (m *CompanyMutation) AddLoanScheduleIDs(ids ...int) {
	if m.loan_schedule == nil {
		m.loan_schedule = make(map[int]struct{})
	}
	for i := range ids {
		m.loan_schedule[ids[i]] = struct{}{}
	}
}

// ClearLoanSchedule clears the "loan_schedule" edge to the LoanSchedule entity.
func (m *CompanyMutation) ClearLoanSchedule() {
	m.clearedloan_schedule = true
}

// LoanScheduleCleared reports if the "loan_schedule" edge to the LoanSchedule entity was cleared.
func (m *CompanyMutation) LoanScheduleCleared() bool {
	return m.clearedloan_schedule
}

// RemoveLoanScheduleIDs removes the "loan_schedule" edge to the LoanSchedule entity by IDs.
func (m *CompanyMutation) RemoveLoanScheduleIDs(ids ...int) {
	if m.removedloan_schedule == nil {
		m.removedloan_schedule = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.loan_schedule, ids[i])
		m.removedloan_schedule[ids[i]] = struct{}{}
	}
}

// RemovedLoanSchedule returns the removed IDs of the "loan_schedule" edge to the LoanSchedule entity.
func (m *CompanyMutation) RemovedLoanScheduleIDs() (ids []int) {
	for id := range m.removedloan_schedule {
		ids = append(ids, id)
	}
	return
}

// LoanScheduleIDs returns the "loan_schedule" edge IDs in the mutation.
func (m *CompanyMutation) LoanScheduleIDs() (ids []int) {
	for id := range m.loan_schedule {
		ids = append(ids, id)
	}
	return
}

// ResetLoanSchedule resets all changes to the "loan_schedule" edge.
func (m *CompanyMutation) ResetLoanSchedule() {
	m.loan_schedule = nil
	m.clearedloan_schedule = false
	m.removedloan_schedule = nil
}

// AddMemberSignupTokenIDs adds the "member_signup_tokens" edge to the MemberSignupToken entity by ids.
func (m *CompanyMutation) AddMemberSignupTokenIDs(ids ...int) {
	if m.member_signup_tokens == nil {
		m.member_signup_tokens = make(map[int]struct{})
	}
	for i := range ids {
		m.member_signup_tokens[ids[i]] = struct{}{}
	}
}

// ClearMemberSignupTokens clears the "member_signup_tokens" edge to the MemberSignupToken entity.
func (m *CompanyMutation) ClearMemberSignupTokens() {
	m.clearedmember_signup_tokens = true
}

// MemberSignupTokensCleared reports if the "member_signup_tokens" edge to the MemberSignupToken entity was cleared.
func (m *CompanyMutation) MemberSignupTokensCleared() bool {
	return m.clearedmember_signup_tokens
}

// RemoveMemberSignupTokenIDs removes the "member_signup_tokens" edge to the MemberSignupToken entity by IDs.
func (m *CompanyMutation) RemoveMemberSignupTokenIDs(ids ...int) {
	if m.removedmember_signup_tokens == nil {
		m.removedmember_signup_tokens = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.member_signup_tokens, ids[i])
		m.removedmember_signup_tokens[ids[i]] = struct{}{}
	}
}

// RemovedMemberSignupTokens returns the removed IDs of the "member_signup_tokens" edge to the MemberSignupToken entity.
func (m *CompanyMutation) RemovedMemberSignupTokensIDs() (ids []int) {
	for id := range m.removedmember_signup_tokens {
		ids = append(ids, id)
	}
	return
}

// MemberSignupTokensIDs returns the "member_signup_tokens" edge IDs in the mutation.
func (m *CompanyMutation) MemberSignupTokensIDs() (ids []int) {
	for id := range m.member_signup_tokens {
		ids = append(ids, id)
	}
	return
}

// ResetMemberSignupTokens resets all changes to the "member_signup_tokens" edge.
func (m *CompanyMutation) ResetMemberSignupTokens() {
	m.member_signup_tokens = nil
	m.clearedmember_signup_tokens = false
	m.removedmember_signup_tokens = nil
}

// AddProductIDs adds the "products" edge to the Product entity by ids.
func (m *CompanyMutation) AddProductIDs(ids ...int) {
	if m.products == nil {
		m.products = make(map[int]struct{})
	}
	for i := range ids {
		m.products[ids[i]] = struct{}{}
	}
}

// ClearProducts clears the "products" edge to the Product entity.
func (m *CompanyMutation) ClearProducts() {
	m.clearedproducts = true
}

// ProductsCleared reports if the "products" edge to the Product entity was cleared.
func (m *CompanyMutation) ProductsCleared() bool {
	return m.clearedproducts
}

// RemoveProductIDs removes the "products" edge to the Product entity by IDs.
func (m *CompanyMutation) RemoveProductIDs(ids ...int) {
	if m.removedproducts == nil {
		m.removedproducts = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.products, ids[i])
		m.removedproducts[ids[i]] = struct{}{}
	}
}

// RemovedProducts returns the removed IDs of the "products" edge to the Product entity.
func (m *CompanyMutation) RemovedProductsIDs() (ids []int) {
	for id := range m.removedproducts {
		ids = append(ids, id)
	}
	return
}

// ProductsIDs returns the "products" edge IDs in the mutation.
func (m *CompanyMutation) ProductsIDs() (ids []int) {
	for id := range m.products {
		ids = append(ids, id)
	}
	return
}

// ResetProducts resets all changes to the "products" edge.
func (m *CompanyMutation) ResetProducts() {
	m.products = nil
	m.clearedproducts = false
	m.removedproducts = nil
}

// AddProjectIDs adds the "projects" edge to the Project entity by ids.
func (m *CompanyMutation) AddProjectIDs(ids ...int) {
	if m.projects == nil {
		m.projects = make(map[int]struct{})
	}
	for i := range ids {
		m.projects[ids[i]] = struct{}{}
	}
}

// ClearProjects clears the "projects" edge to the Project entity.
func (m *CompanyMutation) ClearProjects() {
	m.clearedprojects = true
}

// ProjectsCleared reports if the "projects" edge to the Project entity was cleared.
func (m *CompanyMutation) ProjectsCleared() bool {
	return m.clearedprojects
}

// RemoveProjectIDs removes the "projects" edge to the Project entity by IDs.
func (m *CompanyMutation) RemoveProjectIDs(ids ...int) {
	if m.removedprojects == nil {
		m.removedprojects = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.projects, ids[i])
		m.removedprojects[ids[i]] = struct{}{}
	}
}

// RemovedProjects returns the removed IDs of the "projects" edge to the Project entity.
func (m *CompanyMutation) RemovedProjectsIDs() (ids []int) {
	for id := range m.removedprojects {
		ids = append(ids, id)
	}
	return
}

// ProjectsIDs returns the "projects" edge IDs in the mutation.
func (m *CompanyMutation) ProjectsIDs() (ids []int) {
	for id := range m.projects {
		ids = append(ids, id)
	}
	return
}

// ResetProjects resets all changes to the "projects" edge.
func (m *CompanyMutation) ResetProjects() {
	m.projects = nil
	m.clearedprojects = false
	m.removedprojects = nil
}

// AddPayableIDs adds the "payables" edge to the Payable entity by ids.
func (m *CompanyMutation) AddPayableIDs(ids ...int) {
	if m.payables == nil {
		m.payables = make(map[int]struct{})
	}
	for i := range ids {
		m.payables[ids[i]] = struct{}{}
	}
}

// ClearPayables clears the "payables" edge to the Payable entity.
func (m *CompanyMutation) ClearPayables() {
	m.clearedpayables = true
}

// PayablesCleared reports if the "payables" edge to the Payable entity was cleared.
func (m *CompanyMutation) PayablesCleared() bool {
	return m.clearedpayables
}

// RemovePayableIDs removes the "payables" edge to the Payable entity by IDs.
func (m *CompanyMutation) RemovePayableIDs(ids ...int) {
	if m.removedpayables == nil {
		m.removedpayables = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.payables, ids[i])
		m.removedpayables[ids[i]] = struct{}{}
	}
}

// RemovedPayables returns the removed IDs of the "payables" edge to the Payable entity.
func (m *CompanyMutation) RemovedPayablesIDs() (ids []int) {
	for id := range m.removedpayables {
		ids = append(ids, id)
	}
	return
}

// PayablesIDs returns the "payables" edge IDs in the mutation.
func (m *CompanyMutation) PayablesIDs() (ids []int) {
	for id := range m.payables {
		ids = append(ids, id)
	}
	return
}

// ResetPayables resets all changes to the "payables" edge.
func (m *CompanyMutation) ResetPayables() {
	m.payables = nil
	m.clearedpayables = false
	m.removedpayables = nil
}

// AddReceivableIDs adds the "receivables" edge to the Receivable entity by ids.
func (m *CompanyMutation) AddReceivableIDs(ids ...int) {
	if m.receivables == nil {
		m.receivables = make(map[int]struct{})
	}
	for i := range ids {
		m.receivables[ids[i]] = struct{}{}
	}
}

// ClearReceivables clears the "receivables" edge to the Receivable entity.
func (m *CompanyMutation) ClearReceivables() {
	m.clearedreceivables = true
}

// ReceivablesCleared reports if the "receivables" edge to the Receivable entity was cleared.
func (m *CompanyMutation) ReceivablesCleared() bool {
	return m.clearedreceivables
}

// RemoveReceivableIDs removes the "receivables" edge to the Receivable entity by IDs.
func (m *CompanyMutation) RemoveReceivableIDs(ids ...int) {
	if m.removedreceivables == nil {
		m.removedreceivables = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.receivables, ids[i])
		m.removedreceivables[ids[i]] = struct{}{}
	}
}

// RemovedReceivables returns the removed IDs of the "receivables" edge to the Receivable entity.
func (m *CompanyMutation) RemovedReceivablesIDs() (ids []int) {
	for id := range m.removedreceivables {
		ids = append(ids, id)
	}
	return
}

// ReceivablesIDs returns the "receivables" edge IDs in the mutation.
func (m *CompanyMutation) ReceivablesIDs() (ids []int) {
	for id := range m.receivables {
		ids = append(ids, id)
	}
	return
}

// ResetReceivables resets all changes to the "receivables" edge.
func (m *CompanyMutation) ResetReceivables() {
	m.receivables = nil
	m.clearedreceivables = false
	m.removedreceivables = nil
}

// AddSupplierIDs adds the "suppliers" edge to the Supplier entity by ids.
func (m *CompanyMutation) AddSupplierIDs(ids ...int) {
	if m.suppliers == nil {
		m.suppliers = make(map[int]struct{})
	}
	for i := range ids {
		m.suppliers[ids[i]] = struct{}{}
	}
}

// ClearSuppliers clears the "suppliers" edge to the Supplier entity.
func (m *CompanyMutation) ClearSuppliers() {
	m.clearedsuppliers = true
}

// SuppliersCleared reports if the "suppliers" edge to the Supplier entity was cleared.
func (m *CompanyMutation) SuppliersCleared() bool {
	return m.clearedsuppliers
}

// RemoveSupplierIDs removes the "suppliers" edge to the Supplier entity by IDs.
func (m *CompanyMutation) RemoveSupplierIDs(ids ...int) {
	if m.removedsuppliers == nil {
		m.removedsuppliers = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.suppliers, ids[i])
		m.removedsuppliers[ids[i]] = struct{}{}
	}
}

// RemovedSuppliers returns the removed IDs of the "suppliers" edge to the Supplier entity.
func (m *CompanyMutation) RemovedSuppliersIDs() (ids []int) {
	for id := range m.removedsuppliers {
		ids = append(ids, id)
	}
	return
}

// SuppliersIDs returns the "suppliers" edge IDs in the mutation.
func (m *CompanyMutation) SuppliersIDs() (ids []int) {
	for id := range m.suppliers {
		ids = append(ids, id)
	}
	return
}

// ResetSuppliers resets all changes to the "suppliers" edge.
func (m *CompanyMutation) ResetSuppliers() {
	m.suppliers = nil
	m.clearedsuppliers = false
	m.removedsuppliers = nil
}

// AddTokenIDs adds the "tokens" edge to the Token entity by ids.
func (m *CompanyMutation) AddTokenIDs(ids ...int) {
	if m.tokens == nil {
		m.tokens = make(map[int]struct{})
	}
	for i := range ids {
		m.tokens[ids[i]] = struct{}{}
	}
}

// ClearTokens clears the "tokens" edge to the Token entity.
func (m *CompanyMutation) ClearTokens() {
	m.clearedtokens = true
}

// TokensCleared reports if the "tokens" edge to the Token entity was cleared.
func (m *CompanyMutation) TokensCleared() bool {
	return m.clearedtokens
}

// RemoveTokenIDs removes the "tokens" edge to the Token entity by IDs.
func (m *CompanyMutation) RemoveTokenIDs(ids ...int) {
	if m.removedtokens == nil {
		m.removedtokens = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.tokens, ids[i])
		m.removedtokens[ids[i]] = struct{}{}
	}
}

// RemovedTokens returns the removed IDs of the "tokens" edge to the Token entity.
func (m *CompanyMutation) RemovedTokensIDs() (ids []int) {
	for id := range m.removedtokens {
		ids = append(ids, id)
	}
	return
}

// TokensIDs returns the "tokens" edge IDs in the mutation.
func (m *CompanyMutation) TokensIDs() (ids []int) {
	for id := range m.tokens {
		ids = append(ids, id)
	}
	return
}

// ResetTokens resets all changes to the "tokens" edge.
func (m *CompanyMutation) ResetTokens() {
	m.tokens = nil
	m.clearedtokens = false
	m.removedtokens = nil
}

// AddTreasuryIDs adds the "treasuries" edge to the Treasury entity by ids.
func (m *CompanyMutation) AddTreasuryIDs(ids ...int) {
	if m.treasuries == nil {
		m.treasuries = make(map[int]struct{})
	}
	for i := range ids {
		m.treasuries[ids[i]] = struct{}{}
	}
}

// ClearTreasuries clears the "treasuries" edge to the Treasury entity.
func (m *CompanyMutation) ClearTreasuries() {
	m.clearedtreasuries = true
}

// TreasuriesCleared reports if the "treasuries" edge to the Treasury entity was cleared.
func (m *CompanyMutation) TreasuriesCleared() bool {
	return m.clearedtreasuries
}

// RemoveTreasuryIDs removes the "treasuries" edge to the Treasury entity by IDs.
func (m *CompanyMutation) RemoveTreasuryIDs(ids ...int) {
	if m.removedtreasuries == nil {
		m.removedtreasuries = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.treasuries, ids[i])
		m.removedtreasuries[ids[i]] = struct{}{}
	}
}

// RemovedTreasuries returns the removed IDs of the "treasuries" edge to the Treasury entity.
func (m *CompanyMutation) RemovedTreasuriesIDs() (ids []int) {
	for id := range m.removedtreasuries {
		ids = append(ids, id)
	}
	return
}

// TreasuriesIDs returns the "treasuries" edge IDs in the mutation.
func (m *CompanyMutation) TreasuriesIDs() (ids []int) {
	for id := range m.treasuries {
		ids = append(ids, id)
	}
	return
}

// ResetTreasuries resets all changes to the "treasuries" edge.
func (m *CompanyMutation) ResetTreasuries() {
	m.treasuries = nil
	m.clearedtreasuries = false
	m.removedtreasuries = nil
}

// AddWorkShiftIDs adds the "work_shifts" edge to the Workshift entity by ids.
func (m *CompanyMutation) AddWorkShiftIDs(ids ...int) {
	if m.work_shifts == nil {
		m.work_shifts = make(map[int]struct{})
	}
	for i := range ids {
		m.work_shifts[ids[i]] = struct{}{}
	}
}

// ClearWorkShifts clears the "work_shifts" edge to the Workshift entity.
func (m *CompanyMutation) ClearWorkShifts() {
	m.clearedwork_shifts = true
}

// WorkShiftsCleared reports if the "work_shifts" edge to the Workshift entity was cleared.
func (m *CompanyMutation) WorkShiftsCleared() bool {
	return m.clearedwork_shifts
}

// RemoveWorkShiftIDs removes the "work_shifts" edge to the Workshift entity by IDs.
func (m *CompanyMutation) RemoveWorkShiftIDs(ids ...int) {
	if m.removedwork_shifts == nil {
		m.removedwork_shifts = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.work_shifts, ids[i])
		m.removedwork_shifts[ids[i]] = struct{}{}
	}
}

// RemovedWorkShifts returns the removed IDs of the "work_shifts" edge to the Workshift entity.
func (m *CompanyMutation) RemovedWorkShiftsIDs() (ids []int) {
	for id := range m.removedwork_shifts {
		ids = append(ids, id)
	}
	return
}

// WorkShiftsIDs returns the "work_shifts" edge IDs in the mutation.
func (m *CompanyMutation) WorkShiftsIDs() (ids []int) {
	for id := range m.work_shifts {
		ids = append(ids, id)
	}
	return
}

// ResetWorkShifts resets all changes to the "work_shifts" edge.
func (m *CompanyMutation) ResetWorkShifts() {
	m.work_shifts = nil
	m.clearedwork_shifts = false
	m.removedwork_shifts = nil
}

// AddUserIDs adds the "users" edge to the User entity by ids.
func (m *CompanyMutation) AddUserIDs(ids ...int) {
	if m.users == nil {
		m.users = make(map[int]struct{})
	}
	for i := range ids {
		m.users[ids[i]] = struct{}{}
	}
}

// ClearUsers clears the "users" edge to the User entity.
func (m *CompanyMutation) ClearUsers() {
	m.clearedusers = true
}

// UsersCleared reports if the "users" edge to the User entity was cleared.
func (m *CompanyMutation) UsersCleared() bool {
	return m.clearedusers
}

// RemoveUserIDs removes the "users" edge to the User entity by IDs.
func (m *CompanyMutation) RemoveUserIDs(ids ...int) {
	if m.removedusers == nil {
		m.removedusers = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.users, ids[i])
		m.removedusers[ids[i]] = struct{}{}
	}
}

// RemovedUsers returns the removed IDs of the "users" edge to the User entity.
func (m *CompanyMutation) RemovedUsersIDs() (ids []int) {
	for id := range m.removedusers {
		ids = append(ids, id)
	}
	return
}

// UsersIDs returns the "users" edge IDs in the mutation.
func (m *CompanyMutation) UsersIDs() (ids []int) {
	for id := range m.users {
		ids = append(ids, id)
	}
	return
}

// ResetUsers resets all changes to the "users" edge.
func (m *CompanyMutation) ResetUsers() {
	m.users = nil
	m.clearedusers = false
	m.removedusers = nil
}

// AddDaughterCompanyIDs adds the "daughter_companies" edge to the Company entity by ids.
func (m *CompanyMutation) AddDaughterCompanyIDs(ids ...int) {
	if m.daughter_companies == nil {
		m.daughter_companies = make(map[int]struct{})
	}
	for i := range ids {
		m.daughter_companies[ids[i]] = struct{}{}
	}
}

// ClearDaughterCompanies clears the "daughter_companies" edge to the Company entity.
func (m *CompanyMutation) ClearDaughterCompanies() {
	m.cleareddaughter_companies = true
}

// DaughterCompaniesCleared reports if the "daughter_companies" edge to the Company entity was cleared.
func (m *CompanyMutation) DaughterCompaniesCleared() bool {
	return m.cleareddaughter_companies
}

// RemoveDaughterCompanyIDs removes the "daughter_companies" edge to the Company entity by IDs.
func (m *CompanyMutation) RemoveDaughterCompanyIDs(ids ...int) {
	if m.removeddaughter_companies == nil {
		m.removeddaughter_companies = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.daughter_companies, ids[i])
		m.removeddaughter_companies[ids[i]] = struct{}{}
	}
}

// RemovedDaughterCompanies returns the removed IDs of the "daughter_companies" edge to the Company entity.
func (m *CompanyMutation) RemovedDaughterCompaniesIDs() (ids []int) {
	for id := range m.removeddaughter_companies {
		ids = append(ids, id)
	}
	return
}

// DaughterCompaniesIDs returns the "daughter_companies" edge IDs in the mutation.
func (m *CompanyMutation) DaughterCompaniesIDs() (ids []int) {
	for id := range m.daughter_companies {
		ids = append(ids, id)
	}
	return
}

// ResetDaughterCompanies resets all changes to the "daughter_companies" edge.
func (m *CompanyMutation) ResetDaughterCompanies() {
	m.daughter_companies = nil
	m.cleareddaughter_companies = false
	m.removeddaughter_companies = nil
}

// SetParentCompanyID sets the "parent_company" edge to the Company entity by id.
func (m *CompanyMutation) SetParentCompanyID(id int) {
	m.parent_company = &id
}

// ClearParentCompany clears the "parent_company" edge to the Company entity.
func (m *CompanyMutation) ClearParentCompany() {
	m.clearedparent_company = true
}

// ParentCompanyCleared reports if the "parent_company" edge to the Company entity was cleared.
func (m *CompanyMutation) ParentCompanyCleared() bool {
	return m.clearedparent_company
}

// ParentCompanyID returns the "parent_company" edge ID in the mutation.
func (m *CompanyMutation) ParentCompanyID() (id int, exists bool) {
	if m.parent_company != nil {
		return *m.parent_company, true
	}
	return
}

// ParentCompanyIDs returns the "parent_company" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ParentCompanyID instead. It exists only for internal usage by the builders.
func (m *CompanyMutation) ParentCompanyIDs() (ids []int) {
	if id := m.parent_company; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetParentCompany resets all changes to the "parent_company" edge.
func (m *CompanyMutation) ResetParentCompany() {
	m.parent_company = nil
	m.clearedparent_company = false
}

// Where appends a list predicates to the CompanyMutation builder.
func (m *CompanyMutation) Where(ps ...predicate.Company) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CompanyMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CompanyMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Company, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CompanyMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CompanyMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Company).
func (m *CompanyMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CompanyMutation) Fields() []string {
	fields := make([]string, 0, 23)
	if m.created_at != nil {
		fields = append(fields, company.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, company.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, company.FieldDeletedAt)
	}
	if m.address != nil {
		fields = append(fields, company.FieldAddress)
	}
	if m.base_currency != nil {
		fields = append(fields, company.FieldBaseCurrency)
	}
	if m.ceo_name != nil {
		fields = append(fields, company.FieldCeoName)
	}
	if m.city != nil {
		fields = append(fields, company.FieldCity)
	}
	if m.country != nil {
		fields = append(fields, company.FieldCountry)
	}
	if m.established_at != nil {
		fields = append(fields, company.FieldEstablishedAt)
	}
	if m.description != nil {
		fields = append(fields, company.FieldDescription)
	}
	if m.email != nil {
		fields = append(fields, company.FieldEmail)
	}
	if m.industry != nil {
		fields = append(fields, company.FieldIndustry)
	}
	if m.last_entry_date != nil {
		fields = append(fields, company.FieldLastEntryDate)
	}
	if m.last_invoice_number != nil {
		fields = append(fields, company.FieldLastInvoiceNumber)
	}
	if m.logo_URL != nil {
		fields = append(fields, company.FieldLogoURL)
	}
	if m.logo_storage_URI != nil {
		fields = append(fields, company.FieldLogoStorageURI)
	}
	if m.name != nil {
		fields = append(fields, company.FieldName)
	}
	if m.number_employees != nil {
		fields = append(fields, company.FieldNumberEmployees)
	}
	if m.phone != nil {
		fields = append(fields, company.FieldPhone)
	}
	if m.tax_id != nil {
		fields = append(fields, company.FieldTaxID)
	}
	if m.vat_rate != nil {
		fields = append(fields, company.FieldVatRate)
	}
	if m.website != nil {
		fields = append(fields, company.FieldWebsite)
	}
	if m.incomplete_setup != nil {
		fields = append(fields, company.FieldIncompleteSetup)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CompanyMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case company.FieldCreatedAt:
		return m.CreatedAt()
	case company.FieldUpdatedAt:
		return m.UpdatedAt()
	case company.FieldDeletedAt:
		return m.DeletedAt()
	case company.FieldAddress:
		return m.Address()
	case company.FieldBaseCurrency:
		return m.BaseCurrency()
	case company.FieldCeoName:
		return m.CeoName()
	case company.FieldCity:
		return m.City()
	case company.FieldCountry:
		return m.Country()
	case company.FieldEstablishedAt:
		return m.EstablishedAt()
	case company.FieldDescription:
		return m.Description()
	case company.FieldEmail:
		return m.Email()
	case company.FieldIndustry:
		return m.Industry()
	case company.FieldLastEntryDate:
		return m.LastEntryDate()
	case company.FieldLastInvoiceNumber:
		return m.LastInvoiceNumber()
	case company.FieldLogoURL:
		return m.LogoURL()
	case company.FieldLogoStorageURI:
		return m.LogoStorageURI()
	case company.FieldName:
		return m.Name()
	case company.FieldNumberEmployees:
		return m.NumberEmployees()
	case company.FieldPhone:
		return m.Phone()
	case company.FieldTaxID:
		return m.TaxID()
	case company.FieldVatRate:
		return m.VatRate()
	case company.FieldWebsite:
		return m.Website()
	case company.FieldIncompleteSetup:
		return m.IncompleteSetup()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CompanyMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case company.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case company.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case company.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case company.FieldAddress:
		return m.OldAddress(ctx)
	case company.FieldBaseCurrency:
		return m.OldBaseCurrency(ctx)
	case company.FieldCeoName:
		return m.OldCeoName(ctx)
	case company.FieldCity:
		return m.OldCity(ctx)
	case company.FieldCountry:
		return m.OldCountry(ctx)
	case company.FieldEstablishedAt:
		return m.OldEstablishedAt(ctx)
	case company.FieldDescription:
		return m.OldDescription(ctx)
	case company.FieldEmail:
		return m.OldEmail(ctx)
	case company.FieldIndustry:
		return m.OldIndustry(ctx)
	case company.FieldLastEntryDate:
		return m.OldLastEntryDate(ctx)
	case company.FieldLastInvoiceNumber:
		return m.OldLastInvoiceNumber(ctx)
	case company.FieldLogoURL:
		return m.OldLogoURL(ctx)
	case company.FieldLogoStorageURI:
		return m.OldLogoStorageURI(ctx)
	case company.FieldName:
		return m.OldName(ctx)
	case company.FieldNumberEmployees:
		return m.OldNumberEmployees(ctx)
	case company.FieldPhone:
		return m.OldPhone(ctx)
	case company.FieldTaxID:
		return m.OldTaxID(ctx)
	case company.FieldVatRate:
		return m.OldVatRate(ctx)
	case company.FieldWebsite:
		return m.OldWebsite(ctx)
	case company.FieldIncompleteSetup:
		return m.OldIncompleteSetup(ctx)
	}
	return nil, fmt.Errorf("unknown Company field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CompanyMutation) SetField(name string, value ent.Value) error {
	switch name {
	case company.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case company.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case company.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case company.FieldAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAddress(v)
		return nil
	case company.FieldBaseCurrency:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBaseCurrency(v)
		return nil
	case company.FieldCeoName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCeoName(v)
		return nil
	case company.FieldCity:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCity(v)
		return nil
	case company.FieldCountry:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCountry(v)
		return nil
	case company.FieldEstablishedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEstablishedAt(v)
		return nil
	case company.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case company.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case company.FieldIndustry:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIndustry(v)
		return nil
	case company.FieldLastEntryDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastEntryDate(v)
		return nil
	case company.FieldLastInvoiceNumber:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastInvoiceNumber(v)
		return nil
	case company.FieldLogoURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLogoURL(v)
		return nil
	case company.FieldLogoStorageURI:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLogoStorageURI(v)
		return nil
	case company.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case company.FieldNumberEmployees:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNumberEmployees(v)
		return nil
	case company.FieldPhone:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPhone(v)
		return nil
	case company.FieldTaxID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTaxID(v)
		return nil
	case company.FieldVatRate:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVatRate(v)
		return nil
	case company.FieldWebsite:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWebsite(v)
		return nil
	case company.FieldIncompleteSetup:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIncompleteSetup(v)
		return nil
	}
	return fmt.Errorf("unknown Company field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CompanyMutation) AddedFields() []string {
	var fields []string
	if m.addlast_invoice_number != nil {
		fields = append(fields, company.FieldLastInvoiceNumber)
	}
	if m.addnumber_employees != nil {
		fields = append(fields, company.FieldNumberEmployees)
	}
	if m.addvat_rate != nil {
		fields = append(fields, company.FieldVatRate)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CompanyMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case company.FieldLastInvoiceNumber:
		return m.AddedLastInvoiceNumber()
	case company.FieldNumberEmployees:
		return m.AddedNumberEmployees()
	case company.FieldVatRate:
		return m.AddedVatRate()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CompanyMutation) AddField(name string, value ent.Value) error {
	switch name {
	case company.FieldLastInvoiceNumber:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLastInvoiceNumber(v)
		return nil
	case company.FieldNumberEmployees:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddNumberEmployees(v)
		return nil
	case company.FieldVatRate:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddVatRate(v)
		return nil
	}
	return fmt.Errorf("unknown Company numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CompanyMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(company.FieldDeletedAt) {
		fields = append(fields, company.FieldDeletedAt)
	}
	if m.FieldCleared(company.FieldAddress) {
		fields = append(fields, company.FieldAddress)
	}
	if m.FieldCleared(company.FieldCeoName) {
		fields = append(fields, company.FieldCeoName)
	}
	if m.FieldCleared(company.FieldDescription) {
		fields = append(fields, company.FieldDescription)
	}
	if m.FieldCleared(company.FieldEmail) {
		fields = append(fields, company.FieldEmail)
	}
	if m.FieldCleared(company.FieldIndustry) {
		fields = append(fields, company.FieldIndustry)
	}
	if m.FieldCleared(company.FieldLastEntryDate) {
		fields = append(fields, company.FieldLastEntryDate)
	}
	if m.FieldCleared(company.FieldLastInvoiceNumber) {
		fields = append(fields, company.FieldLastInvoiceNumber)
	}
	if m.FieldCleared(company.FieldLogoURL) {
		fields = append(fields, company.FieldLogoURL)
	}
	if m.FieldCleared(company.FieldLogoStorageURI) {
		fields = append(fields, company.FieldLogoStorageURI)
	}
	if m.FieldCleared(company.FieldPhone) {
		fields = append(fields, company.FieldPhone)
	}
	if m.FieldCleared(company.FieldTaxID) {
		fields = append(fields, company.FieldTaxID)
	}
	if m.FieldCleared(company.FieldWebsite) {
		fields = append(fields, company.FieldWebsite)
	}
	if m.FieldCleared(company.FieldIncompleteSetup) {
		fields = append(fields, company.FieldIncompleteSetup)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CompanyMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CompanyMutation) ClearField(name string) error {
	switch name {
	case company.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case company.FieldAddress:
		m.ClearAddress()
		return nil
	case company.FieldCeoName:
		m.ClearCeoName()
		return nil
	case company.FieldDescription:
		m.ClearDescription()
		return nil
	case company.FieldEmail:
		m.ClearEmail()
		return nil
	case company.FieldIndustry:
		m.ClearIndustry()
		return nil
	case company.FieldLastEntryDate:
		m.ClearLastEntryDate()
		return nil
	case company.FieldLastInvoiceNumber:
		m.ClearLastInvoiceNumber()
		return nil
	case company.FieldLogoURL:
		m.ClearLogoURL()
		return nil
	case company.FieldLogoStorageURI:
		m.ClearLogoStorageURI()
		return nil
	case company.FieldPhone:
		m.ClearPhone()
		return nil
	case company.FieldTaxID:
		m.ClearTaxID()
		return nil
	case company.FieldWebsite:
		m.ClearWebsite()
		return nil
	case company.FieldIncompleteSetup:
		m.ClearIncompleteSetup()
		return nil
	}
	return fmt.Errorf("unknown Company nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CompanyMutation) ResetField(name string) error {
	switch name {
	case company.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case company.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case company.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case company.FieldAddress:
		m.ResetAddress()
		return nil
	case company.FieldBaseCurrency:
		m.ResetBaseCurrency()
		return nil
	case company.FieldCeoName:
		m.ResetCeoName()
		return nil
	case company.FieldCity:
		m.ResetCity()
		return nil
	case company.FieldCountry:
		m.ResetCountry()
		return nil
	case company.FieldEstablishedAt:
		m.ResetEstablishedAt()
		return nil
	case company.FieldDescription:
		m.ResetDescription()
		return nil
	case company.FieldEmail:
		m.ResetEmail()
		return nil
	case company.FieldIndustry:
		m.ResetIndustry()
		return nil
	case company.FieldLastEntryDate:
		m.ResetLastEntryDate()
		return nil
	case company.FieldLastInvoiceNumber:
		m.ResetLastInvoiceNumber()
		return nil
	case company.FieldLogoURL:
		m.ResetLogoURL()
		return nil
	case company.FieldLogoStorageURI:
		m.ResetLogoStorageURI()
		return nil
	case company.FieldName:
		m.ResetName()
		return nil
	case company.FieldNumberEmployees:
		m.ResetNumberEmployees()
		return nil
	case company.FieldPhone:
		m.ResetPhone()
		return nil
	case company.FieldTaxID:
		m.ResetTaxID()
		return nil
	case company.FieldVatRate:
		m.ResetVatRate()
		return nil
	case company.FieldWebsite:
		m.ResetWebsite()
		return nil
	case company.FieldIncompleteSetup:
		m.ResetIncompleteSetup()
		return nil
	}
	return fmt.Errorf("unknown Company field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CompanyMutation) AddedEdges() []string {
	edges := make([]string, 0, 23)
	if m.available_roles != nil {
		edges = append(edges, company.EdgeAvailableRoles)
	}
	if m.accounting_entries != nil {
		edges = append(edges, company.EdgeAccountingEntries)
	}
	if m.customers != nil {
		edges = append(edges, company.EdgeCustomers)
	}
	if m.documents != nil {
		edges = append(edges, company.EdgeDocuments)
	}
	if m.employees != nil {
		edges = append(edges, company.EdgeEmployees)
	}
	if m.files != nil {
		edges = append(edges, company.EdgeFiles)
	}
	if m.inventory != nil {
		edges = append(edges, company.EdgeInventory)
	}
	if m.inventory_movements != nil {
		edges = append(edges, company.EdgeInventoryMovements)
	}
	if m.invoices != nil {
		edges = append(edges, company.EdgeInvoices)
	}
	if m.loans != nil {
		edges = append(edges, company.EdgeLoans)
	}
	if m.loan_schedule != nil {
		edges = append(edges, company.EdgeLoanSchedule)
	}
	if m.member_signup_tokens != nil {
		edges = append(edges, company.EdgeMemberSignupTokens)
	}
	if m.products != nil {
		edges = append(edges, company.EdgeProducts)
	}
	if m.projects != nil {
		edges = append(edges, company.EdgeProjects)
	}
	if m.payables != nil {
		edges = append(edges, company.EdgePayables)
	}
	if m.receivables != nil {
		edges = append(edges, company.EdgeReceivables)
	}
	if m.suppliers != nil {
		edges = append(edges, company.EdgeSuppliers)
	}
	if m.tokens != nil {
		edges = append(edges, company.EdgeTokens)
	}
	if m.treasuries != nil {
		edges = append(edges, company.EdgeTreasuries)
	}
	if m.work_shifts != nil {
		edges = append(edges, company.EdgeWorkShifts)
	}
	if m.users != nil {
		edges = append(edges, company.EdgeUsers)
	}
	if m.daughter_companies != nil {
		edges = append(edges, company.EdgeDaughterCompanies)
	}
	if m.parent_company != nil {
		edges = append(edges, company.EdgeParentCompany)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CompanyMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case company.EdgeAvailableRoles:
		ids := make([]ent.Value, 0, len(m.available_roles))
		for id := range m.available_roles {
			ids = append(ids, id)
		}
		return ids
	case company.EdgeAccountingEntries:
		ids := make([]ent.Value, 0, len(m.accounting_entries))
		for id := range m.accounting_entries {
			ids = append(ids, id)
		}
		return ids
	case company.EdgeCustomers:
		ids := make([]ent.Value, 0, len(m.customers))
		for id := range m.customers {
			ids = append(ids, id)
		}
		return ids
	case company.EdgeDocuments:
		ids := make([]ent.Value, 0, len(m.documents))
		for id := range m.documents {
			ids = append(ids, id)
		}
		return ids
	case company.EdgeEmployees:
		ids := make([]ent.Value, 0, len(m.employees))
		for id := range m.employees {
			ids = append(ids, id)
		}
		return ids
	case company.EdgeFiles:
		ids := make([]ent.Value, 0, len(m.files))
		for id := range m.files {
			ids = append(ids, id)
		}
		return ids
	case company.EdgeInventory:
		ids := make([]ent.Value, 0, len(m.inventory))
		for id := range m.inventory {
			ids = append(ids, id)
		}
		return ids
	case company.EdgeInventoryMovements:
		ids := make([]ent.Value, 0, len(m.inventory_movements))
		for id := range m.inventory_movements {
			ids = append(ids, id)
		}
		return ids
	case company.EdgeInvoices:
		ids := make([]ent.Value, 0, len(m.invoices))
		for id := range m.invoices {
			ids = append(ids, id)
		}
		return ids
	case company.EdgeLoans:
		ids := make([]ent.Value, 0, len(m.loans))
		for id := range m.loans {
			ids = append(ids, id)
		}
		return ids
	case company.EdgeLoanSchedule:
		ids := make([]ent.Value, 0, len(m.loan_schedule))
		for id := range m.loan_schedule {
			ids = append(ids, id)
		}
		return ids
	case company.EdgeMemberSignupTokens:
		ids := make([]ent.Value, 0, len(m.member_signup_tokens))
		for id := range m.member_signup_tokens {
			ids = append(ids, id)
		}
		return ids
	case company.EdgeProducts:
		ids := make([]ent.Value, 0, len(m.products))
		for id := range m.products {
			ids = append(ids, id)
		}
		return ids
	case company.EdgeProjects:
		ids := make([]ent.Value, 0, len(m.projects))
		for id := range m.projects {
			ids = append(ids, id)
		}
		return ids
	case company.EdgePayables:
		ids := make([]ent.Value, 0, len(m.payables))
		for id := range m.payables {
			ids = append(ids, id)
		}
		return ids
	case company.EdgeReceivables:
		ids := make([]ent.Value, 0, len(m.receivables))
		for id := range m.receivables {
			ids = append(ids, id)
		}
		return ids
	case company.EdgeSuppliers:
		ids := make([]ent.Value, 0, len(m.suppliers))
		for id := range m.suppliers {
			ids = append(ids, id)
		}
		return ids
	case company.EdgeTokens:
		ids := make([]ent.Value, 0, len(m.tokens))
		for id := range m.tokens {
			ids = append(ids, id)
		}
		return ids
	case company.EdgeTreasuries:
		ids := make([]ent.Value, 0, len(m.treasuries))
		for id := range m.treasuries {
			ids = append(ids, id)
		}
		return ids
	case company.EdgeWorkShifts:
		ids := make([]ent.Value, 0, len(m.work_shifts))
		for id := range m.work_shifts {
			ids = append(ids, id)
		}
		return ids
	case company.EdgeUsers:
		ids := make([]ent.Value, 0, len(m.users))
		for id := range m.users {
			ids = append(ids, id)
		}
		return ids
	case company.EdgeDaughterCompanies:
		ids := make([]ent.Value, 0, len(m.daughter_companies))
		for id := range m.daughter_companies {
			ids = append(ids, id)
		}
		return ids
	case company.EdgeParentCompany:
		if id := m.parent_company; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CompanyMutation) RemovedEdges() []string {
	edges := make([]string, 0, 23)
	if m.removedavailable_roles != nil {
		edges = append(edges, company.EdgeAvailableRoles)
	}
	if m.removedaccounting_entries != nil {
		edges = append(edges, company.EdgeAccountingEntries)
	}
	if m.removedcustomers != nil {
		edges = append(edges, company.EdgeCustomers)
	}
	if m.removeddocuments != nil {
		edges = append(edges, company.EdgeDocuments)
	}
	if m.removedemployees != nil {
		edges = append(edges, company.EdgeEmployees)
	}
	if m.removedfiles != nil {
		edges = append(edges, company.EdgeFiles)
	}
	if m.removedinventory != nil {
		edges = append(edges, company.EdgeInventory)
	}
	if m.removedinventory_movements != nil {
		edges = append(edges, company.EdgeInventoryMovements)
	}
	if m.removedinvoices != nil {
		edges = append(edges, company.EdgeInvoices)
	}
	if m.removedloans != nil {
		edges = append(edges, company.EdgeLoans)
	}
	if m.removedloan_schedule != nil {
		edges = append(edges, company.EdgeLoanSchedule)
	}
	if m.removedmember_signup_tokens != nil {
		edges = append(edges, company.EdgeMemberSignupTokens)
	}
	if m.removedproducts != nil {
		edges = append(edges, company.EdgeProducts)
	}
	if m.removedprojects != nil {
		edges = append(edges, company.EdgeProjects)
	}
	if m.removedpayables != nil {
		edges = append(edges, company.EdgePayables)
	}
	if m.removedreceivables != nil {
		edges = append(edges, company.EdgeReceivables)
	}
	if m.removedsuppliers != nil {
		edges = append(edges, company.EdgeSuppliers)
	}
	if m.removedtokens != nil {
		edges = append(edges, company.EdgeTokens)
	}
	if m.removedtreasuries != nil {
		edges = append(edges, company.EdgeTreasuries)
	}
	if m.removedwork_shifts != nil {
		edges = append(edges, company.EdgeWorkShifts)
	}
	if m.removedusers != nil {
		edges = append(edges, company.EdgeUsers)
	}
	if m.removeddaughter_companies != nil {
		edges = append(edges, company.EdgeDaughterCompanies)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CompanyMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case company.EdgeAvailableRoles:
		ids := make([]ent.Value, 0, len(m.removedavailable_roles))
		for id := range m.removedavailable_roles {
			ids = append(ids, id)
		}
		return ids
	case company.EdgeAccountingEntries:
		ids := make([]ent.Value, 0, len(m.removedaccounting_entries))
		for id := range m.removedaccounting_entries {
			ids = append(ids, id)
		}
		return ids
	case company.EdgeCustomers:
		ids := make([]ent.Value, 0, len(m.removedcustomers))
		for id := range m.removedcustomers {
			ids = append(ids, id)
		}
		return ids
	case company.EdgeDocuments:
		ids := make([]ent.Value, 0, len(m.removeddocuments))
		for id := range m.removeddocuments {
			ids = append(ids, id)
		}
		return ids
	case company.EdgeEmployees:
		ids := make([]ent.Value, 0, len(m.removedemployees))
		for id := range m.removedemployees {
			ids = append(ids, id)
		}
		return ids
	case company.EdgeFiles:
		ids := make([]ent.Value, 0, len(m.removedfiles))
		for id := range m.removedfiles {
			ids = append(ids, id)
		}
		return ids
	case company.EdgeInventory:
		ids := make([]ent.Value, 0, len(m.removedinventory))
		for id := range m.removedinventory {
			ids = append(ids, id)
		}
		return ids
	case company.EdgeInventoryMovements:
		ids := make([]ent.Value, 0, len(m.removedinventory_movements))
		for id := range m.removedinventory_movements {
			ids = append(ids, id)
		}
		return ids
	case company.EdgeInvoices:
		ids := make([]ent.Value, 0, len(m.removedinvoices))
		for id := range m.removedinvoices {
			ids = append(ids, id)
		}
		return ids
	case company.EdgeLoans:
		ids := make([]ent.Value, 0, len(m.removedloans))
		for id := range m.removedloans {
			ids = append(ids, id)
		}
		return ids
	case company.EdgeLoanSchedule:
		ids := make([]ent.Value, 0, len(m.removedloan_schedule))
		for id := range m.removedloan_schedule {
			ids = append(ids, id)
		}
		return ids
	case company.EdgeMemberSignupTokens:
		ids := make([]ent.Value, 0, len(m.removedmember_signup_tokens))
		for id := range m.removedmember_signup_tokens {
			ids = append(ids, id)
		}
		return ids
	case company.EdgeProducts:
		ids := make([]ent.Value, 0, len(m.removedproducts))
		for id := range m.removedproducts {
			ids = append(ids, id)
		}
		return ids
	case company.EdgeProjects:
		ids := make([]ent.Value, 0, len(m.removedprojects))
		for id := range m.removedprojects {
			ids = append(ids, id)
		}
		return ids
	case company.EdgePayables:
		ids := make([]ent.Value, 0, len(m.removedpayables))
		for id := range m.removedpayables {
			ids = append(ids, id)
		}
		return ids
	case company.EdgeReceivables:
		ids := make([]ent.Value, 0, len(m.removedreceivables))
		for id := range m.removedreceivables {
			ids = append(ids, id)
		}
		return ids
	case company.EdgeSuppliers:
		ids := make([]ent.Value, 0, len(m.removedsuppliers))
		for id := range m.removedsuppliers {
			ids = append(ids, id)
		}
		return ids
	case company.EdgeTokens:
		ids := make([]ent.Value, 0, len(m.removedtokens))
		for id := range m.removedtokens {
			ids = append(ids, id)
		}
		return ids
	case company.EdgeTreasuries:
		ids := make([]ent.Value, 0, len(m.removedtreasuries))
		for id := range m.removedtreasuries {
			ids = append(ids, id)
		}
		return ids
	case company.EdgeWorkShifts:
		ids := make([]ent.Value, 0, len(m.removedwork_shifts))
		for id := range m.removedwork_shifts {
			ids = append(ids, id)
		}
		return ids
	case company.EdgeUsers:
		ids := make([]ent.Value, 0, len(m.removedusers))
		for id := range m.removedusers {
			ids = append(ids, id)
		}
		return ids
	case company.EdgeDaughterCompanies:
		ids := make([]ent.Value, 0, len(m.removeddaughter_companies))
		for id := range m.removeddaughter_companies {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CompanyMutation) ClearedEdges() []string {
	edges := make([]string, 0, 23)
	if m.clearedavailable_roles {
		edges = append(edges, company.EdgeAvailableRoles)
	}
	if m.clearedaccounting_entries {
		edges = append(edges, company.EdgeAccountingEntries)
	}
	if m.clearedcustomers {
		edges = append(edges, company.EdgeCustomers)
	}
	if m.cleareddocuments {
		edges = append(edges, company.EdgeDocuments)
	}
	if m.clearedemployees {
		edges = append(edges, company.EdgeEmployees)
	}
	if m.clearedfiles {
		edges = append(edges, company.EdgeFiles)
	}
	if m.clearedinventory {
		edges = append(edges, company.EdgeInventory)
	}
	if m.clearedinventory_movements {
		edges = append(edges, company.EdgeInventoryMovements)
	}
	if m.clearedinvoices {
		edges = append(edges, company.EdgeInvoices)
	}
	if m.clearedloans {
		edges = append(edges, company.EdgeLoans)
	}
	if m.clearedloan_schedule {
		edges = append(edges, company.EdgeLoanSchedule)
	}
	if m.clearedmember_signup_tokens {
		edges = append(edges, company.EdgeMemberSignupTokens)
	}
	if m.clearedproducts {
		edges = append(edges, company.EdgeProducts)
	}
	if m.clearedprojects {
		edges = append(edges, company.EdgeProjects)
	}
	if m.clearedpayables {
		edges = append(edges, company.EdgePayables)
	}
	if m.clearedreceivables {
		edges = append(edges, company.EdgeReceivables)
	}
	if m.clearedsuppliers {
		edges = append(edges, company.EdgeSuppliers)
	}
	if m.clearedtokens {
		edges = append(edges, company.EdgeTokens)
	}
	if m.clearedtreasuries {
		edges = append(edges, company.EdgeTreasuries)
	}
	if m.clearedwork_shifts {
		edges = append(edges, company.EdgeWorkShifts)
	}
	if m.clearedusers {
		edges = append(edges, company.EdgeUsers)
	}
	if m.cleareddaughter_companies {
		edges = append(edges, company.EdgeDaughterCompanies)
	}
	if m.clearedparent_company {
		edges = append(edges, company.EdgeParentCompany)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CompanyMutation) EdgeCleared(name string) bool {
	switch name {
	case company.EdgeAvailableRoles:
		return m.clearedavailable_roles
	case company.EdgeAccountingEntries:
		return m.clearedaccounting_entries
	case company.EdgeCustomers:
		return m.clearedcustomers
	case company.EdgeDocuments:
		return m.cleareddocuments
	case company.EdgeEmployees:
		return m.clearedemployees
	case company.EdgeFiles:
		return m.clearedfiles
	case company.EdgeInventory:
		return m.clearedinventory
	case company.EdgeInventoryMovements:
		return m.clearedinventory_movements
	case company.EdgeInvoices:
		return m.clearedinvoices
	case company.EdgeLoans:
		return m.clearedloans
	case company.EdgeLoanSchedule:
		return m.clearedloan_schedule
	case company.EdgeMemberSignupTokens:
		return m.clearedmember_signup_tokens
	case company.EdgeProducts:
		return m.clearedproducts
	case company.EdgeProjects:
		return m.clearedprojects
	case company.EdgePayables:
		return m.clearedpayables
	case company.EdgeReceivables:
		return m.clearedreceivables
	case company.EdgeSuppliers:
		return m.clearedsuppliers
	case company.EdgeTokens:
		return m.clearedtokens
	case company.EdgeTreasuries:
		return m.clearedtreasuries
	case company.EdgeWorkShifts:
		return m.clearedwork_shifts
	case company.EdgeUsers:
		return m.clearedusers
	case company.EdgeDaughterCompanies:
		return m.cleareddaughter_companies
	case company.EdgeParentCompany:
		return m.clearedparent_company
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CompanyMutation) ClearEdge(name string) error {
	switch name {
	case company.EdgeParentCompany:
		m.ClearParentCompany()
		return nil
	}
	return fmt.Errorf("unknown Company unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CompanyMutation) ResetEdge(name string) error {
	switch name {
	case company.EdgeAvailableRoles:
		m.ResetAvailableRoles()
		return nil
	case company.EdgeAccountingEntries:
		m.ResetAccountingEntries()
		return nil
	case company.EdgeCustomers:
		m.ResetCustomers()
		return nil
	case company.EdgeDocuments:
		m.ResetDocuments()
		return nil
	case company.EdgeEmployees:
		m.ResetEmployees()
		return nil
	case company.EdgeFiles:
		m.ResetFiles()
		return nil
	case company.EdgeInventory:
		m.ResetInventory()
		return nil
	case company.EdgeInventoryMovements:
		m.ResetInventoryMovements()
		return nil
	case company.EdgeInvoices:
		m.ResetInvoices()
		return nil
	case company.EdgeLoans:
		m.ResetLoans()
		return nil
	case company.EdgeLoanSchedule:
		m.ResetLoanSchedule()
		return nil
	case company.EdgeMemberSignupTokens:
		m.ResetMemberSignupTokens()
		return nil
	case company.EdgeProducts:
		m.ResetProducts()
		return nil
	case company.EdgeProjects:
		m.ResetProjects()
		return nil
	case company.EdgePayables:
		m.ResetPayables()
		return nil
	case company.EdgeReceivables:
		m.ResetReceivables()
		return nil
	case company.EdgeSuppliers:
		m.ResetSuppliers()
		return nil
	case company.EdgeTokens:
		m.ResetTokens()
		return nil
	case company.EdgeTreasuries:
		m.ResetTreasuries()
		return nil
	case company.EdgeWorkShifts:
		m.ResetWorkShifts()
		return nil
	case company.EdgeUsers:
		m.ResetUsers()
		return nil
	case company.EdgeDaughterCompanies:
		m.ResetDaughterCompanies()
		return nil
	case company.EdgeParentCompany:
		m.ResetParentCompany()
		return nil
	}
	return fmt.Errorf("unknown Company edge %s", name)
}

// CompanyDocumentMutation represents an operation that mutates the CompanyDocument nodes in the graph.
type CompanyDocumentMutation struct {
	config
	op                 Op
	typ                string
	id                 *int
	created_at         *time.Time
	updated_at         *time.Time
	deleted_at         *time.Time
	filename           *string
	title              *string
	keywords           *string
	category           *companydocument.Category
	size               *int
	addsize            *int
	file_type          *string
	status             *companydocument.Status
	url                *string
	storage_URI        *string
	thumbnail          *string
	expiry_date        *time.Time
	clearedFields      map[string]struct{}
	company            *int
	clearedcompany     bool
	uploaded_by        *int
	cleareduploaded_by bool
	approved_by        *int
	clearedapproved_by bool
	done               bool
	oldValue           func(context.Context) (*CompanyDocument, error)
	predicates         []predicate.CompanyDocument
}

var _ ent.Mutation = (*CompanyDocumentMutation)(nil)

// companydocumentOption allows management of the mutation configuration using functional options.
type companydocumentOption func(*CompanyDocumentMutation)

// newCompanyDocumentMutation creates new mutation for the CompanyDocument entity.
func newCompanyDocumentMutation(c config, op Op, opts ...companydocumentOption) *CompanyDocumentMutation {
	m := &CompanyDocumentMutation{
		config:        c,
		op:            op,
		typ:           TypeCompanyDocument,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCompanyDocumentID sets the ID field of the mutation.
func withCompanyDocumentID(id int) companydocumentOption {
	return func(m *CompanyDocumentMutation) {
		var (
			err   error
			once  sync.Once
			value *CompanyDocument
		)
		m.oldValue = func(ctx context.Context) (*CompanyDocument, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().CompanyDocument.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCompanyDocument sets the old CompanyDocument of the mutation.
func withCompanyDocument(node *CompanyDocument) companydocumentOption {
	return func(m *CompanyDocumentMutation) {
		m.oldValue = func(context.Context) (*CompanyDocument, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CompanyDocumentMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CompanyDocumentMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("generated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CompanyDocumentMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CompanyDocumentMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().CompanyDocument.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *CompanyDocumentMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *CompanyDocumentMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the CompanyDocument entity.
// If the CompanyDocument object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CompanyDocumentMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *CompanyDocumentMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *CompanyDocumentMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *CompanyDocumentMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the CompanyDocument entity.
// If the CompanyDocument object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CompanyDocumentMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *CompanyDocumentMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *CompanyDocumentMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *CompanyDocumentMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the CompanyDocument entity.
// If the CompanyDocument object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CompanyDocumentMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *CompanyDocumentMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[companydocument.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *CompanyDocumentMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[companydocument.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *CompanyDocumentMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, companydocument.FieldDeletedAt)
}

// SetFilename sets the "filename" field.
func (m *CompanyDocumentMutation) SetFilename(s string) {
	m.filename = &s
}

// Filename returns the value of the "filename" field in the mutation.
func (m *CompanyDocumentMutation) Filename() (r string, exists bool) {
	v := m.filename
	if v == nil {
		return
	}
	return *v, true
}

// OldFilename returns the old "filename" field's value of the CompanyDocument entity.
// If the CompanyDocument object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CompanyDocumentMutation) OldFilename(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFilename is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFilename requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFilename: %w", err)
	}
	return oldValue.Filename, nil
}

// ResetFilename resets all changes to the "filename" field.
func (m *CompanyDocumentMutation) ResetFilename() {
	m.filename = nil
}

// SetTitle sets the "title" field.
func (m *CompanyDocumentMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *CompanyDocumentMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the CompanyDocument entity.
// If the CompanyDocument object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CompanyDocumentMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *CompanyDocumentMutation) ResetTitle() {
	m.title = nil
}

// SetKeywords sets the "keywords" field.
func (m *CompanyDocumentMutation) SetKeywords(s string) {
	m.keywords = &s
}

// Keywords returns the value of the "keywords" field in the mutation.
func (m *CompanyDocumentMutation) Keywords() (r string, exists bool) {
	v := m.keywords
	if v == nil {
		return
	}
	return *v, true
}

// OldKeywords returns the old "keywords" field's value of the CompanyDocument entity.
// If the CompanyDocument object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CompanyDocumentMutation) OldKeywords(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKeywords is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKeywords requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKeywords: %w", err)
	}
	return oldValue.Keywords, nil
}

// ResetKeywords resets all changes to the "keywords" field.
func (m *CompanyDocumentMutation) ResetKeywords() {
	m.keywords = nil
}

// SetCategory sets the "category" field.
func (m *CompanyDocumentMutation) SetCategory(c companydocument.Category) {
	m.category = &c
}

// Category returns the value of the "category" field in the mutation.
func (m *CompanyDocumentMutation) Category() (r companydocument.Category, exists bool) {
	v := m.category
	if v == nil {
		return
	}
	return *v, true
}

// OldCategory returns the old "category" field's value of the CompanyDocument entity.
// If the CompanyDocument object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CompanyDocumentMutation) OldCategory(ctx context.Context) (v companydocument.Category, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCategory is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCategory requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCategory: %w", err)
	}
	return oldValue.Category, nil
}

// ResetCategory resets all changes to the "category" field.
func (m *CompanyDocumentMutation) ResetCategory() {
	m.category = nil
}

// SetSize sets the "size" field.
func (m *CompanyDocumentMutation) SetSize(i int) {
	m.size = &i
	m.addsize = nil
}

// Size returns the value of the "size" field in the mutation.
func (m *CompanyDocumentMutation) Size() (r int, exists bool) {
	v := m.size
	if v == nil {
		return
	}
	return *v, true
}

// OldSize returns the old "size" field's value of the CompanyDocument entity.
// If the CompanyDocument object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CompanyDocumentMutation) OldSize(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSize is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSize requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSize: %w", err)
	}
	return oldValue.Size, nil
}

// AddSize adds i to the "size" field.
func (m *CompanyDocumentMutation) AddSize(i int) {
	if m.addsize != nil {
		*m.addsize += i
	} else {
		m.addsize = &i
	}
}

// AddedSize returns the value that was added to the "size" field in this mutation.
func (m *CompanyDocumentMutation) AddedSize() (r int, exists bool) {
	v := m.addsize
	if v == nil {
		return
	}
	return *v, true
}

// ResetSize resets all changes to the "size" field.
func (m *CompanyDocumentMutation) ResetSize() {
	m.size = nil
	m.addsize = nil
}

// SetFileType sets the "file_type" field.
func (m *CompanyDocumentMutation) SetFileType(s string) {
	m.file_type = &s
}

// FileType returns the value of the "file_type" field in the mutation.
func (m *CompanyDocumentMutation) FileType() (r string, exists bool) {
	v := m.file_type
	if v == nil {
		return
	}
	return *v, true
}

// OldFileType returns the old "file_type" field's value of the CompanyDocument entity.
// If the CompanyDocument object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CompanyDocumentMutation) OldFileType(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFileType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFileType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFileType: %w", err)
	}
	return oldValue.FileType, nil
}

// ResetFileType resets all changes to the "file_type" field.
func (m *CompanyDocumentMutation) ResetFileType() {
	m.file_type = nil
}

// SetStatus sets the "status" field.
func (m *CompanyDocumentMutation) SetStatus(c companydocument.Status) {
	m.status = &c
}

// Status returns the value of the "status" field in the mutation.
func (m *CompanyDocumentMutation) Status() (r companydocument.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the CompanyDocument entity.
// If the CompanyDocument object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CompanyDocumentMutation) OldStatus(ctx context.Context) (v companydocument.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *CompanyDocumentMutation) ResetStatus() {
	m.status = nil
}

// SetURL sets the "url" field.
func (m *CompanyDocumentMutation) SetURL(s string) {
	m.url = &s
}

// URL returns the value of the "url" field in the mutation.
func (m *CompanyDocumentMutation) URL() (r string, exists bool) {
	v := m.url
	if v == nil {
		return
	}
	return *v, true
}

// OldURL returns the old "url" field's value of the CompanyDocument entity.
// If the CompanyDocument object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CompanyDocumentMutation) OldURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldURL: %w", err)
	}
	return oldValue.URL, nil
}

// ResetURL resets all changes to the "url" field.
func (m *CompanyDocumentMutation) ResetURL() {
	m.url = nil
}

// SetStorageURI sets the "storage_URI" field.
func (m *CompanyDocumentMutation) SetStorageURI(s string) {
	m.storage_URI = &s
}

// StorageURI returns the value of the "storage_URI" field in the mutation.
func (m *CompanyDocumentMutation) StorageURI() (r string, exists bool) {
	v := m.storage_URI
	if v == nil {
		return
	}
	return *v, true
}

// OldStorageURI returns the old "storage_URI" field's value of the CompanyDocument entity.
// If the CompanyDocument object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CompanyDocumentMutation) OldStorageURI(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStorageURI is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStorageURI requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStorageURI: %w", err)
	}
	return oldValue.StorageURI, nil
}

// ResetStorageURI resets all changes to the "storage_URI" field.
func (m *CompanyDocumentMutation) ResetStorageURI() {
	m.storage_URI = nil
}

// SetThumbnail sets the "thumbnail" field.
func (m *CompanyDocumentMutation) SetThumbnail(s string) {
	m.thumbnail = &s
}

// Thumbnail returns the value of the "thumbnail" field in the mutation.
func (m *CompanyDocumentMutation) Thumbnail() (r string, exists bool) {
	v := m.thumbnail
	if v == nil {
		return
	}
	return *v, true
}

// OldThumbnail returns the old "thumbnail" field's value of the CompanyDocument entity.
// If the CompanyDocument object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CompanyDocumentMutation) OldThumbnail(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldThumbnail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldThumbnail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldThumbnail: %w", err)
	}
	return oldValue.Thumbnail, nil
}

// ClearThumbnail clears the value of the "thumbnail" field.
func (m *CompanyDocumentMutation) ClearThumbnail() {
	m.thumbnail = nil
	m.clearedFields[companydocument.FieldThumbnail] = struct{}{}
}

// ThumbnailCleared returns if the "thumbnail" field was cleared in this mutation.
func (m *CompanyDocumentMutation) ThumbnailCleared() bool {
	_, ok := m.clearedFields[companydocument.FieldThumbnail]
	return ok
}

// ResetThumbnail resets all changes to the "thumbnail" field.
func (m *CompanyDocumentMutation) ResetThumbnail() {
	m.thumbnail = nil
	delete(m.clearedFields, companydocument.FieldThumbnail)
}

// SetExpiryDate sets the "expiry_date" field.
func (m *CompanyDocumentMutation) SetExpiryDate(t time.Time) {
	m.expiry_date = &t
}

// ExpiryDate returns the value of the "expiry_date" field in the mutation.
func (m *CompanyDocumentMutation) ExpiryDate() (r time.Time, exists bool) {
	v := m.expiry_date
	if v == nil {
		return
	}
	return *v, true
}

// OldExpiryDate returns the old "expiry_date" field's value of the CompanyDocument entity.
// If the CompanyDocument object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CompanyDocumentMutation) OldExpiryDate(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExpiryDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExpiryDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpiryDate: %w", err)
	}
	return oldValue.ExpiryDate, nil
}

// ResetExpiryDate resets all changes to the "expiry_date" field.
func (m *CompanyDocumentMutation) ResetExpiryDate() {
	m.expiry_date = nil
}

// SetCompanyID sets the "company" edge to the Company entity by id.
func (m *CompanyDocumentMutation) SetCompanyID(id int) {
	m.company = &id
}

// ClearCompany clears the "company" edge to the Company entity.
func (m *CompanyDocumentMutation) ClearCompany() {
	m.clearedcompany = true
}

// CompanyCleared reports if the "company" edge to the Company entity was cleared.
func (m *CompanyDocumentMutation) CompanyCleared() bool {
	return m.clearedcompany
}

// CompanyID returns the "company" edge ID in the mutation.
func (m *CompanyDocumentMutation) CompanyID() (id int, exists bool) {
	if m.company != nil {
		return *m.company, true
	}
	return
}

// CompanyIDs returns the "company" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CompanyID instead. It exists only for internal usage by the builders.
func (m *CompanyDocumentMutation) CompanyIDs() (ids []int) {
	if id := m.company; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCompany resets all changes to the "company" edge.
func (m *CompanyDocumentMutation) ResetCompany() {
	m.company = nil
	m.clearedcompany = false
}

// SetUploadedByID sets the "uploaded_by" edge to the User entity by id.
func (m *CompanyDocumentMutation) SetUploadedByID(id int) {
	m.uploaded_by = &id
}

// ClearUploadedBy clears the "uploaded_by" edge to the User entity.
func (m *CompanyDocumentMutation) ClearUploadedBy() {
	m.cleareduploaded_by = true
}

// UploadedByCleared reports if the "uploaded_by" edge to the User entity was cleared.
func (m *CompanyDocumentMutation) UploadedByCleared() bool {
	return m.cleareduploaded_by
}

// UploadedByID returns the "uploaded_by" edge ID in the mutation.
func (m *CompanyDocumentMutation) UploadedByID() (id int, exists bool) {
	if m.uploaded_by != nil {
		return *m.uploaded_by, true
	}
	return
}

// UploadedByIDs returns the "uploaded_by" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UploadedByID instead. It exists only for internal usage by the builders.
func (m *CompanyDocumentMutation) UploadedByIDs() (ids []int) {
	if id := m.uploaded_by; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUploadedBy resets all changes to the "uploaded_by" edge.
func (m *CompanyDocumentMutation) ResetUploadedBy() {
	m.uploaded_by = nil
	m.cleareduploaded_by = false
}

// SetApprovedByID sets the "approved_by" edge to the User entity by id.
func (m *CompanyDocumentMutation) SetApprovedByID(id int) {
	m.approved_by = &id
}

// ClearApprovedBy clears the "approved_by" edge to the User entity.
func (m *CompanyDocumentMutation) ClearApprovedBy() {
	m.clearedapproved_by = true
}

// ApprovedByCleared reports if the "approved_by" edge to the User entity was cleared.
func (m *CompanyDocumentMutation) ApprovedByCleared() bool {
	return m.clearedapproved_by
}

// ApprovedByID returns the "approved_by" edge ID in the mutation.
func (m *CompanyDocumentMutation) ApprovedByID() (id int, exists bool) {
	if m.approved_by != nil {
		return *m.approved_by, true
	}
	return
}

// ApprovedByIDs returns the "approved_by" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ApprovedByID instead. It exists only for internal usage by the builders.
func (m *CompanyDocumentMutation) ApprovedByIDs() (ids []int) {
	if id := m.approved_by; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetApprovedBy resets all changes to the "approved_by" edge.
func (m *CompanyDocumentMutation) ResetApprovedBy() {
	m.approved_by = nil
	m.clearedapproved_by = false
}

// Where appends a list predicates to the CompanyDocumentMutation builder.
func (m *CompanyDocumentMutation) Where(ps ...predicate.CompanyDocument) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CompanyDocumentMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CompanyDocumentMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.CompanyDocument, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CompanyDocumentMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CompanyDocumentMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (CompanyDocument).
func (m *CompanyDocumentMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CompanyDocumentMutation) Fields() []string {
	fields := make([]string, 0, 14)
	if m.created_at != nil {
		fields = append(fields, companydocument.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, companydocument.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, companydocument.FieldDeletedAt)
	}
	if m.filename != nil {
		fields = append(fields, companydocument.FieldFilename)
	}
	if m.title != nil {
		fields = append(fields, companydocument.FieldTitle)
	}
	if m.keywords != nil {
		fields = append(fields, companydocument.FieldKeywords)
	}
	if m.category != nil {
		fields = append(fields, companydocument.FieldCategory)
	}
	if m.size != nil {
		fields = append(fields, companydocument.FieldSize)
	}
	if m.file_type != nil {
		fields = append(fields, companydocument.FieldFileType)
	}
	if m.status != nil {
		fields = append(fields, companydocument.FieldStatus)
	}
	if m.url != nil {
		fields = append(fields, companydocument.FieldURL)
	}
	if m.storage_URI != nil {
		fields = append(fields, companydocument.FieldStorageURI)
	}
	if m.thumbnail != nil {
		fields = append(fields, companydocument.FieldThumbnail)
	}
	if m.expiry_date != nil {
		fields = append(fields, companydocument.FieldExpiryDate)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CompanyDocumentMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case companydocument.FieldCreatedAt:
		return m.CreatedAt()
	case companydocument.FieldUpdatedAt:
		return m.UpdatedAt()
	case companydocument.FieldDeletedAt:
		return m.DeletedAt()
	case companydocument.FieldFilename:
		return m.Filename()
	case companydocument.FieldTitle:
		return m.Title()
	case companydocument.FieldKeywords:
		return m.Keywords()
	case companydocument.FieldCategory:
		return m.Category()
	case companydocument.FieldSize:
		return m.Size()
	case companydocument.FieldFileType:
		return m.FileType()
	case companydocument.FieldStatus:
		return m.Status()
	case companydocument.FieldURL:
		return m.URL()
	case companydocument.FieldStorageURI:
		return m.StorageURI()
	case companydocument.FieldThumbnail:
		return m.Thumbnail()
	case companydocument.FieldExpiryDate:
		return m.ExpiryDate()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CompanyDocumentMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case companydocument.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case companydocument.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case companydocument.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case companydocument.FieldFilename:
		return m.OldFilename(ctx)
	case companydocument.FieldTitle:
		return m.OldTitle(ctx)
	case companydocument.FieldKeywords:
		return m.OldKeywords(ctx)
	case companydocument.FieldCategory:
		return m.OldCategory(ctx)
	case companydocument.FieldSize:
		return m.OldSize(ctx)
	case companydocument.FieldFileType:
		return m.OldFileType(ctx)
	case companydocument.FieldStatus:
		return m.OldStatus(ctx)
	case companydocument.FieldURL:
		return m.OldURL(ctx)
	case companydocument.FieldStorageURI:
		return m.OldStorageURI(ctx)
	case companydocument.FieldThumbnail:
		return m.OldThumbnail(ctx)
	case companydocument.FieldExpiryDate:
		return m.OldExpiryDate(ctx)
	}
	return nil, fmt.Errorf("unknown CompanyDocument field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CompanyDocumentMutation) SetField(name string, value ent.Value) error {
	switch name {
	case companydocument.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case companydocument.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case companydocument.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case companydocument.FieldFilename:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFilename(v)
		return nil
	case companydocument.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case companydocument.FieldKeywords:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKeywords(v)
		return nil
	case companydocument.FieldCategory:
		v, ok := value.(companydocument.Category)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCategory(v)
		return nil
	case companydocument.FieldSize:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSize(v)
		return nil
	case companydocument.FieldFileType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFileType(v)
		return nil
	case companydocument.FieldStatus:
		v, ok := value.(companydocument.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case companydocument.FieldURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetURL(v)
		return nil
	case companydocument.FieldStorageURI:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStorageURI(v)
		return nil
	case companydocument.FieldThumbnail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetThumbnail(v)
		return nil
	case companydocument.FieldExpiryDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpiryDate(v)
		return nil
	}
	return fmt.Errorf("unknown CompanyDocument field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CompanyDocumentMutation) AddedFields() []string {
	var fields []string
	if m.addsize != nil {
		fields = append(fields, companydocument.FieldSize)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CompanyDocumentMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case companydocument.FieldSize:
		return m.AddedSize()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CompanyDocumentMutation) AddField(name string, value ent.Value) error {
	switch name {
	case companydocument.FieldSize:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSize(v)
		return nil
	}
	return fmt.Errorf("unknown CompanyDocument numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CompanyDocumentMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(companydocument.FieldDeletedAt) {
		fields = append(fields, companydocument.FieldDeletedAt)
	}
	if m.FieldCleared(companydocument.FieldThumbnail) {
		fields = append(fields, companydocument.FieldThumbnail)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CompanyDocumentMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CompanyDocumentMutation) ClearField(name string) error {
	switch name {
	case companydocument.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case companydocument.FieldThumbnail:
		m.ClearThumbnail()
		return nil
	}
	return fmt.Errorf("unknown CompanyDocument nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CompanyDocumentMutation) ResetField(name string) error {
	switch name {
	case companydocument.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case companydocument.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case companydocument.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case companydocument.FieldFilename:
		m.ResetFilename()
		return nil
	case companydocument.FieldTitle:
		m.ResetTitle()
		return nil
	case companydocument.FieldKeywords:
		m.ResetKeywords()
		return nil
	case companydocument.FieldCategory:
		m.ResetCategory()
		return nil
	case companydocument.FieldSize:
		m.ResetSize()
		return nil
	case companydocument.FieldFileType:
		m.ResetFileType()
		return nil
	case companydocument.FieldStatus:
		m.ResetStatus()
		return nil
	case companydocument.FieldURL:
		m.ResetURL()
		return nil
	case companydocument.FieldStorageURI:
		m.ResetStorageURI()
		return nil
	case companydocument.FieldThumbnail:
		m.ResetThumbnail()
		return nil
	case companydocument.FieldExpiryDate:
		m.ResetExpiryDate()
		return nil
	}
	return fmt.Errorf("unknown CompanyDocument field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CompanyDocumentMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.company != nil {
		edges = append(edges, companydocument.EdgeCompany)
	}
	if m.uploaded_by != nil {
		edges = append(edges, companydocument.EdgeUploadedBy)
	}
	if m.approved_by != nil {
		edges = append(edges, companydocument.EdgeApprovedBy)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CompanyDocumentMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case companydocument.EdgeCompany:
		if id := m.company; id != nil {
			return []ent.Value{*id}
		}
	case companydocument.EdgeUploadedBy:
		if id := m.uploaded_by; id != nil {
			return []ent.Value{*id}
		}
	case companydocument.EdgeApprovedBy:
		if id := m.approved_by; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CompanyDocumentMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CompanyDocumentMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CompanyDocumentMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedcompany {
		edges = append(edges, companydocument.EdgeCompany)
	}
	if m.cleareduploaded_by {
		edges = append(edges, companydocument.EdgeUploadedBy)
	}
	if m.clearedapproved_by {
		edges = append(edges, companydocument.EdgeApprovedBy)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CompanyDocumentMutation) EdgeCleared(name string) bool {
	switch name {
	case companydocument.EdgeCompany:
		return m.clearedcompany
	case companydocument.EdgeUploadedBy:
		return m.cleareduploaded_by
	case companydocument.EdgeApprovedBy:
		return m.clearedapproved_by
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CompanyDocumentMutation) ClearEdge(name string) error {
	switch name {
	case companydocument.EdgeCompany:
		m.ClearCompany()
		return nil
	case companydocument.EdgeUploadedBy:
		m.ClearUploadedBy()
		return nil
	case companydocument.EdgeApprovedBy:
		m.ClearApprovedBy()
		return nil
	}
	return fmt.Errorf("unknown CompanyDocument unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CompanyDocumentMutation) ResetEdge(name string) error {
	switch name {
	case companydocument.EdgeCompany:
		m.ResetCompany()
		return nil
	case companydocument.EdgeUploadedBy:
		m.ResetUploadedBy()
		return nil
	case companydocument.EdgeApprovedBy:
		m.ResetApprovedBy()
		return nil
	}
	return fmt.Errorf("unknown CompanyDocument edge %s", name)
}

// CustomerMutation represents an operation that mutates the Customer nodes in the graph.
type CustomerMutation struct {
	config
	op                 Op
	typ                string
	id                 *int
	created_at         *time.Time
	updated_at         *time.Time
	deleted_at         *time.Time
	address            *string
	city               *string
	country            *string
	description        *string
	email              *string
	is_default         *bool
	name               *string
	phone              *string
	tax_id             *string
	clearedFields      map[string]struct{}
	company            *int
	clearedcompany     bool
	loans              map[int]struct{}
	removedloans       map[int]struct{}
	clearedloans       bool
	receivables        map[int]struct{}
	removedreceivables map[int]struct{}
	clearedreceivables bool
	invoices           map[int]struct{}
	removedinvoices    map[int]struct{}
	clearedinvoices    bool
	done               bool
	oldValue           func(context.Context) (*Customer, error)
	predicates         []predicate.Customer
}

var _ ent.Mutation = (*CustomerMutation)(nil)

// customerOption allows management of the mutation configuration using functional options.
type customerOption func(*CustomerMutation)

// newCustomerMutation creates new mutation for the Customer entity.
func newCustomerMutation(c config, op Op, opts ...customerOption) *CustomerMutation {
	m := &CustomerMutation{
		config:        c,
		op:            op,
		typ:           TypeCustomer,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCustomerID sets the ID field of the mutation.
func withCustomerID(id int) customerOption {
	return func(m *CustomerMutation) {
		var (
			err   error
			once  sync.Once
			value *Customer
		)
		m.oldValue = func(ctx context.Context) (*Customer, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Customer.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCustomer sets the old Customer of the mutation.
func withCustomer(node *Customer) customerOption {
	return func(m *CustomerMutation) {
		m.oldValue = func(context.Context) (*Customer, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CustomerMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CustomerMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("generated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CustomerMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CustomerMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Customer.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *CustomerMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *CustomerMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Customer entity.
// If the Customer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *CustomerMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *CustomerMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *CustomerMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Customer entity.
// If the Customer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *CustomerMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *CustomerMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *CustomerMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Customer entity.
// If the Customer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *CustomerMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[customer.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *CustomerMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[customer.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *CustomerMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, customer.FieldDeletedAt)
}

// SetAddress sets the "address" field.
func (m *CustomerMutation) SetAddress(s string) {
	m.address = &s
}

// Address returns the value of the "address" field in the mutation.
func (m *CustomerMutation) Address() (r string, exists bool) {
	v := m.address
	if v == nil {
		return
	}
	return *v, true
}

// OldAddress returns the old "address" field's value of the Customer entity.
// If the Customer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerMutation) OldAddress(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAddress: %w", err)
	}
	return oldValue.Address, nil
}

// ClearAddress clears the value of the "address" field.
func (m *CustomerMutation) ClearAddress() {
	m.address = nil
	m.clearedFields[customer.FieldAddress] = struct{}{}
}

// AddressCleared returns if the "address" field was cleared in this mutation.
func (m *CustomerMutation) AddressCleared() bool {
	_, ok := m.clearedFields[customer.FieldAddress]
	return ok
}

// ResetAddress resets all changes to the "address" field.
func (m *CustomerMutation) ResetAddress() {
	m.address = nil
	delete(m.clearedFields, customer.FieldAddress)
}

// SetCity sets the "city" field.
func (m *CustomerMutation) SetCity(s string) {
	m.city = &s
}

// City returns the value of the "city" field in the mutation.
func (m *CustomerMutation) City() (r string, exists bool) {
	v := m.city
	if v == nil {
		return
	}
	return *v, true
}

// OldCity returns the old "city" field's value of the Customer entity.
// If the Customer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerMutation) OldCity(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCity: %w", err)
	}
	return oldValue.City, nil
}

// ClearCity clears the value of the "city" field.
func (m *CustomerMutation) ClearCity() {
	m.city = nil
	m.clearedFields[customer.FieldCity] = struct{}{}
}

// CityCleared returns if the "city" field was cleared in this mutation.
func (m *CustomerMutation) CityCleared() bool {
	_, ok := m.clearedFields[customer.FieldCity]
	return ok
}

// ResetCity resets all changes to the "city" field.
func (m *CustomerMutation) ResetCity() {
	m.city = nil
	delete(m.clearedFields, customer.FieldCity)
}

// SetCountry sets the "country" field.
func (m *CustomerMutation) SetCountry(s string) {
	m.country = &s
}

// Country returns the value of the "country" field in the mutation.
func (m *CustomerMutation) Country() (r string, exists bool) {
	v := m.country
	if v == nil {
		return
	}
	return *v, true
}

// OldCountry returns the old "country" field's value of the Customer entity.
// If the Customer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerMutation) OldCountry(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCountry is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCountry requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCountry: %w", err)
	}
	return oldValue.Country, nil
}

// ClearCountry clears the value of the "country" field.
func (m *CustomerMutation) ClearCountry() {
	m.country = nil
	m.clearedFields[customer.FieldCountry] = struct{}{}
}

// CountryCleared returns if the "country" field was cleared in this mutation.
func (m *CustomerMutation) CountryCleared() bool {
	_, ok := m.clearedFields[customer.FieldCountry]
	return ok
}

// ResetCountry resets all changes to the "country" field.
func (m *CustomerMutation) ResetCountry() {
	m.country = nil
	delete(m.clearedFields, customer.FieldCountry)
}

// SetDescription sets the "description" field.
func (m *CustomerMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *CustomerMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Customer entity.
// If the Customer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *CustomerMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[customer.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *CustomerMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[customer.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *CustomerMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, customer.FieldDescription)
}

// SetEmail sets the "email" field.
func (m *CustomerMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *CustomerMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the Customer entity.
// If the Customer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ClearEmail clears the value of the "email" field.
func (m *CustomerMutation) ClearEmail() {
	m.email = nil
	m.clearedFields[customer.FieldEmail] = struct{}{}
}

// EmailCleared returns if the "email" field was cleared in this mutation.
func (m *CustomerMutation) EmailCleared() bool {
	_, ok := m.clearedFields[customer.FieldEmail]
	return ok
}

// ResetEmail resets all changes to the "email" field.
func (m *CustomerMutation) ResetEmail() {
	m.email = nil
	delete(m.clearedFields, customer.FieldEmail)
}

// SetIsDefault sets the "is_default" field.
func (m *CustomerMutation) SetIsDefault(b bool) {
	m.is_default = &b
}

// IsDefault returns the value of the "is_default" field in the mutation.
func (m *CustomerMutation) IsDefault() (r bool, exists bool) {
	v := m.is_default
	if v == nil {
		return
	}
	return *v, true
}

// OldIsDefault returns the old "is_default" field's value of the Customer entity.
// If the Customer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerMutation) OldIsDefault(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsDefault is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsDefault requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsDefault: %w", err)
	}
	return oldValue.IsDefault, nil
}

// ClearIsDefault clears the value of the "is_default" field.
func (m *CustomerMutation) ClearIsDefault() {
	m.is_default = nil
	m.clearedFields[customer.FieldIsDefault] = struct{}{}
}

// IsDefaultCleared returns if the "is_default" field was cleared in this mutation.
func (m *CustomerMutation) IsDefaultCleared() bool {
	_, ok := m.clearedFields[customer.FieldIsDefault]
	return ok
}

// ResetIsDefault resets all changes to the "is_default" field.
func (m *CustomerMutation) ResetIsDefault() {
	m.is_default = nil
	delete(m.clearedFields, customer.FieldIsDefault)
}

// SetName sets the "name" field.
func (m *CustomerMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *CustomerMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Customer entity.
// If the Customer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *CustomerMutation) ResetName() {
	m.name = nil
}

// SetPhone sets the "phone" field.
func (m *CustomerMutation) SetPhone(s string) {
	m.phone = &s
}

// Phone returns the value of the "phone" field in the mutation.
func (m *CustomerMutation) Phone() (r string, exists bool) {
	v := m.phone
	if v == nil {
		return
	}
	return *v, true
}

// OldPhone returns the old "phone" field's value of the Customer entity.
// If the Customer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerMutation) OldPhone(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPhone is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPhone requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPhone: %w", err)
	}
	return oldValue.Phone, nil
}

// ClearPhone clears the value of the "phone" field.
func (m *CustomerMutation) ClearPhone() {
	m.phone = nil
	m.clearedFields[customer.FieldPhone] = struct{}{}
}

// PhoneCleared returns if the "phone" field was cleared in this mutation.
func (m *CustomerMutation) PhoneCleared() bool {
	_, ok := m.clearedFields[customer.FieldPhone]
	return ok
}

// ResetPhone resets all changes to the "phone" field.
func (m *CustomerMutation) ResetPhone() {
	m.phone = nil
	delete(m.clearedFields, customer.FieldPhone)
}

// SetTaxID sets the "tax_id" field.
func (m *CustomerMutation) SetTaxID(s string) {
	m.tax_id = &s
}

// TaxID returns the value of the "tax_id" field in the mutation.
func (m *CustomerMutation) TaxID() (r string, exists bool) {
	v := m.tax_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTaxID returns the old "tax_id" field's value of the Customer entity.
// If the Customer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerMutation) OldTaxID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTaxID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTaxID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTaxID: %w", err)
	}
	return oldValue.TaxID, nil
}

// ClearTaxID clears the value of the "tax_id" field.
func (m *CustomerMutation) ClearTaxID() {
	m.tax_id = nil
	m.clearedFields[customer.FieldTaxID] = struct{}{}
}

// TaxIDCleared returns if the "tax_id" field was cleared in this mutation.
func (m *CustomerMutation) TaxIDCleared() bool {
	_, ok := m.clearedFields[customer.FieldTaxID]
	return ok
}

// ResetTaxID resets all changes to the "tax_id" field.
func (m *CustomerMutation) ResetTaxID() {
	m.tax_id = nil
	delete(m.clearedFields, customer.FieldTaxID)
}

// SetCompanyID sets the "company" edge to the Company entity by id.
func (m *CustomerMutation) SetCompanyID(id int) {
	m.company = &id
}

// ClearCompany clears the "company" edge to the Company entity.
func (m *CustomerMutation) ClearCompany() {
	m.clearedcompany = true
}

// CompanyCleared reports if the "company" edge to the Company entity was cleared.
func (m *CustomerMutation) CompanyCleared() bool {
	return m.clearedcompany
}

// CompanyID returns the "company" edge ID in the mutation.
func (m *CustomerMutation) CompanyID() (id int, exists bool) {
	if m.company != nil {
		return *m.company, true
	}
	return
}

// CompanyIDs returns the "company" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CompanyID instead. It exists only for internal usage by the builders.
func (m *CustomerMutation) CompanyIDs() (ids []int) {
	if id := m.company; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCompany resets all changes to the "company" edge.
func (m *CustomerMutation) ResetCompany() {
	m.company = nil
	m.clearedcompany = false
}

// AddLoanIDs adds the "loans" edge to the Loan entity by ids.
func (m *CustomerMutation) AddLoanIDs(ids ...int) {
	if m.loans == nil {
		m.loans = make(map[int]struct{})
	}
	for i := range ids {
		m.loans[ids[i]] = struct{}{}
	}
}

// ClearLoans clears the "loans" edge to the Loan entity.
func (m *CustomerMutation) ClearLoans() {
	m.clearedloans = true
}

// LoansCleared reports if the "loans" edge to the Loan entity was cleared.
func (m *CustomerMutation) LoansCleared() bool {
	return m.clearedloans
}

// RemoveLoanIDs removes the "loans" edge to the Loan entity by IDs.
func (m *CustomerMutation) RemoveLoanIDs(ids ...int) {
	if m.removedloans == nil {
		m.removedloans = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.loans, ids[i])
		m.removedloans[ids[i]] = struct{}{}
	}
}

// RemovedLoans returns the removed IDs of the "loans" edge to the Loan entity.
func (m *CustomerMutation) RemovedLoansIDs() (ids []int) {
	for id := range m.removedloans {
		ids = append(ids, id)
	}
	return
}

// LoansIDs returns the "loans" edge IDs in the mutation.
func (m *CustomerMutation) LoansIDs() (ids []int) {
	for id := range m.loans {
		ids = append(ids, id)
	}
	return
}

// ResetLoans resets all changes to the "loans" edge.
func (m *CustomerMutation) ResetLoans() {
	m.loans = nil
	m.clearedloans = false
	m.removedloans = nil
}

// AddReceivableIDs adds the "receivables" edge to the Receivable entity by ids.
func (m *CustomerMutation) AddReceivableIDs(ids ...int) {
	if m.receivables == nil {
		m.receivables = make(map[int]struct{})
	}
	for i := range ids {
		m.receivables[ids[i]] = struct{}{}
	}
}

// ClearReceivables clears the "receivables" edge to the Receivable entity.
func (m *CustomerMutation) ClearReceivables() {
	m.clearedreceivables = true
}

// ReceivablesCleared reports if the "receivables" edge to the Receivable entity was cleared.
func (m *CustomerMutation) ReceivablesCleared() bool {
	return m.clearedreceivables
}

// RemoveReceivableIDs removes the "receivables" edge to the Receivable entity by IDs.
func (m *CustomerMutation) RemoveReceivableIDs(ids ...int) {
	if m.removedreceivables == nil {
		m.removedreceivables = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.receivables, ids[i])
		m.removedreceivables[ids[i]] = struct{}{}
	}
}

// RemovedReceivables returns the removed IDs of the "receivables" edge to the Receivable entity.
func (m *CustomerMutation) RemovedReceivablesIDs() (ids []int) {
	for id := range m.removedreceivables {
		ids = append(ids, id)
	}
	return
}

// ReceivablesIDs returns the "receivables" edge IDs in the mutation.
func (m *CustomerMutation) ReceivablesIDs() (ids []int) {
	for id := range m.receivables {
		ids = append(ids, id)
	}
	return
}

// ResetReceivables resets all changes to the "receivables" edge.
func (m *CustomerMutation) ResetReceivables() {
	m.receivables = nil
	m.clearedreceivables = false
	m.removedreceivables = nil
}

// AddInvoiceIDs adds the "invoices" edge to the Invoice entity by ids.
func (m *CustomerMutation) AddInvoiceIDs(ids ...int) {
	if m.invoices == nil {
		m.invoices = make(map[int]struct{})
	}
	for i := range ids {
		m.invoices[ids[i]] = struct{}{}
	}
}

// ClearInvoices clears the "invoices" edge to the Invoice entity.
func (m *CustomerMutation) ClearInvoices() {
	m.clearedinvoices = true
}

// InvoicesCleared reports if the "invoices" edge to the Invoice entity was cleared.
func (m *CustomerMutation) InvoicesCleared() bool {
	return m.clearedinvoices
}

// RemoveInvoiceIDs removes the "invoices" edge to the Invoice entity by IDs.
func (m *CustomerMutation) RemoveInvoiceIDs(ids ...int) {
	if m.removedinvoices == nil {
		m.removedinvoices = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.invoices, ids[i])
		m.removedinvoices[ids[i]] = struct{}{}
	}
}

// RemovedInvoices returns the removed IDs of the "invoices" edge to the Invoice entity.
func (m *CustomerMutation) RemovedInvoicesIDs() (ids []int) {
	for id := range m.removedinvoices {
		ids = append(ids, id)
	}
	return
}

// InvoicesIDs returns the "invoices" edge IDs in the mutation.
func (m *CustomerMutation) InvoicesIDs() (ids []int) {
	for id := range m.invoices {
		ids = append(ids, id)
	}
	return
}

// ResetInvoices resets all changes to the "invoices" edge.
func (m *CustomerMutation) ResetInvoices() {
	m.invoices = nil
	m.clearedinvoices = false
	m.removedinvoices = nil
}

// Where appends a list predicates to the CustomerMutation builder.
func (m *CustomerMutation) Where(ps ...predicate.Customer) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CustomerMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CustomerMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Customer, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CustomerMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CustomerMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Customer).
func (m *CustomerMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CustomerMutation) Fields() []string {
	fields := make([]string, 0, 12)
	if m.created_at != nil {
		fields = append(fields, customer.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, customer.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, customer.FieldDeletedAt)
	}
	if m.address != nil {
		fields = append(fields, customer.FieldAddress)
	}
	if m.city != nil {
		fields = append(fields, customer.FieldCity)
	}
	if m.country != nil {
		fields = append(fields, customer.FieldCountry)
	}
	if m.description != nil {
		fields = append(fields, customer.FieldDescription)
	}
	if m.email != nil {
		fields = append(fields, customer.FieldEmail)
	}
	if m.is_default != nil {
		fields = append(fields, customer.FieldIsDefault)
	}
	if m.name != nil {
		fields = append(fields, customer.FieldName)
	}
	if m.phone != nil {
		fields = append(fields, customer.FieldPhone)
	}
	if m.tax_id != nil {
		fields = append(fields, customer.FieldTaxID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CustomerMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case customer.FieldCreatedAt:
		return m.CreatedAt()
	case customer.FieldUpdatedAt:
		return m.UpdatedAt()
	case customer.FieldDeletedAt:
		return m.DeletedAt()
	case customer.FieldAddress:
		return m.Address()
	case customer.FieldCity:
		return m.City()
	case customer.FieldCountry:
		return m.Country()
	case customer.FieldDescription:
		return m.Description()
	case customer.FieldEmail:
		return m.Email()
	case customer.FieldIsDefault:
		return m.IsDefault()
	case customer.FieldName:
		return m.Name()
	case customer.FieldPhone:
		return m.Phone()
	case customer.FieldTaxID:
		return m.TaxID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CustomerMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case customer.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case customer.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case customer.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case customer.FieldAddress:
		return m.OldAddress(ctx)
	case customer.FieldCity:
		return m.OldCity(ctx)
	case customer.FieldCountry:
		return m.OldCountry(ctx)
	case customer.FieldDescription:
		return m.OldDescription(ctx)
	case customer.FieldEmail:
		return m.OldEmail(ctx)
	case customer.FieldIsDefault:
		return m.OldIsDefault(ctx)
	case customer.FieldName:
		return m.OldName(ctx)
	case customer.FieldPhone:
		return m.OldPhone(ctx)
	case customer.FieldTaxID:
		return m.OldTaxID(ctx)
	}
	return nil, fmt.Errorf("unknown Customer field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CustomerMutation) SetField(name string, value ent.Value) error {
	switch name {
	case customer.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case customer.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case customer.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case customer.FieldAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAddress(v)
		return nil
	case customer.FieldCity:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCity(v)
		return nil
	case customer.FieldCountry:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCountry(v)
		return nil
	case customer.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case customer.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case customer.FieldIsDefault:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsDefault(v)
		return nil
	case customer.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case customer.FieldPhone:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPhone(v)
		return nil
	case customer.FieldTaxID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTaxID(v)
		return nil
	}
	return fmt.Errorf("unknown Customer field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CustomerMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CustomerMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CustomerMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Customer numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CustomerMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(customer.FieldDeletedAt) {
		fields = append(fields, customer.FieldDeletedAt)
	}
	if m.FieldCleared(customer.FieldAddress) {
		fields = append(fields, customer.FieldAddress)
	}
	if m.FieldCleared(customer.FieldCity) {
		fields = append(fields, customer.FieldCity)
	}
	if m.FieldCleared(customer.FieldCountry) {
		fields = append(fields, customer.FieldCountry)
	}
	if m.FieldCleared(customer.FieldDescription) {
		fields = append(fields, customer.FieldDescription)
	}
	if m.FieldCleared(customer.FieldEmail) {
		fields = append(fields, customer.FieldEmail)
	}
	if m.FieldCleared(customer.FieldIsDefault) {
		fields = append(fields, customer.FieldIsDefault)
	}
	if m.FieldCleared(customer.FieldPhone) {
		fields = append(fields, customer.FieldPhone)
	}
	if m.FieldCleared(customer.FieldTaxID) {
		fields = append(fields, customer.FieldTaxID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CustomerMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CustomerMutation) ClearField(name string) error {
	switch name {
	case customer.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case customer.FieldAddress:
		m.ClearAddress()
		return nil
	case customer.FieldCity:
		m.ClearCity()
		return nil
	case customer.FieldCountry:
		m.ClearCountry()
		return nil
	case customer.FieldDescription:
		m.ClearDescription()
		return nil
	case customer.FieldEmail:
		m.ClearEmail()
		return nil
	case customer.FieldIsDefault:
		m.ClearIsDefault()
		return nil
	case customer.FieldPhone:
		m.ClearPhone()
		return nil
	case customer.FieldTaxID:
		m.ClearTaxID()
		return nil
	}
	return fmt.Errorf("unknown Customer nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CustomerMutation) ResetField(name string) error {
	switch name {
	case customer.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case customer.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case customer.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case customer.FieldAddress:
		m.ResetAddress()
		return nil
	case customer.FieldCity:
		m.ResetCity()
		return nil
	case customer.FieldCountry:
		m.ResetCountry()
		return nil
	case customer.FieldDescription:
		m.ResetDescription()
		return nil
	case customer.FieldEmail:
		m.ResetEmail()
		return nil
	case customer.FieldIsDefault:
		m.ResetIsDefault()
		return nil
	case customer.FieldName:
		m.ResetName()
		return nil
	case customer.FieldPhone:
		m.ResetPhone()
		return nil
	case customer.FieldTaxID:
		m.ResetTaxID()
		return nil
	}
	return fmt.Errorf("unknown Customer field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CustomerMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.company != nil {
		edges = append(edges, customer.EdgeCompany)
	}
	if m.loans != nil {
		edges = append(edges, customer.EdgeLoans)
	}
	if m.receivables != nil {
		edges = append(edges, customer.EdgeReceivables)
	}
	if m.invoices != nil {
		edges = append(edges, customer.EdgeInvoices)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CustomerMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case customer.EdgeCompany:
		if id := m.company; id != nil {
			return []ent.Value{*id}
		}
	case customer.EdgeLoans:
		ids := make([]ent.Value, 0, len(m.loans))
		for id := range m.loans {
			ids = append(ids, id)
		}
		return ids
	case customer.EdgeReceivables:
		ids := make([]ent.Value, 0, len(m.receivables))
		for id := range m.receivables {
			ids = append(ids, id)
		}
		return ids
	case customer.EdgeInvoices:
		ids := make([]ent.Value, 0, len(m.invoices))
		for id := range m.invoices {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CustomerMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedloans != nil {
		edges = append(edges, customer.EdgeLoans)
	}
	if m.removedreceivables != nil {
		edges = append(edges, customer.EdgeReceivables)
	}
	if m.removedinvoices != nil {
		edges = append(edges, customer.EdgeInvoices)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CustomerMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case customer.EdgeLoans:
		ids := make([]ent.Value, 0, len(m.removedloans))
		for id := range m.removedloans {
			ids = append(ids, id)
		}
		return ids
	case customer.EdgeReceivables:
		ids := make([]ent.Value, 0, len(m.removedreceivables))
		for id := range m.removedreceivables {
			ids = append(ids, id)
		}
		return ids
	case customer.EdgeInvoices:
		ids := make([]ent.Value, 0, len(m.removedinvoices))
		for id := range m.removedinvoices {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CustomerMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedcompany {
		edges = append(edges, customer.EdgeCompany)
	}
	if m.clearedloans {
		edges = append(edges, customer.EdgeLoans)
	}
	if m.clearedreceivables {
		edges = append(edges, customer.EdgeReceivables)
	}
	if m.clearedinvoices {
		edges = append(edges, customer.EdgeInvoices)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CustomerMutation) EdgeCleared(name string) bool {
	switch name {
	case customer.EdgeCompany:
		return m.clearedcompany
	case customer.EdgeLoans:
		return m.clearedloans
	case customer.EdgeReceivables:
		return m.clearedreceivables
	case customer.EdgeInvoices:
		return m.clearedinvoices
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CustomerMutation) ClearEdge(name string) error {
	switch name {
	case customer.EdgeCompany:
		m.ClearCompany()
		return nil
	}
	return fmt.Errorf("unknown Customer unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CustomerMutation) ResetEdge(name string) error {
	switch name {
	case customer.EdgeCompany:
		m.ResetCompany()
		return nil
	case customer.EdgeLoans:
		m.ResetLoans()
		return nil
	case customer.EdgeReceivables:
		m.ResetReceivables()
		return nil
	case customer.EdgeInvoices:
		m.ResetInvoices()
		return nil
	}
	return fmt.Errorf("unknown Customer edge %s", name)
}

// EmployeeMutation represents an operation that mutates the Employee nodes in the graph.
type EmployeeMutation struct {
	config
	op                  Op
	typ                 string
	id                  *int
	created_at          *time.Time
	updated_at          *time.Time
	deleted_at          *time.Time
	name                *string
	birthdate           *time.Time
	gender              *employee.Gender
	position            *string
	department          *string
	email               *string
	phone               *string
	avatar              *string
	hire_date           *time.Time
	monthly_salary      *int
	addmonthly_salary   *int
	status              *employee.Status
	performace_score    *float64
	addperformace_score *float64
	clearedFields       map[string]struct{}
	company             *int
	clearedcompany      bool
	user                *int
	cleareduser         bool
	subordinates        map[int]struct{}
	removedsubordinates map[int]struct{}
	clearedsubordinates bool
	leader              *int
	clearedleader       bool
	done                bool
	oldValue            func(context.Context) (*Employee, error)
	predicates          []predicate.Employee
}

var _ ent.Mutation = (*EmployeeMutation)(nil)

// employeeOption allows management of the mutation configuration using functional options.
type employeeOption func(*EmployeeMutation)

// newEmployeeMutation creates new mutation for the Employee entity.
func newEmployeeMutation(c config, op Op, opts ...employeeOption) *EmployeeMutation {
	m := &EmployeeMutation{
		config:        c,
		op:            op,
		typ:           TypeEmployee,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withEmployeeID sets the ID field of the mutation.
func withEmployeeID(id int) employeeOption {
	return func(m *EmployeeMutation) {
		var (
			err   error
			once  sync.Once
			value *Employee
		)
		m.oldValue = func(ctx context.Context) (*Employee, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Employee.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withEmployee sets the old Employee of the mutation.
func withEmployee(node *Employee) employeeOption {
	return func(m *EmployeeMutation) {
		m.oldValue = func(context.Context) (*Employee, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m EmployeeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m EmployeeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("generated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *EmployeeMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *EmployeeMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Employee.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *EmployeeMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *EmployeeMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Employee entity.
// If the Employee object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeeMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *EmployeeMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *EmployeeMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *EmployeeMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Employee entity.
// If the Employee object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeeMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *EmployeeMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *EmployeeMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *EmployeeMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Employee entity.
// If the Employee object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeeMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *EmployeeMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[employee.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *EmployeeMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[employee.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *EmployeeMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, employee.FieldDeletedAt)
}

// SetName sets the "name" field.
func (m *EmployeeMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *EmployeeMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Employee entity.
// If the Employee object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeeMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *EmployeeMutation) ResetName() {
	m.name = nil
}

// SetBirthdate sets the "birthdate" field.
func (m *EmployeeMutation) SetBirthdate(t time.Time) {
	m.birthdate = &t
}

// Birthdate returns the value of the "birthdate" field in the mutation.
func (m *EmployeeMutation) Birthdate() (r time.Time, exists bool) {
	v := m.birthdate
	if v == nil {
		return
	}
	return *v, true
}

// OldBirthdate returns the old "birthdate" field's value of the Employee entity.
// If the Employee object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeeMutation) OldBirthdate(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBirthdate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBirthdate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBirthdate: %w", err)
	}
	return oldValue.Birthdate, nil
}

// ClearBirthdate clears the value of the "birthdate" field.
func (m *EmployeeMutation) ClearBirthdate() {
	m.birthdate = nil
	m.clearedFields[employee.FieldBirthdate] = struct{}{}
}

// BirthdateCleared returns if the "birthdate" field was cleared in this mutation.
func (m *EmployeeMutation) BirthdateCleared() bool {
	_, ok := m.clearedFields[employee.FieldBirthdate]
	return ok
}

// ResetBirthdate resets all changes to the "birthdate" field.
func (m *EmployeeMutation) ResetBirthdate() {
	m.birthdate = nil
	delete(m.clearedFields, employee.FieldBirthdate)
}

// SetGender sets the "gender" field.
func (m *EmployeeMutation) SetGender(e employee.Gender) {
	m.gender = &e
}

// Gender returns the value of the "gender" field in the mutation.
func (m *EmployeeMutation) Gender() (r employee.Gender, exists bool) {
	v := m.gender
	if v == nil {
		return
	}
	return *v, true
}

// OldGender returns the old "gender" field's value of the Employee entity.
// If the Employee object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeeMutation) OldGender(ctx context.Context) (v employee.Gender, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGender is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGender requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGender: %w", err)
	}
	return oldValue.Gender, nil
}

// ResetGender resets all changes to the "gender" field.
func (m *EmployeeMutation) ResetGender() {
	m.gender = nil
}

// SetPosition sets the "position" field.
func (m *EmployeeMutation) SetPosition(s string) {
	m.position = &s
}

// Position returns the value of the "position" field in the mutation.
func (m *EmployeeMutation) Position() (r string, exists bool) {
	v := m.position
	if v == nil {
		return
	}
	return *v, true
}

// OldPosition returns the old "position" field's value of the Employee entity.
// If the Employee object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeeMutation) OldPosition(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPosition is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPosition requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPosition: %w", err)
	}
	return oldValue.Position, nil
}

// ResetPosition resets all changes to the "position" field.
func (m *EmployeeMutation) ResetPosition() {
	m.position = nil
}

// SetDepartment sets the "department" field.
func (m *EmployeeMutation) SetDepartment(s string) {
	m.department = &s
}

// Department returns the value of the "department" field in the mutation.
func (m *EmployeeMutation) Department() (r string, exists bool) {
	v := m.department
	if v == nil {
		return
	}
	return *v, true
}

// OldDepartment returns the old "department" field's value of the Employee entity.
// If the Employee object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeeMutation) OldDepartment(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDepartment is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDepartment requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDepartment: %w", err)
	}
	return oldValue.Department, nil
}

// ClearDepartment clears the value of the "department" field.
func (m *EmployeeMutation) ClearDepartment() {
	m.department = nil
	m.clearedFields[employee.FieldDepartment] = struct{}{}
}

// DepartmentCleared returns if the "department" field was cleared in this mutation.
func (m *EmployeeMutation) DepartmentCleared() bool {
	_, ok := m.clearedFields[employee.FieldDepartment]
	return ok
}

// ResetDepartment resets all changes to the "department" field.
func (m *EmployeeMutation) ResetDepartment() {
	m.department = nil
	delete(m.clearedFields, employee.FieldDepartment)
}

// SetEmail sets the "email" field.
func (m *EmployeeMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *EmployeeMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the Employee entity.
// If the Employee object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeeMutation) OldEmail(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ClearEmail clears the value of the "email" field.
func (m *EmployeeMutation) ClearEmail() {
	m.email = nil
	m.clearedFields[employee.FieldEmail] = struct{}{}
}

// EmailCleared returns if the "email" field was cleared in this mutation.
func (m *EmployeeMutation) EmailCleared() bool {
	_, ok := m.clearedFields[employee.FieldEmail]
	return ok
}

// ResetEmail resets all changes to the "email" field.
func (m *EmployeeMutation) ResetEmail() {
	m.email = nil
	delete(m.clearedFields, employee.FieldEmail)
}

// SetPhone sets the "phone" field.
func (m *EmployeeMutation) SetPhone(s string) {
	m.phone = &s
}

// Phone returns the value of the "phone" field in the mutation.
func (m *EmployeeMutation) Phone() (r string, exists bool) {
	v := m.phone
	if v == nil {
		return
	}
	return *v, true
}

// OldPhone returns the old "phone" field's value of the Employee entity.
// If the Employee object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeeMutation) OldPhone(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPhone is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPhone requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPhone: %w", err)
	}
	return oldValue.Phone, nil
}

// ClearPhone clears the value of the "phone" field.
func (m *EmployeeMutation) ClearPhone() {
	m.phone = nil
	m.clearedFields[employee.FieldPhone] = struct{}{}
}

// PhoneCleared returns if the "phone" field was cleared in this mutation.
func (m *EmployeeMutation) PhoneCleared() bool {
	_, ok := m.clearedFields[employee.FieldPhone]
	return ok
}

// ResetPhone resets all changes to the "phone" field.
func (m *EmployeeMutation) ResetPhone() {
	m.phone = nil
	delete(m.clearedFields, employee.FieldPhone)
}

// SetAvatar sets the "avatar" field.
func (m *EmployeeMutation) SetAvatar(s string) {
	m.avatar = &s
}

// Avatar returns the value of the "avatar" field in the mutation.
func (m *EmployeeMutation) Avatar() (r string, exists bool) {
	v := m.avatar
	if v == nil {
		return
	}
	return *v, true
}

// OldAvatar returns the old "avatar" field's value of the Employee entity.
// If the Employee object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeeMutation) OldAvatar(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAvatar is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAvatar requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAvatar: %w", err)
	}
	return oldValue.Avatar, nil
}

// ClearAvatar clears the value of the "avatar" field.
func (m *EmployeeMutation) ClearAvatar() {
	m.avatar = nil
	m.clearedFields[employee.FieldAvatar] = struct{}{}
}

// AvatarCleared returns if the "avatar" field was cleared in this mutation.
func (m *EmployeeMutation) AvatarCleared() bool {
	_, ok := m.clearedFields[employee.FieldAvatar]
	return ok
}

// ResetAvatar resets all changes to the "avatar" field.
func (m *EmployeeMutation) ResetAvatar() {
	m.avatar = nil
	delete(m.clearedFields, employee.FieldAvatar)
}

// SetHireDate sets the "hire_date" field.
func (m *EmployeeMutation) SetHireDate(t time.Time) {
	m.hire_date = &t
}

// HireDate returns the value of the "hire_date" field in the mutation.
func (m *EmployeeMutation) HireDate() (r time.Time, exists bool) {
	v := m.hire_date
	if v == nil {
		return
	}
	return *v, true
}

// OldHireDate returns the old "hire_date" field's value of the Employee entity.
// If the Employee object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeeMutation) OldHireDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHireDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHireDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHireDate: %w", err)
	}
	return oldValue.HireDate, nil
}

// ResetHireDate resets all changes to the "hire_date" field.
func (m *EmployeeMutation) ResetHireDate() {
	m.hire_date = nil
}

// SetMonthlySalary sets the "monthly_salary" field.
func (m *EmployeeMutation) SetMonthlySalary(i int) {
	m.monthly_salary = &i
	m.addmonthly_salary = nil
}

// MonthlySalary returns the value of the "monthly_salary" field in the mutation.
func (m *EmployeeMutation) MonthlySalary() (r int, exists bool) {
	v := m.monthly_salary
	if v == nil {
		return
	}
	return *v, true
}

// OldMonthlySalary returns the old "monthly_salary" field's value of the Employee entity.
// If the Employee object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeeMutation) OldMonthlySalary(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMonthlySalary is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMonthlySalary requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMonthlySalary: %w", err)
	}
	return oldValue.MonthlySalary, nil
}

// AddMonthlySalary adds i to the "monthly_salary" field.
func (m *EmployeeMutation) AddMonthlySalary(i int) {
	if m.addmonthly_salary != nil {
		*m.addmonthly_salary += i
	} else {
		m.addmonthly_salary = &i
	}
}

// AddedMonthlySalary returns the value that was added to the "monthly_salary" field in this mutation.
func (m *EmployeeMutation) AddedMonthlySalary() (r int, exists bool) {
	v := m.addmonthly_salary
	if v == nil {
		return
	}
	return *v, true
}

// ResetMonthlySalary resets all changes to the "monthly_salary" field.
func (m *EmployeeMutation) ResetMonthlySalary() {
	m.monthly_salary = nil
	m.addmonthly_salary = nil
}

// SetStatus sets the "status" field.
func (m *EmployeeMutation) SetStatus(e employee.Status) {
	m.status = &e
}

// Status returns the value of the "status" field in the mutation.
func (m *EmployeeMutation) Status() (r employee.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Employee entity.
// If the Employee object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeeMutation) OldStatus(ctx context.Context) (v employee.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ClearStatus clears the value of the "status" field.
func (m *EmployeeMutation) ClearStatus() {
	m.status = nil
	m.clearedFields[employee.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "status" field was cleared in this mutation.
func (m *EmployeeMutation) StatusCleared() bool {
	_, ok := m.clearedFields[employee.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "status" field.
func (m *EmployeeMutation) ResetStatus() {
	m.status = nil
	delete(m.clearedFields, employee.FieldStatus)
}

// SetPerformaceScore sets the "performace_score" field.
func (m *EmployeeMutation) SetPerformaceScore(f float64) {
	m.performace_score = &f
	m.addperformace_score = nil
}

// PerformaceScore returns the value of the "performace_score" field in the mutation.
func (m *EmployeeMutation) PerformaceScore() (r float64, exists bool) {
	v := m.performace_score
	if v == nil {
		return
	}
	return *v, true
}

// OldPerformaceScore returns the old "performace_score" field's value of the Employee entity.
// If the Employee object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeeMutation) OldPerformaceScore(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPerformaceScore is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPerformaceScore requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPerformaceScore: %w", err)
	}
	return oldValue.PerformaceScore, nil
}

// AddPerformaceScore adds f to the "performace_score" field.
func (m *EmployeeMutation) AddPerformaceScore(f float64) {
	if m.addperformace_score != nil {
		*m.addperformace_score += f
	} else {
		m.addperformace_score = &f
	}
}

// AddedPerformaceScore returns the value that was added to the "performace_score" field in this mutation.
func (m *EmployeeMutation) AddedPerformaceScore() (r float64, exists bool) {
	v := m.addperformace_score
	if v == nil {
		return
	}
	return *v, true
}

// ClearPerformaceScore clears the value of the "performace_score" field.
func (m *EmployeeMutation) ClearPerformaceScore() {
	m.performace_score = nil
	m.addperformace_score = nil
	m.clearedFields[employee.FieldPerformaceScore] = struct{}{}
}

// PerformaceScoreCleared returns if the "performace_score" field was cleared in this mutation.
func (m *EmployeeMutation) PerformaceScoreCleared() bool {
	_, ok := m.clearedFields[employee.FieldPerformaceScore]
	return ok
}

// ResetPerformaceScore resets all changes to the "performace_score" field.
func (m *EmployeeMutation) ResetPerformaceScore() {
	m.performace_score = nil
	m.addperformace_score = nil
	delete(m.clearedFields, employee.FieldPerformaceScore)
}

// SetCompanyID sets the "company" edge to the Company entity by id.
func (m *EmployeeMutation) SetCompanyID(id int) {
	m.company = &id
}

// ClearCompany clears the "company" edge to the Company entity.
func (m *EmployeeMutation) ClearCompany() {
	m.clearedcompany = true
}

// CompanyCleared reports if the "company" edge to the Company entity was cleared.
func (m *EmployeeMutation) CompanyCleared() bool {
	return m.clearedcompany
}

// CompanyID returns the "company" edge ID in the mutation.
func (m *EmployeeMutation) CompanyID() (id int, exists bool) {
	if m.company != nil {
		return *m.company, true
	}
	return
}

// CompanyIDs returns the "company" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CompanyID instead. It exists only for internal usage by the builders.
func (m *EmployeeMutation) CompanyIDs() (ids []int) {
	if id := m.company; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCompany resets all changes to the "company" edge.
func (m *EmployeeMutation) ResetCompany() {
	m.company = nil
	m.clearedcompany = false
}

// SetUserID sets the "user" edge to the User entity by id.
func (m *EmployeeMutation) SetUserID(id int) {
	m.user = &id
}

// ClearUser clears the "user" edge to the User entity.
func (m *EmployeeMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *EmployeeMutation) UserCleared() bool {
	return m.cleareduser
}

// UserID returns the "user" edge ID in the mutation.
func (m *EmployeeMutation) UserID() (id int, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *EmployeeMutation) UserIDs() (ids []int) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *EmployeeMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// AddSubordinateIDs adds the "subordinates" edge to the Employee entity by ids.
func (m *EmployeeMutation) AddSubordinateIDs(ids ...int) {
	if m.subordinates == nil {
		m.subordinates = make(map[int]struct{})
	}
	for i := range ids {
		m.subordinates[ids[i]] = struct{}{}
	}
}

// ClearSubordinates clears the "subordinates" edge to the Employee entity.
func (m *EmployeeMutation) ClearSubordinates() {
	m.clearedsubordinates = true
}

// SubordinatesCleared reports if the "subordinates" edge to the Employee entity was cleared.
func (m *EmployeeMutation) SubordinatesCleared() bool {
	return m.clearedsubordinates
}

// RemoveSubordinateIDs removes the "subordinates" edge to the Employee entity by IDs.
func (m *EmployeeMutation) RemoveSubordinateIDs(ids ...int) {
	if m.removedsubordinates == nil {
		m.removedsubordinates = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.subordinates, ids[i])
		m.removedsubordinates[ids[i]] = struct{}{}
	}
}

// RemovedSubordinates returns the removed IDs of the "subordinates" edge to the Employee entity.
func (m *EmployeeMutation) RemovedSubordinatesIDs() (ids []int) {
	for id := range m.removedsubordinates {
		ids = append(ids, id)
	}
	return
}

// SubordinatesIDs returns the "subordinates" edge IDs in the mutation.
func (m *EmployeeMutation) SubordinatesIDs() (ids []int) {
	for id := range m.subordinates {
		ids = append(ids, id)
	}
	return
}

// ResetSubordinates resets all changes to the "subordinates" edge.
func (m *EmployeeMutation) ResetSubordinates() {
	m.subordinates = nil
	m.clearedsubordinates = false
	m.removedsubordinates = nil
}

// SetLeaderID sets the "leader" edge to the Employee entity by id.
func (m *EmployeeMutation) SetLeaderID(id int) {
	m.leader = &id
}

// ClearLeader clears the "leader" edge to the Employee entity.
func (m *EmployeeMutation) ClearLeader() {
	m.clearedleader = true
}

// LeaderCleared reports if the "leader" edge to the Employee entity was cleared.
func (m *EmployeeMutation) LeaderCleared() bool {
	return m.clearedleader
}

// LeaderID returns the "leader" edge ID in the mutation.
func (m *EmployeeMutation) LeaderID() (id int, exists bool) {
	if m.leader != nil {
		return *m.leader, true
	}
	return
}

// LeaderIDs returns the "leader" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// LeaderID instead. It exists only for internal usage by the builders.
func (m *EmployeeMutation) LeaderIDs() (ids []int) {
	if id := m.leader; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetLeader resets all changes to the "leader" edge.
func (m *EmployeeMutation) ResetLeader() {
	m.leader = nil
	m.clearedleader = false
}

// Where appends a list predicates to the EmployeeMutation builder.
func (m *EmployeeMutation) Where(ps ...predicate.Employee) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the EmployeeMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *EmployeeMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Employee, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *EmployeeMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *EmployeeMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Employee).
func (m *EmployeeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *EmployeeMutation) Fields() []string {
	fields := make([]string, 0, 15)
	if m.created_at != nil {
		fields = append(fields, employee.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, employee.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, employee.FieldDeletedAt)
	}
	if m.name != nil {
		fields = append(fields, employee.FieldName)
	}
	if m.birthdate != nil {
		fields = append(fields, employee.FieldBirthdate)
	}
	if m.gender != nil {
		fields = append(fields, employee.FieldGender)
	}
	if m.position != nil {
		fields = append(fields, employee.FieldPosition)
	}
	if m.department != nil {
		fields = append(fields, employee.FieldDepartment)
	}
	if m.email != nil {
		fields = append(fields, employee.FieldEmail)
	}
	if m.phone != nil {
		fields = append(fields, employee.FieldPhone)
	}
	if m.avatar != nil {
		fields = append(fields, employee.FieldAvatar)
	}
	if m.hire_date != nil {
		fields = append(fields, employee.FieldHireDate)
	}
	if m.monthly_salary != nil {
		fields = append(fields, employee.FieldMonthlySalary)
	}
	if m.status != nil {
		fields = append(fields, employee.FieldStatus)
	}
	if m.performace_score != nil {
		fields = append(fields, employee.FieldPerformaceScore)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *EmployeeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case employee.FieldCreatedAt:
		return m.CreatedAt()
	case employee.FieldUpdatedAt:
		return m.UpdatedAt()
	case employee.FieldDeletedAt:
		return m.DeletedAt()
	case employee.FieldName:
		return m.Name()
	case employee.FieldBirthdate:
		return m.Birthdate()
	case employee.FieldGender:
		return m.Gender()
	case employee.FieldPosition:
		return m.Position()
	case employee.FieldDepartment:
		return m.Department()
	case employee.FieldEmail:
		return m.Email()
	case employee.FieldPhone:
		return m.Phone()
	case employee.FieldAvatar:
		return m.Avatar()
	case employee.FieldHireDate:
		return m.HireDate()
	case employee.FieldMonthlySalary:
		return m.MonthlySalary()
	case employee.FieldStatus:
		return m.Status()
	case employee.FieldPerformaceScore:
		return m.PerformaceScore()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *EmployeeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case employee.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case employee.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case employee.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case employee.FieldName:
		return m.OldName(ctx)
	case employee.FieldBirthdate:
		return m.OldBirthdate(ctx)
	case employee.FieldGender:
		return m.OldGender(ctx)
	case employee.FieldPosition:
		return m.OldPosition(ctx)
	case employee.FieldDepartment:
		return m.OldDepartment(ctx)
	case employee.FieldEmail:
		return m.OldEmail(ctx)
	case employee.FieldPhone:
		return m.OldPhone(ctx)
	case employee.FieldAvatar:
		return m.OldAvatar(ctx)
	case employee.FieldHireDate:
		return m.OldHireDate(ctx)
	case employee.FieldMonthlySalary:
		return m.OldMonthlySalary(ctx)
	case employee.FieldStatus:
		return m.OldStatus(ctx)
	case employee.FieldPerformaceScore:
		return m.OldPerformaceScore(ctx)
	}
	return nil, fmt.Errorf("unknown Employee field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EmployeeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case employee.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case employee.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case employee.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case employee.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case employee.FieldBirthdate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBirthdate(v)
		return nil
	case employee.FieldGender:
		v, ok := value.(employee.Gender)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGender(v)
		return nil
	case employee.FieldPosition:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPosition(v)
		return nil
	case employee.FieldDepartment:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDepartment(v)
		return nil
	case employee.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case employee.FieldPhone:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPhone(v)
		return nil
	case employee.FieldAvatar:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAvatar(v)
		return nil
	case employee.FieldHireDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHireDate(v)
		return nil
	case employee.FieldMonthlySalary:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMonthlySalary(v)
		return nil
	case employee.FieldStatus:
		v, ok := value.(employee.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case employee.FieldPerformaceScore:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPerformaceScore(v)
		return nil
	}
	return fmt.Errorf("unknown Employee field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *EmployeeMutation) AddedFields() []string {
	var fields []string
	if m.addmonthly_salary != nil {
		fields = append(fields, employee.FieldMonthlySalary)
	}
	if m.addperformace_score != nil {
		fields = append(fields, employee.FieldPerformaceScore)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *EmployeeMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case employee.FieldMonthlySalary:
		return m.AddedMonthlySalary()
	case employee.FieldPerformaceScore:
		return m.AddedPerformaceScore()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EmployeeMutation) AddField(name string, value ent.Value) error {
	switch name {
	case employee.FieldMonthlySalary:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMonthlySalary(v)
		return nil
	case employee.FieldPerformaceScore:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPerformaceScore(v)
		return nil
	}
	return fmt.Errorf("unknown Employee numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *EmployeeMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(employee.FieldDeletedAt) {
		fields = append(fields, employee.FieldDeletedAt)
	}
	if m.FieldCleared(employee.FieldBirthdate) {
		fields = append(fields, employee.FieldBirthdate)
	}
	if m.FieldCleared(employee.FieldDepartment) {
		fields = append(fields, employee.FieldDepartment)
	}
	if m.FieldCleared(employee.FieldEmail) {
		fields = append(fields, employee.FieldEmail)
	}
	if m.FieldCleared(employee.FieldPhone) {
		fields = append(fields, employee.FieldPhone)
	}
	if m.FieldCleared(employee.FieldAvatar) {
		fields = append(fields, employee.FieldAvatar)
	}
	if m.FieldCleared(employee.FieldStatus) {
		fields = append(fields, employee.FieldStatus)
	}
	if m.FieldCleared(employee.FieldPerformaceScore) {
		fields = append(fields, employee.FieldPerformaceScore)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *EmployeeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *EmployeeMutation) ClearField(name string) error {
	switch name {
	case employee.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case employee.FieldBirthdate:
		m.ClearBirthdate()
		return nil
	case employee.FieldDepartment:
		m.ClearDepartment()
		return nil
	case employee.FieldEmail:
		m.ClearEmail()
		return nil
	case employee.FieldPhone:
		m.ClearPhone()
		return nil
	case employee.FieldAvatar:
		m.ClearAvatar()
		return nil
	case employee.FieldStatus:
		m.ClearStatus()
		return nil
	case employee.FieldPerformaceScore:
		m.ClearPerformaceScore()
		return nil
	}
	return fmt.Errorf("unknown Employee nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *EmployeeMutation) ResetField(name string) error {
	switch name {
	case employee.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case employee.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case employee.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case employee.FieldName:
		m.ResetName()
		return nil
	case employee.FieldBirthdate:
		m.ResetBirthdate()
		return nil
	case employee.FieldGender:
		m.ResetGender()
		return nil
	case employee.FieldPosition:
		m.ResetPosition()
		return nil
	case employee.FieldDepartment:
		m.ResetDepartment()
		return nil
	case employee.FieldEmail:
		m.ResetEmail()
		return nil
	case employee.FieldPhone:
		m.ResetPhone()
		return nil
	case employee.FieldAvatar:
		m.ResetAvatar()
		return nil
	case employee.FieldHireDate:
		m.ResetHireDate()
		return nil
	case employee.FieldMonthlySalary:
		m.ResetMonthlySalary()
		return nil
	case employee.FieldStatus:
		m.ResetStatus()
		return nil
	case employee.FieldPerformaceScore:
		m.ResetPerformaceScore()
		return nil
	}
	return fmt.Errorf("unknown Employee field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *EmployeeMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.company != nil {
		edges = append(edges, employee.EdgeCompany)
	}
	if m.user != nil {
		edges = append(edges, employee.EdgeUser)
	}
	if m.subordinates != nil {
		edges = append(edges, employee.EdgeSubordinates)
	}
	if m.leader != nil {
		edges = append(edges, employee.EdgeLeader)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *EmployeeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case employee.EdgeCompany:
		if id := m.company; id != nil {
			return []ent.Value{*id}
		}
	case employee.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case employee.EdgeSubordinates:
		ids := make([]ent.Value, 0, len(m.subordinates))
		for id := range m.subordinates {
			ids = append(ids, id)
		}
		return ids
	case employee.EdgeLeader:
		if id := m.leader; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *EmployeeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedsubordinates != nil {
		edges = append(edges, employee.EdgeSubordinates)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *EmployeeMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case employee.EdgeSubordinates:
		ids := make([]ent.Value, 0, len(m.removedsubordinates))
		for id := range m.removedsubordinates {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *EmployeeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedcompany {
		edges = append(edges, employee.EdgeCompany)
	}
	if m.cleareduser {
		edges = append(edges, employee.EdgeUser)
	}
	if m.clearedsubordinates {
		edges = append(edges, employee.EdgeSubordinates)
	}
	if m.clearedleader {
		edges = append(edges, employee.EdgeLeader)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *EmployeeMutation) EdgeCleared(name string) bool {
	switch name {
	case employee.EdgeCompany:
		return m.clearedcompany
	case employee.EdgeUser:
		return m.cleareduser
	case employee.EdgeSubordinates:
		return m.clearedsubordinates
	case employee.EdgeLeader:
		return m.clearedleader
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *EmployeeMutation) ClearEdge(name string) error {
	switch name {
	case employee.EdgeCompany:
		m.ClearCompany()
		return nil
	case employee.EdgeUser:
		m.ClearUser()
		return nil
	case employee.EdgeLeader:
		m.ClearLeader()
		return nil
	}
	return fmt.Errorf("unknown Employee unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *EmployeeMutation) ResetEdge(name string) error {
	switch name {
	case employee.EdgeCompany:
		m.ResetCompany()
		return nil
	case employee.EdgeUser:
		m.ResetUser()
		return nil
	case employee.EdgeSubordinates:
		m.ResetSubordinates()
		return nil
	case employee.EdgeLeader:
		m.ResetLeader()
		return nil
	}
	return fmt.Errorf("unknown Employee edge %s", name)
}

// FileMutation represents an operation that mutates the File nodes in the graph.
type FileMutation struct {
	config
	op             Op
	typ            string
	id             *int
	created_at     *time.Time
	updated_at     *time.Time
	deleted_at     *time.Time
	category       *file.Category
	extension      *string
	size           *string
	uri            *string
	url            *string
	description    *string
	clearedFields  map[string]struct{}
	company        *int
	clearedcompany bool
	done           bool
	oldValue       func(context.Context) (*File, error)
	predicates     []predicate.File
}

var _ ent.Mutation = (*FileMutation)(nil)

// fileOption allows management of the mutation configuration using functional options.
type fileOption func(*FileMutation)

// newFileMutation creates new mutation for the File entity.
func newFileMutation(c config, op Op, opts ...fileOption) *FileMutation {
	m := &FileMutation{
		config:        c,
		op:            op,
		typ:           TypeFile,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withFileID sets the ID field of the mutation.
func withFileID(id int) fileOption {
	return func(m *FileMutation) {
		var (
			err   error
			once  sync.Once
			value *File
		)
		m.oldValue = func(ctx context.Context) (*File, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().File.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withFile sets the old File of the mutation.
func withFile(node *File) fileOption {
	return func(m *FileMutation) {
		m.oldValue = func(context.Context) (*File, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m FileMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m FileMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("generated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *FileMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *FileMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().File.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *FileMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *FileMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the File entity.
// If the File object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *FileMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *FileMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *FileMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the File entity.
// If the File object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *FileMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *FileMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *FileMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the File entity.
// If the File object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *FileMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[file.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *FileMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[file.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *FileMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, file.FieldDeletedAt)
}

// SetCategory sets the "category" field.
func (m *FileMutation) SetCategory(f file.Category) {
	m.category = &f
}

// Category returns the value of the "category" field in the mutation.
func (m *FileMutation) Category() (r file.Category, exists bool) {
	v := m.category
	if v == nil {
		return
	}
	return *v, true
}

// OldCategory returns the old "category" field's value of the File entity.
// If the File object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileMutation) OldCategory(ctx context.Context) (v file.Category, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCategory is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCategory requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCategory: %w", err)
	}
	return oldValue.Category, nil
}

// ResetCategory resets all changes to the "category" field.
func (m *FileMutation) ResetCategory() {
	m.category = nil
}

// SetExtension sets the "extension" field.
func (m *FileMutation) SetExtension(s string) {
	m.extension = &s
}

// Extension returns the value of the "extension" field in the mutation.
func (m *FileMutation) Extension() (r string, exists bool) {
	v := m.extension
	if v == nil {
		return
	}
	return *v, true
}

// OldExtension returns the old "extension" field's value of the File entity.
// If the File object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileMutation) OldExtension(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExtension is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExtension requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExtension: %w", err)
	}
	return oldValue.Extension, nil
}

// ResetExtension resets all changes to the "extension" field.
func (m *FileMutation) ResetExtension() {
	m.extension = nil
}

// SetSize sets the "size" field.
func (m *FileMutation) SetSize(s string) {
	m.size = &s
}

// Size returns the value of the "size" field in the mutation.
func (m *FileMutation) Size() (r string, exists bool) {
	v := m.size
	if v == nil {
		return
	}
	return *v, true
}

// OldSize returns the old "size" field's value of the File entity.
// If the File object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileMutation) OldSize(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSize is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSize requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSize: %w", err)
	}
	return oldValue.Size, nil
}

// ResetSize resets all changes to the "size" field.
func (m *FileMutation) ResetSize() {
	m.size = nil
}

// SetURI sets the "uri" field.
func (m *FileMutation) SetURI(s string) {
	m.uri = &s
}

// URI returns the value of the "uri" field in the mutation.
func (m *FileMutation) URI() (r string, exists bool) {
	v := m.uri
	if v == nil {
		return
	}
	return *v, true
}

// OldURI returns the old "uri" field's value of the File entity.
// If the File object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileMutation) OldURI(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldURI is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldURI requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldURI: %w", err)
	}
	return oldValue.URI, nil
}

// ResetURI resets all changes to the "uri" field.
func (m *FileMutation) ResetURI() {
	m.uri = nil
}

// SetURL sets the "url" field.
func (m *FileMutation) SetURL(s string) {
	m.url = &s
}

// URL returns the value of the "url" field in the mutation.
func (m *FileMutation) URL() (r string, exists bool) {
	v := m.url
	if v == nil {
		return
	}
	return *v, true
}

// OldURL returns the old "url" field's value of the File entity.
// If the File object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileMutation) OldURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldURL: %w", err)
	}
	return oldValue.URL, nil
}

// ResetURL resets all changes to the "url" field.
func (m *FileMutation) ResetURL() {
	m.url = nil
}

// SetDescription sets the "description" field.
func (m *FileMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *FileMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the File entity.
// If the File object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *FileMutation) ResetDescription() {
	m.description = nil
}

// SetCompanyID sets the "company" edge to the Company entity by id.
func (m *FileMutation) SetCompanyID(id int) {
	m.company = &id
}

// ClearCompany clears the "company" edge to the Company entity.
func (m *FileMutation) ClearCompany() {
	m.clearedcompany = true
}

// CompanyCleared reports if the "company" edge to the Company entity was cleared.
func (m *FileMutation) CompanyCleared() bool {
	return m.clearedcompany
}

// CompanyID returns the "company" edge ID in the mutation.
func (m *FileMutation) CompanyID() (id int, exists bool) {
	if m.company != nil {
		return *m.company, true
	}
	return
}

// CompanyIDs returns the "company" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CompanyID instead. It exists only for internal usage by the builders.
func (m *FileMutation) CompanyIDs() (ids []int) {
	if id := m.company; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCompany resets all changes to the "company" edge.
func (m *FileMutation) ResetCompany() {
	m.company = nil
	m.clearedcompany = false
}

// Where appends a list predicates to the FileMutation builder.
func (m *FileMutation) Where(ps ...predicate.File) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the FileMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *FileMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.File, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *FileMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *FileMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (File).
func (m *FileMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *FileMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.created_at != nil {
		fields = append(fields, file.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, file.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, file.FieldDeletedAt)
	}
	if m.category != nil {
		fields = append(fields, file.FieldCategory)
	}
	if m.extension != nil {
		fields = append(fields, file.FieldExtension)
	}
	if m.size != nil {
		fields = append(fields, file.FieldSize)
	}
	if m.uri != nil {
		fields = append(fields, file.FieldURI)
	}
	if m.url != nil {
		fields = append(fields, file.FieldURL)
	}
	if m.description != nil {
		fields = append(fields, file.FieldDescription)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *FileMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case file.FieldCreatedAt:
		return m.CreatedAt()
	case file.FieldUpdatedAt:
		return m.UpdatedAt()
	case file.FieldDeletedAt:
		return m.DeletedAt()
	case file.FieldCategory:
		return m.Category()
	case file.FieldExtension:
		return m.Extension()
	case file.FieldSize:
		return m.Size()
	case file.FieldURI:
		return m.URI()
	case file.FieldURL:
		return m.URL()
	case file.FieldDescription:
		return m.Description()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *FileMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case file.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case file.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case file.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case file.FieldCategory:
		return m.OldCategory(ctx)
	case file.FieldExtension:
		return m.OldExtension(ctx)
	case file.FieldSize:
		return m.OldSize(ctx)
	case file.FieldURI:
		return m.OldURI(ctx)
	case file.FieldURL:
		return m.OldURL(ctx)
	case file.FieldDescription:
		return m.OldDescription(ctx)
	}
	return nil, fmt.Errorf("unknown File field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FileMutation) SetField(name string, value ent.Value) error {
	switch name {
	case file.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case file.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case file.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case file.FieldCategory:
		v, ok := value.(file.Category)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCategory(v)
		return nil
	case file.FieldExtension:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExtension(v)
		return nil
	case file.FieldSize:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSize(v)
		return nil
	case file.FieldURI:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetURI(v)
		return nil
	case file.FieldURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetURL(v)
		return nil
	case file.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	}
	return fmt.Errorf("unknown File field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *FileMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *FileMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FileMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown File numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *FileMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(file.FieldDeletedAt) {
		fields = append(fields, file.FieldDeletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *FileMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *FileMutation) ClearField(name string) error {
	switch name {
	case file.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown File nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *FileMutation) ResetField(name string) error {
	switch name {
	case file.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case file.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case file.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case file.FieldCategory:
		m.ResetCategory()
		return nil
	case file.FieldExtension:
		m.ResetExtension()
		return nil
	case file.FieldSize:
		m.ResetSize()
		return nil
	case file.FieldURI:
		m.ResetURI()
		return nil
	case file.FieldURL:
		m.ResetURL()
		return nil
	case file.FieldDescription:
		m.ResetDescription()
		return nil
	}
	return fmt.Errorf("unknown File field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *FileMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.company != nil {
		edges = append(edges, file.EdgeCompany)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *FileMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case file.EdgeCompany:
		if id := m.company; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *FileMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *FileMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *FileMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedcompany {
		edges = append(edges, file.EdgeCompany)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *FileMutation) EdgeCleared(name string) bool {
	switch name {
	case file.EdgeCompany:
		return m.clearedcompany
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *FileMutation) ClearEdge(name string) error {
	switch name {
	case file.EdgeCompany:
		m.ClearCompany()
		return nil
	}
	return fmt.Errorf("unknown File unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *FileMutation) ResetEdge(name string) error {
	switch name {
	case file.EdgeCompany:
		m.ResetCompany()
		return nil
	}
	return fmt.Errorf("unknown File edge %s", name)
}

// InventoryMutation represents an operation that mutates the Inventory nodes in the graph.
type InventoryMutation struct {
	config
	op               Op
	typ              string
	id               *int
	created_at       *time.Time
	updated_at       *time.Time
	deleted_at       *time.Time
	name             *string
	category         *inventory.Category
	quantity         *float64
	addquantity      *float64
	unit             *string
	minimum_level    *float64
	addminimum_level *float64
	current_value    *float64
	addcurrent_value *float64
	notes            *string
	clearedFields    map[string]struct{}
	company          *int
	clearedcompany   bool
	movements        map[int]struct{}
	removedmovements map[int]struct{}
	clearedmovements bool
	done             bool
	oldValue         func(context.Context) (*Inventory, error)
	predicates       []predicate.Inventory
}

var _ ent.Mutation = (*InventoryMutation)(nil)

// inventoryOption allows management of the mutation configuration using functional options.
type inventoryOption func(*InventoryMutation)

// newInventoryMutation creates new mutation for the Inventory entity.
func newInventoryMutation(c config, op Op, opts ...inventoryOption) *InventoryMutation {
	m := &InventoryMutation{
		config:        c,
		op:            op,
		typ:           TypeInventory,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withInventoryID sets the ID field of the mutation.
func withInventoryID(id int) inventoryOption {
	return func(m *InventoryMutation) {
		var (
			err   error
			once  sync.Once
			value *Inventory
		)
		m.oldValue = func(ctx context.Context) (*Inventory, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Inventory.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withInventory sets the old Inventory of the mutation.
func withInventory(node *Inventory) inventoryOption {
	return func(m *InventoryMutation) {
		m.oldValue = func(context.Context) (*Inventory, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m InventoryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m InventoryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("generated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *InventoryMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *InventoryMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Inventory.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *InventoryMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *InventoryMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Inventory entity.
// If the Inventory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InventoryMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *InventoryMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *InventoryMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *InventoryMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Inventory entity.
// If the Inventory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InventoryMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *InventoryMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *InventoryMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *InventoryMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Inventory entity.
// If the Inventory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InventoryMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *InventoryMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[inventory.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *InventoryMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[inventory.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *InventoryMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, inventory.FieldDeletedAt)
}

// SetName sets the "name" field.
func (m *InventoryMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *InventoryMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Inventory entity.
// If the Inventory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InventoryMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *InventoryMutation) ResetName() {
	m.name = nil
}

// SetCategory sets the "category" field.
func (m *InventoryMutation) SetCategory(i inventory.Category) {
	m.category = &i
}

// Category returns the value of the "category" field in the mutation.
func (m *InventoryMutation) Category() (r inventory.Category, exists bool) {
	v := m.category
	if v == nil {
		return
	}
	return *v, true
}

// OldCategory returns the old "category" field's value of the Inventory entity.
// If the Inventory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InventoryMutation) OldCategory(ctx context.Context) (v inventory.Category, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCategory is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCategory requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCategory: %w", err)
	}
	return oldValue.Category, nil
}

// ResetCategory resets all changes to the "category" field.
func (m *InventoryMutation) ResetCategory() {
	m.category = nil
}

// SetQuantity sets the "quantity" field.
func (m *InventoryMutation) SetQuantity(f float64) {
	m.quantity = &f
	m.addquantity = nil
}

// Quantity returns the value of the "quantity" field in the mutation.
func (m *InventoryMutation) Quantity() (r float64, exists bool) {
	v := m.quantity
	if v == nil {
		return
	}
	return *v, true
}

// OldQuantity returns the old "quantity" field's value of the Inventory entity.
// If the Inventory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InventoryMutation) OldQuantity(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldQuantity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldQuantity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldQuantity: %w", err)
	}
	return oldValue.Quantity, nil
}

// AddQuantity adds f to the "quantity" field.
func (m *InventoryMutation) AddQuantity(f float64) {
	if m.addquantity != nil {
		*m.addquantity += f
	} else {
		m.addquantity = &f
	}
}

// AddedQuantity returns the value that was added to the "quantity" field in this mutation.
func (m *InventoryMutation) AddedQuantity() (r float64, exists bool) {
	v := m.addquantity
	if v == nil {
		return
	}
	return *v, true
}

// ResetQuantity resets all changes to the "quantity" field.
func (m *InventoryMutation) ResetQuantity() {
	m.quantity = nil
	m.addquantity = nil
}

// SetUnit sets the "unit" field.
func (m *InventoryMutation) SetUnit(s string) {
	m.unit = &s
}

// Unit returns the value of the "unit" field in the mutation.
func (m *InventoryMutation) Unit() (r string, exists bool) {
	v := m.unit
	if v == nil {
		return
	}
	return *v, true
}

// OldUnit returns the old "unit" field's value of the Inventory entity.
// If the Inventory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InventoryMutation) OldUnit(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUnit is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUnit requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUnit: %w", err)
	}
	return oldValue.Unit, nil
}

// ResetUnit resets all changes to the "unit" field.
func (m *InventoryMutation) ResetUnit() {
	m.unit = nil
}

// SetMinimumLevel sets the "minimum_level" field.
func (m *InventoryMutation) SetMinimumLevel(f float64) {
	m.minimum_level = &f
	m.addminimum_level = nil
}

// MinimumLevel returns the value of the "minimum_level" field in the mutation.
func (m *InventoryMutation) MinimumLevel() (r float64, exists bool) {
	v := m.minimum_level
	if v == nil {
		return
	}
	return *v, true
}

// OldMinimumLevel returns the old "minimum_level" field's value of the Inventory entity.
// If the Inventory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InventoryMutation) OldMinimumLevel(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMinimumLevel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMinimumLevel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMinimumLevel: %w", err)
	}
	return oldValue.MinimumLevel, nil
}

// AddMinimumLevel adds f to the "minimum_level" field.
func (m *InventoryMutation) AddMinimumLevel(f float64) {
	if m.addminimum_level != nil {
		*m.addminimum_level += f
	} else {
		m.addminimum_level = &f
	}
}

// AddedMinimumLevel returns the value that was added to the "minimum_level" field in this mutation.
func (m *InventoryMutation) AddedMinimumLevel() (r float64, exists bool) {
	v := m.addminimum_level
	if v == nil {
		return
	}
	return *v, true
}

// ResetMinimumLevel resets all changes to the "minimum_level" field.
func (m *InventoryMutation) ResetMinimumLevel() {
	m.minimum_level = nil
	m.addminimum_level = nil
}

// SetCurrentValue sets the "current_value" field.
func (m *InventoryMutation) SetCurrentValue(f float64) {
	m.current_value = &f
	m.addcurrent_value = nil
}

// CurrentValue returns the value of the "current_value" field in the mutation.
func (m *InventoryMutation) CurrentValue() (r float64, exists bool) {
	v := m.current_value
	if v == nil {
		return
	}
	return *v, true
}

// OldCurrentValue returns the old "current_value" field's value of the Inventory entity.
// If the Inventory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InventoryMutation) OldCurrentValue(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCurrentValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCurrentValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCurrentValue: %w", err)
	}
	return oldValue.CurrentValue, nil
}

// AddCurrentValue adds f to the "current_value" field.
func (m *InventoryMutation) AddCurrentValue(f float64) {
	if m.addcurrent_value != nil {
		*m.addcurrent_value += f
	} else {
		m.addcurrent_value = &f
	}
}

// AddedCurrentValue returns the value that was added to the "current_value" field in this mutation.
func (m *InventoryMutation) AddedCurrentValue() (r float64, exists bool) {
	v := m.addcurrent_value
	if v == nil {
		return
	}
	return *v, true
}

// ResetCurrentValue resets all changes to the "current_value" field.
func (m *InventoryMutation) ResetCurrentValue() {
	m.current_value = nil
	m.addcurrent_value = nil
}

// SetNotes sets the "notes" field.
func (m *InventoryMutation) SetNotes(s string) {
	m.notes = &s
}

// Notes returns the value of the "notes" field in the mutation.
func (m *InventoryMutation) Notes() (r string, exists bool) {
	v := m.notes
	if v == nil {
		return
	}
	return *v, true
}

// OldNotes returns the old "notes" field's value of the Inventory entity.
// If the Inventory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InventoryMutation) OldNotes(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNotes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNotes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNotes: %w", err)
	}
	return oldValue.Notes, nil
}

// ResetNotes resets all changes to the "notes" field.
func (m *InventoryMutation) ResetNotes() {
	m.notes = nil
}

// SetCompanyID sets the "company" edge to the Company entity by id.
func (m *InventoryMutation) SetCompanyID(id int) {
	m.company = &id
}

// ClearCompany clears the "company" edge to the Company entity.
func (m *InventoryMutation) ClearCompany() {
	m.clearedcompany = true
}

// CompanyCleared reports if the "company" edge to the Company entity was cleared.
func (m *InventoryMutation) CompanyCleared() bool {
	return m.clearedcompany
}

// CompanyID returns the "company" edge ID in the mutation.
func (m *InventoryMutation) CompanyID() (id int, exists bool) {
	if m.company != nil {
		return *m.company, true
	}
	return
}

// CompanyIDs returns the "company" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CompanyID instead. It exists only for internal usage by the builders.
func (m *InventoryMutation) CompanyIDs() (ids []int) {
	if id := m.company; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCompany resets all changes to the "company" edge.
func (m *InventoryMutation) ResetCompany() {
	m.company = nil
	m.clearedcompany = false
}

// AddMovementIDs adds the "movements" edge to the InventoryMovement entity by ids.
func (m *InventoryMutation) AddMovementIDs(ids ...int) {
	if m.movements == nil {
		m.movements = make(map[int]struct{})
	}
	for i := range ids {
		m.movements[ids[i]] = struct{}{}
	}
}

// ClearMovements clears the "movements" edge to the InventoryMovement entity.
func (m *InventoryMutation) ClearMovements() {
	m.clearedmovements = true
}

// MovementsCleared reports if the "movements" edge to the InventoryMovement entity was cleared.
func (m *InventoryMutation) MovementsCleared() bool {
	return m.clearedmovements
}

// RemoveMovementIDs removes the "movements" edge to the InventoryMovement entity by IDs.
func (m *InventoryMutation) RemoveMovementIDs(ids ...int) {
	if m.removedmovements == nil {
		m.removedmovements = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.movements, ids[i])
		m.removedmovements[ids[i]] = struct{}{}
	}
}

// RemovedMovements returns the removed IDs of the "movements" edge to the InventoryMovement entity.
func (m *InventoryMutation) RemovedMovementsIDs() (ids []int) {
	for id := range m.removedmovements {
		ids = append(ids, id)
	}
	return
}

// MovementsIDs returns the "movements" edge IDs in the mutation.
func (m *InventoryMutation) MovementsIDs() (ids []int) {
	for id := range m.movements {
		ids = append(ids, id)
	}
	return
}

// ResetMovements resets all changes to the "movements" edge.
func (m *InventoryMutation) ResetMovements() {
	m.movements = nil
	m.clearedmovements = false
	m.removedmovements = nil
}

// Where appends a list predicates to the InventoryMutation builder.
func (m *InventoryMutation) Where(ps ...predicate.Inventory) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the InventoryMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *InventoryMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Inventory, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *InventoryMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *InventoryMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Inventory).
func (m *InventoryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *InventoryMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.created_at != nil {
		fields = append(fields, inventory.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, inventory.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, inventory.FieldDeletedAt)
	}
	if m.name != nil {
		fields = append(fields, inventory.FieldName)
	}
	if m.category != nil {
		fields = append(fields, inventory.FieldCategory)
	}
	if m.quantity != nil {
		fields = append(fields, inventory.FieldQuantity)
	}
	if m.unit != nil {
		fields = append(fields, inventory.FieldUnit)
	}
	if m.minimum_level != nil {
		fields = append(fields, inventory.FieldMinimumLevel)
	}
	if m.current_value != nil {
		fields = append(fields, inventory.FieldCurrentValue)
	}
	if m.notes != nil {
		fields = append(fields, inventory.FieldNotes)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *InventoryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case inventory.FieldCreatedAt:
		return m.CreatedAt()
	case inventory.FieldUpdatedAt:
		return m.UpdatedAt()
	case inventory.FieldDeletedAt:
		return m.DeletedAt()
	case inventory.FieldName:
		return m.Name()
	case inventory.FieldCategory:
		return m.Category()
	case inventory.FieldQuantity:
		return m.Quantity()
	case inventory.FieldUnit:
		return m.Unit()
	case inventory.FieldMinimumLevel:
		return m.MinimumLevel()
	case inventory.FieldCurrentValue:
		return m.CurrentValue()
	case inventory.FieldNotes:
		return m.Notes()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *InventoryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case inventory.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case inventory.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case inventory.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case inventory.FieldName:
		return m.OldName(ctx)
	case inventory.FieldCategory:
		return m.OldCategory(ctx)
	case inventory.FieldQuantity:
		return m.OldQuantity(ctx)
	case inventory.FieldUnit:
		return m.OldUnit(ctx)
	case inventory.FieldMinimumLevel:
		return m.OldMinimumLevel(ctx)
	case inventory.FieldCurrentValue:
		return m.OldCurrentValue(ctx)
	case inventory.FieldNotes:
		return m.OldNotes(ctx)
	}
	return nil, fmt.Errorf("unknown Inventory field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *InventoryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case inventory.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case inventory.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case inventory.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case inventory.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case inventory.FieldCategory:
		v, ok := value.(inventory.Category)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCategory(v)
		return nil
	case inventory.FieldQuantity:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetQuantity(v)
		return nil
	case inventory.FieldUnit:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUnit(v)
		return nil
	case inventory.FieldMinimumLevel:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMinimumLevel(v)
		return nil
	case inventory.FieldCurrentValue:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCurrentValue(v)
		return nil
	case inventory.FieldNotes:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNotes(v)
		return nil
	}
	return fmt.Errorf("unknown Inventory field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *InventoryMutation) AddedFields() []string {
	var fields []string
	if m.addquantity != nil {
		fields = append(fields, inventory.FieldQuantity)
	}
	if m.addminimum_level != nil {
		fields = append(fields, inventory.FieldMinimumLevel)
	}
	if m.addcurrent_value != nil {
		fields = append(fields, inventory.FieldCurrentValue)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *InventoryMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case inventory.FieldQuantity:
		return m.AddedQuantity()
	case inventory.FieldMinimumLevel:
		return m.AddedMinimumLevel()
	case inventory.FieldCurrentValue:
		return m.AddedCurrentValue()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *InventoryMutation) AddField(name string, value ent.Value) error {
	switch name {
	case inventory.FieldQuantity:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddQuantity(v)
		return nil
	case inventory.FieldMinimumLevel:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMinimumLevel(v)
		return nil
	case inventory.FieldCurrentValue:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCurrentValue(v)
		return nil
	}
	return fmt.Errorf("unknown Inventory numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *InventoryMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(inventory.FieldDeletedAt) {
		fields = append(fields, inventory.FieldDeletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *InventoryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *InventoryMutation) ClearField(name string) error {
	switch name {
	case inventory.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown Inventory nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *InventoryMutation) ResetField(name string) error {
	switch name {
	case inventory.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case inventory.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case inventory.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case inventory.FieldName:
		m.ResetName()
		return nil
	case inventory.FieldCategory:
		m.ResetCategory()
		return nil
	case inventory.FieldQuantity:
		m.ResetQuantity()
		return nil
	case inventory.FieldUnit:
		m.ResetUnit()
		return nil
	case inventory.FieldMinimumLevel:
		m.ResetMinimumLevel()
		return nil
	case inventory.FieldCurrentValue:
		m.ResetCurrentValue()
		return nil
	case inventory.FieldNotes:
		m.ResetNotes()
		return nil
	}
	return fmt.Errorf("unknown Inventory field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *InventoryMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.company != nil {
		edges = append(edges, inventory.EdgeCompany)
	}
	if m.movements != nil {
		edges = append(edges, inventory.EdgeMovements)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *InventoryMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case inventory.EdgeCompany:
		if id := m.company; id != nil {
			return []ent.Value{*id}
		}
	case inventory.EdgeMovements:
		ids := make([]ent.Value, 0, len(m.movements))
		for id := range m.movements {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *InventoryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedmovements != nil {
		edges = append(edges, inventory.EdgeMovements)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *InventoryMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case inventory.EdgeMovements:
		ids := make([]ent.Value, 0, len(m.removedmovements))
		for id := range m.removedmovements {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *InventoryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedcompany {
		edges = append(edges, inventory.EdgeCompany)
	}
	if m.clearedmovements {
		edges = append(edges, inventory.EdgeMovements)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *InventoryMutation) EdgeCleared(name string) bool {
	switch name {
	case inventory.EdgeCompany:
		return m.clearedcompany
	case inventory.EdgeMovements:
		return m.clearedmovements
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *InventoryMutation) ClearEdge(name string) error {
	switch name {
	case inventory.EdgeCompany:
		m.ClearCompany()
		return nil
	}
	return fmt.Errorf("unknown Inventory unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *InventoryMutation) ResetEdge(name string) error {
	switch name {
	case inventory.EdgeCompany:
		m.ResetCompany()
		return nil
	case inventory.EdgeMovements:
		m.ResetMovements()
		return nil
	}
	return fmt.Errorf("unknown Inventory edge %s", name)
}

// InventoryMovementMutation represents an operation that mutates the InventoryMovement nodes in the graph.
type InventoryMovementMutation struct {
	config
	op               Op
	typ              string
	id               *int
	created_at       *time.Time
	updated_at       *time.Time
	deleted_at       *time.Time
	category         *inventorymovement.Category
	quantity         *float64
	addquantity      *float64
	value            *float64
	addvalue         *float64
	date             *time.Time
	source           *string
	destination      *string
	notes            *string
	clearedFields    map[string]struct{}
	company          *int
	clearedcompany   bool
	inventory        *int
	clearedinventory bool
	done             bool
	oldValue         func(context.Context) (*InventoryMovement, error)
	predicates       []predicate.InventoryMovement
}

var _ ent.Mutation = (*InventoryMovementMutation)(nil)

// inventorymovementOption allows management of the mutation configuration using functional options.
type inventorymovementOption func(*InventoryMovementMutation)

// newInventoryMovementMutation creates new mutation for the InventoryMovement entity.
func newInventoryMovementMutation(c config, op Op, opts ...inventorymovementOption) *InventoryMovementMutation {
	m := &InventoryMovementMutation{
		config:        c,
		op:            op,
		typ:           TypeInventoryMovement,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withInventoryMovementID sets the ID field of the mutation.
func withInventoryMovementID(id int) inventorymovementOption {
	return func(m *InventoryMovementMutation) {
		var (
			err   error
			once  sync.Once
			value *InventoryMovement
		)
		m.oldValue = func(ctx context.Context) (*InventoryMovement, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().InventoryMovement.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withInventoryMovement sets the old InventoryMovement of the mutation.
func withInventoryMovement(node *InventoryMovement) inventorymovementOption {
	return func(m *InventoryMovementMutation) {
		m.oldValue = func(context.Context) (*InventoryMovement, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m InventoryMovementMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m InventoryMovementMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("generated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *InventoryMovementMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *InventoryMovementMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().InventoryMovement.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *InventoryMovementMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *InventoryMovementMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the InventoryMovement entity.
// If the InventoryMovement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InventoryMovementMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *InventoryMovementMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *InventoryMovementMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *InventoryMovementMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the InventoryMovement entity.
// If the InventoryMovement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InventoryMovementMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *InventoryMovementMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *InventoryMovementMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *InventoryMovementMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the InventoryMovement entity.
// If the InventoryMovement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InventoryMovementMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *InventoryMovementMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[inventorymovement.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *InventoryMovementMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[inventorymovement.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *InventoryMovementMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, inventorymovement.FieldDeletedAt)
}

// SetCategory sets the "category" field.
func (m *InventoryMovementMutation) SetCategory(i inventorymovement.Category) {
	m.category = &i
}

// Category returns the value of the "category" field in the mutation.
func (m *InventoryMovementMutation) Category() (r inventorymovement.Category, exists bool) {
	v := m.category
	if v == nil {
		return
	}
	return *v, true
}

// OldCategory returns the old "category" field's value of the InventoryMovement entity.
// If the InventoryMovement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InventoryMovementMutation) OldCategory(ctx context.Context) (v inventorymovement.Category, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCategory is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCategory requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCategory: %w", err)
	}
	return oldValue.Category, nil
}

// ResetCategory resets all changes to the "category" field.
func (m *InventoryMovementMutation) ResetCategory() {
	m.category = nil
}

// SetQuantity sets the "quantity" field.
func (m *InventoryMovementMutation) SetQuantity(f float64) {
	m.quantity = &f
	m.addquantity = nil
}

// Quantity returns the value of the "quantity" field in the mutation.
func (m *InventoryMovementMutation) Quantity() (r float64, exists bool) {
	v := m.quantity
	if v == nil {
		return
	}
	return *v, true
}

// OldQuantity returns the old "quantity" field's value of the InventoryMovement entity.
// If the InventoryMovement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InventoryMovementMutation) OldQuantity(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldQuantity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldQuantity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldQuantity: %w", err)
	}
	return oldValue.Quantity, nil
}

// AddQuantity adds f to the "quantity" field.
func (m *InventoryMovementMutation) AddQuantity(f float64) {
	if m.addquantity != nil {
		*m.addquantity += f
	} else {
		m.addquantity = &f
	}
}

// AddedQuantity returns the value that was added to the "quantity" field in this mutation.
func (m *InventoryMovementMutation) AddedQuantity() (r float64, exists bool) {
	v := m.addquantity
	if v == nil {
		return
	}
	return *v, true
}

// ResetQuantity resets all changes to the "quantity" field.
func (m *InventoryMovementMutation) ResetQuantity() {
	m.quantity = nil
	m.addquantity = nil
}

// SetValue sets the "value" field.
func (m *InventoryMovementMutation) SetValue(f float64) {
	m.value = &f
	m.addvalue = nil
}

// Value returns the value of the "value" field in the mutation.
func (m *InventoryMovementMutation) Value() (r float64, exists bool) {
	v := m.value
	if v == nil {
		return
	}
	return *v, true
}

// OldValue returns the old "value" field's value of the InventoryMovement entity.
// If the InventoryMovement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InventoryMovementMutation) OldValue(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldValue: %w", err)
	}
	return oldValue.Value, nil
}

// AddValue adds f to the "value" field.
func (m *InventoryMovementMutation) AddValue(f float64) {
	if m.addvalue != nil {
		*m.addvalue += f
	} else {
		m.addvalue = &f
	}
}

// AddedValue returns the value that was added to the "value" field in this mutation.
func (m *InventoryMovementMutation) AddedValue() (r float64, exists bool) {
	v := m.addvalue
	if v == nil {
		return
	}
	return *v, true
}

// ResetValue resets all changes to the "value" field.
func (m *InventoryMovementMutation) ResetValue() {
	m.value = nil
	m.addvalue = nil
}

// SetDate sets the "date" field.
func (m *InventoryMovementMutation) SetDate(t time.Time) {
	m.date = &t
}

// Date returns the value of the "date" field in the mutation.
func (m *InventoryMovementMutation) Date() (r time.Time, exists bool) {
	v := m.date
	if v == nil {
		return
	}
	return *v, true
}

// OldDate returns the old "date" field's value of the InventoryMovement entity.
// If the InventoryMovement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InventoryMovementMutation) OldDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDate: %w", err)
	}
	return oldValue.Date, nil
}

// ResetDate resets all changes to the "date" field.
func (m *InventoryMovementMutation) ResetDate() {
	m.date = nil
}

// SetSource sets the "source" field.
func (m *InventoryMovementMutation) SetSource(s string) {
	m.source = &s
}

// Source returns the value of the "source" field in the mutation.
func (m *InventoryMovementMutation) Source() (r string, exists bool) {
	v := m.source
	if v == nil {
		return
	}
	return *v, true
}

// OldSource returns the old "source" field's value of the InventoryMovement entity.
// If the InventoryMovement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InventoryMovementMutation) OldSource(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSource is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSource requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSource: %w", err)
	}
	return oldValue.Source, nil
}

// ClearSource clears the value of the "source" field.
func (m *InventoryMovementMutation) ClearSource() {
	m.source = nil
	m.clearedFields[inventorymovement.FieldSource] = struct{}{}
}

// SourceCleared returns if the "source" field was cleared in this mutation.
func (m *InventoryMovementMutation) SourceCleared() bool {
	_, ok := m.clearedFields[inventorymovement.FieldSource]
	return ok
}

// ResetSource resets all changes to the "source" field.
func (m *InventoryMovementMutation) ResetSource() {
	m.source = nil
	delete(m.clearedFields, inventorymovement.FieldSource)
}

// SetDestination sets the "destination" field.
func (m *InventoryMovementMutation) SetDestination(s string) {
	m.destination = &s
}

// Destination returns the value of the "destination" field in the mutation.
func (m *InventoryMovementMutation) Destination() (r string, exists bool) {
	v := m.destination
	if v == nil {
		return
	}
	return *v, true
}

// OldDestination returns the old "destination" field's value of the InventoryMovement entity.
// If the InventoryMovement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InventoryMovementMutation) OldDestination(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDestination is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDestination requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDestination: %w", err)
	}
	return oldValue.Destination, nil
}

// ClearDestination clears the value of the "destination" field.
func (m *InventoryMovementMutation) ClearDestination() {
	m.destination = nil
	m.clearedFields[inventorymovement.FieldDestination] = struct{}{}
}

// DestinationCleared returns if the "destination" field was cleared in this mutation.
func (m *InventoryMovementMutation) DestinationCleared() bool {
	_, ok := m.clearedFields[inventorymovement.FieldDestination]
	return ok
}

// ResetDestination resets all changes to the "destination" field.
func (m *InventoryMovementMutation) ResetDestination() {
	m.destination = nil
	delete(m.clearedFields, inventorymovement.FieldDestination)
}

// SetNotes sets the "notes" field.
func (m *InventoryMovementMutation) SetNotes(s string) {
	m.notes = &s
}

// Notes returns the value of the "notes" field in the mutation.
func (m *InventoryMovementMutation) Notes() (r string, exists bool) {
	v := m.notes
	if v == nil {
		return
	}
	return *v, true
}

// OldNotes returns the old "notes" field's value of the InventoryMovement entity.
// If the InventoryMovement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InventoryMovementMutation) OldNotes(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNotes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNotes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNotes: %w", err)
	}
	return oldValue.Notes, nil
}

// ResetNotes resets all changes to the "notes" field.
func (m *InventoryMovementMutation) ResetNotes() {
	m.notes = nil
}

// SetCompanyID sets the "company" edge to the Company entity by id.
func (m *InventoryMovementMutation) SetCompanyID(id int) {
	m.company = &id
}

// ClearCompany clears the "company" edge to the Company entity.
func (m *InventoryMovementMutation) ClearCompany() {
	m.clearedcompany = true
}

// CompanyCleared reports if the "company" edge to the Company entity was cleared.
func (m *InventoryMovementMutation) CompanyCleared() bool {
	return m.clearedcompany
}

// CompanyID returns the "company" edge ID in the mutation.
func (m *InventoryMovementMutation) CompanyID() (id int, exists bool) {
	if m.company != nil {
		return *m.company, true
	}
	return
}

// CompanyIDs returns the "company" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CompanyID instead. It exists only for internal usage by the builders.
func (m *InventoryMovementMutation) CompanyIDs() (ids []int) {
	if id := m.company; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCompany resets all changes to the "company" edge.
func (m *InventoryMovementMutation) ResetCompany() {
	m.company = nil
	m.clearedcompany = false
}

// SetInventoryID sets the "inventory" edge to the Inventory entity by id.
func (m *InventoryMovementMutation) SetInventoryID(id int) {
	m.inventory = &id
}

// ClearInventory clears the "inventory" edge to the Inventory entity.
func (m *InventoryMovementMutation) ClearInventory() {
	m.clearedinventory = true
}

// InventoryCleared reports if the "inventory" edge to the Inventory entity was cleared.
func (m *InventoryMovementMutation) InventoryCleared() bool {
	return m.clearedinventory
}

// InventoryID returns the "inventory" edge ID in the mutation.
func (m *InventoryMovementMutation) InventoryID() (id int, exists bool) {
	if m.inventory != nil {
		return *m.inventory, true
	}
	return
}

// InventoryIDs returns the "inventory" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// InventoryID instead. It exists only for internal usage by the builders.
func (m *InventoryMovementMutation) InventoryIDs() (ids []int) {
	if id := m.inventory; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetInventory resets all changes to the "inventory" edge.
func (m *InventoryMovementMutation) ResetInventory() {
	m.inventory = nil
	m.clearedinventory = false
}

// Where appends a list predicates to the InventoryMovementMutation builder.
func (m *InventoryMovementMutation) Where(ps ...predicate.InventoryMovement) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the InventoryMovementMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *InventoryMovementMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.InventoryMovement, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *InventoryMovementMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *InventoryMovementMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (InventoryMovement).
func (m *InventoryMovementMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *InventoryMovementMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.created_at != nil {
		fields = append(fields, inventorymovement.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, inventorymovement.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, inventorymovement.FieldDeletedAt)
	}
	if m.category != nil {
		fields = append(fields, inventorymovement.FieldCategory)
	}
	if m.quantity != nil {
		fields = append(fields, inventorymovement.FieldQuantity)
	}
	if m.value != nil {
		fields = append(fields, inventorymovement.FieldValue)
	}
	if m.date != nil {
		fields = append(fields, inventorymovement.FieldDate)
	}
	if m.source != nil {
		fields = append(fields, inventorymovement.FieldSource)
	}
	if m.destination != nil {
		fields = append(fields, inventorymovement.FieldDestination)
	}
	if m.notes != nil {
		fields = append(fields, inventorymovement.FieldNotes)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *InventoryMovementMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case inventorymovement.FieldCreatedAt:
		return m.CreatedAt()
	case inventorymovement.FieldUpdatedAt:
		return m.UpdatedAt()
	case inventorymovement.FieldDeletedAt:
		return m.DeletedAt()
	case inventorymovement.FieldCategory:
		return m.Category()
	case inventorymovement.FieldQuantity:
		return m.Quantity()
	case inventorymovement.FieldValue:
		return m.Value()
	case inventorymovement.FieldDate:
		return m.Date()
	case inventorymovement.FieldSource:
		return m.Source()
	case inventorymovement.FieldDestination:
		return m.Destination()
	case inventorymovement.FieldNotes:
		return m.Notes()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *InventoryMovementMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case inventorymovement.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case inventorymovement.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case inventorymovement.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case inventorymovement.FieldCategory:
		return m.OldCategory(ctx)
	case inventorymovement.FieldQuantity:
		return m.OldQuantity(ctx)
	case inventorymovement.FieldValue:
		return m.OldValue(ctx)
	case inventorymovement.FieldDate:
		return m.OldDate(ctx)
	case inventorymovement.FieldSource:
		return m.OldSource(ctx)
	case inventorymovement.FieldDestination:
		return m.OldDestination(ctx)
	case inventorymovement.FieldNotes:
		return m.OldNotes(ctx)
	}
	return nil, fmt.Errorf("unknown InventoryMovement field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *InventoryMovementMutation) SetField(name string, value ent.Value) error {
	switch name {
	case inventorymovement.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case inventorymovement.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case inventorymovement.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case inventorymovement.FieldCategory:
		v, ok := value.(inventorymovement.Category)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCategory(v)
		return nil
	case inventorymovement.FieldQuantity:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetQuantity(v)
		return nil
	case inventorymovement.FieldValue:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetValue(v)
		return nil
	case inventorymovement.FieldDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDate(v)
		return nil
	case inventorymovement.FieldSource:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSource(v)
		return nil
	case inventorymovement.FieldDestination:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDestination(v)
		return nil
	case inventorymovement.FieldNotes:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNotes(v)
		return nil
	}
	return fmt.Errorf("unknown InventoryMovement field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *InventoryMovementMutation) AddedFields() []string {
	var fields []string
	if m.addquantity != nil {
		fields = append(fields, inventorymovement.FieldQuantity)
	}
	if m.addvalue != nil {
		fields = append(fields, inventorymovement.FieldValue)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *InventoryMovementMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case inventorymovement.FieldQuantity:
		return m.AddedQuantity()
	case inventorymovement.FieldValue:
		return m.AddedValue()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *InventoryMovementMutation) AddField(name string, value ent.Value) error {
	switch name {
	case inventorymovement.FieldQuantity:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddQuantity(v)
		return nil
	case inventorymovement.FieldValue:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddValue(v)
		return nil
	}
	return fmt.Errorf("unknown InventoryMovement numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *InventoryMovementMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(inventorymovement.FieldDeletedAt) {
		fields = append(fields, inventorymovement.FieldDeletedAt)
	}
	if m.FieldCleared(inventorymovement.FieldSource) {
		fields = append(fields, inventorymovement.FieldSource)
	}
	if m.FieldCleared(inventorymovement.FieldDestination) {
		fields = append(fields, inventorymovement.FieldDestination)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *InventoryMovementMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *InventoryMovementMutation) ClearField(name string) error {
	switch name {
	case inventorymovement.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case inventorymovement.FieldSource:
		m.ClearSource()
		return nil
	case inventorymovement.FieldDestination:
		m.ClearDestination()
		return nil
	}
	return fmt.Errorf("unknown InventoryMovement nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *InventoryMovementMutation) ResetField(name string) error {
	switch name {
	case inventorymovement.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case inventorymovement.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case inventorymovement.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case inventorymovement.FieldCategory:
		m.ResetCategory()
		return nil
	case inventorymovement.FieldQuantity:
		m.ResetQuantity()
		return nil
	case inventorymovement.FieldValue:
		m.ResetValue()
		return nil
	case inventorymovement.FieldDate:
		m.ResetDate()
		return nil
	case inventorymovement.FieldSource:
		m.ResetSource()
		return nil
	case inventorymovement.FieldDestination:
		m.ResetDestination()
		return nil
	case inventorymovement.FieldNotes:
		m.ResetNotes()
		return nil
	}
	return fmt.Errorf("unknown InventoryMovement field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *InventoryMovementMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.company != nil {
		edges = append(edges, inventorymovement.EdgeCompany)
	}
	if m.inventory != nil {
		edges = append(edges, inventorymovement.EdgeInventory)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *InventoryMovementMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case inventorymovement.EdgeCompany:
		if id := m.company; id != nil {
			return []ent.Value{*id}
		}
	case inventorymovement.EdgeInventory:
		if id := m.inventory; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *InventoryMovementMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *InventoryMovementMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *InventoryMovementMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedcompany {
		edges = append(edges, inventorymovement.EdgeCompany)
	}
	if m.clearedinventory {
		edges = append(edges, inventorymovement.EdgeInventory)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *InventoryMovementMutation) EdgeCleared(name string) bool {
	switch name {
	case inventorymovement.EdgeCompany:
		return m.clearedcompany
	case inventorymovement.EdgeInventory:
		return m.clearedinventory
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *InventoryMovementMutation) ClearEdge(name string) error {
	switch name {
	case inventorymovement.EdgeCompany:
		m.ClearCompany()
		return nil
	case inventorymovement.EdgeInventory:
		m.ClearInventory()
		return nil
	}
	return fmt.Errorf("unknown InventoryMovement unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *InventoryMovementMutation) ResetEdge(name string) error {
	switch name {
	case inventorymovement.EdgeCompany:
		m.ResetCompany()
		return nil
	case inventorymovement.EdgeInventory:
		m.ResetInventory()
		return nil
	}
	return fmt.Errorf("unknown InventoryMovement edge %s", name)
}

// InvoiceMutation represents an operation that mutates the Invoice nodes in the graph.
type InvoiceMutation struct {
	config
	op                  Op
	typ                 string
	id                  *int
	created_at          *time.Time
	updated_at          *time.Time
	deleted_at          *time.Time
	company_logo        *string
	company_name        *string
	company_tax_id      *string
	company_address     *string
	company_city        *string
	company_email       *string
	company_phone       *string
	number              *string
	issue_date          *time.Time
	due_date            *time.Time
	paid_at             *time.Time
	status              *invoice.Status
	customer_name       *string
	customer_tax_id     *string
	customer_address    *string
	customer_city       *string
	customer_email      *string
	customer_phone      *string
	items               *string
	subtotal            *float64
	addsubtotal         *float64
	tax                 *float64
	addtax              *float64
	total               *float64
	addtotal            *float64
	notes               *string
	payment_method      *string
	bank_name           *string
	bank_agency         *string
	bank_account_number *string
	bank_account_name   *string
	storage_URI         *string
	_URL                *string
	filename            *string
	size                *float64
	addsize             *float64
	keywords            *string
	clearedFields       map[string]struct{}
	company             *int
	clearedcompany      bool
	issued_by           *int
	clearedissued_by    bool
	client              *int
	clearedclient       bool
	receivable          *int
	clearedreceivable   bool
	done                bool
	oldValue            func(context.Context) (*Invoice, error)
	predicates          []predicate.Invoice
}

var _ ent.Mutation = (*InvoiceMutation)(nil)

// invoiceOption allows management of the mutation configuration using functional options.
type invoiceOption func(*InvoiceMutation)

// newInvoiceMutation creates new mutation for the Invoice entity.
func newInvoiceMutation(c config, op Op, opts ...invoiceOption) *InvoiceMutation {
	m := &InvoiceMutation{
		config:        c,
		op:            op,
		typ:           TypeInvoice,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withInvoiceID sets the ID field of the mutation.
func withInvoiceID(id int) invoiceOption {
	return func(m *InvoiceMutation) {
		var (
			err   error
			once  sync.Once
			value *Invoice
		)
		m.oldValue = func(ctx context.Context) (*Invoice, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Invoice.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withInvoice sets the old Invoice of the mutation.
func withInvoice(node *Invoice) invoiceOption {
	return func(m *InvoiceMutation) {
		m.oldValue = func(context.Context) (*Invoice, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m InvoiceMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m InvoiceMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("generated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *InvoiceMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *InvoiceMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Invoice.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *InvoiceMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *InvoiceMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Invoice entity.
// If the Invoice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InvoiceMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *InvoiceMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *InvoiceMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *InvoiceMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Invoice entity.
// If the Invoice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InvoiceMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *InvoiceMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *InvoiceMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *InvoiceMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Invoice entity.
// If the Invoice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InvoiceMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *InvoiceMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[invoice.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *InvoiceMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[invoice.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *InvoiceMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, invoice.FieldDeletedAt)
}

// SetCompanyLogo sets the "company_logo" field.
func (m *InvoiceMutation) SetCompanyLogo(s string) {
	m.company_logo = &s
}

// CompanyLogo returns the value of the "company_logo" field in the mutation.
func (m *InvoiceMutation) CompanyLogo() (r string, exists bool) {
	v := m.company_logo
	if v == nil {
		return
	}
	return *v, true
}

// OldCompanyLogo returns the old "company_logo" field's value of the Invoice entity.
// If the Invoice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InvoiceMutation) OldCompanyLogo(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCompanyLogo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCompanyLogo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCompanyLogo: %w", err)
	}
	return oldValue.CompanyLogo, nil
}

// ClearCompanyLogo clears the value of the "company_logo" field.
func (m *InvoiceMutation) ClearCompanyLogo() {
	m.company_logo = nil
	m.clearedFields[invoice.FieldCompanyLogo] = struct{}{}
}

// CompanyLogoCleared returns if the "company_logo" field was cleared in this mutation.
func (m *InvoiceMutation) CompanyLogoCleared() bool {
	_, ok := m.clearedFields[invoice.FieldCompanyLogo]
	return ok
}

// ResetCompanyLogo resets all changes to the "company_logo" field.
func (m *InvoiceMutation) ResetCompanyLogo() {
	m.company_logo = nil
	delete(m.clearedFields, invoice.FieldCompanyLogo)
}

// SetCompanyName sets the "company_name" field.
func (m *InvoiceMutation) SetCompanyName(s string) {
	m.company_name = &s
}

// CompanyName returns the value of the "company_name" field in the mutation.
func (m *InvoiceMutation) CompanyName() (r string, exists bool) {
	v := m.company_name
	if v == nil {
		return
	}
	return *v, true
}

// OldCompanyName returns the old "company_name" field's value of the Invoice entity.
// If the Invoice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InvoiceMutation) OldCompanyName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCompanyName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCompanyName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCompanyName: %w", err)
	}
	return oldValue.CompanyName, nil
}

// ResetCompanyName resets all changes to the "company_name" field.
func (m *InvoiceMutation) ResetCompanyName() {
	m.company_name = nil
}

// SetCompanyTaxID sets the "company_tax_id" field.
func (m *InvoiceMutation) SetCompanyTaxID(s string) {
	m.company_tax_id = &s
}

// CompanyTaxID returns the value of the "company_tax_id" field in the mutation.
func (m *InvoiceMutation) CompanyTaxID() (r string, exists bool) {
	v := m.company_tax_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCompanyTaxID returns the old "company_tax_id" field's value of the Invoice entity.
// If the Invoice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InvoiceMutation) OldCompanyTaxID(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCompanyTaxID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCompanyTaxID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCompanyTaxID: %w", err)
	}
	return oldValue.CompanyTaxID, nil
}

// ClearCompanyTaxID clears the value of the "company_tax_id" field.
func (m *InvoiceMutation) ClearCompanyTaxID() {
	m.company_tax_id = nil
	m.clearedFields[invoice.FieldCompanyTaxID] = struct{}{}
}

// CompanyTaxIDCleared returns if the "company_tax_id" field was cleared in this mutation.
func (m *InvoiceMutation) CompanyTaxIDCleared() bool {
	_, ok := m.clearedFields[invoice.FieldCompanyTaxID]
	return ok
}

// ResetCompanyTaxID resets all changes to the "company_tax_id" field.
func (m *InvoiceMutation) ResetCompanyTaxID() {
	m.company_tax_id = nil
	delete(m.clearedFields, invoice.FieldCompanyTaxID)
}

// SetCompanyAddress sets the "company_address" field.
func (m *InvoiceMutation) SetCompanyAddress(s string) {
	m.company_address = &s
}

// CompanyAddress returns the value of the "company_address" field in the mutation.
func (m *InvoiceMutation) CompanyAddress() (r string, exists bool) {
	v := m.company_address
	if v == nil {
		return
	}
	return *v, true
}

// OldCompanyAddress returns the old "company_address" field's value of the Invoice entity.
// If the Invoice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InvoiceMutation) OldCompanyAddress(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCompanyAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCompanyAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCompanyAddress: %w", err)
	}
	return oldValue.CompanyAddress, nil
}

// ResetCompanyAddress resets all changes to the "company_address" field.
func (m *InvoiceMutation) ResetCompanyAddress() {
	m.company_address = nil
}

// SetCompanyCity sets the "company_city" field.
func (m *InvoiceMutation) SetCompanyCity(s string) {
	m.company_city = &s
}

// CompanyCity returns the value of the "company_city" field in the mutation.
func (m *InvoiceMutation) CompanyCity() (r string, exists bool) {
	v := m.company_city
	if v == nil {
		return
	}
	return *v, true
}

// OldCompanyCity returns the old "company_city" field's value of the Invoice entity.
// If the Invoice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InvoiceMutation) OldCompanyCity(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCompanyCity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCompanyCity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCompanyCity: %w", err)
	}
	return oldValue.CompanyCity, nil
}

// ResetCompanyCity resets all changes to the "company_city" field.
func (m *InvoiceMutation) ResetCompanyCity() {
	m.company_city = nil
}

// SetCompanyEmail sets the "company_email" field.
func (m *InvoiceMutation) SetCompanyEmail(s string) {
	m.company_email = &s
}

// CompanyEmail returns the value of the "company_email" field in the mutation.
func (m *InvoiceMutation) CompanyEmail() (r string, exists bool) {
	v := m.company_email
	if v == nil {
		return
	}
	return *v, true
}

// OldCompanyEmail returns the old "company_email" field's value of the Invoice entity.
// If the Invoice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InvoiceMutation) OldCompanyEmail(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCompanyEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCompanyEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCompanyEmail: %w", err)
	}
	return oldValue.CompanyEmail, nil
}

// ClearCompanyEmail clears the value of the "company_email" field.
func (m *InvoiceMutation) ClearCompanyEmail() {
	m.company_email = nil
	m.clearedFields[invoice.FieldCompanyEmail] = struct{}{}
}

// CompanyEmailCleared returns if the "company_email" field was cleared in this mutation.
func (m *InvoiceMutation) CompanyEmailCleared() bool {
	_, ok := m.clearedFields[invoice.FieldCompanyEmail]
	return ok
}

// ResetCompanyEmail resets all changes to the "company_email" field.
func (m *InvoiceMutation) ResetCompanyEmail() {
	m.company_email = nil
	delete(m.clearedFields, invoice.FieldCompanyEmail)
}

// SetCompanyPhone sets the "company_phone" field.
func (m *InvoiceMutation) SetCompanyPhone(s string) {
	m.company_phone = &s
}

// CompanyPhone returns the value of the "company_phone" field in the mutation.
func (m *InvoiceMutation) CompanyPhone() (r string, exists bool) {
	v := m.company_phone
	if v == nil {
		return
	}
	return *v, true
}

// OldCompanyPhone returns the old "company_phone" field's value of the Invoice entity.
// If the Invoice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InvoiceMutation) OldCompanyPhone(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCompanyPhone is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCompanyPhone requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCompanyPhone: %w", err)
	}
	return oldValue.CompanyPhone, nil
}

// ClearCompanyPhone clears the value of the "company_phone" field.
func (m *InvoiceMutation) ClearCompanyPhone() {
	m.company_phone = nil
	m.clearedFields[invoice.FieldCompanyPhone] = struct{}{}
}

// CompanyPhoneCleared returns if the "company_phone" field was cleared in this mutation.
func (m *InvoiceMutation) CompanyPhoneCleared() bool {
	_, ok := m.clearedFields[invoice.FieldCompanyPhone]
	return ok
}

// ResetCompanyPhone resets all changes to the "company_phone" field.
func (m *InvoiceMutation) ResetCompanyPhone() {
	m.company_phone = nil
	delete(m.clearedFields, invoice.FieldCompanyPhone)
}

// SetNumber sets the "number" field.
func (m *InvoiceMutation) SetNumber(s string) {
	m.number = &s
}

// Number returns the value of the "number" field in the mutation.
func (m *InvoiceMutation) Number() (r string, exists bool) {
	v := m.number
	if v == nil {
		return
	}
	return *v, true
}

// OldNumber returns the old "number" field's value of the Invoice entity.
// If the Invoice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InvoiceMutation) OldNumber(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNumber: %w", err)
	}
	return oldValue.Number, nil
}

// ClearNumber clears the value of the "number" field.
func (m *InvoiceMutation) ClearNumber() {
	m.number = nil
	m.clearedFields[invoice.FieldNumber] = struct{}{}
}

// NumberCleared returns if the "number" field was cleared in this mutation.
func (m *InvoiceMutation) NumberCleared() bool {
	_, ok := m.clearedFields[invoice.FieldNumber]
	return ok
}

// ResetNumber resets all changes to the "number" field.
func (m *InvoiceMutation) ResetNumber() {
	m.number = nil
	delete(m.clearedFields, invoice.FieldNumber)
}

// SetIssueDate sets the "issue_date" field.
func (m *InvoiceMutation) SetIssueDate(t time.Time) {
	m.issue_date = &t
}

// IssueDate returns the value of the "issue_date" field in the mutation.
func (m *InvoiceMutation) IssueDate() (r time.Time, exists bool) {
	v := m.issue_date
	if v == nil {
		return
	}
	return *v, true
}

// OldIssueDate returns the old "issue_date" field's value of the Invoice entity.
// If the Invoice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InvoiceMutation) OldIssueDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIssueDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIssueDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIssueDate: %w", err)
	}
	return oldValue.IssueDate, nil
}

// ResetIssueDate resets all changes to the "issue_date" field.
func (m *InvoiceMutation) ResetIssueDate() {
	m.issue_date = nil
}

// SetDueDate sets the "due_date" field.
func (m *InvoiceMutation) SetDueDate(t time.Time) {
	m.due_date = &t
}

// DueDate returns the value of the "due_date" field in the mutation.
func (m *InvoiceMutation) DueDate() (r time.Time, exists bool) {
	v := m.due_date
	if v == nil {
		return
	}
	return *v, true
}

// OldDueDate returns the old "due_date" field's value of the Invoice entity.
// If the Invoice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InvoiceMutation) OldDueDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDueDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDueDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDueDate: %w", err)
	}
	return oldValue.DueDate, nil
}

// ResetDueDate resets all changes to the "due_date" field.
func (m *InvoiceMutation) ResetDueDate() {
	m.due_date = nil
}

// SetPaidAt sets the "paid_at" field.
func (m *InvoiceMutation) SetPaidAt(t time.Time) {
	m.paid_at = &t
}

// PaidAt returns the value of the "paid_at" field in the mutation.
func (m *InvoiceMutation) PaidAt() (r time.Time, exists bool) {
	v := m.paid_at
	if v == nil {
		return
	}
	return *v, true
}

// OldPaidAt returns the old "paid_at" field's value of the Invoice entity.
// If the Invoice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InvoiceMutation) OldPaidAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPaidAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPaidAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPaidAt: %w", err)
	}
	return oldValue.PaidAt, nil
}

// ClearPaidAt clears the value of the "paid_at" field.
func (m *InvoiceMutation) ClearPaidAt() {
	m.paid_at = nil
	m.clearedFields[invoice.FieldPaidAt] = struct{}{}
}

// PaidAtCleared returns if the "paid_at" field was cleared in this mutation.
func (m *InvoiceMutation) PaidAtCleared() bool {
	_, ok := m.clearedFields[invoice.FieldPaidAt]
	return ok
}

// ResetPaidAt resets all changes to the "paid_at" field.
func (m *InvoiceMutation) ResetPaidAt() {
	m.paid_at = nil
	delete(m.clearedFields, invoice.FieldPaidAt)
}

// SetStatus sets the "status" field.
func (m *InvoiceMutation) SetStatus(i invoice.Status) {
	m.status = &i
}

// Status returns the value of the "status" field in the mutation.
func (m *InvoiceMutation) Status() (r invoice.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Invoice entity.
// If the Invoice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InvoiceMutation) OldStatus(ctx context.Context) (v invoice.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *InvoiceMutation) ResetStatus() {
	m.status = nil
}

// SetCustomerName sets the "customer_name" field.
func (m *InvoiceMutation) SetCustomerName(s string) {
	m.customer_name = &s
}

// CustomerName returns the value of the "customer_name" field in the mutation.
func (m *InvoiceMutation) CustomerName() (r string, exists bool) {
	v := m.customer_name
	if v == nil {
		return
	}
	return *v, true
}

// OldCustomerName returns the old "customer_name" field's value of the Invoice entity.
// If the Invoice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InvoiceMutation) OldCustomerName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCustomerName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCustomerName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCustomerName: %w", err)
	}
	return oldValue.CustomerName, nil
}

// ClearCustomerName clears the value of the "customer_name" field.
func (m *InvoiceMutation) ClearCustomerName() {
	m.customer_name = nil
	m.clearedFields[invoice.FieldCustomerName] = struct{}{}
}

// CustomerNameCleared returns if the "customer_name" field was cleared in this mutation.
func (m *InvoiceMutation) CustomerNameCleared() bool {
	_, ok := m.clearedFields[invoice.FieldCustomerName]
	return ok
}

// ResetCustomerName resets all changes to the "customer_name" field.
func (m *InvoiceMutation) ResetCustomerName() {
	m.customer_name = nil
	delete(m.clearedFields, invoice.FieldCustomerName)
}

// SetCustomerTaxID sets the "customer_tax_id" field.
func (m *InvoiceMutation) SetCustomerTaxID(s string) {
	m.customer_tax_id = &s
}

// CustomerTaxID returns the value of the "customer_tax_id" field in the mutation.
func (m *InvoiceMutation) CustomerTaxID() (r string, exists bool) {
	v := m.customer_tax_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCustomerTaxID returns the old "customer_tax_id" field's value of the Invoice entity.
// If the Invoice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InvoiceMutation) OldCustomerTaxID(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCustomerTaxID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCustomerTaxID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCustomerTaxID: %w", err)
	}
	return oldValue.CustomerTaxID, nil
}

// ClearCustomerTaxID clears the value of the "customer_tax_id" field.
func (m *InvoiceMutation) ClearCustomerTaxID() {
	m.customer_tax_id = nil
	m.clearedFields[invoice.FieldCustomerTaxID] = struct{}{}
}

// CustomerTaxIDCleared returns if the "customer_tax_id" field was cleared in this mutation.
func (m *InvoiceMutation) CustomerTaxIDCleared() bool {
	_, ok := m.clearedFields[invoice.FieldCustomerTaxID]
	return ok
}

// ResetCustomerTaxID resets all changes to the "customer_tax_id" field.
func (m *InvoiceMutation) ResetCustomerTaxID() {
	m.customer_tax_id = nil
	delete(m.clearedFields, invoice.FieldCustomerTaxID)
}

// SetCustomerAddress sets the "customer_address" field.
func (m *InvoiceMutation) SetCustomerAddress(s string) {
	m.customer_address = &s
}

// CustomerAddress returns the value of the "customer_address" field in the mutation.
func (m *InvoiceMutation) CustomerAddress() (r string, exists bool) {
	v := m.customer_address
	if v == nil {
		return
	}
	return *v, true
}

// OldCustomerAddress returns the old "customer_address" field's value of the Invoice entity.
// If the Invoice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InvoiceMutation) OldCustomerAddress(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCustomerAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCustomerAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCustomerAddress: %w", err)
	}
	return oldValue.CustomerAddress, nil
}

// ClearCustomerAddress clears the value of the "customer_address" field.
func (m *InvoiceMutation) ClearCustomerAddress() {
	m.customer_address = nil
	m.clearedFields[invoice.FieldCustomerAddress] = struct{}{}
}

// CustomerAddressCleared returns if the "customer_address" field was cleared in this mutation.
func (m *InvoiceMutation) CustomerAddressCleared() bool {
	_, ok := m.clearedFields[invoice.FieldCustomerAddress]
	return ok
}

// ResetCustomerAddress resets all changes to the "customer_address" field.
func (m *InvoiceMutation) ResetCustomerAddress() {
	m.customer_address = nil
	delete(m.clearedFields, invoice.FieldCustomerAddress)
}

// SetCustomerCity sets the "customer_city" field.
func (m *InvoiceMutation) SetCustomerCity(s string) {
	m.customer_city = &s
}

// CustomerCity returns the value of the "customer_city" field in the mutation.
func (m *InvoiceMutation) CustomerCity() (r string, exists bool) {
	v := m.customer_city
	if v == nil {
		return
	}
	return *v, true
}

// OldCustomerCity returns the old "customer_city" field's value of the Invoice entity.
// If the Invoice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InvoiceMutation) OldCustomerCity(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCustomerCity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCustomerCity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCustomerCity: %w", err)
	}
	return oldValue.CustomerCity, nil
}

// ClearCustomerCity clears the value of the "customer_city" field.
func (m *InvoiceMutation) ClearCustomerCity() {
	m.customer_city = nil
	m.clearedFields[invoice.FieldCustomerCity] = struct{}{}
}

// CustomerCityCleared returns if the "customer_city" field was cleared in this mutation.
func (m *InvoiceMutation) CustomerCityCleared() bool {
	_, ok := m.clearedFields[invoice.FieldCustomerCity]
	return ok
}

// ResetCustomerCity resets all changes to the "customer_city" field.
func (m *InvoiceMutation) ResetCustomerCity() {
	m.customer_city = nil
	delete(m.clearedFields, invoice.FieldCustomerCity)
}

// SetCustomerEmail sets the "customer_email" field.
func (m *InvoiceMutation) SetCustomerEmail(s string) {
	m.customer_email = &s
}

// CustomerEmail returns the value of the "customer_email" field in the mutation.
func (m *InvoiceMutation) CustomerEmail() (r string, exists bool) {
	v := m.customer_email
	if v == nil {
		return
	}
	return *v, true
}

// OldCustomerEmail returns the old "customer_email" field's value of the Invoice entity.
// If the Invoice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InvoiceMutation) OldCustomerEmail(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCustomerEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCustomerEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCustomerEmail: %w", err)
	}
	return oldValue.CustomerEmail, nil
}

// ClearCustomerEmail clears the value of the "customer_email" field.
func (m *InvoiceMutation) ClearCustomerEmail() {
	m.customer_email = nil
	m.clearedFields[invoice.FieldCustomerEmail] = struct{}{}
}

// CustomerEmailCleared returns if the "customer_email" field was cleared in this mutation.
func (m *InvoiceMutation) CustomerEmailCleared() bool {
	_, ok := m.clearedFields[invoice.FieldCustomerEmail]
	return ok
}

// ResetCustomerEmail resets all changes to the "customer_email" field.
func (m *InvoiceMutation) ResetCustomerEmail() {
	m.customer_email = nil
	delete(m.clearedFields, invoice.FieldCustomerEmail)
}

// SetCustomerPhone sets the "customer_phone" field.
func (m *InvoiceMutation) SetCustomerPhone(s string) {
	m.customer_phone = &s
}

// CustomerPhone returns the value of the "customer_phone" field in the mutation.
func (m *InvoiceMutation) CustomerPhone() (r string, exists bool) {
	v := m.customer_phone
	if v == nil {
		return
	}
	return *v, true
}

// OldCustomerPhone returns the old "customer_phone" field's value of the Invoice entity.
// If the Invoice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InvoiceMutation) OldCustomerPhone(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCustomerPhone is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCustomerPhone requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCustomerPhone: %w", err)
	}
	return oldValue.CustomerPhone, nil
}

// ClearCustomerPhone clears the value of the "customer_phone" field.
func (m *InvoiceMutation) ClearCustomerPhone() {
	m.customer_phone = nil
	m.clearedFields[invoice.FieldCustomerPhone] = struct{}{}
}

// CustomerPhoneCleared returns if the "customer_phone" field was cleared in this mutation.
func (m *InvoiceMutation) CustomerPhoneCleared() bool {
	_, ok := m.clearedFields[invoice.FieldCustomerPhone]
	return ok
}

// ResetCustomerPhone resets all changes to the "customer_phone" field.
func (m *InvoiceMutation) ResetCustomerPhone() {
	m.customer_phone = nil
	delete(m.clearedFields, invoice.FieldCustomerPhone)
}

// SetItems sets the "items" field.
func (m *InvoiceMutation) SetItems(s string) {
	m.items = &s
}

// Items returns the value of the "items" field in the mutation.
func (m *InvoiceMutation) Items() (r string, exists bool) {
	v := m.items
	if v == nil {
		return
	}
	return *v, true
}

// OldItems returns the old "items" field's value of the Invoice entity.
// If the Invoice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InvoiceMutation) OldItems(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldItems is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldItems requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldItems: %w", err)
	}
	return oldValue.Items, nil
}

// ResetItems resets all changes to the "items" field.
func (m *InvoiceMutation) ResetItems() {
	m.items = nil
}

// SetSubtotal sets the "subtotal" field.
func (m *InvoiceMutation) SetSubtotal(f float64) {
	m.subtotal = &f
	m.addsubtotal = nil
}

// Subtotal returns the value of the "subtotal" field in the mutation.
func (m *InvoiceMutation) Subtotal() (r float64, exists bool) {
	v := m.subtotal
	if v == nil {
		return
	}
	return *v, true
}

// OldSubtotal returns the old "subtotal" field's value of the Invoice entity.
// If the Invoice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InvoiceMutation) OldSubtotal(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSubtotal is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSubtotal requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSubtotal: %w", err)
	}
	return oldValue.Subtotal, nil
}

// AddSubtotal adds f to the "subtotal" field.
func (m *InvoiceMutation) AddSubtotal(f float64) {
	if m.addsubtotal != nil {
		*m.addsubtotal += f
	} else {
		m.addsubtotal = &f
	}
}

// AddedSubtotal returns the value that was added to the "subtotal" field in this mutation.
func (m *InvoiceMutation) AddedSubtotal() (r float64, exists bool) {
	v := m.addsubtotal
	if v == nil {
		return
	}
	return *v, true
}

// ResetSubtotal resets all changes to the "subtotal" field.
func (m *InvoiceMutation) ResetSubtotal() {
	m.subtotal = nil
	m.addsubtotal = nil
}

// SetTax sets the "tax" field.
func (m *InvoiceMutation) SetTax(f float64) {
	m.tax = &f
	m.addtax = nil
}

// Tax returns the value of the "tax" field in the mutation.
func (m *InvoiceMutation) Tax() (r float64, exists bool) {
	v := m.tax
	if v == nil {
		return
	}
	return *v, true
}

// OldTax returns the old "tax" field's value of the Invoice entity.
// If the Invoice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InvoiceMutation) OldTax(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTax is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTax requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTax: %w", err)
	}
	return oldValue.Tax, nil
}

// AddTax adds f to the "tax" field.
func (m *InvoiceMutation) AddTax(f float64) {
	if m.addtax != nil {
		*m.addtax += f
	} else {
		m.addtax = &f
	}
}

// AddedTax returns the value that was added to the "tax" field in this mutation.
func (m *InvoiceMutation) AddedTax() (r float64, exists bool) {
	v := m.addtax
	if v == nil {
		return
	}
	return *v, true
}

// ResetTax resets all changes to the "tax" field.
func (m *InvoiceMutation) ResetTax() {
	m.tax = nil
	m.addtax = nil
}

// SetTotal sets the "total" field.
func (m *InvoiceMutation) SetTotal(f float64) {
	m.total = &f
	m.addtotal = nil
}

// Total returns the value of the "total" field in the mutation.
func (m *InvoiceMutation) Total() (r float64, exists bool) {
	v := m.total
	if v == nil {
		return
	}
	return *v, true
}

// OldTotal returns the old "total" field's value of the Invoice entity.
// If the Invoice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InvoiceMutation) OldTotal(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTotal is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTotal requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTotal: %w", err)
	}
	return oldValue.Total, nil
}

// AddTotal adds f to the "total" field.
func (m *InvoiceMutation) AddTotal(f float64) {
	if m.addtotal != nil {
		*m.addtotal += f
	} else {
		m.addtotal = &f
	}
}

// AddedTotal returns the value that was added to the "total" field in this mutation.
func (m *InvoiceMutation) AddedTotal() (r float64, exists bool) {
	v := m.addtotal
	if v == nil {
		return
	}
	return *v, true
}

// ResetTotal resets all changes to the "total" field.
func (m *InvoiceMutation) ResetTotal() {
	m.total = nil
	m.addtotal = nil
}

// SetNotes sets the "notes" field.
func (m *InvoiceMutation) SetNotes(s string) {
	m.notes = &s
}

// Notes returns the value of the "notes" field in the mutation.
func (m *InvoiceMutation) Notes() (r string, exists bool) {
	v := m.notes
	if v == nil {
		return
	}
	return *v, true
}

// OldNotes returns the old "notes" field's value of the Invoice entity.
// If the Invoice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InvoiceMutation) OldNotes(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNotes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNotes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNotes: %w", err)
	}
	return oldValue.Notes, nil
}

// ClearNotes clears the value of the "notes" field.
func (m *InvoiceMutation) ClearNotes() {
	m.notes = nil
	m.clearedFields[invoice.FieldNotes] = struct{}{}
}

// NotesCleared returns if the "notes" field was cleared in this mutation.
func (m *InvoiceMutation) NotesCleared() bool {
	_, ok := m.clearedFields[invoice.FieldNotes]
	return ok
}

// ResetNotes resets all changes to the "notes" field.
func (m *InvoiceMutation) ResetNotes() {
	m.notes = nil
	delete(m.clearedFields, invoice.FieldNotes)
}

// SetPaymentMethod sets the "payment_method" field.
func (m *InvoiceMutation) SetPaymentMethod(s string) {
	m.payment_method = &s
}

// PaymentMethod returns the value of the "payment_method" field in the mutation.
func (m *InvoiceMutation) PaymentMethod() (r string, exists bool) {
	v := m.payment_method
	if v == nil {
		return
	}
	return *v, true
}

// OldPaymentMethod returns the old "payment_method" field's value of the Invoice entity.
// If the Invoice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InvoiceMutation) OldPaymentMethod(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPaymentMethod is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPaymentMethod requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPaymentMethod: %w", err)
	}
	return oldValue.PaymentMethod, nil
}

// ClearPaymentMethod clears the value of the "payment_method" field.
func (m *InvoiceMutation) ClearPaymentMethod() {
	m.payment_method = nil
	m.clearedFields[invoice.FieldPaymentMethod] = struct{}{}
}

// PaymentMethodCleared returns if the "payment_method" field was cleared in this mutation.
func (m *InvoiceMutation) PaymentMethodCleared() bool {
	_, ok := m.clearedFields[invoice.FieldPaymentMethod]
	return ok
}

// ResetPaymentMethod resets all changes to the "payment_method" field.
func (m *InvoiceMutation) ResetPaymentMethod() {
	m.payment_method = nil
	delete(m.clearedFields, invoice.FieldPaymentMethod)
}

// SetBankName sets the "bank_name" field.
func (m *InvoiceMutation) SetBankName(s string) {
	m.bank_name = &s
}

// BankName returns the value of the "bank_name" field in the mutation.
func (m *InvoiceMutation) BankName() (r string, exists bool) {
	v := m.bank_name
	if v == nil {
		return
	}
	return *v, true
}

// OldBankName returns the old "bank_name" field's value of the Invoice entity.
// If the Invoice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InvoiceMutation) OldBankName(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBankName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBankName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBankName: %w", err)
	}
	return oldValue.BankName, nil
}

// ClearBankName clears the value of the "bank_name" field.
func (m *InvoiceMutation) ClearBankName() {
	m.bank_name = nil
	m.clearedFields[invoice.FieldBankName] = struct{}{}
}

// BankNameCleared returns if the "bank_name" field was cleared in this mutation.
func (m *InvoiceMutation) BankNameCleared() bool {
	_, ok := m.clearedFields[invoice.FieldBankName]
	return ok
}

// ResetBankName resets all changes to the "bank_name" field.
func (m *InvoiceMutation) ResetBankName() {
	m.bank_name = nil
	delete(m.clearedFields, invoice.FieldBankName)
}

// SetBankAgency sets the "bank_agency" field.
func (m *InvoiceMutation) SetBankAgency(s string) {
	m.bank_agency = &s
}

// BankAgency returns the value of the "bank_agency" field in the mutation.
func (m *InvoiceMutation) BankAgency() (r string, exists bool) {
	v := m.bank_agency
	if v == nil {
		return
	}
	return *v, true
}

// OldBankAgency returns the old "bank_agency" field's value of the Invoice entity.
// If the Invoice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InvoiceMutation) OldBankAgency(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBankAgency is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBankAgency requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBankAgency: %w", err)
	}
	return oldValue.BankAgency, nil
}

// ClearBankAgency clears the value of the "bank_agency" field.
func (m *InvoiceMutation) ClearBankAgency() {
	m.bank_agency = nil
	m.clearedFields[invoice.FieldBankAgency] = struct{}{}
}

// BankAgencyCleared returns if the "bank_agency" field was cleared in this mutation.
func (m *InvoiceMutation) BankAgencyCleared() bool {
	_, ok := m.clearedFields[invoice.FieldBankAgency]
	return ok
}

// ResetBankAgency resets all changes to the "bank_agency" field.
func (m *InvoiceMutation) ResetBankAgency() {
	m.bank_agency = nil
	delete(m.clearedFields, invoice.FieldBankAgency)
}

// SetBankAccountNumber sets the "bank_account_number" field.
func (m *InvoiceMutation) SetBankAccountNumber(s string) {
	m.bank_account_number = &s
}

// BankAccountNumber returns the value of the "bank_account_number" field in the mutation.
func (m *InvoiceMutation) BankAccountNumber() (r string, exists bool) {
	v := m.bank_account_number
	if v == nil {
		return
	}
	return *v, true
}

// OldBankAccountNumber returns the old "bank_account_number" field's value of the Invoice entity.
// If the Invoice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InvoiceMutation) OldBankAccountNumber(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBankAccountNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBankAccountNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBankAccountNumber: %w", err)
	}
	return oldValue.BankAccountNumber, nil
}

// ClearBankAccountNumber clears the value of the "bank_account_number" field.
func (m *InvoiceMutation) ClearBankAccountNumber() {
	m.bank_account_number = nil
	m.clearedFields[invoice.FieldBankAccountNumber] = struct{}{}
}

// BankAccountNumberCleared returns if the "bank_account_number" field was cleared in this mutation.
func (m *InvoiceMutation) BankAccountNumberCleared() bool {
	_, ok := m.clearedFields[invoice.FieldBankAccountNumber]
	return ok
}

// ResetBankAccountNumber resets all changes to the "bank_account_number" field.
func (m *InvoiceMutation) ResetBankAccountNumber() {
	m.bank_account_number = nil
	delete(m.clearedFields, invoice.FieldBankAccountNumber)
}

// SetBankAccountName sets the "bank_account_name" field.
func (m *InvoiceMutation) SetBankAccountName(s string) {
	m.bank_account_name = &s
}

// BankAccountName returns the value of the "bank_account_name" field in the mutation.
func (m *InvoiceMutation) BankAccountName() (r string, exists bool) {
	v := m.bank_account_name
	if v == nil {
		return
	}
	return *v, true
}

// OldBankAccountName returns the old "bank_account_name" field's value of the Invoice entity.
// If the Invoice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InvoiceMutation) OldBankAccountName(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBankAccountName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBankAccountName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBankAccountName: %w", err)
	}
	return oldValue.BankAccountName, nil
}

// ClearBankAccountName clears the value of the "bank_account_name" field.
func (m *InvoiceMutation) ClearBankAccountName() {
	m.bank_account_name = nil
	m.clearedFields[invoice.FieldBankAccountName] = struct{}{}
}

// BankAccountNameCleared returns if the "bank_account_name" field was cleared in this mutation.
func (m *InvoiceMutation) BankAccountNameCleared() bool {
	_, ok := m.clearedFields[invoice.FieldBankAccountName]
	return ok
}

// ResetBankAccountName resets all changes to the "bank_account_name" field.
func (m *InvoiceMutation) ResetBankAccountName() {
	m.bank_account_name = nil
	delete(m.clearedFields, invoice.FieldBankAccountName)
}

// SetStorageURI sets the "storage_URI" field.
func (m *InvoiceMutation) SetStorageURI(s string) {
	m.storage_URI = &s
}

// StorageURI returns the value of the "storage_URI" field in the mutation.
func (m *InvoiceMutation) StorageURI() (r string, exists bool) {
	v := m.storage_URI
	if v == nil {
		return
	}
	return *v, true
}

// OldStorageURI returns the old "storage_URI" field's value of the Invoice entity.
// If the Invoice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InvoiceMutation) OldStorageURI(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStorageURI is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStorageURI requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStorageURI: %w", err)
	}
	return oldValue.StorageURI, nil
}

// ClearStorageURI clears the value of the "storage_URI" field.
func (m *InvoiceMutation) ClearStorageURI() {
	m.storage_URI = nil
	m.clearedFields[invoice.FieldStorageURI] = struct{}{}
}

// StorageURICleared returns if the "storage_URI" field was cleared in this mutation.
func (m *InvoiceMutation) StorageURICleared() bool {
	_, ok := m.clearedFields[invoice.FieldStorageURI]
	return ok
}

// ResetStorageURI resets all changes to the "storage_URI" field.
func (m *InvoiceMutation) ResetStorageURI() {
	m.storage_URI = nil
	delete(m.clearedFields, invoice.FieldStorageURI)
}

// SetURL sets the "URL" field.
func (m *InvoiceMutation) SetURL(s string) {
	m._URL = &s
}

// URL returns the value of the "URL" field in the mutation.
func (m *InvoiceMutation) URL() (r string, exists bool) {
	v := m._URL
	if v == nil {
		return
	}
	return *v, true
}

// OldURL returns the old "URL" field's value of the Invoice entity.
// If the Invoice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InvoiceMutation) OldURL(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldURL: %w", err)
	}
	return oldValue.URL, nil
}

// ClearURL clears the value of the "URL" field.
func (m *InvoiceMutation) ClearURL() {
	m._URL = nil
	m.clearedFields[invoice.FieldURL] = struct{}{}
}

// URLCleared returns if the "URL" field was cleared in this mutation.
func (m *InvoiceMutation) URLCleared() bool {
	_, ok := m.clearedFields[invoice.FieldURL]
	return ok
}

// ResetURL resets all changes to the "URL" field.
func (m *InvoiceMutation) ResetURL() {
	m._URL = nil
	delete(m.clearedFields, invoice.FieldURL)
}

// SetFilename sets the "filename" field.
func (m *InvoiceMutation) SetFilename(s string) {
	m.filename = &s
}

// Filename returns the value of the "filename" field in the mutation.
func (m *InvoiceMutation) Filename() (r string, exists bool) {
	v := m.filename
	if v == nil {
		return
	}
	return *v, true
}

// OldFilename returns the old "filename" field's value of the Invoice entity.
// If the Invoice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InvoiceMutation) OldFilename(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFilename is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFilename requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFilename: %w", err)
	}
	return oldValue.Filename, nil
}

// ClearFilename clears the value of the "filename" field.
func (m *InvoiceMutation) ClearFilename() {
	m.filename = nil
	m.clearedFields[invoice.FieldFilename] = struct{}{}
}

// FilenameCleared returns if the "filename" field was cleared in this mutation.
func (m *InvoiceMutation) FilenameCleared() bool {
	_, ok := m.clearedFields[invoice.FieldFilename]
	return ok
}

// ResetFilename resets all changes to the "filename" field.
func (m *InvoiceMutation) ResetFilename() {
	m.filename = nil
	delete(m.clearedFields, invoice.FieldFilename)
}

// SetSize sets the "size" field.
func (m *InvoiceMutation) SetSize(f float64) {
	m.size = &f
	m.addsize = nil
}

// Size returns the value of the "size" field in the mutation.
func (m *InvoiceMutation) Size() (r float64, exists bool) {
	v := m.size
	if v == nil {
		return
	}
	return *v, true
}

// OldSize returns the old "size" field's value of the Invoice entity.
// If the Invoice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InvoiceMutation) OldSize(ctx context.Context) (v *float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSize is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSize requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSize: %w", err)
	}
	return oldValue.Size, nil
}

// AddSize adds f to the "size" field.
func (m *InvoiceMutation) AddSize(f float64) {
	if m.addsize != nil {
		*m.addsize += f
	} else {
		m.addsize = &f
	}
}

// AddedSize returns the value that was added to the "size" field in this mutation.
func (m *InvoiceMutation) AddedSize() (r float64, exists bool) {
	v := m.addsize
	if v == nil {
		return
	}
	return *v, true
}

// ClearSize clears the value of the "size" field.
func (m *InvoiceMutation) ClearSize() {
	m.size = nil
	m.addsize = nil
	m.clearedFields[invoice.FieldSize] = struct{}{}
}

// SizeCleared returns if the "size" field was cleared in this mutation.
func (m *InvoiceMutation) SizeCleared() bool {
	_, ok := m.clearedFields[invoice.FieldSize]
	return ok
}

// ResetSize resets all changes to the "size" field.
func (m *InvoiceMutation) ResetSize() {
	m.size = nil
	m.addsize = nil
	delete(m.clearedFields, invoice.FieldSize)
}

// SetKeywords sets the "keywords" field.
func (m *InvoiceMutation) SetKeywords(s string) {
	m.keywords = &s
}

// Keywords returns the value of the "keywords" field in the mutation.
func (m *InvoiceMutation) Keywords() (r string, exists bool) {
	v := m.keywords
	if v == nil {
		return
	}
	return *v, true
}

// OldKeywords returns the old "keywords" field's value of the Invoice entity.
// If the Invoice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InvoiceMutation) OldKeywords(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKeywords is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKeywords requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKeywords: %w", err)
	}
	return oldValue.Keywords, nil
}

// ResetKeywords resets all changes to the "keywords" field.
func (m *InvoiceMutation) ResetKeywords() {
	m.keywords = nil
}

// SetCompanyID sets the "company" edge to the Company entity by id.
func (m *InvoiceMutation) SetCompanyID(id int) {
	m.company = &id
}

// ClearCompany clears the "company" edge to the Company entity.
func (m *InvoiceMutation) ClearCompany() {
	m.clearedcompany = true
}

// CompanyCleared reports if the "company" edge to the Company entity was cleared.
func (m *InvoiceMutation) CompanyCleared() bool {
	return m.clearedcompany
}

// CompanyID returns the "company" edge ID in the mutation.
func (m *InvoiceMutation) CompanyID() (id int, exists bool) {
	if m.company != nil {
		return *m.company, true
	}
	return
}

// CompanyIDs returns the "company" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CompanyID instead. It exists only for internal usage by the builders.
func (m *InvoiceMutation) CompanyIDs() (ids []int) {
	if id := m.company; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCompany resets all changes to the "company" edge.
func (m *InvoiceMutation) ResetCompany() {
	m.company = nil
	m.clearedcompany = false
}

// SetIssuedByID sets the "issued_by" edge to the User entity by id.
func (m *InvoiceMutation) SetIssuedByID(id int) {
	m.issued_by = &id
}

// ClearIssuedBy clears the "issued_by" edge to the User entity.
func (m *InvoiceMutation) ClearIssuedBy() {
	m.clearedissued_by = true
}

// IssuedByCleared reports if the "issued_by" edge to the User entity was cleared.
func (m *InvoiceMutation) IssuedByCleared() bool {
	return m.clearedissued_by
}

// IssuedByID returns the "issued_by" edge ID in the mutation.
func (m *InvoiceMutation) IssuedByID() (id int, exists bool) {
	if m.issued_by != nil {
		return *m.issued_by, true
	}
	return
}

// IssuedByIDs returns the "issued_by" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// IssuedByID instead. It exists only for internal usage by the builders.
func (m *InvoiceMutation) IssuedByIDs() (ids []int) {
	if id := m.issued_by; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetIssuedBy resets all changes to the "issued_by" edge.
func (m *InvoiceMutation) ResetIssuedBy() {
	m.issued_by = nil
	m.clearedissued_by = false
}

// SetClientID sets the "client" edge to the Customer entity by id.
func (m *InvoiceMutation) SetClientID(id int) {
	m.client = &id
}

// ClearClient clears the "client" edge to the Customer entity.
func (m *InvoiceMutation) ClearClient() {
	m.clearedclient = true
}

// ClientCleared reports if the "client" edge to the Customer entity was cleared.
func (m *InvoiceMutation) ClientCleared() bool {
	return m.clearedclient
}

// ClientID returns the "client" edge ID in the mutation.
func (m *InvoiceMutation) ClientID() (id int, exists bool) {
	if m.client != nil {
		return *m.client, true
	}
	return
}

// ClientIDs returns the "client" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ClientID instead. It exists only for internal usage by the builders.
func (m *InvoiceMutation) ClientIDs() (ids []int) {
	if id := m.client; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetClient resets all changes to the "client" edge.
func (m *InvoiceMutation) ResetClient() {
	m.client = nil
	m.clearedclient = false
}

// SetReceivableID sets the "receivable" edge to the Receivable entity by id.
func (m *InvoiceMutation) SetReceivableID(id int) {
	m.receivable = &id
}

// ClearReceivable clears the "receivable" edge to the Receivable entity.
func (m *InvoiceMutation) ClearReceivable() {
	m.clearedreceivable = true
}

// ReceivableCleared reports if the "receivable" edge to the Receivable entity was cleared.
func (m *InvoiceMutation) ReceivableCleared() bool {
	return m.clearedreceivable
}

// ReceivableID returns the "receivable" edge ID in the mutation.
func (m *InvoiceMutation) ReceivableID() (id int, exists bool) {
	if m.receivable != nil {
		return *m.receivable, true
	}
	return
}

// ReceivableIDs returns the "receivable" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ReceivableID instead. It exists only for internal usage by the builders.
func (m *InvoiceMutation) ReceivableIDs() (ids []int) {
	if id := m.receivable; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetReceivable resets all changes to the "receivable" edge.
func (m *InvoiceMutation) ResetReceivable() {
	m.receivable = nil
	m.clearedreceivable = false
}

// Where appends a list predicates to the InvoiceMutation builder.
func (m *InvoiceMutation) Where(ps ...predicate.Invoice) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the InvoiceMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *InvoiceMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Invoice, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *InvoiceMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *InvoiceMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Invoice).
func (m *InvoiceMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *InvoiceMutation) Fields() []string {
	fields := make([]string, 0, 36)
	if m.created_at != nil {
		fields = append(fields, invoice.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, invoice.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, invoice.FieldDeletedAt)
	}
	if m.company_logo != nil {
		fields = append(fields, invoice.FieldCompanyLogo)
	}
	if m.company_name != nil {
		fields = append(fields, invoice.FieldCompanyName)
	}
	if m.company_tax_id != nil {
		fields = append(fields, invoice.FieldCompanyTaxID)
	}
	if m.company_address != nil {
		fields = append(fields, invoice.FieldCompanyAddress)
	}
	if m.company_city != nil {
		fields = append(fields, invoice.FieldCompanyCity)
	}
	if m.company_email != nil {
		fields = append(fields, invoice.FieldCompanyEmail)
	}
	if m.company_phone != nil {
		fields = append(fields, invoice.FieldCompanyPhone)
	}
	if m.number != nil {
		fields = append(fields, invoice.FieldNumber)
	}
	if m.issue_date != nil {
		fields = append(fields, invoice.FieldIssueDate)
	}
	if m.due_date != nil {
		fields = append(fields, invoice.FieldDueDate)
	}
	if m.paid_at != nil {
		fields = append(fields, invoice.FieldPaidAt)
	}
	if m.status != nil {
		fields = append(fields, invoice.FieldStatus)
	}
	if m.customer_name != nil {
		fields = append(fields, invoice.FieldCustomerName)
	}
	if m.customer_tax_id != nil {
		fields = append(fields, invoice.FieldCustomerTaxID)
	}
	if m.customer_address != nil {
		fields = append(fields, invoice.FieldCustomerAddress)
	}
	if m.customer_city != nil {
		fields = append(fields, invoice.FieldCustomerCity)
	}
	if m.customer_email != nil {
		fields = append(fields, invoice.FieldCustomerEmail)
	}
	if m.customer_phone != nil {
		fields = append(fields, invoice.FieldCustomerPhone)
	}
	if m.items != nil {
		fields = append(fields, invoice.FieldItems)
	}
	if m.subtotal != nil {
		fields = append(fields, invoice.FieldSubtotal)
	}
	if m.tax != nil {
		fields = append(fields, invoice.FieldTax)
	}
	if m.total != nil {
		fields = append(fields, invoice.FieldTotal)
	}
	if m.notes != nil {
		fields = append(fields, invoice.FieldNotes)
	}
	if m.payment_method != nil {
		fields = append(fields, invoice.FieldPaymentMethod)
	}
	if m.bank_name != nil {
		fields = append(fields, invoice.FieldBankName)
	}
	if m.bank_agency != nil {
		fields = append(fields, invoice.FieldBankAgency)
	}
	if m.bank_account_number != nil {
		fields = append(fields, invoice.FieldBankAccountNumber)
	}
	if m.bank_account_name != nil {
		fields = append(fields, invoice.FieldBankAccountName)
	}
	if m.storage_URI != nil {
		fields = append(fields, invoice.FieldStorageURI)
	}
	if m._URL != nil {
		fields = append(fields, invoice.FieldURL)
	}
	if m.filename != nil {
		fields = append(fields, invoice.FieldFilename)
	}
	if m.size != nil {
		fields = append(fields, invoice.FieldSize)
	}
	if m.keywords != nil {
		fields = append(fields, invoice.FieldKeywords)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *InvoiceMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case invoice.FieldCreatedAt:
		return m.CreatedAt()
	case invoice.FieldUpdatedAt:
		return m.UpdatedAt()
	case invoice.FieldDeletedAt:
		return m.DeletedAt()
	case invoice.FieldCompanyLogo:
		return m.CompanyLogo()
	case invoice.FieldCompanyName:
		return m.CompanyName()
	case invoice.FieldCompanyTaxID:
		return m.CompanyTaxID()
	case invoice.FieldCompanyAddress:
		return m.CompanyAddress()
	case invoice.FieldCompanyCity:
		return m.CompanyCity()
	case invoice.FieldCompanyEmail:
		return m.CompanyEmail()
	case invoice.FieldCompanyPhone:
		return m.CompanyPhone()
	case invoice.FieldNumber:
		return m.Number()
	case invoice.FieldIssueDate:
		return m.IssueDate()
	case invoice.FieldDueDate:
		return m.DueDate()
	case invoice.FieldPaidAt:
		return m.PaidAt()
	case invoice.FieldStatus:
		return m.Status()
	case invoice.FieldCustomerName:
		return m.CustomerName()
	case invoice.FieldCustomerTaxID:
		return m.CustomerTaxID()
	case invoice.FieldCustomerAddress:
		return m.CustomerAddress()
	case invoice.FieldCustomerCity:
		return m.CustomerCity()
	case invoice.FieldCustomerEmail:
		return m.CustomerEmail()
	case invoice.FieldCustomerPhone:
		return m.CustomerPhone()
	case invoice.FieldItems:
		return m.Items()
	case invoice.FieldSubtotal:
		return m.Subtotal()
	case invoice.FieldTax:
		return m.Tax()
	case invoice.FieldTotal:
		return m.Total()
	case invoice.FieldNotes:
		return m.Notes()
	case invoice.FieldPaymentMethod:
		return m.PaymentMethod()
	case invoice.FieldBankName:
		return m.BankName()
	case invoice.FieldBankAgency:
		return m.BankAgency()
	case invoice.FieldBankAccountNumber:
		return m.BankAccountNumber()
	case invoice.FieldBankAccountName:
		return m.BankAccountName()
	case invoice.FieldStorageURI:
		return m.StorageURI()
	case invoice.FieldURL:
		return m.URL()
	case invoice.FieldFilename:
		return m.Filename()
	case invoice.FieldSize:
		return m.Size()
	case invoice.FieldKeywords:
		return m.Keywords()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *InvoiceMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case invoice.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case invoice.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case invoice.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case invoice.FieldCompanyLogo:
		return m.OldCompanyLogo(ctx)
	case invoice.FieldCompanyName:
		return m.OldCompanyName(ctx)
	case invoice.FieldCompanyTaxID:
		return m.OldCompanyTaxID(ctx)
	case invoice.FieldCompanyAddress:
		return m.OldCompanyAddress(ctx)
	case invoice.FieldCompanyCity:
		return m.OldCompanyCity(ctx)
	case invoice.FieldCompanyEmail:
		return m.OldCompanyEmail(ctx)
	case invoice.FieldCompanyPhone:
		return m.OldCompanyPhone(ctx)
	case invoice.FieldNumber:
		return m.OldNumber(ctx)
	case invoice.FieldIssueDate:
		return m.OldIssueDate(ctx)
	case invoice.FieldDueDate:
		return m.OldDueDate(ctx)
	case invoice.FieldPaidAt:
		return m.OldPaidAt(ctx)
	case invoice.FieldStatus:
		return m.OldStatus(ctx)
	case invoice.FieldCustomerName:
		return m.OldCustomerName(ctx)
	case invoice.FieldCustomerTaxID:
		return m.OldCustomerTaxID(ctx)
	case invoice.FieldCustomerAddress:
		return m.OldCustomerAddress(ctx)
	case invoice.FieldCustomerCity:
		return m.OldCustomerCity(ctx)
	case invoice.FieldCustomerEmail:
		return m.OldCustomerEmail(ctx)
	case invoice.FieldCustomerPhone:
		return m.OldCustomerPhone(ctx)
	case invoice.FieldItems:
		return m.OldItems(ctx)
	case invoice.FieldSubtotal:
		return m.OldSubtotal(ctx)
	case invoice.FieldTax:
		return m.OldTax(ctx)
	case invoice.FieldTotal:
		return m.OldTotal(ctx)
	case invoice.FieldNotes:
		return m.OldNotes(ctx)
	case invoice.FieldPaymentMethod:
		return m.OldPaymentMethod(ctx)
	case invoice.FieldBankName:
		return m.OldBankName(ctx)
	case invoice.FieldBankAgency:
		return m.OldBankAgency(ctx)
	case invoice.FieldBankAccountNumber:
		return m.OldBankAccountNumber(ctx)
	case invoice.FieldBankAccountName:
		return m.OldBankAccountName(ctx)
	case invoice.FieldStorageURI:
		return m.OldStorageURI(ctx)
	case invoice.FieldURL:
		return m.OldURL(ctx)
	case invoice.FieldFilename:
		return m.OldFilename(ctx)
	case invoice.FieldSize:
		return m.OldSize(ctx)
	case invoice.FieldKeywords:
		return m.OldKeywords(ctx)
	}
	return nil, fmt.Errorf("unknown Invoice field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *InvoiceMutation) SetField(name string, value ent.Value) error {
	switch name {
	case invoice.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case invoice.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case invoice.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case invoice.FieldCompanyLogo:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCompanyLogo(v)
		return nil
	case invoice.FieldCompanyName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCompanyName(v)
		return nil
	case invoice.FieldCompanyTaxID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCompanyTaxID(v)
		return nil
	case invoice.FieldCompanyAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCompanyAddress(v)
		return nil
	case invoice.FieldCompanyCity:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCompanyCity(v)
		return nil
	case invoice.FieldCompanyEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCompanyEmail(v)
		return nil
	case invoice.FieldCompanyPhone:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCompanyPhone(v)
		return nil
	case invoice.FieldNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNumber(v)
		return nil
	case invoice.FieldIssueDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIssueDate(v)
		return nil
	case invoice.FieldDueDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDueDate(v)
		return nil
	case invoice.FieldPaidAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPaidAt(v)
		return nil
	case invoice.FieldStatus:
		v, ok := value.(invoice.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case invoice.FieldCustomerName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCustomerName(v)
		return nil
	case invoice.FieldCustomerTaxID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCustomerTaxID(v)
		return nil
	case invoice.FieldCustomerAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCustomerAddress(v)
		return nil
	case invoice.FieldCustomerCity:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCustomerCity(v)
		return nil
	case invoice.FieldCustomerEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCustomerEmail(v)
		return nil
	case invoice.FieldCustomerPhone:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCustomerPhone(v)
		return nil
	case invoice.FieldItems:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetItems(v)
		return nil
	case invoice.FieldSubtotal:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSubtotal(v)
		return nil
	case invoice.FieldTax:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTax(v)
		return nil
	case invoice.FieldTotal:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTotal(v)
		return nil
	case invoice.FieldNotes:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNotes(v)
		return nil
	case invoice.FieldPaymentMethod:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPaymentMethod(v)
		return nil
	case invoice.FieldBankName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBankName(v)
		return nil
	case invoice.FieldBankAgency:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBankAgency(v)
		return nil
	case invoice.FieldBankAccountNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBankAccountNumber(v)
		return nil
	case invoice.FieldBankAccountName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBankAccountName(v)
		return nil
	case invoice.FieldStorageURI:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStorageURI(v)
		return nil
	case invoice.FieldURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetURL(v)
		return nil
	case invoice.FieldFilename:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFilename(v)
		return nil
	case invoice.FieldSize:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSize(v)
		return nil
	case invoice.FieldKeywords:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKeywords(v)
		return nil
	}
	return fmt.Errorf("unknown Invoice field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *InvoiceMutation) AddedFields() []string {
	var fields []string
	if m.addsubtotal != nil {
		fields = append(fields, invoice.FieldSubtotal)
	}
	if m.addtax != nil {
		fields = append(fields, invoice.FieldTax)
	}
	if m.addtotal != nil {
		fields = append(fields, invoice.FieldTotal)
	}
	if m.addsize != nil {
		fields = append(fields, invoice.FieldSize)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *InvoiceMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case invoice.FieldSubtotal:
		return m.AddedSubtotal()
	case invoice.FieldTax:
		return m.AddedTax()
	case invoice.FieldTotal:
		return m.AddedTotal()
	case invoice.FieldSize:
		return m.AddedSize()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *InvoiceMutation) AddField(name string, value ent.Value) error {
	switch name {
	case invoice.FieldSubtotal:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSubtotal(v)
		return nil
	case invoice.FieldTax:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTax(v)
		return nil
	case invoice.FieldTotal:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTotal(v)
		return nil
	case invoice.FieldSize:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSize(v)
		return nil
	}
	return fmt.Errorf("unknown Invoice numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *InvoiceMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(invoice.FieldDeletedAt) {
		fields = append(fields, invoice.FieldDeletedAt)
	}
	if m.FieldCleared(invoice.FieldCompanyLogo) {
		fields = append(fields, invoice.FieldCompanyLogo)
	}
	if m.FieldCleared(invoice.FieldCompanyTaxID) {
		fields = append(fields, invoice.FieldCompanyTaxID)
	}
	if m.FieldCleared(invoice.FieldCompanyEmail) {
		fields = append(fields, invoice.FieldCompanyEmail)
	}
	if m.FieldCleared(invoice.FieldCompanyPhone) {
		fields = append(fields, invoice.FieldCompanyPhone)
	}
	if m.FieldCleared(invoice.FieldNumber) {
		fields = append(fields, invoice.FieldNumber)
	}
	if m.FieldCleared(invoice.FieldPaidAt) {
		fields = append(fields, invoice.FieldPaidAt)
	}
	if m.FieldCleared(invoice.FieldCustomerName) {
		fields = append(fields, invoice.FieldCustomerName)
	}
	if m.FieldCleared(invoice.FieldCustomerTaxID) {
		fields = append(fields, invoice.FieldCustomerTaxID)
	}
	if m.FieldCleared(invoice.FieldCustomerAddress) {
		fields = append(fields, invoice.FieldCustomerAddress)
	}
	if m.FieldCleared(invoice.FieldCustomerCity) {
		fields = append(fields, invoice.FieldCustomerCity)
	}
	if m.FieldCleared(invoice.FieldCustomerEmail) {
		fields = append(fields, invoice.FieldCustomerEmail)
	}
	if m.FieldCleared(invoice.FieldCustomerPhone) {
		fields = append(fields, invoice.FieldCustomerPhone)
	}
	if m.FieldCleared(invoice.FieldNotes) {
		fields = append(fields, invoice.FieldNotes)
	}
	if m.FieldCleared(invoice.FieldPaymentMethod) {
		fields = append(fields, invoice.FieldPaymentMethod)
	}
	if m.FieldCleared(invoice.FieldBankName) {
		fields = append(fields, invoice.FieldBankName)
	}
	if m.FieldCleared(invoice.FieldBankAgency) {
		fields = append(fields, invoice.FieldBankAgency)
	}
	if m.FieldCleared(invoice.FieldBankAccountNumber) {
		fields = append(fields, invoice.FieldBankAccountNumber)
	}
	if m.FieldCleared(invoice.FieldBankAccountName) {
		fields = append(fields, invoice.FieldBankAccountName)
	}
	if m.FieldCleared(invoice.FieldStorageURI) {
		fields = append(fields, invoice.FieldStorageURI)
	}
	if m.FieldCleared(invoice.FieldURL) {
		fields = append(fields, invoice.FieldURL)
	}
	if m.FieldCleared(invoice.FieldFilename) {
		fields = append(fields, invoice.FieldFilename)
	}
	if m.FieldCleared(invoice.FieldSize) {
		fields = append(fields, invoice.FieldSize)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *InvoiceMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *InvoiceMutation) ClearField(name string) error {
	switch name {
	case invoice.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case invoice.FieldCompanyLogo:
		m.ClearCompanyLogo()
		return nil
	case invoice.FieldCompanyTaxID:
		m.ClearCompanyTaxID()
		return nil
	case invoice.FieldCompanyEmail:
		m.ClearCompanyEmail()
		return nil
	case invoice.FieldCompanyPhone:
		m.ClearCompanyPhone()
		return nil
	case invoice.FieldNumber:
		m.ClearNumber()
		return nil
	case invoice.FieldPaidAt:
		m.ClearPaidAt()
		return nil
	case invoice.FieldCustomerName:
		m.ClearCustomerName()
		return nil
	case invoice.FieldCustomerTaxID:
		m.ClearCustomerTaxID()
		return nil
	case invoice.FieldCustomerAddress:
		m.ClearCustomerAddress()
		return nil
	case invoice.FieldCustomerCity:
		m.ClearCustomerCity()
		return nil
	case invoice.FieldCustomerEmail:
		m.ClearCustomerEmail()
		return nil
	case invoice.FieldCustomerPhone:
		m.ClearCustomerPhone()
		return nil
	case invoice.FieldNotes:
		m.ClearNotes()
		return nil
	case invoice.FieldPaymentMethod:
		m.ClearPaymentMethod()
		return nil
	case invoice.FieldBankName:
		m.ClearBankName()
		return nil
	case invoice.FieldBankAgency:
		m.ClearBankAgency()
		return nil
	case invoice.FieldBankAccountNumber:
		m.ClearBankAccountNumber()
		return nil
	case invoice.FieldBankAccountName:
		m.ClearBankAccountName()
		return nil
	case invoice.FieldStorageURI:
		m.ClearStorageURI()
		return nil
	case invoice.FieldURL:
		m.ClearURL()
		return nil
	case invoice.FieldFilename:
		m.ClearFilename()
		return nil
	case invoice.FieldSize:
		m.ClearSize()
		return nil
	}
	return fmt.Errorf("unknown Invoice nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *InvoiceMutation) ResetField(name string) error {
	switch name {
	case invoice.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case invoice.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case invoice.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case invoice.FieldCompanyLogo:
		m.ResetCompanyLogo()
		return nil
	case invoice.FieldCompanyName:
		m.ResetCompanyName()
		return nil
	case invoice.FieldCompanyTaxID:
		m.ResetCompanyTaxID()
		return nil
	case invoice.FieldCompanyAddress:
		m.ResetCompanyAddress()
		return nil
	case invoice.FieldCompanyCity:
		m.ResetCompanyCity()
		return nil
	case invoice.FieldCompanyEmail:
		m.ResetCompanyEmail()
		return nil
	case invoice.FieldCompanyPhone:
		m.ResetCompanyPhone()
		return nil
	case invoice.FieldNumber:
		m.ResetNumber()
		return nil
	case invoice.FieldIssueDate:
		m.ResetIssueDate()
		return nil
	case invoice.FieldDueDate:
		m.ResetDueDate()
		return nil
	case invoice.FieldPaidAt:
		m.ResetPaidAt()
		return nil
	case invoice.FieldStatus:
		m.ResetStatus()
		return nil
	case invoice.FieldCustomerName:
		m.ResetCustomerName()
		return nil
	case invoice.FieldCustomerTaxID:
		m.ResetCustomerTaxID()
		return nil
	case invoice.FieldCustomerAddress:
		m.ResetCustomerAddress()
		return nil
	case invoice.FieldCustomerCity:
		m.ResetCustomerCity()
		return nil
	case invoice.FieldCustomerEmail:
		m.ResetCustomerEmail()
		return nil
	case invoice.FieldCustomerPhone:
		m.ResetCustomerPhone()
		return nil
	case invoice.FieldItems:
		m.ResetItems()
		return nil
	case invoice.FieldSubtotal:
		m.ResetSubtotal()
		return nil
	case invoice.FieldTax:
		m.ResetTax()
		return nil
	case invoice.FieldTotal:
		m.ResetTotal()
		return nil
	case invoice.FieldNotes:
		m.ResetNotes()
		return nil
	case invoice.FieldPaymentMethod:
		m.ResetPaymentMethod()
		return nil
	case invoice.FieldBankName:
		m.ResetBankName()
		return nil
	case invoice.FieldBankAgency:
		m.ResetBankAgency()
		return nil
	case invoice.FieldBankAccountNumber:
		m.ResetBankAccountNumber()
		return nil
	case invoice.FieldBankAccountName:
		m.ResetBankAccountName()
		return nil
	case invoice.FieldStorageURI:
		m.ResetStorageURI()
		return nil
	case invoice.FieldURL:
		m.ResetURL()
		return nil
	case invoice.FieldFilename:
		m.ResetFilename()
		return nil
	case invoice.FieldSize:
		m.ResetSize()
		return nil
	case invoice.FieldKeywords:
		m.ResetKeywords()
		return nil
	}
	return fmt.Errorf("unknown Invoice field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *InvoiceMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.company != nil {
		edges = append(edges, invoice.EdgeCompany)
	}
	if m.issued_by != nil {
		edges = append(edges, invoice.EdgeIssuedBy)
	}
	if m.client != nil {
		edges = append(edges, invoice.EdgeClient)
	}
	if m.receivable != nil {
		edges = append(edges, invoice.EdgeReceivable)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *InvoiceMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case invoice.EdgeCompany:
		if id := m.company; id != nil {
			return []ent.Value{*id}
		}
	case invoice.EdgeIssuedBy:
		if id := m.issued_by; id != nil {
			return []ent.Value{*id}
		}
	case invoice.EdgeClient:
		if id := m.client; id != nil {
			return []ent.Value{*id}
		}
	case invoice.EdgeReceivable:
		if id := m.receivable; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *InvoiceMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *InvoiceMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *InvoiceMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedcompany {
		edges = append(edges, invoice.EdgeCompany)
	}
	if m.clearedissued_by {
		edges = append(edges, invoice.EdgeIssuedBy)
	}
	if m.clearedclient {
		edges = append(edges, invoice.EdgeClient)
	}
	if m.clearedreceivable {
		edges = append(edges, invoice.EdgeReceivable)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *InvoiceMutation) EdgeCleared(name string) bool {
	switch name {
	case invoice.EdgeCompany:
		return m.clearedcompany
	case invoice.EdgeIssuedBy:
		return m.clearedissued_by
	case invoice.EdgeClient:
		return m.clearedclient
	case invoice.EdgeReceivable:
		return m.clearedreceivable
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *InvoiceMutation) ClearEdge(name string) error {
	switch name {
	case invoice.EdgeCompany:
		m.ClearCompany()
		return nil
	case invoice.EdgeIssuedBy:
		m.ClearIssuedBy()
		return nil
	case invoice.EdgeClient:
		m.ClearClient()
		return nil
	case invoice.EdgeReceivable:
		m.ClearReceivable()
		return nil
	}
	return fmt.Errorf("unknown Invoice unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *InvoiceMutation) ResetEdge(name string) error {
	switch name {
	case invoice.EdgeCompany:
		m.ResetCompany()
		return nil
	case invoice.EdgeIssuedBy:
		m.ResetIssuedBy()
		return nil
	case invoice.EdgeClient:
		m.ResetClient()
		return nil
	case invoice.EdgeReceivable:
		m.ResetReceivable()
		return nil
	}
	return fmt.Errorf("unknown Invoice edge %s", name)
}

// LoanMutation represents an operation that mutates the Loan nodes in the graph.
type LoanMutation struct {
	config
	op                         Op
	typ                        string
	id                         *int
	created_at                 *time.Time
	updated_at                 *time.Time
	deleted_at                 *time.Time
	is_lending                 *bool
	amount                     *float64
	addamount                  *float64
	category                   *loan.Category
	collateral                 *string
	description                *string
	interest_rate              *float64
	addinterest_rate           *float64
	installments               *int
	addinstallments            *int
	maturity_date              *time.Time
	next_payment_date          *time.Time
	next_payment_amount        *float64
	addnext_payment_amount     *float64
	outstanding_balance        *float64
	addoutstanding_balance     *float64
	payment_frequency          *loan.PaymentFrequency
	paid_installments          *int
	addpaid_installments       *int
	payment_type               *loan.PaymentType
	counterparty_name          *string
	start_date                 *time.Time
	status                     *loan.Status
	clearedFields              map[string]struct{}
	client                     *int
	clearedclient              bool
	supplier                   *int
	clearedsupplier            bool
	company                    *int
	clearedcompany             bool
	loan_schedule              map[int]struct{}
	removedloan_schedule       map[int]struct{}
	clearedloan_schedule       bool
	transaction_history        map[int]struct{}
	removedtransaction_history map[int]struct{}
	clearedtransaction_history bool
	done                       bool
	oldValue                   func(context.Context) (*Loan, error)
	predicates                 []predicate.Loan
}

var _ ent.Mutation = (*LoanMutation)(nil)

// loanOption allows management of the mutation configuration using functional options.
type loanOption func(*LoanMutation)

// newLoanMutation creates new mutation for the Loan entity.
func newLoanMutation(c config, op Op, opts ...loanOption) *LoanMutation {
	m := &LoanMutation{
		config:        c,
		op:            op,
		typ:           TypeLoan,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withLoanID sets the ID field of the mutation.
func withLoanID(id int) loanOption {
	return func(m *LoanMutation) {
		var (
			err   error
			once  sync.Once
			value *Loan
		)
		m.oldValue = func(ctx context.Context) (*Loan, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Loan.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withLoan sets the old Loan of the mutation.
func withLoan(node *Loan) loanOption {
	return func(m *LoanMutation) {
		m.oldValue = func(context.Context) (*Loan, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m LoanMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m LoanMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("generated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *LoanMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *LoanMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Loan.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *LoanMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *LoanMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Loan entity.
// If the Loan object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LoanMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *LoanMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *LoanMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *LoanMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Loan entity.
// If the Loan object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LoanMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *LoanMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *LoanMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *LoanMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Loan entity.
// If the Loan object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LoanMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *LoanMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[loan.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *LoanMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[loan.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *LoanMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, loan.FieldDeletedAt)
}

// SetIsLending sets the "is_lending" field.
func (m *LoanMutation) SetIsLending(b bool) {
	m.is_lending = &b
}

// IsLending returns the value of the "is_lending" field in the mutation.
func (m *LoanMutation) IsLending() (r bool, exists bool) {
	v := m.is_lending
	if v == nil {
		return
	}
	return *v, true
}

// OldIsLending returns the old "is_lending" field's value of the Loan entity.
// If the Loan object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LoanMutation) OldIsLending(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsLending is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsLending requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsLending: %w", err)
	}
	return oldValue.IsLending, nil
}

// ResetIsLending resets all changes to the "is_lending" field.
func (m *LoanMutation) ResetIsLending() {
	m.is_lending = nil
}

// SetAmount sets the "amount" field.
func (m *LoanMutation) SetAmount(f float64) {
	m.amount = &f
	m.addamount = nil
}

// Amount returns the value of the "amount" field in the mutation.
func (m *LoanMutation) Amount() (r float64, exists bool) {
	v := m.amount
	if v == nil {
		return
	}
	return *v, true
}

// OldAmount returns the old "amount" field's value of the Loan entity.
// If the Loan object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LoanMutation) OldAmount(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAmount: %w", err)
	}
	return oldValue.Amount, nil
}

// AddAmount adds f to the "amount" field.
func (m *LoanMutation) AddAmount(f float64) {
	if m.addamount != nil {
		*m.addamount += f
	} else {
		m.addamount = &f
	}
}

// AddedAmount returns the value that was added to the "amount" field in this mutation.
func (m *LoanMutation) AddedAmount() (r float64, exists bool) {
	v := m.addamount
	if v == nil {
		return
	}
	return *v, true
}

// ResetAmount resets all changes to the "amount" field.
func (m *LoanMutation) ResetAmount() {
	m.amount = nil
	m.addamount = nil
}

// SetCategory sets the "category" field.
func (m *LoanMutation) SetCategory(l loan.Category) {
	m.category = &l
}

// Category returns the value of the "category" field in the mutation.
func (m *LoanMutation) Category() (r loan.Category, exists bool) {
	v := m.category
	if v == nil {
		return
	}
	return *v, true
}

// OldCategory returns the old "category" field's value of the Loan entity.
// If the Loan object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LoanMutation) OldCategory(ctx context.Context) (v loan.Category, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCategory is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCategory requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCategory: %w", err)
	}
	return oldValue.Category, nil
}

// ResetCategory resets all changes to the "category" field.
func (m *LoanMutation) ResetCategory() {
	m.category = nil
}

// SetCollateral sets the "collateral" field.
func (m *LoanMutation) SetCollateral(s string) {
	m.collateral = &s
}

// Collateral returns the value of the "collateral" field in the mutation.
func (m *LoanMutation) Collateral() (r string, exists bool) {
	v := m.collateral
	if v == nil {
		return
	}
	return *v, true
}

// OldCollateral returns the old "collateral" field's value of the Loan entity.
// If the Loan object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LoanMutation) OldCollateral(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCollateral is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCollateral requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCollateral: %w", err)
	}
	return oldValue.Collateral, nil
}

// ClearCollateral clears the value of the "collateral" field.
func (m *LoanMutation) ClearCollateral() {
	m.collateral = nil
	m.clearedFields[loan.FieldCollateral] = struct{}{}
}

// CollateralCleared returns if the "collateral" field was cleared in this mutation.
func (m *LoanMutation) CollateralCleared() bool {
	_, ok := m.clearedFields[loan.FieldCollateral]
	return ok
}

// ResetCollateral resets all changes to the "collateral" field.
func (m *LoanMutation) ResetCollateral() {
	m.collateral = nil
	delete(m.clearedFields, loan.FieldCollateral)
}

// SetDescription sets the "description" field.
func (m *LoanMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *LoanMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Loan entity.
// If the Loan object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LoanMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *LoanMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[loan.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *LoanMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[loan.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *LoanMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, loan.FieldDescription)
}

// SetInterestRate sets the "interest_rate" field.
func (m *LoanMutation) SetInterestRate(f float64) {
	m.interest_rate = &f
	m.addinterest_rate = nil
}

// InterestRate returns the value of the "interest_rate" field in the mutation.
func (m *LoanMutation) InterestRate() (r float64, exists bool) {
	v := m.interest_rate
	if v == nil {
		return
	}
	return *v, true
}

// OldInterestRate returns the old "interest_rate" field's value of the Loan entity.
// If the Loan object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LoanMutation) OldInterestRate(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInterestRate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInterestRate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInterestRate: %w", err)
	}
	return oldValue.InterestRate, nil
}

// AddInterestRate adds f to the "interest_rate" field.
func (m *LoanMutation) AddInterestRate(f float64) {
	if m.addinterest_rate != nil {
		*m.addinterest_rate += f
	} else {
		m.addinterest_rate = &f
	}
}

// AddedInterestRate returns the value that was added to the "interest_rate" field in this mutation.
func (m *LoanMutation) AddedInterestRate() (r float64, exists bool) {
	v := m.addinterest_rate
	if v == nil {
		return
	}
	return *v, true
}

// ResetInterestRate resets all changes to the "interest_rate" field.
func (m *LoanMutation) ResetInterestRate() {
	m.interest_rate = nil
	m.addinterest_rate = nil
}

// SetInstallments sets the "installments" field.
func (m *LoanMutation) SetInstallments(i int) {
	m.installments = &i
	m.addinstallments = nil
}

// Installments returns the value of the "installments" field in the mutation.
func (m *LoanMutation) Installments() (r int, exists bool) {
	v := m.installments
	if v == nil {
		return
	}
	return *v, true
}

// OldInstallments returns the old "installments" field's value of the Loan entity.
// If the Loan object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LoanMutation) OldInstallments(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInstallments is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInstallments requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInstallments: %w", err)
	}
	return oldValue.Installments, nil
}

// AddInstallments adds i to the "installments" field.
func (m *LoanMutation) AddInstallments(i int) {
	if m.addinstallments != nil {
		*m.addinstallments += i
	} else {
		m.addinstallments = &i
	}
}

// AddedInstallments returns the value that was added to the "installments" field in this mutation.
func (m *LoanMutation) AddedInstallments() (r int, exists bool) {
	v := m.addinstallments
	if v == nil {
		return
	}
	return *v, true
}

// ResetInstallments resets all changes to the "installments" field.
func (m *LoanMutation) ResetInstallments() {
	m.installments = nil
	m.addinstallments = nil
}

// SetMaturityDate sets the "maturity_date" field.
func (m *LoanMutation) SetMaturityDate(t time.Time) {
	m.maturity_date = &t
}

// MaturityDate returns the value of the "maturity_date" field in the mutation.
func (m *LoanMutation) MaturityDate() (r time.Time, exists bool) {
	v := m.maturity_date
	if v == nil {
		return
	}
	return *v, true
}

// OldMaturityDate returns the old "maturity_date" field's value of the Loan entity.
// If the Loan object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LoanMutation) OldMaturityDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMaturityDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMaturityDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMaturityDate: %w", err)
	}
	return oldValue.MaturityDate, nil
}

// ResetMaturityDate resets all changes to the "maturity_date" field.
func (m *LoanMutation) ResetMaturityDate() {
	m.maturity_date = nil
}

// SetNextPaymentDate sets the "next_payment_date" field.
func (m *LoanMutation) SetNextPaymentDate(t time.Time) {
	m.next_payment_date = &t
}

// NextPaymentDate returns the value of the "next_payment_date" field in the mutation.
func (m *LoanMutation) NextPaymentDate() (r time.Time, exists bool) {
	v := m.next_payment_date
	if v == nil {
		return
	}
	return *v, true
}

// OldNextPaymentDate returns the old "next_payment_date" field's value of the Loan entity.
// If the Loan object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LoanMutation) OldNextPaymentDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNextPaymentDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNextPaymentDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNextPaymentDate: %w", err)
	}
	return oldValue.NextPaymentDate, nil
}

// ClearNextPaymentDate clears the value of the "next_payment_date" field.
func (m *LoanMutation) ClearNextPaymentDate() {
	m.next_payment_date = nil
	m.clearedFields[loan.FieldNextPaymentDate] = struct{}{}
}

// NextPaymentDateCleared returns if the "next_payment_date" field was cleared in this mutation.
func (m *LoanMutation) NextPaymentDateCleared() bool {
	_, ok := m.clearedFields[loan.FieldNextPaymentDate]
	return ok
}

// ResetNextPaymentDate resets all changes to the "next_payment_date" field.
func (m *LoanMutation) ResetNextPaymentDate() {
	m.next_payment_date = nil
	delete(m.clearedFields, loan.FieldNextPaymentDate)
}

// SetNextPaymentAmount sets the "next_payment_amount" field.
func (m *LoanMutation) SetNextPaymentAmount(f float64) {
	m.next_payment_amount = &f
	m.addnext_payment_amount = nil
}

// NextPaymentAmount returns the value of the "next_payment_amount" field in the mutation.
func (m *LoanMutation) NextPaymentAmount() (r float64, exists bool) {
	v := m.next_payment_amount
	if v == nil {
		return
	}
	return *v, true
}

// OldNextPaymentAmount returns the old "next_payment_amount" field's value of the Loan entity.
// If the Loan object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LoanMutation) OldNextPaymentAmount(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNextPaymentAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNextPaymentAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNextPaymentAmount: %w", err)
	}
	return oldValue.NextPaymentAmount, nil
}

// AddNextPaymentAmount adds f to the "next_payment_amount" field.
func (m *LoanMutation) AddNextPaymentAmount(f float64) {
	if m.addnext_payment_amount != nil {
		*m.addnext_payment_amount += f
	} else {
		m.addnext_payment_amount = &f
	}
}

// AddedNextPaymentAmount returns the value that was added to the "next_payment_amount" field in this mutation.
func (m *LoanMutation) AddedNextPaymentAmount() (r float64, exists bool) {
	v := m.addnext_payment_amount
	if v == nil {
		return
	}
	return *v, true
}

// ClearNextPaymentAmount clears the value of the "next_payment_amount" field.
func (m *LoanMutation) ClearNextPaymentAmount() {
	m.next_payment_amount = nil
	m.addnext_payment_amount = nil
	m.clearedFields[loan.FieldNextPaymentAmount] = struct{}{}
}

// NextPaymentAmountCleared returns if the "next_payment_amount" field was cleared in this mutation.
func (m *LoanMutation) NextPaymentAmountCleared() bool {
	_, ok := m.clearedFields[loan.FieldNextPaymentAmount]
	return ok
}

// ResetNextPaymentAmount resets all changes to the "next_payment_amount" field.
func (m *LoanMutation) ResetNextPaymentAmount() {
	m.next_payment_amount = nil
	m.addnext_payment_amount = nil
	delete(m.clearedFields, loan.FieldNextPaymentAmount)
}

// SetOutstandingBalance sets the "outstanding_balance" field.
func (m *LoanMutation) SetOutstandingBalance(f float64) {
	m.outstanding_balance = &f
	m.addoutstanding_balance = nil
}

// OutstandingBalance returns the value of the "outstanding_balance" field in the mutation.
func (m *LoanMutation) OutstandingBalance() (r float64, exists bool) {
	v := m.outstanding_balance
	if v == nil {
		return
	}
	return *v, true
}

// OldOutstandingBalance returns the old "outstanding_balance" field's value of the Loan entity.
// If the Loan object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LoanMutation) OldOutstandingBalance(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOutstandingBalance is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOutstandingBalance requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOutstandingBalance: %w", err)
	}
	return oldValue.OutstandingBalance, nil
}

// AddOutstandingBalance adds f to the "outstanding_balance" field.
func (m *LoanMutation) AddOutstandingBalance(f float64) {
	if m.addoutstanding_balance != nil {
		*m.addoutstanding_balance += f
	} else {
		m.addoutstanding_balance = &f
	}
}

// AddedOutstandingBalance returns the value that was added to the "outstanding_balance" field in this mutation.
func (m *LoanMutation) AddedOutstandingBalance() (r float64, exists bool) {
	v := m.addoutstanding_balance
	if v == nil {
		return
	}
	return *v, true
}

// ResetOutstandingBalance resets all changes to the "outstanding_balance" field.
func (m *LoanMutation) ResetOutstandingBalance() {
	m.outstanding_balance = nil
	m.addoutstanding_balance = nil
}

// SetPaymentFrequency sets the "payment_frequency" field.
func (m *LoanMutation) SetPaymentFrequency(lf loan.PaymentFrequency) {
	m.payment_frequency = &lf
}

// PaymentFrequency returns the value of the "payment_frequency" field in the mutation.
func (m *LoanMutation) PaymentFrequency() (r loan.PaymentFrequency, exists bool) {
	v := m.payment_frequency
	if v == nil {
		return
	}
	return *v, true
}

// OldPaymentFrequency returns the old "payment_frequency" field's value of the Loan entity.
// If the Loan object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LoanMutation) OldPaymentFrequency(ctx context.Context) (v loan.PaymentFrequency, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPaymentFrequency is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPaymentFrequency requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPaymentFrequency: %w", err)
	}
	return oldValue.PaymentFrequency, nil
}

// ResetPaymentFrequency resets all changes to the "payment_frequency" field.
func (m *LoanMutation) ResetPaymentFrequency() {
	m.payment_frequency = nil
}

// SetPaidInstallments sets the "paid_installments" field.
func (m *LoanMutation) SetPaidInstallments(i int) {
	m.paid_installments = &i
	m.addpaid_installments = nil
}

// PaidInstallments returns the value of the "paid_installments" field in the mutation.
func (m *LoanMutation) PaidInstallments() (r int, exists bool) {
	v := m.paid_installments
	if v == nil {
		return
	}
	return *v, true
}

// OldPaidInstallments returns the old "paid_installments" field's value of the Loan entity.
// If the Loan object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LoanMutation) OldPaidInstallments(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPaidInstallments is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPaidInstallments requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPaidInstallments: %w", err)
	}
	return oldValue.PaidInstallments, nil
}

// AddPaidInstallments adds i to the "paid_installments" field.
func (m *LoanMutation) AddPaidInstallments(i int) {
	if m.addpaid_installments != nil {
		*m.addpaid_installments += i
	} else {
		m.addpaid_installments = &i
	}
}

// AddedPaidInstallments returns the value that was added to the "paid_installments" field in this mutation.
func (m *LoanMutation) AddedPaidInstallments() (r int, exists bool) {
	v := m.addpaid_installments
	if v == nil {
		return
	}
	return *v, true
}

// ResetPaidInstallments resets all changes to the "paid_installments" field.
func (m *LoanMutation) ResetPaidInstallments() {
	m.paid_installments = nil
	m.addpaid_installments = nil
}

// SetPaymentType sets the "payment_type" field.
func (m *LoanMutation) SetPaymentType(lt loan.PaymentType) {
	m.payment_type = &lt
}

// PaymentType returns the value of the "payment_type" field in the mutation.
func (m *LoanMutation) PaymentType() (r loan.PaymentType, exists bool) {
	v := m.payment_type
	if v == nil {
		return
	}
	return *v, true
}

// OldPaymentType returns the old "payment_type" field's value of the Loan entity.
// If the Loan object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LoanMutation) OldPaymentType(ctx context.Context) (v loan.PaymentType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPaymentType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPaymentType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPaymentType: %w", err)
	}
	return oldValue.PaymentType, nil
}

// ResetPaymentType resets all changes to the "payment_type" field.
func (m *LoanMutation) ResetPaymentType() {
	m.payment_type = nil
}

// SetCounterpartyName sets the "counterparty_name" field.
func (m *LoanMutation) SetCounterpartyName(s string) {
	m.counterparty_name = &s
}

// CounterpartyName returns the value of the "counterparty_name" field in the mutation.
func (m *LoanMutation) CounterpartyName() (r string, exists bool) {
	v := m.counterparty_name
	if v == nil {
		return
	}
	return *v, true
}

// OldCounterpartyName returns the old "counterparty_name" field's value of the Loan entity.
// If the Loan object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LoanMutation) OldCounterpartyName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCounterpartyName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCounterpartyName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCounterpartyName: %w", err)
	}
	return oldValue.CounterpartyName, nil
}

// ResetCounterpartyName resets all changes to the "counterparty_name" field.
func (m *LoanMutation) ResetCounterpartyName() {
	m.counterparty_name = nil
}

// SetStartDate sets the "start_date" field.
func (m *LoanMutation) SetStartDate(t time.Time) {
	m.start_date = &t
}

// StartDate returns the value of the "start_date" field in the mutation.
func (m *LoanMutation) StartDate() (r time.Time, exists bool) {
	v := m.start_date
	if v == nil {
		return
	}
	return *v, true
}

// OldStartDate returns the old "start_date" field's value of the Loan entity.
// If the Loan object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LoanMutation) OldStartDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartDate: %w", err)
	}
	return oldValue.StartDate, nil
}

// ResetStartDate resets all changes to the "start_date" field.
func (m *LoanMutation) ResetStartDate() {
	m.start_date = nil
}

// SetStatus sets the "status" field.
func (m *LoanMutation) SetStatus(l loan.Status) {
	m.status = &l
}

// Status returns the value of the "status" field in the mutation.
func (m *LoanMutation) Status() (r loan.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Loan entity.
// If the Loan object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LoanMutation) OldStatus(ctx context.Context) (v loan.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *LoanMutation) ResetStatus() {
	m.status = nil
}

// SetClientID sets the "client" edge to the Customer entity by id.
func (m *LoanMutation) SetClientID(id int) {
	m.client = &id
}

// ClearClient clears the "client" edge to the Customer entity.
func (m *LoanMutation) ClearClient() {
	m.clearedclient = true
}

// ClientCleared reports if the "client" edge to the Customer entity was cleared.
func (m *LoanMutation) ClientCleared() bool {
	return m.clearedclient
}

// ClientID returns the "client" edge ID in the mutation.
func (m *LoanMutation) ClientID() (id int, exists bool) {
	if m.client != nil {
		return *m.client, true
	}
	return
}

// ClientIDs returns the "client" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ClientID instead. It exists only for internal usage by the builders.
func (m *LoanMutation) ClientIDs() (ids []int) {
	if id := m.client; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetClient resets all changes to the "client" edge.
func (m *LoanMutation) ResetClient() {
	m.client = nil
	m.clearedclient = false
}

// SetSupplierID sets the "supplier" edge to the Supplier entity by id.
func (m *LoanMutation) SetSupplierID(id int) {
	m.supplier = &id
}

// ClearSupplier clears the "supplier" edge to the Supplier entity.
func (m *LoanMutation) ClearSupplier() {
	m.clearedsupplier = true
}

// SupplierCleared reports if the "supplier" edge to the Supplier entity was cleared.
func (m *LoanMutation) SupplierCleared() bool {
	return m.clearedsupplier
}

// SupplierID returns the "supplier" edge ID in the mutation.
func (m *LoanMutation) SupplierID() (id int, exists bool) {
	if m.supplier != nil {
		return *m.supplier, true
	}
	return
}

// SupplierIDs returns the "supplier" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SupplierID instead. It exists only for internal usage by the builders.
func (m *LoanMutation) SupplierIDs() (ids []int) {
	if id := m.supplier; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSupplier resets all changes to the "supplier" edge.
func (m *LoanMutation) ResetSupplier() {
	m.supplier = nil
	m.clearedsupplier = false
}

// SetCompanyID sets the "company" edge to the Company entity by id.
func (m *LoanMutation) SetCompanyID(id int) {
	m.company = &id
}

// ClearCompany clears the "company" edge to the Company entity.
func (m *LoanMutation) ClearCompany() {
	m.clearedcompany = true
}

// CompanyCleared reports if the "company" edge to the Company entity was cleared.
func (m *LoanMutation) CompanyCleared() bool {
	return m.clearedcompany
}

// CompanyID returns the "company" edge ID in the mutation.
func (m *LoanMutation) CompanyID() (id int, exists bool) {
	if m.company != nil {
		return *m.company, true
	}
	return
}

// CompanyIDs returns the "company" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CompanyID instead. It exists only for internal usage by the builders.
func (m *LoanMutation) CompanyIDs() (ids []int) {
	if id := m.company; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCompany resets all changes to the "company" edge.
func (m *LoanMutation) ResetCompany() {
	m.company = nil
	m.clearedcompany = false
}

// AddLoanScheduleIDs adds the "loan_schedule" edge to the LoanSchedule entity by ids.
func (m *LoanMutation) AddLoanScheduleIDs(ids ...int) {
	if m.loan_schedule == nil {
		m.loan_schedule = make(map[int]struct{})
	}
	for i := range ids {
		m.loan_schedule[ids[i]] = struct{}{}
	}
}

// ClearLoanSchedule clears the "loan_schedule" edge to the LoanSchedule entity.
func (m *LoanMutation) ClearLoanSchedule() {
	m.clearedloan_schedule = true
}

// LoanScheduleCleared reports if the "loan_schedule" edge to the LoanSchedule entity was cleared.
func (m *LoanMutation) LoanScheduleCleared() bool {
	return m.clearedloan_schedule
}

// RemoveLoanScheduleIDs removes the "loan_schedule" edge to the LoanSchedule entity by IDs.
func (m *LoanMutation) RemoveLoanScheduleIDs(ids ...int) {
	if m.removedloan_schedule == nil {
		m.removedloan_schedule = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.loan_schedule, ids[i])
		m.removedloan_schedule[ids[i]] = struct{}{}
	}
}

// RemovedLoanSchedule returns the removed IDs of the "loan_schedule" edge to the LoanSchedule entity.
func (m *LoanMutation) RemovedLoanScheduleIDs() (ids []int) {
	for id := range m.removedloan_schedule {
		ids = append(ids, id)
	}
	return
}

// LoanScheduleIDs returns the "loan_schedule" edge IDs in the mutation.
func (m *LoanMutation) LoanScheduleIDs() (ids []int) {
	for id := range m.loan_schedule {
		ids = append(ids, id)
	}
	return
}

// ResetLoanSchedule resets all changes to the "loan_schedule" edge.
func (m *LoanMutation) ResetLoanSchedule() {
	m.loan_schedule = nil
	m.clearedloan_schedule = false
	m.removedloan_schedule = nil
}

// AddTransactionHistoryIDs adds the "transaction_history" edge to the AccountingEntry entity by ids.
func (m *LoanMutation) AddTransactionHistoryIDs(ids ...int) {
	if m.transaction_history == nil {
		m.transaction_history = make(map[int]struct{})
	}
	for i := range ids {
		m.transaction_history[ids[i]] = struct{}{}
	}
}

// ClearTransactionHistory clears the "transaction_history" edge to the AccountingEntry entity.
func (m *LoanMutation) ClearTransactionHistory() {
	m.clearedtransaction_history = true
}

// TransactionHistoryCleared reports if the "transaction_history" edge to the AccountingEntry entity was cleared.
func (m *LoanMutation) TransactionHistoryCleared() bool {
	return m.clearedtransaction_history
}

// RemoveTransactionHistoryIDs removes the "transaction_history" edge to the AccountingEntry entity by IDs.
func (m *LoanMutation) RemoveTransactionHistoryIDs(ids ...int) {
	if m.removedtransaction_history == nil {
		m.removedtransaction_history = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.transaction_history, ids[i])
		m.removedtransaction_history[ids[i]] = struct{}{}
	}
}

// RemovedTransactionHistory returns the removed IDs of the "transaction_history" edge to the AccountingEntry entity.
func (m *LoanMutation) RemovedTransactionHistoryIDs() (ids []int) {
	for id := range m.removedtransaction_history {
		ids = append(ids, id)
	}
	return
}

// TransactionHistoryIDs returns the "transaction_history" edge IDs in the mutation.
func (m *LoanMutation) TransactionHistoryIDs() (ids []int) {
	for id := range m.transaction_history {
		ids = append(ids, id)
	}
	return
}

// ResetTransactionHistory resets all changes to the "transaction_history" edge.
func (m *LoanMutation) ResetTransactionHistory() {
	m.transaction_history = nil
	m.clearedtransaction_history = false
	m.removedtransaction_history = nil
}

// Where appends a list predicates to the LoanMutation builder.
func (m *LoanMutation) Where(ps ...predicate.Loan) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the LoanMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *LoanMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Loan, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *LoanMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *LoanMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Loan).
func (m *LoanMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *LoanMutation) Fields() []string {
	fields := make([]string, 0, 20)
	if m.created_at != nil {
		fields = append(fields, loan.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, loan.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, loan.FieldDeletedAt)
	}
	if m.is_lending != nil {
		fields = append(fields, loan.FieldIsLending)
	}
	if m.amount != nil {
		fields = append(fields, loan.FieldAmount)
	}
	if m.category != nil {
		fields = append(fields, loan.FieldCategory)
	}
	if m.collateral != nil {
		fields = append(fields, loan.FieldCollateral)
	}
	if m.description != nil {
		fields = append(fields, loan.FieldDescription)
	}
	if m.interest_rate != nil {
		fields = append(fields, loan.FieldInterestRate)
	}
	if m.installments != nil {
		fields = append(fields, loan.FieldInstallments)
	}
	if m.maturity_date != nil {
		fields = append(fields, loan.FieldMaturityDate)
	}
	if m.next_payment_date != nil {
		fields = append(fields, loan.FieldNextPaymentDate)
	}
	if m.next_payment_amount != nil {
		fields = append(fields, loan.FieldNextPaymentAmount)
	}
	if m.outstanding_balance != nil {
		fields = append(fields, loan.FieldOutstandingBalance)
	}
	if m.payment_frequency != nil {
		fields = append(fields, loan.FieldPaymentFrequency)
	}
	if m.paid_installments != nil {
		fields = append(fields, loan.FieldPaidInstallments)
	}
	if m.payment_type != nil {
		fields = append(fields, loan.FieldPaymentType)
	}
	if m.counterparty_name != nil {
		fields = append(fields, loan.FieldCounterpartyName)
	}
	if m.start_date != nil {
		fields = append(fields, loan.FieldStartDate)
	}
	if m.status != nil {
		fields = append(fields, loan.FieldStatus)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *LoanMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case loan.FieldCreatedAt:
		return m.CreatedAt()
	case loan.FieldUpdatedAt:
		return m.UpdatedAt()
	case loan.FieldDeletedAt:
		return m.DeletedAt()
	case loan.FieldIsLending:
		return m.IsLending()
	case loan.FieldAmount:
		return m.Amount()
	case loan.FieldCategory:
		return m.Category()
	case loan.FieldCollateral:
		return m.Collateral()
	case loan.FieldDescription:
		return m.Description()
	case loan.FieldInterestRate:
		return m.InterestRate()
	case loan.FieldInstallments:
		return m.Installments()
	case loan.FieldMaturityDate:
		return m.MaturityDate()
	case loan.FieldNextPaymentDate:
		return m.NextPaymentDate()
	case loan.FieldNextPaymentAmount:
		return m.NextPaymentAmount()
	case loan.FieldOutstandingBalance:
		return m.OutstandingBalance()
	case loan.FieldPaymentFrequency:
		return m.PaymentFrequency()
	case loan.FieldPaidInstallments:
		return m.PaidInstallments()
	case loan.FieldPaymentType:
		return m.PaymentType()
	case loan.FieldCounterpartyName:
		return m.CounterpartyName()
	case loan.FieldStartDate:
		return m.StartDate()
	case loan.FieldStatus:
		return m.Status()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *LoanMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case loan.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case loan.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case loan.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case loan.FieldIsLending:
		return m.OldIsLending(ctx)
	case loan.FieldAmount:
		return m.OldAmount(ctx)
	case loan.FieldCategory:
		return m.OldCategory(ctx)
	case loan.FieldCollateral:
		return m.OldCollateral(ctx)
	case loan.FieldDescription:
		return m.OldDescription(ctx)
	case loan.FieldInterestRate:
		return m.OldInterestRate(ctx)
	case loan.FieldInstallments:
		return m.OldInstallments(ctx)
	case loan.FieldMaturityDate:
		return m.OldMaturityDate(ctx)
	case loan.FieldNextPaymentDate:
		return m.OldNextPaymentDate(ctx)
	case loan.FieldNextPaymentAmount:
		return m.OldNextPaymentAmount(ctx)
	case loan.FieldOutstandingBalance:
		return m.OldOutstandingBalance(ctx)
	case loan.FieldPaymentFrequency:
		return m.OldPaymentFrequency(ctx)
	case loan.FieldPaidInstallments:
		return m.OldPaidInstallments(ctx)
	case loan.FieldPaymentType:
		return m.OldPaymentType(ctx)
	case loan.FieldCounterpartyName:
		return m.OldCounterpartyName(ctx)
	case loan.FieldStartDate:
		return m.OldStartDate(ctx)
	case loan.FieldStatus:
		return m.OldStatus(ctx)
	}
	return nil, fmt.Errorf("unknown Loan field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LoanMutation) SetField(name string, value ent.Value) error {
	switch name {
	case loan.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case loan.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case loan.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case loan.FieldIsLending:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsLending(v)
		return nil
	case loan.FieldAmount:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAmount(v)
		return nil
	case loan.FieldCategory:
		v, ok := value.(loan.Category)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCategory(v)
		return nil
	case loan.FieldCollateral:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCollateral(v)
		return nil
	case loan.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case loan.FieldInterestRate:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInterestRate(v)
		return nil
	case loan.FieldInstallments:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInstallments(v)
		return nil
	case loan.FieldMaturityDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMaturityDate(v)
		return nil
	case loan.FieldNextPaymentDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNextPaymentDate(v)
		return nil
	case loan.FieldNextPaymentAmount:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNextPaymentAmount(v)
		return nil
	case loan.FieldOutstandingBalance:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOutstandingBalance(v)
		return nil
	case loan.FieldPaymentFrequency:
		v, ok := value.(loan.PaymentFrequency)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPaymentFrequency(v)
		return nil
	case loan.FieldPaidInstallments:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPaidInstallments(v)
		return nil
	case loan.FieldPaymentType:
		v, ok := value.(loan.PaymentType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPaymentType(v)
		return nil
	case loan.FieldCounterpartyName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCounterpartyName(v)
		return nil
	case loan.FieldStartDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartDate(v)
		return nil
	case loan.FieldStatus:
		v, ok := value.(loan.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	}
	return fmt.Errorf("unknown Loan field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *LoanMutation) AddedFields() []string {
	var fields []string
	if m.addamount != nil {
		fields = append(fields, loan.FieldAmount)
	}
	if m.addinterest_rate != nil {
		fields = append(fields, loan.FieldInterestRate)
	}
	if m.addinstallments != nil {
		fields = append(fields, loan.FieldInstallments)
	}
	if m.addnext_payment_amount != nil {
		fields = append(fields, loan.FieldNextPaymentAmount)
	}
	if m.addoutstanding_balance != nil {
		fields = append(fields, loan.FieldOutstandingBalance)
	}
	if m.addpaid_installments != nil {
		fields = append(fields, loan.FieldPaidInstallments)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *LoanMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case loan.FieldAmount:
		return m.AddedAmount()
	case loan.FieldInterestRate:
		return m.AddedInterestRate()
	case loan.FieldInstallments:
		return m.AddedInstallments()
	case loan.FieldNextPaymentAmount:
		return m.AddedNextPaymentAmount()
	case loan.FieldOutstandingBalance:
		return m.AddedOutstandingBalance()
	case loan.FieldPaidInstallments:
		return m.AddedPaidInstallments()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LoanMutation) AddField(name string, value ent.Value) error {
	switch name {
	case loan.FieldAmount:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAmount(v)
		return nil
	case loan.FieldInterestRate:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddInterestRate(v)
		return nil
	case loan.FieldInstallments:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddInstallments(v)
		return nil
	case loan.FieldNextPaymentAmount:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddNextPaymentAmount(v)
		return nil
	case loan.FieldOutstandingBalance:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOutstandingBalance(v)
		return nil
	case loan.FieldPaidInstallments:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPaidInstallments(v)
		return nil
	}
	return fmt.Errorf("unknown Loan numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *LoanMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(loan.FieldDeletedAt) {
		fields = append(fields, loan.FieldDeletedAt)
	}
	if m.FieldCleared(loan.FieldCollateral) {
		fields = append(fields, loan.FieldCollateral)
	}
	if m.FieldCleared(loan.FieldDescription) {
		fields = append(fields, loan.FieldDescription)
	}
	if m.FieldCleared(loan.FieldNextPaymentDate) {
		fields = append(fields, loan.FieldNextPaymentDate)
	}
	if m.FieldCleared(loan.FieldNextPaymentAmount) {
		fields = append(fields, loan.FieldNextPaymentAmount)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *LoanMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *LoanMutation) ClearField(name string) error {
	switch name {
	case loan.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case loan.FieldCollateral:
		m.ClearCollateral()
		return nil
	case loan.FieldDescription:
		m.ClearDescription()
		return nil
	case loan.FieldNextPaymentDate:
		m.ClearNextPaymentDate()
		return nil
	case loan.FieldNextPaymentAmount:
		m.ClearNextPaymentAmount()
		return nil
	}
	return fmt.Errorf("unknown Loan nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *LoanMutation) ResetField(name string) error {
	switch name {
	case loan.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case loan.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case loan.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case loan.FieldIsLending:
		m.ResetIsLending()
		return nil
	case loan.FieldAmount:
		m.ResetAmount()
		return nil
	case loan.FieldCategory:
		m.ResetCategory()
		return nil
	case loan.FieldCollateral:
		m.ResetCollateral()
		return nil
	case loan.FieldDescription:
		m.ResetDescription()
		return nil
	case loan.FieldInterestRate:
		m.ResetInterestRate()
		return nil
	case loan.FieldInstallments:
		m.ResetInstallments()
		return nil
	case loan.FieldMaturityDate:
		m.ResetMaturityDate()
		return nil
	case loan.FieldNextPaymentDate:
		m.ResetNextPaymentDate()
		return nil
	case loan.FieldNextPaymentAmount:
		m.ResetNextPaymentAmount()
		return nil
	case loan.FieldOutstandingBalance:
		m.ResetOutstandingBalance()
		return nil
	case loan.FieldPaymentFrequency:
		m.ResetPaymentFrequency()
		return nil
	case loan.FieldPaidInstallments:
		m.ResetPaidInstallments()
		return nil
	case loan.FieldPaymentType:
		m.ResetPaymentType()
		return nil
	case loan.FieldCounterpartyName:
		m.ResetCounterpartyName()
		return nil
	case loan.FieldStartDate:
		m.ResetStartDate()
		return nil
	case loan.FieldStatus:
		m.ResetStatus()
		return nil
	}
	return fmt.Errorf("unknown Loan field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *LoanMutation) AddedEdges() []string {
	edges := make([]string, 0, 5)
	if m.client != nil {
		edges = append(edges, loan.EdgeClient)
	}
	if m.supplier != nil {
		edges = append(edges, loan.EdgeSupplier)
	}
	if m.company != nil {
		edges = append(edges, loan.EdgeCompany)
	}
	if m.loan_schedule != nil {
		edges = append(edges, loan.EdgeLoanSchedule)
	}
	if m.transaction_history != nil {
		edges = append(edges, loan.EdgeTransactionHistory)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *LoanMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case loan.EdgeClient:
		if id := m.client; id != nil {
			return []ent.Value{*id}
		}
	case loan.EdgeSupplier:
		if id := m.supplier; id != nil {
			return []ent.Value{*id}
		}
	case loan.EdgeCompany:
		if id := m.company; id != nil {
			return []ent.Value{*id}
		}
	case loan.EdgeLoanSchedule:
		ids := make([]ent.Value, 0, len(m.loan_schedule))
		for id := range m.loan_schedule {
			ids = append(ids, id)
		}
		return ids
	case loan.EdgeTransactionHistory:
		ids := make([]ent.Value, 0, len(m.transaction_history))
		for id := range m.transaction_history {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *LoanMutation) RemovedEdges() []string {
	edges := make([]string, 0, 5)
	if m.removedloan_schedule != nil {
		edges = append(edges, loan.EdgeLoanSchedule)
	}
	if m.removedtransaction_history != nil {
		edges = append(edges, loan.EdgeTransactionHistory)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *LoanMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case loan.EdgeLoanSchedule:
		ids := make([]ent.Value, 0, len(m.removedloan_schedule))
		for id := range m.removedloan_schedule {
			ids = append(ids, id)
		}
		return ids
	case loan.EdgeTransactionHistory:
		ids := make([]ent.Value, 0, len(m.removedtransaction_history))
		for id := range m.removedtransaction_history {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *LoanMutation) ClearedEdges() []string {
	edges := make([]string, 0, 5)
	if m.clearedclient {
		edges = append(edges, loan.EdgeClient)
	}
	if m.clearedsupplier {
		edges = append(edges, loan.EdgeSupplier)
	}
	if m.clearedcompany {
		edges = append(edges, loan.EdgeCompany)
	}
	if m.clearedloan_schedule {
		edges = append(edges, loan.EdgeLoanSchedule)
	}
	if m.clearedtransaction_history {
		edges = append(edges, loan.EdgeTransactionHistory)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *LoanMutation) EdgeCleared(name string) bool {
	switch name {
	case loan.EdgeClient:
		return m.clearedclient
	case loan.EdgeSupplier:
		return m.clearedsupplier
	case loan.EdgeCompany:
		return m.clearedcompany
	case loan.EdgeLoanSchedule:
		return m.clearedloan_schedule
	case loan.EdgeTransactionHistory:
		return m.clearedtransaction_history
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *LoanMutation) ClearEdge(name string) error {
	switch name {
	case loan.EdgeClient:
		m.ClearClient()
		return nil
	case loan.EdgeSupplier:
		m.ClearSupplier()
		return nil
	case loan.EdgeCompany:
		m.ClearCompany()
		return nil
	}
	return fmt.Errorf("unknown Loan unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *LoanMutation) ResetEdge(name string) error {
	switch name {
	case loan.EdgeClient:
		m.ResetClient()
		return nil
	case loan.EdgeSupplier:
		m.ResetSupplier()
		return nil
	case loan.EdgeCompany:
		m.ResetCompany()
		return nil
	case loan.EdgeLoanSchedule:
		m.ResetLoanSchedule()
		return nil
	case loan.EdgeTransactionHistory:
		m.ResetTransactionHistory()
		return nil
	}
	return fmt.Errorf("unknown Loan edge %s", name)
}

// LoanScheduleMutation represents an operation that mutates the LoanSchedule nodes in the graph.
type LoanScheduleMutation struct {
	config
	op                         Op
	typ                        string
	id                         *int
	created_at                 *time.Time
	updated_at                 *time.Time
	deleted_at                 *time.Time
	amount                     *float64
	addamount                  *float64
	amount_paid                *float64
	addamount_paid             *float64
	due_date                   *time.Time
	date_paid                  *time.Time
	interest                   *float64
	addinterest                *float64
	installment_number         *int
	addinstallment_number      *int
	principal                  *float64
	addprincipal               *float64
	outstanding_balance        *float64
	addoutstanding_balance     *float64
	status                     *loanschedule.Status
	clearedFields              map[string]struct{}
	loan                       *int
	clearedloan                bool
	transaction_history        map[int]struct{}
	removedtransaction_history map[int]struct{}
	clearedtransaction_history bool
	done                       bool
	oldValue                   func(context.Context) (*LoanSchedule, error)
	predicates                 []predicate.LoanSchedule
}

var _ ent.Mutation = (*LoanScheduleMutation)(nil)

// loanscheduleOption allows management of the mutation configuration using functional options.
type loanscheduleOption func(*LoanScheduleMutation)

// newLoanScheduleMutation creates new mutation for the LoanSchedule entity.
func newLoanScheduleMutation(c config, op Op, opts ...loanscheduleOption) *LoanScheduleMutation {
	m := &LoanScheduleMutation{
		config:        c,
		op:            op,
		typ:           TypeLoanSchedule,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withLoanScheduleID sets the ID field of the mutation.
func withLoanScheduleID(id int) loanscheduleOption {
	return func(m *LoanScheduleMutation) {
		var (
			err   error
			once  sync.Once
			value *LoanSchedule
		)
		m.oldValue = func(ctx context.Context) (*LoanSchedule, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().LoanSchedule.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withLoanSchedule sets the old LoanSchedule of the mutation.
func withLoanSchedule(node *LoanSchedule) loanscheduleOption {
	return func(m *LoanScheduleMutation) {
		m.oldValue = func(context.Context) (*LoanSchedule, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m LoanScheduleMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m LoanScheduleMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("generated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *LoanScheduleMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *LoanScheduleMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().LoanSchedule.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *LoanScheduleMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *LoanScheduleMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the LoanSchedule entity.
// If the LoanSchedule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LoanScheduleMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *LoanScheduleMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *LoanScheduleMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *LoanScheduleMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the LoanSchedule entity.
// If the LoanSchedule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LoanScheduleMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *LoanScheduleMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *LoanScheduleMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *LoanScheduleMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the LoanSchedule entity.
// If the LoanSchedule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LoanScheduleMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *LoanScheduleMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[loanschedule.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *LoanScheduleMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[loanschedule.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *LoanScheduleMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, loanschedule.FieldDeletedAt)
}

// SetAmount sets the "amount" field.
func (m *LoanScheduleMutation) SetAmount(f float64) {
	m.amount = &f
	m.addamount = nil
}

// Amount returns the value of the "amount" field in the mutation.
func (m *LoanScheduleMutation) Amount() (r float64, exists bool) {
	v := m.amount
	if v == nil {
		return
	}
	return *v, true
}

// OldAmount returns the old "amount" field's value of the LoanSchedule entity.
// If the LoanSchedule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LoanScheduleMutation) OldAmount(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAmount: %w", err)
	}
	return oldValue.Amount, nil
}

// AddAmount adds f to the "amount" field.
func (m *LoanScheduleMutation) AddAmount(f float64) {
	if m.addamount != nil {
		*m.addamount += f
	} else {
		m.addamount = &f
	}
}

// AddedAmount returns the value that was added to the "amount" field in this mutation.
func (m *LoanScheduleMutation) AddedAmount() (r float64, exists bool) {
	v := m.addamount
	if v == nil {
		return
	}
	return *v, true
}

// ResetAmount resets all changes to the "amount" field.
func (m *LoanScheduleMutation) ResetAmount() {
	m.amount = nil
	m.addamount = nil
}

// SetAmountPaid sets the "amount_paid" field.
func (m *LoanScheduleMutation) SetAmountPaid(f float64) {
	m.amount_paid = &f
	m.addamount_paid = nil
}

// AmountPaid returns the value of the "amount_paid" field in the mutation.
func (m *LoanScheduleMutation) AmountPaid() (r float64, exists bool) {
	v := m.amount_paid
	if v == nil {
		return
	}
	return *v, true
}

// OldAmountPaid returns the old "amount_paid" field's value of the LoanSchedule entity.
// If the LoanSchedule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LoanScheduleMutation) OldAmountPaid(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAmountPaid is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAmountPaid requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAmountPaid: %w", err)
	}
	return oldValue.AmountPaid, nil
}

// AddAmountPaid adds f to the "amount_paid" field.
func (m *LoanScheduleMutation) AddAmountPaid(f float64) {
	if m.addamount_paid != nil {
		*m.addamount_paid += f
	} else {
		m.addamount_paid = &f
	}
}

// AddedAmountPaid returns the value that was added to the "amount_paid" field in this mutation.
func (m *LoanScheduleMutation) AddedAmountPaid() (r float64, exists bool) {
	v := m.addamount_paid
	if v == nil {
		return
	}
	return *v, true
}

// ResetAmountPaid resets all changes to the "amount_paid" field.
func (m *LoanScheduleMutation) ResetAmountPaid() {
	m.amount_paid = nil
	m.addamount_paid = nil
}

// SetDueDate sets the "due_date" field.
func (m *LoanScheduleMutation) SetDueDate(t time.Time) {
	m.due_date = &t
}

// DueDate returns the value of the "due_date" field in the mutation.
func (m *LoanScheduleMutation) DueDate() (r time.Time, exists bool) {
	v := m.due_date
	if v == nil {
		return
	}
	return *v, true
}

// OldDueDate returns the old "due_date" field's value of the LoanSchedule entity.
// If the LoanSchedule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LoanScheduleMutation) OldDueDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDueDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDueDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDueDate: %w", err)
	}
	return oldValue.DueDate, nil
}

// ResetDueDate resets all changes to the "due_date" field.
func (m *LoanScheduleMutation) ResetDueDate() {
	m.due_date = nil
}

// SetDatePaid sets the "date_paid" field.
func (m *LoanScheduleMutation) SetDatePaid(t time.Time) {
	m.date_paid = &t
}

// DatePaid returns the value of the "date_paid" field in the mutation.
func (m *LoanScheduleMutation) DatePaid() (r time.Time, exists bool) {
	v := m.date_paid
	if v == nil {
		return
	}
	return *v, true
}

// OldDatePaid returns the old "date_paid" field's value of the LoanSchedule entity.
// If the LoanSchedule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LoanScheduleMutation) OldDatePaid(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDatePaid is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDatePaid requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDatePaid: %w", err)
	}
	return oldValue.DatePaid, nil
}

// ClearDatePaid clears the value of the "date_paid" field.
func (m *LoanScheduleMutation) ClearDatePaid() {
	m.date_paid = nil
	m.clearedFields[loanschedule.FieldDatePaid] = struct{}{}
}

// DatePaidCleared returns if the "date_paid" field was cleared in this mutation.
func (m *LoanScheduleMutation) DatePaidCleared() bool {
	_, ok := m.clearedFields[loanschedule.FieldDatePaid]
	return ok
}

// ResetDatePaid resets all changes to the "date_paid" field.
func (m *LoanScheduleMutation) ResetDatePaid() {
	m.date_paid = nil
	delete(m.clearedFields, loanschedule.FieldDatePaid)
}

// SetInterest sets the "interest" field.
func (m *LoanScheduleMutation) SetInterest(f float64) {
	m.interest = &f
	m.addinterest = nil
}

// Interest returns the value of the "interest" field in the mutation.
func (m *LoanScheduleMutation) Interest() (r float64, exists bool) {
	v := m.interest
	if v == nil {
		return
	}
	return *v, true
}

// OldInterest returns the old "interest" field's value of the LoanSchedule entity.
// If the LoanSchedule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LoanScheduleMutation) OldInterest(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInterest is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInterest requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInterest: %w", err)
	}
	return oldValue.Interest, nil
}

// AddInterest adds f to the "interest" field.
func (m *LoanScheduleMutation) AddInterest(f float64) {
	if m.addinterest != nil {
		*m.addinterest += f
	} else {
		m.addinterest = &f
	}
}

// AddedInterest returns the value that was added to the "interest" field in this mutation.
func (m *LoanScheduleMutation) AddedInterest() (r float64, exists bool) {
	v := m.addinterest
	if v == nil {
		return
	}
	return *v, true
}

// ResetInterest resets all changes to the "interest" field.
func (m *LoanScheduleMutation) ResetInterest() {
	m.interest = nil
	m.addinterest = nil
}

// SetInstallmentNumber sets the "installment_number" field.
func (m *LoanScheduleMutation) SetInstallmentNumber(i int) {
	m.installment_number = &i
	m.addinstallment_number = nil
}

// InstallmentNumber returns the value of the "installment_number" field in the mutation.
func (m *LoanScheduleMutation) InstallmentNumber() (r int, exists bool) {
	v := m.installment_number
	if v == nil {
		return
	}
	return *v, true
}

// OldInstallmentNumber returns the old "installment_number" field's value of the LoanSchedule entity.
// If the LoanSchedule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LoanScheduleMutation) OldInstallmentNumber(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInstallmentNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInstallmentNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInstallmentNumber: %w", err)
	}
	return oldValue.InstallmentNumber, nil
}

// AddInstallmentNumber adds i to the "installment_number" field.
func (m *LoanScheduleMutation) AddInstallmentNumber(i int) {
	if m.addinstallment_number != nil {
		*m.addinstallment_number += i
	} else {
		m.addinstallment_number = &i
	}
}

// AddedInstallmentNumber returns the value that was added to the "installment_number" field in this mutation.
func (m *LoanScheduleMutation) AddedInstallmentNumber() (r int, exists bool) {
	v := m.addinstallment_number
	if v == nil {
		return
	}
	return *v, true
}

// ResetInstallmentNumber resets all changes to the "installment_number" field.
func (m *LoanScheduleMutation) ResetInstallmentNumber() {
	m.installment_number = nil
	m.addinstallment_number = nil
}

// SetPrincipal sets the "principal" field.
func (m *LoanScheduleMutation) SetPrincipal(f float64) {
	m.principal = &f
	m.addprincipal = nil
}

// Principal returns the value of the "principal" field in the mutation.
func (m *LoanScheduleMutation) Principal() (r float64, exists bool) {
	v := m.principal
	if v == nil {
		return
	}
	return *v, true
}

// OldPrincipal returns the old "principal" field's value of the LoanSchedule entity.
// If the LoanSchedule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LoanScheduleMutation) OldPrincipal(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPrincipal is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPrincipal requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPrincipal: %w", err)
	}
	return oldValue.Principal, nil
}

// AddPrincipal adds f to the "principal" field.
func (m *LoanScheduleMutation) AddPrincipal(f float64) {
	if m.addprincipal != nil {
		*m.addprincipal += f
	} else {
		m.addprincipal = &f
	}
}

// AddedPrincipal returns the value that was added to the "principal" field in this mutation.
func (m *LoanScheduleMutation) AddedPrincipal() (r float64, exists bool) {
	v := m.addprincipal
	if v == nil {
		return
	}
	return *v, true
}

// ResetPrincipal resets all changes to the "principal" field.
func (m *LoanScheduleMutation) ResetPrincipal() {
	m.principal = nil
	m.addprincipal = nil
}

// SetOutstandingBalance sets the "outstanding_balance" field.
func (m *LoanScheduleMutation) SetOutstandingBalance(f float64) {
	m.outstanding_balance = &f
	m.addoutstanding_balance = nil
}

// OutstandingBalance returns the value of the "outstanding_balance" field in the mutation.
func (m *LoanScheduleMutation) OutstandingBalance() (r float64, exists bool) {
	v := m.outstanding_balance
	if v == nil {
		return
	}
	return *v, true
}

// OldOutstandingBalance returns the old "outstanding_balance" field's value of the LoanSchedule entity.
// If the LoanSchedule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LoanScheduleMutation) OldOutstandingBalance(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOutstandingBalance is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOutstandingBalance requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOutstandingBalance: %w", err)
	}
	return oldValue.OutstandingBalance, nil
}

// AddOutstandingBalance adds f to the "outstanding_balance" field.
func (m *LoanScheduleMutation) AddOutstandingBalance(f float64) {
	if m.addoutstanding_balance != nil {
		*m.addoutstanding_balance += f
	} else {
		m.addoutstanding_balance = &f
	}
}

// AddedOutstandingBalance returns the value that was added to the "outstanding_balance" field in this mutation.
func (m *LoanScheduleMutation) AddedOutstandingBalance() (r float64, exists bool) {
	v := m.addoutstanding_balance
	if v == nil {
		return
	}
	return *v, true
}

// ClearOutstandingBalance clears the value of the "outstanding_balance" field.
func (m *LoanScheduleMutation) ClearOutstandingBalance() {
	m.outstanding_balance = nil
	m.addoutstanding_balance = nil
	m.clearedFields[loanschedule.FieldOutstandingBalance] = struct{}{}
}

// OutstandingBalanceCleared returns if the "outstanding_balance" field was cleared in this mutation.
func (m *LoanScheduleMutation) OutstandingBalanceCleared() bool {
	_, ok := m.clearedFields[loanschedule.FieldOutstandingBalance]
	return ok
}

// ResetOutstandingBalance resets all changes to the "outstanding_balance" field.
func (m *LoanScheduleMutation) ResetOutstandingBalance() {
	m.outstanding_balance = nil
	m.addoutstanding_balance = nil
	delete(m.clearedFields, loanschedule.FieldOutstandingBalance)
}

// SetStatus sets the "status" field.
func (m *LoanScheduleMutation) SetStatus(l loanschedule.Status) {
	m.status = &l
}

// Status returns the value of the "status" field in the mutation.
func (m *LoanScheduleMutation) Status() (r loanschedule.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the LoanSchedule entity.
// If the LoanSchedule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LoanScheduleMutation) OldStatus(ctx context.Context) (v loanschedule.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *LoanScheduleMutation) ResetStatus() {
	m.status = nil
}

// SetLoanID sets the "loan" edge to the Loan entity by id.
func (m *LoanScheduleMutation) SetLoanID(id int) {
	m.loan = &id
}

// ClearLoan clears the "loan" edge to the Loan entity.
func (m *LoanScheduleMutation) ClearLoan() {
	m.clearedloan = true
}

// LoanCleared reports if the "loan" edge to the Loan entity was cleared.
func (m *LoanScheduleMutation) LoanCleared() bool {
	return m.clearedloan
}

// LoanID returns the "loan" edge ID in the mutation.
func (m *LoanScheduleMutation) LoanID() (id int, exists bool) {
	if m.loan != nil {
		return *m.loan, true
	}
	return
}

// LoanIDs returns the "loan" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// LoanID instead. It exists only for internal usage by the builders.
func (m *LoanScheduleMutation) LoanIDs() (ids []int) {
	if id := m.loan; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetLoan resets all changes to the "loan" edge.
func (m *LoanScheduleMutation) ResetLoan() {
	m.loan = nil
	m.clearedloan = false
}

// AddTransactionHistoryIDs adds the "transaction_history" edge to the AccountingEntry entity by ids.
func (m *LoanScheduleMutation) AddTransactionHistoryIDs(ids ...int) {
	if m.transaction_history == nil {
		m.transaction_history = make(map[int]struct{})
	}
	for i := range ids {
		m.transaction_history[ids[i]] = struct{}{}
	}
}

// ClearTransactionHistory clears the "transaction_history" edge to the AccountingEntry entity.
func (m *LoanScheduleMutation) ClearTransactionHistory() {
	m.clearedtransaction_history = true
}

// TransactionHistoryCleared reports if the "transaction_history" edge to the AccountingEntry entity was cleared.
func (m *LoanScheduleMutation) TransactionHistoryCleared() bool {
	return m.clearedtransaction_history
}

// RemoveTransactionHistoryIDs removes the "transaction_history" edge to the AccountingEntry entity by IDs.
func (m *LoanScheduleMutation) RemoveTransactionHistoryIDs(ids ...int) {
	if m.removedtransaction_history == nil {
		m.removedtransaction_history = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.transaction_history, ids[i])
		m.removedtransaction_history[ids[i]] = struct{}{}
	}
}

// RemovedTransactionHistory returns the removed IDs of the "transaction_history" edge to the AccountingEntry entity.
func (m *LoanScheduleMutation) RemovedTransactionHistoryIDs() (ids []int) {
	for id := range m.removedtransaction_history {
		ids = append(ids, id)
	}
	return
}

// TransactionHistoryIDs returns the "transaction_history" edge IDs in the mutation.
func (m *LoanScheduleMutation) TransactionHistoryIDs() (ids []int) {
	for id := range m.transaction_history {
		ids = append(ids, id)
	}
	return
}

// ResetTransactionHistory resets all changes to the "transaction_history" edge.
func (m *LoanScheduleMutation) ResetTransactionHistory() {
	m.transaction_history = nil
	m.clearedtransaction_history = false
	m.removedtransaction_history = nil
}

// Where appends a list predicates to the LoanScheduleMutation builder.
func (m *LoanScheduleMutation) Where(ps ...predicate.LoanSchedule) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the LoanScheduleMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *LoanScheduleMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.LoanSchedule, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *LoanScheduleMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *LoanScheduleMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (LoanSchedule).
func (m *LoanScheduleMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *LoanScheduleMutation) Fields() []string {
	fields := make([]string, 0, 12)
	if m.created_at != nil {
		fields = append(fields, loanschedule.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, loanschedule.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, loanschedule.FieldDeletedAt)
	}
	if m.amount != nil {
		fields = append(fields, loanschedule.FieldAmount)
	}
	if m.amount_paid != nil {
		fields = append(fields, loanschedule.FieldAmountPaid)
	}
	if m.due_date != nil {
		fields = append(fields, loanschedule.FieldDueDate)
	}
	if m.date_paid != nil {
		fields = append(fields, loanschedule.FieldDatePaid)
	}
	if m.interest != nil {
		fields = append(fields, loanschedule.FieldInterest)
	}
	if m.installment_number != nil {
		fields = append(fields, loanschedule.FieldInstallmentNumber)
	}
	if m.principal != nil {
		fields = append(fields, loanschedule.FieldPrincipal)
	}
	if m.outstanding_balance != nil {
		fields = append(fields, loanschedule.FieldOutstandingBalance)
	}
	if m.status != nil {
		fields = append(fields, loanschedule.FieldStatus)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *LoanScheduleMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case loanschedule.FieldCreatedAt:
		return m.CreatedAt()
	case loanschedule.FieldUpdatedAt:
		return m.UpdatedAt()
	case loanschedule.FieldDeletedAt:
		return m.DeletedAt()
	case loanschedule.FieldAmount:
		return m.Amount()
	case loanschedule.FieldAmountPaid:
		return m.AmountPaid()
	case loanschedule.FieldDueDate:
		return m.DueDate()
	case loanschedule.FieldDatePaid:
		return m.DatePaid()
	case loanschedule.FieldInterest:
		return m.Interest()
	case loanschedule.FieldInstallmentNumber:
		return m.InstallmentNumber()
	case loanschedule.FieldPrincipal:
		return m.Principal()
	case loanschedule.FieldOutstandingBalance:
		return m.OutstandingBalance()
	case loanschedule.FieldStatus:
		return m.Status()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *LoanScheduleMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case loanschedule.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case loanschedule.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case loanschedule.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case loanschedule.FieldAmount:
		return m.OldAmount(ctx)
	case loanschedule.FieldAmountPaid:
		return m.OldAmountPaid(ctx)
	case loanschedule.FieldDueDate:
		return m.OldDueDate(ctx)
	case loanschedule.FieldDatePaid:
		return m.OldDatePaid(ctx)
	case loanschedule.FieldInterest:
		return m.OldInterest(ctx)
	case loanschedule.FieldInstallmentNumber:
		return m.OldInstallmentNumber(ctx)
	case loanschedule.FieldPrincipal:
		return m.OldPrincipal(ctx)
	case loanschedule.FieldOutstandingBalance:
		return m.OldOutstandingBalance(ctx)
	case loanschedule.FieldStatus:
		return m.OldStatus(ctx)
	}
	return nil, fmt.Errorf("unknown LoanSchedule field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LoanScheduleMutation) SetField(name string, value ent.Value) error {
	switch name {
	case loanschedule.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case loanschedule.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case loanschedule.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case loanschedule.FieldAmount:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAmount(v)
		return nil
	case loanschedule.FieldAmountPaid:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAmountPaid(v)
		return nil
	case loanschedule.FieldDueDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDueDate(v)
		return nil
	case loanschedule.FieldDatePaid:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDatePaid(v)
		return nil
	case loanschedule.FieldInterest:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInterest(v)
		return nil
	case loanschedule.FieldInstallmentNumber:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInstallmentNumber(v)
		return nil
	case loanschedule.FieldPrincipal:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrincipal(v)
		return nil
	case loanschedule.FieldOutstandingBalance:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOutstandingBalance(v)
		return nil
	case loanschedule.FieldStatus:
		v, ok := value.(loanschedule.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	}
	return fmt.Errorf("unknown LoanSchedule field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *LoanScheduleMutation) AddedFields() []string {
	var fields []string
	if m.addamount != nil {
		fields = append(fields, loanschedule.FieldAmount)
	}
	if m.addamount_paid != nil {
		fields = append(fields, loanschedule.FieldAmountPaid)
	}
	if m.addinterest != nil {
		fields = append(fields, loanschedule.FieldInterest)
	}
	if m.addinstallment_number != nil {
		fields = append(fields, loanschedule.FieldInstallmentNumber)
	}
	if m.addprincipal != nil {
		fields = append(fields, loanschedule.FieldPrincipal)
	}
	if m.addoutstanding_balance != nil {
		fields = append(fields, loanschedule.FieldOutstandingBalance)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *LoanScheduleMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case loanschedule.FieldAmount:
		return m.AddedAmount()
	case loanschedule.FieldAmountPaid:
		return m.AddedAmountPaid()
	case loanschedule.FieldInterest:
		return m.AddedInterest()
	case loanschedule.FieldInstallmentNumber:
		return m.AddedInstallmentNumber()
	case loanschedule.FieldPrincipal:
		return m.AddedPrincipal()
	case loanschedule.FieldOutstandingBalance:
		return m.AddedOutstandingBalance()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LoanScheduleMutation) AddField(name string, value ent.Value) error {
	switch name {
	case loanschedule.FieldAmount:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAmount(v)
		return nil
	case loanschedule.FieldAmountPaid:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAmountPaid(v)
		return nil
	case loanschedule.FieldInterest:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddInterest(v)
		return nil
	case loanschedule.FieldInstallmentNumber:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddInstallmentNumber(v)
		return nil
	case loanschedule.FieldPrincipal:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPrincipal(v)
		return nil
	case loanschedule.FieldOutstandingBalance:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOutstandingBalance(v)
		return nil
	}
	return fmt.Errorf("unknown LoanSchedule numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *LoanScheduleMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(loanschedule.FieldDeletedAt) {
		fields = append(fields, loanschedule.FieldDeletedAt)
	}
	if m.FieldCleared(loanschedule.FieldDatePaid) {
		fields = append(fields, loanschedule.FieldDatePaid)
	}
	if m.FieldCleared(loanschedule.FieldOutstandingBalance) {
		fields = append(fields, loanschedule.FieldOutstandingBalance)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *LoanScheduleMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *LoanScheduleMutation) ClearField(name string) error {
	switch name {
	case loanschedule.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case loanschedule.FieldDatePaid:
		m.ClearDatePaid()
		return nil
	case loanschedule.FieldOutstandingBalance:
		m.ClearOutstandingBalance()
		return nil
	}
	return fmt.Errorf("unknown LoanSchedule nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *LoanScheduleMutation) ResetField(name string) error {
	switch name {
	case loanschedule.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case loanschedule.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case loanschedule.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case loanschedule.FieldAmount:
		m.ResetAmount()
		return nil
	case loanschedule.FieldAmountPaid:
		m.ResetAmountPaid()
		return nil
	case loanschedule.FieldDueDate:
		m.ResetDueDate()
		return nil
	case loanschedule.FieldDatePaid:
		m.ResetDatePaid()
		return nil
	case loanschedule.FieldInterest:
		m.ResetInterest()
		return nil
	case loanschedule.FieldInstallmentNumber:
		m.ResetInstallmentNumber()
		return nil
	case loanschedule.FieldPrincipal:
		m.ResetPrincipal()
		return nil
	case loanschedule.FieldOutstandingBalance:
		m.ResetOutstandingBalance()
		return nil
	case loanschedule.FieldStatus:
		m.ResetStatus()
		return nil
	}
	return fmt.Errorf("unknown LoanSchedule field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *LoanScheduleMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.loan != nil {
		edges = append(edges, loanschedule.EdgeLoan)
	}
	if m.transaction_history != nil {
		edges = append(edges, loanschedule.EdgeTransactionHistory)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *LoanScheduleMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case loanschedule.EdgeLoan:
		if id := m.loan; id != nil {
			return []ent.Value{*id}
		}
	case loanschedule.EdgeTransactionHistory:
		ids := make([]ent.Value, 0, len(m.transaction_history))
		for id := range m.transaction_history {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *LoanScheduleMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedtransaction_history != nil {
		edges = append(edges, loanschedule.EdgeTransactionHistory)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *LoanScheduleMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case loanschedule.EdgeTransactionHistory:
		ids := make([]ent.Value, 0, len(m.removedtransaction_history))
		for id := range m.removedtransaction_history {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *LoanScheduleMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedloan {
		edges = append(edges, loanschedule.EdgeLoan)
	}
	if m.clearedtransaction_history {
		edges = append(edges, loanschedule.EdgeTransactionHistory)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *LoanScheduleMutation) EdgeCleared(name string) bool {
	switch name {
	case loanschedule.EdgeLoan:
		return m.clearedloan
	case loanschedule.EdgeTransactionHistory:
		return m.clearedtransaction_history
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *LoanScheduleMutation) ClearEdge(name string) error {
	switch name {
	case loanschedule.EdgeLoan:
		m.ClearLoan()
		return nil
	}
	return fmt.Errorf("unknown LoanSchedule unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *LoanScheduleMutation) ResetEdge(name string) error {
	switch name {
	case loanschedule.EdgeLoan:
		m.ResetLoan()
		return nil
	case loanschedule.EdgeTransactionHistory:
		m.ResetTransactionHistory()
		return nil
	}
	return fmt.Errorf("unknown LoanSchedule edge %s", name)
}

// MemberSignupTokenMutation represents an operation that mutates the MemberSignupToken nodes in the graph.
type MemberSignupTokenMutation struct {
	config
	op                 Op
	typ                string
	id                 *int
	created_at         *time.Time
	updated_at         *time.Time
	deleted_at         *time.Time
	name               *string
	email              *string
	token              *string
	avatar             *string
	role               *membersignuptoken.Role
	note               *string
	number_accessed    *int
	addnumber_accessed *int
	expires_at         *time.Time
	already_used       *bool
	clearedFields      map[string]struct{}
	company            *int
	clearedcompany     bool
	created_by         *int
	clearedcreated_by  bool
	done               bool
	oldValue           func(context.Context) (*MemberSignupToken, error)
	predicates         []predicate.MemberSignupToken
}

var _ ent.Mutation = (*MemberSignupTokenMutation)(nil)

// membersignuptokenOption allows management of the mutation configuration using functional options.
type membersignuptokenOption func(*MemberSignupTokenMutation)

// newMemberSignupTokenMutation creates new mutation for the MemberSignupToken entity.
func newMemberSignupTokenMutation(c config, op Op, opts ...membersignuptokenOption) *MemberSignupTokenMutation {
	m := &MemberSignupTokenMutation{
		config:        c,
		op:            op,
		typ:           TypeMemberSignupToken,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withMemberSignupTokenID sets the ID field of the mutation.
func withMemberSignupTokenID(id int) membersignuptokenOption {
	return func(m *MemberSignupTokenMutation) {
		var (
			err   error
			once  sync.Once
			value *MemberSignupToken
		)
		m.oldValue = func(ctx context.Context) (*MemberSignupToken, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().MemberSignupToken.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withMemberSignupToken sets the old MemberSignupToken of the mutation.
func withMemberSignupToken(node *MemberSignupToken) membersignuptokenOption {
	return func(m *MemberSignupTokenMutation) {
		m.oldValue = func(context.Context) (*MemberSignupToken, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m MemberSignupTokenMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m MemberSignupTokenMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("generated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *MemberSignupTokenMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *MemberSignupTokenMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().MemberSignupToken.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *MemberSignupTokenMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *MemberSignupTokenMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the MemberSignupToken entity.
// If the MemberSignupToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberSignupTokenMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *MemberSignupTokenMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *MemberSignupTokenMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *MemberSignupTokenMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the MemberSignupToken entity.
// If the MemberSignupToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberSignupTokenMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *MemberSignupTokenMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *MemberSignupTokenMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *MemberSignupTokenMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the MemberSignupToken entity.
// If the MemberSignupToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberSignupTokenMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *MemberSignupTokenMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[membersignuptoken.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *MemberSignupTokenMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[membersignuptoken.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *MemberSignupTokenMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, membersignuptoken.FieldDeletedAt)
}

// SetName sets the "name" field.
func (m *MemberSignupTokenMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *MemberSignupTokenMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the MemberSignupToken entity.
// If the MemberSignupToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberSignupTokenMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *MemberSignupTokenMutation) ResetName() {
	m.name = nil
}

// SetEmail sets the "email" field.
func (m *MemberSignupTokenMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *MemberSignupTokenMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the MemberSignupToken entity.
// If the MemberSignupToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberSignupTokenMutation) OldEmail(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ClearEmail clears the value of the "email" field.
func (m *MemberSignupTokenMutation) ClearEmail() {
	m.email = nil
	m.clearedFields[membersignuptoken.FieldEmail] = struct{}{}
}

// EmailCleared returns if the "email" field was cleared in this mutation.
func (m *MemberSignupTokenMutation) EmailCleared() bool {
	_, ok := m.clearedFields[membersignuptoken.FieldEmail]
	return ok
}

// ResetEmail resets all changes to the "email" field.
func (m *MemberSignupTokenMutation) ResetEmail() {
	m.email = nil
	delete(m.clearedFields, membersignuptoken.FieldEmail)
}

// SetToken sets the "token" field.
func (m *MemberSignupTokenMutation) SetToken(s string) {
	m.token = &s
}

// Token returns the value of the "token" field in the mutation.
func (m *MemberSignupTokenMutation) Token() (r string, exists bool) {
	v := m.token
	if v == nil {
		return
	}
	return *v, true
}

// OldToken returns the old "token" field's value of the MemberSignupToken entity.
// If the MemberSignupToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberSignupTokenMutation) OldToken(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldToken is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldToken requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldToken: %w", err)
	}
	return oldValue.Token, nil
}

// ResetToken resets all changes to the "token" field.
func (m *MemberSignupTokenMutation) ResetToken() {
	m.token = nil
}

// SetAvatar sets the "avatar" field.
func (m *MemberSignupTokenMutation) SetAvatar(s string) {
	m.avatar = &s
}

// Avatar returns the value of the "avatar" field in the mutation.
func (m *MemberSignupTokenMutation) Avatar() (r string, exists bool) {
	v := m.avatar
	if v == nil {
		return
	}
	return *v, true
}

// OldAvatar returns the old "avatar" field's value of the MemberSignupToken entity.
// If the MemberSignupToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberSignupTokenMutation) OldAvatar(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAvatar is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAvatar requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAvatar: %w", err)
	}
	return oldValue.Avatar, nil
}

// ResetAvatar resets all changes to the "avatar" field.
func (m *MemberSignupTokenMutation) ResetAvatar() {
	m.avatar = nil
}

// SetRole sets the "role" field.
func (m *MemberSignupTokenMutation) SetRole(value membersignuptoken.Role) {
	m.role = &value
}

// Role returns the value of the "role" field in the mutation.
func (m *MemberSignupTokenMutation) Role() (r membersignuptoken.Role, exists bool) {
	v := m.role
	if v == nil {
		return
	}
	return *v, true
}

// OldRole returns the old "role" field's value of the MemberSignupToken entity.
// If the MemberSignupToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberSignupTokenMutation) OldRole(ctx context.Context) (v membersignuptoken.Role, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRole is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRole requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRole: %w", err)
	}
	return oldValue.Role, nil
}

// ResetRole resets all changes to the "role" field.
func (m *MemberSignupTokenMutation) ResetRole() {
	m.role = nil
}

// SetNote sets the "note" field.
func (m *MemberSignupTokenMutation) SetNote(s string) {
	m.note = &s
}

// Note returns the value of the "note" field in the mutation.
func (m *MemberSignupTokenMutation) Note() (r string, exists bool) {
	v := m.note
	if v == nil {
		return
	}
	return *v, true
}

// OldNote returns the old "note" field's value of the MemberSignupToken entity.
// If the MemberSignupToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberSignupTokenMutation) OldNote(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNote is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNote requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNote: %w", err)
	}
	return oldValue.Note, nil
}

// ResetNote resets all changes to the "note" field.
func (m *MemberSignupTokenMutation) ResetNote() {
	m.note = nil
}

// SetNumberAccessed sets the "number_accessed" field.
func (m *MemberSignupTokenMutation) SetNumberAccessed(i int) {
	m.number_accessed = &i
	m.addnumber_accessed = nil
}

// NumberAccessed returns the value of the "number_accessed" field in the mutation.
func (m *MemberSignupTokenMutation) NumberAccessed() (r int, exists bool) {
	v := m.number_accessed
	if v == nil {
		return
	}
	return *v, true
}

// OldNumberAccessed returns the old "number_accessed" field's value of the MemberSignupToken entity.
// If the MemberSignupToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberSignupTokenMutation) OldNumberAccessed(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNumberAccessed is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNumberAccessed requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNumberAccessed: %w", err)
	}
	return oldValue.NumberAccessed, nil
}

// AddNumberAccessed adds i to the "number_accessed" field.
func (m *MemberSignupTokenMutation) AddNumberAccessed(i int) {
	if m.addnumber_accessed != nil {
		*m.addnumber_accessed += i
	} else {
		m.addnumber_accessed = &i
	}
}

// AddedNumberAccessed returns the value that was added to the "number_accessed" field in this mutation.
func (m *MemberSignupTokenMutation) AddedNumberAccessed() (r int, exists bool) {
	v := m.addnumber_accessed
	if v == nil {
		return
	}
	return *v, true
}

// ResetNumberAccessed resets all changes to the "number_accessed" field.
func (m *MemberSignupTokenMutation) ResetNumberAccessed() {
	m.number_accessed = nil
	m.addnumber_accessed = nil
}

// SetExpiresAt sets the "expires_at" field.
func (m *MemberSignupTokenMutation) SetExpiresAt(t time.Time) {
	m.expires_at = &t
}

// ExpiresAt returns the value of the "expires_at" field in the mutation.
func (m *MemberSignupTokenMutation) ExpiresAt() (r time.Time, exists bool) {
	v := m.expires_at
	if v == nil {
		return
	}
	return *v, true
}

// OldExpiresAt returns the old "expires_at" field's value of the MemberSignupToken entity.
// If the MemberSignupToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberSignupTokenMutation) OldExpiresAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExpiresAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExpiresAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpiresAt: %w", err)
	}
	return oldValue.ExpiresAt, nil
}

// ResetExpiresAt resets all changes to the "expires_at" field.
func (m *MemberSignupTokenMutation) ResetExpiresAt() {
	m.expires_at = nil
}

// SetAlreadyUsed sets the "already_used" field.
func (m *MemberSignupTokenMutation) SetAlreadyUsed(b bool) {
	m.already_used = &b
}

// AlreadyUsed returns the value of the "already_used" field in the mutation.
func (m *MemberSignupTokenMutation) AlreadyUsed() (r bool, exists bool) {
	v := m.already_used
	if v == nil {
		return
	}
	return *v, true
}

// OldAlreadyUsed returns the old "already_used" field's value of the MemberSignupToken entity.
// If the MemberSignupToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberSignupTokenMutation) OldAlreadyUsed(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAlreadyUsed is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAlreadyUsed requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAlreadyUsed: %w", err)
	}
	return oldValue.AlreadyUsed, nil
}

// ResetAlreadyUsed resets all changes to the "already_used" field.
func (m *MemberSignupTokenMutation) ResetAlreadyUsed() {
	m.already_used = nil
}

// SetCompanyID sets the "company" edge to the Company entity by id.
func (m *MemberSignupTokenMutation) SetCompanyID(id int) {
	m.company = &id
}

// ClearCompany clears the "company" edge to the Company entity.
func (m *MemberSignupTokenMutation) ClearCompany() {
	m.clearedcompany = true
}

// CompanyCleared reports if the "company" edge to the Company entity was cleared.
func (m *MemberSignupTokenMutation) CompanyCleared() bool {
	return m.clearedcompany
}

// CompanyID returns the "company" edge ID in the mutation.
func (m *MemberSignupTokenMutation) CompanyID() (id int, exists bool) {
	if m.company != nil {
		return *m.company, true
	}
	return
}

// CompanyIDs returns the "company" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CompanyID instead. It exists only for internal usage by the builders.
func (m *MemberSignupTokenMutation) CompanyIDs() (ids []int) {
	if id := m.company; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCompany resets all changes to the "company" edge.
func (m *MemberSignupTokenMutation) ResetCompany() {
	m.company = nil
	m.clearedcompany = false
}

// SetCreatedByID sets the "created_by" edge to the User entity by id.
func (m *MemberSignupTokenMutation) SetCreatedByID(id int) {
	m.created_by = &id
}

// ClearCreatedBy clears the "created_by" edge to the User entity.
func (m *MemberSignupTokenMutation) ClearCreatedBy() {
	m.clearedcreated_by = true
}

// CreatedByCleared reports if the "created_by" edge to the User entity was cleared.
func (m *MemberSignupTokenMutation) CreatedByCleared() bool {
	return m.clearedcreated_by
}

// CreatedByID returns the "created_by" edge ID in the mutation.
func (m *MemberSignupTokenMutation) CreatedByID() (id int, exists bool) {
	if m.created_by != nil {
		return *m.created_by, true
	}
	return
}

// CreatedByIDs returns the "created_by" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CreatedByID instead. It exists only for internal usage by the builders.
func (m *MemberSignupTokenMutation) CreatedByIDs() (ids []int) {
	if id := m.created_by; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCreatedBy resets all changes to the "created_by" edge.
func (m *MemberSignupTokenMutation) ResetCreatedBy() {
	m.created_by = nil
	m.clearedcreated_by = false
}

// Where appends a list predicates to the MemberSignupTokenMutation builder.
func (m *MemberSignupTokenMutation) Where(ps ...predicate.MemberSignupToken) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the MemberSignupTokenMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *MemberSignupTokenMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.MemberSignupToken, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *MemberSignupTokenMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *MemberSignupTokenMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (MemberSignupToken).
func (m *MemberSignupTokenMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *MemberSignupTokenMutation) Fields() []string {
	fields := make([]string, 0, 12)
	if m.created_at != nil {
		fields = append(fields, membersignuptoken.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, membersignuptoken.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, membersignuptoken.FieldDeletedAt)
	}
	if m.name != nil {
		fields = append(fields, membersignuptoken.FieldName)
	}
	if m.email != nil {
		fields = append(fields, membersignuptoken.FieldEmail)
	}
	if m.token != nil {
		fields = append(fields, membersignuptoken.FieldToken)
	}
	if m.avatar != nil {
		fields = append(fields, membersignuptoken.FieldAvatar)
	}
	if m.role != nil {
		fields = append(fields, membersignuptoken.FieldRole)
	}
	if m.note != nil {
		fields = append(fields, membersignuptoken.FieldNote)
	}
	if m.number_accessed != nil {
		fields = append(fields, membersignuptoken.FieldNumberAccessed)
	}
	if m.expires_at != nil {
		fields = append(fields, membersignuptoken.FieldExpiresAt)
	}
	if m.already_used != nil {
		fields = append(fields, membersignuptoken.FieldAlreadyUsed)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *MemberSignupTokenMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case membersignuptoken.FieldCreatedAt:
		return m.CreatedAt()
	case membersignuptoken.FieldUpdatedAt:
		return m.UpdatedAt()
	case membersignuptoken.FieldDeletedAt:
		return m.DeletedAt()
	case membersignuptoken.FieldName:
		return m.Name()
	case membersignuptoken.FieldEmail:
		return m.Email()
	case membersignuptoken.FieldToken:
		return m.Token()
	case membersignuptoken.FieldAvatar:
		return m.Avatar()
	case membersignuptoken.FieldRole:
		return m.Role()
	case membersignuptoken.FieldNote:
		return m.Note()
	case membersignuptoken.FieldNumberAccessed:
		return m.NumberAccessed()
	case membersignuptoken.FieldExpiresAt:
		return m.ExpiresAt()
	case membersignuptoken.FieldAlreadyUsed:
		return m.AlreadyUsed()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *MemberSignupTokenMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case membersignuptoken.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case membersignuptoken.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case membersignuptoken.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case membersignuptoken.FieldName:
		return m.OldName(ctx)
	case membersignuptoken.FieldEmail:
		return m.OldEmail(ctx)
	case membersignuptoken.FieldToken:
		return m.OldToken(ctx)
	case membersignuptoken.FieldAvatar:
		return m.OldAvatar(ctx)
	case membersignuptoken.FieldRole:
		return m.OldRole(ctx)
	case membersignuptoken.FieldNote:
		return m.OldNote(ctx)
	case membersignuptoken.FieldNumberAccessed:
		return m.OldNumberAccessed(ctx)
	case membersignuptoken.FieldExpiresAt:
		return m.OldExpiresAt(ctx)
	case membersignuptoken.FieldAlreadyUsed:
		return m.OldAlreadyUsed(ctx)
	}
	return nil, fmt.Errorf("unknown MemberSignupToken field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MemberSignupTokenMutation) SetField(name string, value ent.Value) error {
	switch name {
	case membersignuptoken.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case membersignuptoken.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case membersignuptoken.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case membersignuptoken.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case membersignuptoken.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case membersignuptoken.FieldToken:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetToken(v)
		return nil
	case membersignuptoken.FieldAvatar:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAvatar(v)
		return nil
	case membersignuptoken.FieldRole:
		v, ok := value.(membersignuptoken.Role)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRole(v)
		return nil
	case membersignuptoken.FieldNote:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNote(v)
		return nil
	case membersignuptoken.FieldNumberAccessed:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNumberAccessed(v)
		return nil
	case membersignuptoken.FieldExpiresAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpiresAt(v)
		return nil
	case membersignuptoken.FieldAlreadyUsed:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAlreadyUsed(v)
		return nil
	}
	return fmt.Errorf("unknown MemberSignupToken field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *MemberSignupTokenMutation) AddedFields() []string {
	var fields []string
	if m.addnumber_accessed != nil {
		fields = append(fields, membersignuptoken.FieldNumberAccessed)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *MemberSignupTokenMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case membersignuptoken.FieldNumberAccessed:
		return m.AddedNumberAccessed()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MemberSignupTokenMutation) AddField(name string, value ent.Value) error {
	switch name {
	case membersignuptoken.FieldNumberAccessed:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddNumberAccessed(v)
		return nil
	}
	return fmt.Errorf("unknown MemberSignupToken numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *MemberSignupTokenMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(membersignuptoken.FieldDeletedAt) {
		fields = append(fields, membersignuptoken.FieldDeletedAt)
	}
	if m.FieldCleared(membersignuptoken.FieldEmail) {
		fields = append(fields, membersignuptoken.FieldEmail)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *MemberSignupTokenMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *MemberSignupTokenMutation) ClearField(name string) error {
	switch name {
	case membersignuptoken.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case membersignuptoken.FieldEmail:
		m.ClearEmail()
		return nil
	}
	return fmt.Errorf("unknown MemberSignupToken nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *MemberSignupTokenMutation) ResetField(name string) error {
	switch name {
	case membersignuptoken.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case membersignuptoken.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case membersignuptoken.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case membersignuptoken.FieldName:
		m.ResetName()
		return nil
	case membersignuptoken.FieldEmail:
		m.ResetEmail()
		return nil
	case membersignuptoken.FieldToken:
		m.ResetToken()
		return nil
	case membersignuptoken.FieldAvatar:
		m.ResetAvatar()
		return nil
	case membersignuptoken.FieldRole:
		m.ResetRole()
		return nil
	case membersignuptoken.FieldNote:
		m.ResetNote()
		return nil
	case membersignuptoken.FieldNumberAccessed:
		m.ResetNumberAccessed()
		return nil
	case membersignuptoken.FieldExpiresAt:
		m.ResetExpiresAt()
		return nil
	case membersignuptoken.FieldAlreadyUsed:
		m.ResetAlreadyUsed()
		return nil
	}
	return fmt.Errorf("unknown MemberSignupToken field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *MemberSignupTokenMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.company != nil {
		edges = append(edges, membersignuptoken.EdgeCompany)
	}
	if m.created_by != nil {
		edges = append(edges, membersignuptoken.EdgeCreatedBy)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *MemberSignupTokenMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case membersignuptoken.EdgeCompany:
		if id := m.company; id != nil {
			return []ent.Value{*id}
		}
	case membersignuptoken.EdgeCreatedBy:
		if id := m.created_by; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *MemberSignupTokenMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *MemberSignupTokenMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *MemberSignupTokenMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedcompany {
		edges = append(edges, membersignuptoken.EdgeCompany)
	}
	if m.clearedcreated_by {
		edges = append(edges, membersignuptoken.EdgeCreatedBy)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *MemberSignupTokenMutation) EdgeCleared(name string) bool {
	switch name {
	case membersignuptoken.EdgeCompany:
		return m.clearedcompany
	case membersignuptoken.EdgeCreatedBy:
		return m.clearedcreated_by
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *MemberSignupTokenMutation) ClearEdge(name string) error {
	switch name {
	case membersignuptoken.EdgeCompany:
		m.ClearCompany()
		return nil
	case membersignuptoken.EdgeCreatedBy:
		m.ClearCreatedBy()
		return nil
	}
	return fmt.Errorf("unknown MemberSignupToken unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *MemberSignupTokenMutation) ResetEdge(name string) error {
	switch name {
	case membersignuptoken.EdgeCompany:
		m.ResetCompany()
		return nil
	case membersignuptoken.EdgeCreatedBy:
		m.ResetCreatedBy()
		return nil
	}
	return fmt.Errorf("unknown MemberSignupToken edge %s", name)
}

// PayableMutation represents an operation that mutates the Payable nodes in the graph.
type PayableMutation struct {
	config
	op                     Op
	typ                    string
	id                     *int
	created_at             *time.Time
	updated_at             *time.Time
	deleted_at             *time.Time
	entry_group            *int
	addentry_group         *int
	date                   *time.Time
	name                   *string
	amount_in_default      *float64
	addamount_in_default   *float64
	outstanding_balance    *float64
	addoutstanding_balance *float64
	total_transaction      *float64
	addtotal_transaction   *float64
	due_date               *time.Time
	status                 *payable.Status
	clearedFields          map[string]struct{}
	company                *int
	clearedcompany         bool
	done                   bool
	oldValue               func(context.Context) (*Payable, error)
	predicates             []predicate.Payable
}

var _ ent.Mutation = (*PayableMutation)(nil)

// payableOption allows management of the mutation configuration using functional options.
type payableOption func(*PayableMutation)

// newPayableMutation creates new mutation for the Payable entity.
func newPayableMutation(c config, op Op, opts ...payableOption) *PayableMutation {
	m := &PayableMutation{
		config:        c,
		op:            op,
		typ:           TypePayable,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPayableID sets the ID field of the mutation.
func withPayableID(id int) payableOption {
	return func(m *PayableMutation) {
		var (
			err   error
			once  sync.Once
			value *Payable
		)
		m.oldValue = func(ctx context.Context) (*Payable, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Payable.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPayable sets the old Payable of the mutation.
func withPayable(node *Payable) payableOption {
	return func(m *PayableMutation) {
		m.oldValue = func(context.Context) (*Payable, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PayableMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PayableMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("generated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PayableMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PayableMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Payable.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *PayableMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *PayableMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Payable entity.
// If the Payable object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PayableMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *PayableMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *PayableMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *PayableMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Payable entity.
// If the Payable object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PayableMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *PayableMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *PayableMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *PayableMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Payable entity.
// If the Payable object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PayableMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *PayableMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[payable.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *PayableMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[payable.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *PayableMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, payable.FieldDeletedAt)
}

// SetEntryGroup sets the "entry_group" field.
func (m *PayableMutation) SetEntryGroup(i int) {
	m.entry_group = &i
	m.addentry_group = nil
}

// EntryGroup returns the value of the "entry_group" field in the mutation.
func (m *PayableMutation) EntryGroup() (r int, exists bool) {
	v := m.entry_group
	if v == nil {
		return
	}
	return *v, true
}

// OldEntryGroup returns the old "entry_group" field's value of the Payable entity.
// If the Payable object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PayableMutation) OldEntryGroup(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEntryGroup is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEntryGroup requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEntryGroup: %w", err)
	}
	return oldValue.EntryGroup, nil
}

// AddEntryGroup adds i to the "entry_group" field.
func (m *PayableMutation) AddEntryGroup(i int) {
	if m.addentry_group != nil {
		*m.addentry_group += i
	} else {
		m.addentry_group = &i
	}
}

// AddedEntryGroup returns the value that was added to the "entry_group" field in this mutation.
func (m *PayableMutation) AddedEntryGroup() (r int, exists bool) {
	v := m.addentry_group
	if v == nil {
		return
	}
	return *v, true
}

// ResetEntryGroup resets all changes to the "entry_group" field.
func (m *PayableMutation) ResetEntryGroup() {
	m.entry_group = nil
	m.addentry_group = nil
}

// SetDate sets the "date" field.
func (m *PayableMutation) SetDate(t time.Time) {
	m.date = &t
}

// Date returns the value of the "date" field in the mutation.
func (m *PayableMutation) Date() (r time.Time, exists bool) {
	v := m.date
	if v == nil {
		return
	}
	return *v, true
}

// OldDate returns the old "date" field's value of the Payable entity.
// If the Payable object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PayableMutation) OldDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDate: %w", err)
	}
	return oldValue.Date, nil
}

// ResetDate resets all changes to the "date" field.
func (m *PayableMutation) ResetDate() {
	m.date = nil
}

// SetName sets the "name" field.
func (m *PayableMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *PayableMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Payable entity.
// If the Payable object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PayableMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *PayableMutation) ResetName() {
	m.name = nil
}

// SetAmountInDefault sets the "amount_in_default" field.
func (m *PayableMutation) SetAmountInDefault(f float64) {
	m.amount_in_default = &f
	m.addamount_in_default = nil
}

// AmountInDefault returns the value of the "amount_in_default" field in the mutation.
func (m *PayableMutation) AmountInDefault() (r float64, exists bool) {
	v := m.amount_in_default
	if v == nil {
		return
	}
	return *v, true
}

// OldAmountInDefault returns the old "amount_in_default" field's value of the Payable entity.
// If the Payable object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PayableMutation) OldAmountInDefault(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAmountInDefault is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAmountInDefault requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAmountInDefault: %w", err)
	}
	return oldValue.AmountInDefault, nil
}

// AddAmountInDefault adds f to the "amount_in_default" field.
func (m *PayableMutation) AddAmountInDefault(f float64) {
	if m.addamount_in_default != nil {
		*m.addamount_in_default += f
	} else {
		m.addamount_in_default = &f
	}
}

// AddedAmountInDefault returns the value that was added to the "amount_in_default" field in this mutation.
func (m *PayableMutation) AddedAmountInDefault() (r float64, exists bool) {
	v := m.addamount_in_default
	if v == nil {
		return
	}
	return *v, true
}

// ResetAmountInDefault resets all changes to the "amount_in_default" field.
func (m *PayableMutation) ResetAmountInDefault() {
	m.amount_in_default = nil
	m.addamount_in_default = nil
}

// SetOutstandingBalance sets the "outstanding_balance" field.
func (m *PayableMutation) SetOutstandingBalance(f float64) {
	m.outstanding_balance = &f
	m.addoutstanding_balance = nil
}

// OutstandingBalance returns the value of the "outstanding_balance" field in the mutation.
func (m *PayableMutation) OutstandingBalance() (r float64, exists bool) {
	v := m.outstanding_balance
	if v == nil {
		return
	}
	return *v, true
}

// OldOutstandingBalance returns the old "outstanding_balance" field's value of the Payable entity.
// If the Payable object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PayableMutation) OldOutstandingBalance(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOutstandingBalance is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOutstandingBalance requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOutstandingBalance: %w", err)
	}
	return oldValue.OutstandingBalance, nil
}

// AddOutstandingBalance adds f to the "outstanding_balance" field.
func (m *PayableMutation) AddOutstandingBalance(f float64) {
	if m.addoutstanding_balance != nil {
		*m.addoutstanding_balance += f
	} else {
		m.addoutstanding_balance = &f
	}
}

// AddedOutstandingBalance returns the value that was added to the "outstanding_balance" field in this mutation.
func (m *PayableMutation) AddedOutstandingBalance() (r float64, exists bool) {
	v := m.addoutstanding_balance
	if v == nil {
		return
	}
	return *v, true
}

// ResetOutstandingBalance resets all changes to the "outstanding_balance" field.
func (m *PayableMutation) ResetOutstandingBalance() {
	m.outstanding_balance = nil
	m.addoutstanding_balance = nil
}

// SetTotalTransaction sets the "total_transaction" field.
func (m *PayableMutation) SetTotalTransaction(f float64) {
	m.total_transaction = &f
	m.addtotal_transaction = nil
}

// TotalTransaction returns the value of the "total_transaction" field in the mutation.
func (m *PayableMutation) TotalTransaction() (r float64, exists bool) {
	v := m.total_transaction
	if v == nil {
		return
	}
	return *v, true
}

// OldTotalTransaction returns the old "total_transaction" field's value of the Payable entity.
// If the Payable object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PayableMutation) OldTotalTransaction(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTotalTransaction is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTotalTransaction requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTotalTransaction: %w", err)
	}
	return oldValue.TotalTransaction, nil
}

// AddTotalTransaction adds f to the "total_transaction" field.
func (m *PayableMutation) AddTotalTransaction(f float64) {
	if m.addtotal_transaction != nil {
		*m.addtotal_transaction += f
	} else {
		m.addtotal_transaction = &f
	}
}

// AddedTotalTransaction returns the value that was added to the "total_transaction" field in this mutation.
func (m *PayableMutation) AddedTotalTransaction() (r float64, exists bool) {
	v := m.addtotal_transaction
	if v == nil {
		return
	}
	return *v, true
}

// ResetTotalTransaction resets all changes to the "total_transaction" field.
func (m *PayableMutation) ResetTotalTransaction() {
	m.total_transaction = nil
	m.addtotal_transaction = nil
}

// SetDueDate sets the "due_date" field.
func (m *PayableMutation) SetDueDate(t time.Time) {
	m.due_date = &t
}

// DueDate returns the value of the "due_date" field in the mutation.
func (m *PayableMutation) DueDate() (r time.Time, exists bool) {
	v := m.due_date
	if v == nil {
		return
	}
	return *v, true
}

// OldDueDate returns the old "due_date" field's value of the Payable entity.
// If the Payable object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PayableMutation) OldDueDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDueDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDueDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDueDate: %w", err)
	}
	return oldValue.DueDate, nil
}

// ResetDueDate resets all changes to the "due_date" field.
func (m *PayableMutation) ResetDueDate() {
	m.due_date = nil
}

// SetStatus sets the "status" field.
func (m *PayableMutation) SetStatus(pa payable.Status) {
	m.status = &pa
}

// Status returns the value of the "status" field in the mutation.
func (m *PayableMutation) Status() (r payable.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Payable entity.
// If the Payable object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PayableMutation) OldStatus(ctx context.Context) (v payable.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *PayableMutation) ResetStatus() {
	m.status = nil
}

// SetCompanyID sets the "company" edge to the Company entity by id.
func (m *PayableMutation) SetCompanyID(id int) {
	m.company = &id
}

// ClearCompany clears the "company" edge to the Company entity.
func (m *PayableMutation) ClearCompany() {
	m.clearedcompany = true
}

// CompanyCleared reports if the "company" edge to the Company entity was cleared.
func (m *PayableMutation) CompanyCleared() bool {
	return m.clearedcompany
}

// CompanyID returns the "company" edge ID in the mutation.
func (m *PayableMutation) CompanyID() (id int, exists bool) {
	if m.company != nil {
		return *m.company, true
	}
	return
}

// CompanyIDs returns the "company" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CompanyID instead. It exists only for internal usage by the builders.
func (m *PayableMutation) CompanyIDs() (ids []int) {
	if id := m.company; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCompany resets all changes to the "company" edge.
func (m *PayableMutation) ResetCompany() {
	m.company = nil
	m.clearedcompany = false
}

// Where appends a list predicates to the PayableMutation builder.
func (m *PayableMutation) Where(ps ...predicate.Payable) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PayableMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PayableMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Payable, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PayableMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PayableMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Payable).
func (m *PayableMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PayableMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.created_at != nil {
		fields = append(fields, payable.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, payable.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, payable.FieldDeletedAt)
	}
	if m.entry_group != nil {
		fields = append(fields, payable.FieldEntryGroup)
	}
	if m.date != nil {
		fields = append(fields, payable.FieldDate)
	}
	if m.name != nil {
		fields = append(fields, payable.FieldName)
	}
	if m.amount_in_default != nil {
		fields = append(fields, payable.FieldAmountInDefault)
	}
	if m.outstanding_balance != nil {
		fields = append(fields, payable.FieldOutstandingBalance)
	}
	if m.total_transaction != nil {
		fields = append(fields, payable.FieldTotalTransaction)
	}
	if m.due_date != nil {
		fields = append(fields, payable.FieldDueDate)
	}
	if m.status != nil {
		fields = append(fields, payable.FieldStatus)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PayableMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case payable.FieldCreatedAt:
		return m.CreatedAt()
	case payable.FieldUpdatedAt:
		return m.UpdatedAt()
	case payable.FieldDeletedAt:
		return m.DeletedAt()
	case payable.FieldEntryGroup:
		return m.EntryGroup()
	case payable.FieldDate:
		return m.Date()
	case payable.FieldName:
		return m.Name()
	case payable.FieldAmountInDefault:
		return m.AmountInDefault()
	case payable.FieldOutstandingBalance:
		return m.OutstandingBalance()
	case payable.FieldTotalTransaction:
		return m.TotalTransaction()
	case payable.FieldDueDate:
		return m.DueDate()
	case payable.FieldStatus:
		return m.Status()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PayableMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case payable.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case payable.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case payable.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case payable.FieldEntryGroup:
		return m.OldEntryGroup(ctx)
	case payable.FieldDate:
		return m.OldDate(ctx)
	case payable.FieldName:
		return m.OldName(ctx)
	case payable.FieldAmountInDefault:
		return m.OldAmountInDefault(ctx)
	case payable.FieldOutstandingBalance:
		return m.OldOutstandingBalance(ctx)
	case payable.FieldTotalTransaction:
		return m.OldTotalTransaction(ctx)
	case payable.FieldDueDate:
		return m.OldDueDate(ctx)
	case payable.FieldStatus:
		return m.OldStatus(ctx)
	}
	return nil, fmt.Errorf("unknown Payable field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PayableMutation) SetField(name string, value ent.Value) error {
	switch name {
	case payable.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case payable.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case payable.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case payable.FieldEntryGroup:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEntryGroup(v)
		return nil
	case payable.FieldDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDate(v)
		return nil
	case payable.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case payable.FieldAmountInDefault:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAmountInDefault(v)
		return nil
	case payable.FieldOutstandingBalance:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOutstandingBalance(v)
		return nil
	case payable.FieldTotalTransaction:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTotalTransaction(v)
		return nil
	case payable.FieldDueDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDueDate(v)
		return nil
	case payable.FieldStatus:
		v, ok := value.(payable.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	}
	return fmt.Errorf("unknown Payable field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PayableMutation) AddedFields() []string {
	var fields []string
	if m.addentry_group != nil {
		fields = append(fields, payable.FieldEntryGroup)
	}
	if m.addamount_in_default != nil {
		fields = append(fields, payable.FieldAmountInDefault)
	}
	if m.addoutstanding_balance != nil {
		fields = append(fields, payable.FieldOutstandingBalance)
	}
	if m.addtotal_transaction != nil {
		fields = append(fields, payable.FieldTotalTransaction)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PayableMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case payable.FieldEntryGroup:
		return m.AddedEntryGroup()
	case payable.FieldAmountInDefault:
		return m.AddedAmountInDefault()
	case payable.FieldOutstandingBalance:
		return m.AddedOutstandingBalance()
	case payable.FieldTotalTransaction:
		return m.AddedTotalTransaction()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PayableMutation) AddField(name string, value ent.Value) error {
	switch name {
	case payable.FieldEntryGroup:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddEntryGroup(v)
		return nil
	case payable.FieldAmountInDefault:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAmountInDefault(v)
		return nil
	case payable.FieldOutstandingBalance:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOutstandingBalance(v)
		return nil
	case payable.FieldTotalTransaction:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTotalTransaction(v)
		return nil
	}
	return fmt.Errorf("unknown Payable numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PayableMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(payable.FieldDeletedAt) {
		fields = append(fields, payable.FieldDeletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PayableMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PayableMutation) ClearField(name string) error {
	switch name {
	case payable.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown Payable nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PayableMutation) ResetField(name string) error {
	switch name {
	case payable.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case payable.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case payable.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case payable.FieldEntryGroup:
		m.ResetEntryGroup()
		return nil
	case payable.FieldDate:
		m.ResetDate()
		return nil
	case payable.FieldName:
		m.ResetName()
		return nil
	case payable.FieldAmountInDefault:
		m.ResetAmountInDefault()
		return nil
	case payable.FieldOutstandingBalance:
		m.ResetOutstandingBalance()
		return nil
	case payable.FieldTotalTransaction:
		m.ResetTotalTransaction()
		return nil
	case payable.FieldDueDate:
		m.ResetDueDate()
		return nil
	case payable.FieldStatus:
		m.ResetStatus()
		return nil
	}
	return fmt.Errorf("unknown Payable field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PayableMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.company != nil {
		edges = append(edges, payable.EdgeCompany)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PayableMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case payable.EdgeCompany:
		if id := m.company; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PayableMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PayableMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PayableMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedcompany {
		edges = append(edges, payable.EdgeCompany)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PayableMutation) EdgeCleared(name string) bool {
	switch name {
	case payable.EdgeCompany:
		return m.clearedcompany
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PayableMutation) ClearEdge(name string) error {
	switch name {
	case payable.EdgeCompany:
		m.ClearCompany()
		return nil
	}
	return fmt.Errorf("unknown Payable unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PayableMutation) ResetEdge(name string) error {
	switch name {
	case payable.EdgeCompany:
		m.ResetCompany()
		return nil
	}
	return fmt.Errorf("unknown Payable edge %s", name)
}

// ProductMutation represents an operation that mutates the Product nodes in the graph.
type ProductMutation struct {
	config
	op             Op
	typ            string
	id             *int
	created_at     *time.Time
	updated_at     *time.Time
	deleted_at     *time.Time
	stock          *int
	addstock       *int
	clearedFields  map[string]struct{}
	company        *int
	clearedcompany bool
	done           bool
	oldValue       func(context.Context) (*Product, error)
	predicates     []predicate.Product
}

var _ ent.Mutation = (*ProductMutation)(nil)

// productOption allows management of the mutation configuration using functional options.
type productOption func(*ProductMutation)

// newProductMutation creates new mutation for the Product entity.
func newProductMutation(c config, op Op, opts ...productOption) *ProductMutation {
	m := &ProductMutation{
		config:        c,
		op:            op,
		typ:           TypeProduct,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withProductID sets the ID field of the mutation.
func withProductID(id int) productOption {
	return func(m *ProductMutation) {
		var (
			err   error
			once  sync.Once
			value *Product
		)
		m.oldValue = func(ctx context.Context) (*Product, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Product.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withProduct sets the old Product of the mutation.
func withProduct(node *Product) productOption {
	return func(m *ProductMutation) {
		m.oldValue = func(context.Context) (*Product, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ProductMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ProductMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("generated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ProductMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ProductMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Product.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *ProductMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ProductMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ProductMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ProductMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ProductMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ProductMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *ProductMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *ProductMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *ProductMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[product.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *ProductMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[product.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *ProductMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, product.FieldDeletedAt)
}

// SetStock sets the "stock" field.
func (m *ProductMutation) SetStock(i int) {
	m.stock = &i
	m.addstock = nil
}

// Stock returns the value of the "stock" field in the mutation.
func (m *ProductMutation) Stock() (r int, exists bool) {
	v := m.stock
	if v == nil {
		return
	}
	return *v, true
}

// OldStock returns the old "stock" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldStock(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStock is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStock requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStock: %w", err)
	}
	return oldValue.Stock, nil
}

// AddStock adds i to the "stock" field.
func (m *ProductMutation) AddStock(i int) {
	if m.addstock != nil {
		*m.addstock += i
	} else {
		m.addstock = &i
	}
}

// AddedStock returns the value that was added to the "stock" field in this mutation.
func (m *ProductMutation) AddedStock() (r int, exists bool) {
	v := m.addstock
	if v == nil {
		return
	}
	return *v, true
}

// ResetStock resets all changes to the "stock" field.
func (m *ProductMutation) ResetStock() {
	m.stock = nil
	m.addstock = nil
}

// SetCompanyID sets the "company" edge to the Company entity by id.
func (m *ProductMutation) SetCompanyID(id int) {
	m.company = &id
}

// ClearCompany clears the "company" edge to the Company entity.
func (m *ProductMutation) ClearCompany() {
	m.clearedcompany = true
}

// CompanyCleared reports if the "company" edge to the Company entity was cleared.
func (m *ProductMutation) CompanyCleared() bool {
	return m.clearedcompany
}

// CompanyID returns the "company" edge ID in the mutation.
func (m *ProductMutation) CompanyID() (id int, exists bool) {
	if m.company != nil {
		return *m.company, true
	}
	return
}

// CompanyIDs returns the "company" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CompanyID instead. It exists only for internal usage by the builders.
func (m *ProductMutation) CompanyIDs() (ids []int) {
	if id := m.company; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCompany resets all changes to the "company" edge.
func (m *ProductMutation) ResetCompany() {
	m.company = nil
	m.clearedcompany = false
}

// Where appends a list predicates to the ProductMutation builder.
func (m *ProductMutation) Where(ps ...predicate.Product) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ProductMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ProductMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Product, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ProductMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ProductMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Product).
func (m *ProductMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ProductMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.created_at != nil {
		fields = append(fields, product.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, product.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, product.FieldDeletedAt)
	}
	if m.stock != nil {
		fields = append(fields, product.FieldStock)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ProductMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case product.FieldCreatedAt:
		return m.CreatedAt()
	case product.FieldUpdatedAt:
		return m.UpdatedAt()
	case product.FieldDeletedAt:
		return m.DeletedAt()
	case product.FieldStock:
		return m.Stock()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ProductMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case product.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case product.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case product.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case product.FieldStock:
		return m.OldStock(ctx)
	}
	return nil, fmt.Errorf("unknown Product field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProductMutation) SetField(name string, value ent.Value) error {
	switch name {
	case product.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case product.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case product.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case product.FieldStock:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStock(v)
		return nil
	}
	return fmt.Errorf("unknown Product field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ProductMutation) AddedFields() []string {
	var fields []string
	if m.addstock != nil {
		fields = append(fields, product.FieldStock)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ProductMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case product.FieldStock:
		return m.AddedStock()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProductMutation) AddField(name string, value ent.Value) error {
	switch name {
	case product.FieldStock:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStock(v)
		return nil
	}
	return fmt.Errorf("unknown Product numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ProductMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(product.FieldDeletedAt) {
		fields = append(fields, product.FieldDeletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ProductMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ProductMutation) ClearField(name string) error {
	switch name {
	case product.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown Product nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ProductMutation) ResetField(name string) error {
	switch name {
	case product.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case product.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case product.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case product.FieldStock:
		m.ResetStock()
		return nil
	}
	return fmt.Errorf("unknown Product field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ProductMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.company != nil {
		edges = append(edges, product.EdgeCompany)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ProductMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case product.EdgeCompany:
		if id := m.company; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ProductMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ProductMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ProductMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedcompany {
		edges = append(edges, product.EdgeCompany)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ProductMutation) EdgeCleared(name string) bool {
	switch name {
	case product.EdgeCompany:
		return m.clearedcompany
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ProductMutation) ClearEdge(name string) error {
	switch name {
	case product.EdgeCompany:
		m.ClearCompany()
		return nil
	}
	return fmt.Errorf("unknown Product unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ProductMutation) ResetEdge(name string) error {
	switch name {
	case product.EdgeCompany:
		m.ResetCompany()
		return nil
	}
	return fmt.Errorf("unknown Product edge %s", name)
}

// ProjectMutation represents an operation that mutates the Project nodes in the graph.
type ProjectMutation struct {
	config
	op                 Op
	typ                string
	id                 *int
	created_at         *time.Time
	updated_at         *time.Time
	deleted_at         *time.Time
	name               *string
	description        *string
	planned_start_date *time.Time
	actual_start_date  *time.Time
	planned_end_date   *time.Time
	actual_end_date    *time.Time
	progress           *float64
	addprogress        *float64
	status             *project.Status
	clearedFields      map[string]struct{}
	company            *int
	clearedcompany     bool
	created_by         *int
	clearedcreated_by  bool
	leader             *int
	clearedleader      bool
	tasks              map[int]struct{}
	removedtasks       map[int]struct{}
	clearedtasks       bool
	milestones         map[int]struct{}
	removedmilestones  map[int]struct{}
	clearedmilestones  bool
	done               bool
	oldValue           func(context.Context) (*Project, error)
	predicates         []predicate.Project
}

var _ ent.Mutation = (*ProjectMutation)(nil)

// projectOption allows management of the mutation configuration using functional options.
type projectOption func(*ProjectMutation)

// newProjectMutation creates new mutation for the Project entity.
func newProjectMutation(c config, op Op, opts ...projectOption) *ProjectMutation {
	m := &ProjectMutation{
		config:        c,
		op:            op,
		typ:           TypeProject,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withProjectID sets the ID field of the mutation.
func withProjectID(id int) projectOption {
	return func(m *ProjectMutation) {
		var (
			err   error
			once  sync.Once
			value *Project
		)
		m.oldValue = func(ctx context.Context) (*Project, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Project.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withProject sets the old Project of the mutation.
func withProject(node *Project) projectOption {
	return func(m *ProjectMutation) {
		m.oldValue = func(context.Context) (*Project, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ProjectMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ProjectMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("generated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ProjectMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ProjectMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Project.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *ProjectMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ProjectMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Project entity.
// If the Project object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ProjectMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ProjectMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ProjectMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Project entity.
// If the Project object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ProjectMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *ProjectMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *ProjectMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Project entity.
// If the Project object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *ProjectMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[project.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *ProjectMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[project.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *ProjectMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, project.FieldDeletedAt)
}

// SetName sets the "name" field.
func (m *ProjectMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ProjectMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Project entity.
// If the Project object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ProjectMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *ProjectMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *ProjectMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Project entity.
// If the Project object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *ProjectMutation) ResetDescription() {
	m.description = nil
}

// SetPlannedStartDate sets the "planned_start_date" field.
func (m *ProjectMutation) SetPlannedStartDate(t time.Time) {
	m.planned_start_date = &t
}

// PlannedStartDate returns the value of the "planned_start_date" field in the mutation.
func (m *ProjectMutation) PlannedStartDate() (r time.Time, exists bool) {
	v := m.planned_start_date
	if v == nil {
		return
	}
	return *v, true
}

// OldPlannedStartDate returns the old "planned_start_date" field's value of the Project entity.
// If the Project object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectMutation) OldPlannedStartDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPlannedStartDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPlannedStartDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPlannedStartDate: %w", err)
	}
	return oldValue.PlannedStartDate, nil
}

// ResetPlannedStartDate resets all changes to the "planned_start_date" field.
func (m *ProjectMutation) ResetPlannedStartDate() {
	m.planned_start_date = nil
}

// SetActualStartDate sets the "actual_start_date" field.
func (m *ProjectMutation) SetActualStartDate(t time.Time) {
	m.actual_start_date = &t
}

// ActualStartDate returns the value of the "actual_start_date" field in the mutation.
func (m *ProjectMutation) ActualStartDate() (r time.Time, exists bool) {
	v := m.actual_start_date
	if v == nil {
		return
	}
	return *v, true
}

// OldActualStartDate returns the old "actual_start_date" field's value of the Project entity.
// If the Project object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectMutation) OldActualStartDate(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldActualStartDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldActualStartDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldActualStartDate: %w", err)
	}
	return oldValue.ActualStartDate, nil
}

// ClearActualStartDate clears the value of the "actual_start_date" field.
func (m *ProjectMutation) ClearActualStartDate() {
	m.actual_start_date = nil
	m.clearedFields[project.FieldActualStartDate] = struct{}{}
}

// ActualStartDateCleared returns if the "actual_start_date" field was cleared in this mutation.
func (m *ProjectMutation) ActualStartDateCleared() bool {
	_, ok := m.clearedFields[project.FieldActualStartDate]
	return ok
}

// ResetActualStartDate resets all changes to the "actual_start_date" field.
func (m *ProjectMutation) ResetActualStartDate() {
	m.actual_start_date = nil
	delete(m.clearedFields, project.FieldActualStartDate)
}

// SetPlannedEndDate sets the "planned_end_date" field.
func (m *ProjectMutation) SetPlannedEndDate(t time.Time) {
	m.planned_end_date = &t
}

// PlannedEndDate returns the value of the "planned_end_date" field in the mutation.
func (m *ProjectMutation) PlannedEndDate() (r time.Time, exists bool) {
	v := m.planned_end_date
	if v == nil {
		return
	}
	return *v, true
}

// OldPlannedEndDate returns the old "planned_end_date" field's value of the Project entity.
// If the Project object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectMutation) OldPlannedEndDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPlannedEndDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPlannedEndDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPlannedEndDate: %w", err)
	}
	return oldValue.PlannedEndDate, nil
}

// ResetPlannedEndDate resets all changes to the "planned_end_date" field.
func (m *ProjectMutation) ResetPlannedEndDate() {
	m.planned_end_date = nil
}

// SetActualEndDate sets the "actual_end_date" field.
func (m *ProjectMutation) SetActualEndDate(t time.Time) {
	m.actual_end_date = &t
}

// ActualEndDate returns the value of the "actual_end_date" field in the mutation.
func (m *ProjectMutation) ActualEndDate() (r time.Time, exists bool) {
	v := m.actual_end_date
	if v == nil {
		return
	}
	return *v, true
}

// OldActualEndDate returns the old "actual_end_date" field's value of the Project entity.
// If the Project object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectMutation) OldActualEndDate(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldActualEndDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldActualEndDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldActualEndDate: %w", err)
	}
	return oldValue.ActualEndDate, nil
}

// ClearActualEndDate clears the value of the "actual_end_date" field.
func (m *ProjectMutation) ClearActualEndDate() {
	m.actual_end_date = nil
	m.clearedFields[project.FieldActualEndDate] = struct{}{}
}

// ActualEndDateCleared returns if the "actual_end_date" field was cleared in this mutation.
func (m *ProjectMutation) ActualEndDateCleared() bool {
	_, ok := m.clearedFields[project.FieldActualEndDate]
	return ok
}

// ResetActualEndDate resets all changes to the "actual_end_date" field.
func (m *ProjectMutation) ResetActualEndDate() {
	m.actual_end_date = nil
	delete(m.clearedFields, project.FieldActualEndDate)
}

// SetProgress sets the "progress" field.
func (m *ProjectMutation) SetProgress(f float64) {
	m.progress = &f
	m.addprogress = nil
}

// Progress returns the value of the "progress" field in the mutation.
func (m *ProjectMutation) Progress() (r float64, exists bool) {
	v := m.progress
	if v == nil {
		return
	}
	return *v, true
}

// OldProgress returns the old "progress" field's value of the Project entity.
// If the Project object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectMutation) OldProgress(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProgress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProgress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProgress: %w", err)
	}
	return oldValue.Progress, nil
}

// AddProgress adds f to the "progress" field.
func (m *ProjectMutation) AddProgress(f float64) {
	if m.addprogress != nil {
		*m.addprogress += f
	} else {
		m.addprogress = &f
	}
}

// AddedProgress returns the value that was added to the "progress" field in this mutation.
func (m *ProjectMutation) AddedProgress() (r float64, exists bool) {
	v := m.addprogress
	if v == nil {
		return
	}
	return *v, true
}

// ResetProgress resets all changes to the "progress" field.
func (m *ProjectMutation) ResetProgress() {
	m.progress = nil
	m.addprogress = nil
}

// SetStatus sets the "status" field.
func (m *ProjectMutation) SetStatus(pr project.Status) {
	m.status = &pr
}

// Status returns the value of the "status" field in the mutation.
func (m *ProjectMutation) Status() (r project.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Project entity.
// If the Project object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectMutation) OldStatus(ctx context.Context) (v project.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *ProjectMutation) ResetStatus() {
	m.status = nil
}

// SetCompanyID sets the "company" edge to the Company entity by id.
func (m *ProjectMutation) SetCompanyID(id int) {
	m.company = &id
}

// ClearCompany clears the "company" edge to the Company entity.
func (m *ProjectMutation) ClearCompany() {
	m.clearedcompany = true
}

// CompanyCleared reports if the "company" edge to the Company entity was cleared.
func (m *ProjectMutation) CompanyCleared() bool {
	return m.clearedcompany
}

// CompanyID returns the "company" edge ID in the mutation.
func (m *ProjectMutation) CompanyID() (id int, exists bool) {
	if m.company != nil {
		return *m.company, true
	}
	return
}

// CompanyIDs returns the "company" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CompanyID instead. It exists only for internal usage by the builders.
func (m *ProjectMutation) CompanyIDs() (ids []int) {
	if id := m.company; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCompany resets all changes to the "company" edge.
func (m *ProjectMutation) ResetCompany() {
	m.company = nil
	m.clearedcompany = false
}

// SetCreatedByID sets the "created_by" edge to the User entity by id.
func (m *ProjectMutation) SetCreatedByID(id int) {
	m.created_by = &id
}

// ClearCreatedBy clears the "created_by" edge to the User entity.
func (m *ProjectMutation) ClearCreatedBy() {
	m.clearedcreated_by = true
}

// CreatedByCleared reports if the "created_by" edge to the User entity was cleared.
func (m *ProjectMutation) CreatedByCleared() bool {
	return m.clearedcreated_by
}

// CreatedByID returns the "created_by" edge ID in the mutation.
func (m *ProjectMutation) CreatedByID() (id int, exists bool) {
	if m.created_by != nil {
		return *m.created_by, true
	}
	return
}

// CreatedByIDs returns the "created_by" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CreatedByID instead. It exists only for internal usage by the builders.
func (m *ProjectMutation) CreatedByIDs() (ids []int) {
	if id := m.created_by; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCreatedBy resets all changes to the "created_by" edge.
func (m *ProjectMutation) ResetCreatedBy() {
	m.created_by = nil
	m.clearedcreated_by = false
}

// SetLeaderID sets the "leader" edge to the User entity by id.
func (m *ProjectMutation) SetLeaderID(id int) {
	m.leader = &id
}

// ClearLeader clears the "leader" edge to the User entity.
func (m *ProjectMutation) ClearLeader() {
	m.clearedleader = true
}

// LeaderCleared reports if the "leader" edge to the User entity was cleared.
func (m *ProjectMutation) LeaderCleared() bool {
	return m.clearedleader
}

// LeaderID returns the "leader" edge ID in the mutation.
func (m *ProjectMutation) LeaderID() (id int, exists bool) {
	if m.leader != nil {
		return *m.leader, true
	}
	return
}

// LeaderIDs returns the "leader" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// LeaderID instead. It exists only for internal usage by the builders.
func (m *ProjectMutation) LeaderIDs() (ids []int) {
	if id := m.leader; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetLeader resets all changes to the "leader" edge.
func (m *ProjectMutation) ResetLeader() {
	m.leader = nil
	m.clearedleader = false
}

// AddTaskIDs adds the "tasks" edge to the ProjectTask entity by ids.
func (m *ProjectMutation) AddTaskIDs(ids ...int) {
	if m.tasks == nil {
		m.tasks = make(map[int]struct{})
	}
	for i := range ids {
		m.tasks[ids[i]] = struct{}{}
	}
}

// ClearTasks clears the "tasks" edge to the ProjectTask entity.
func (m *ProjectMutation) ClearTasks() {
	m.clearedtasks = true
}

// TasksCleared reports if the "tasks" edge to the ProjectTask entity was cleared.
func (m *ProjectMutation) TasksCleared() bool {
	return m.clearedtasks
}

// RemoveTaskIDs removes the "tasks" edge to the ProjectTask entity by IDs.
func (m *ProjectMutation) RemoveTaskIDs(ids ...int) {
	if m.removedtasks == nil {
		m.removedtasks = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.tasks, ids[i])
		m.removedtasks[ids[i]] = struct{}{}
	}
}

// RemovedTasks returns the removed IDs of the "tasks" edge to the ProjectTask entity.
func (m *ProjectMutation) RemovedTasksIDs() (ids []int) {
	for id := range m.removedtasks {
		ids = append(ids, id)
	}
	return
}

// TasksIDs returns the "tasks" edge IDs in the mutation.
func (m *ProjectMutation) TasksIDs() (ids []int) {
	for id := range m.tasks {
		ids = append(ids, id)
	}
	return
}

// ResetTasks resets all changes to the "tasks" edge.
func (m *ProjectMutation) ResetTasks() {
	m.tasks = nil
	m.clearedtasks = false
	m.removedtasks = nil
}

// AddMilestoneIDs adds the "milestones" edge to the ProjectMilestone entity by ids.
func (m *ProjectMutation) AddMilestoneIDs(ids ...int) {
	if m.milestones == nil {
		m.milestones = make(map[int]struct{})
	}
	for i := range ids {
		m.milestones[ids[i]] = struct{}{}
	}
}

// ClearMilestones clears the "milestones" edge to the ProjectMilestone entity.
func (m *ProjectMutation) ClearMilestones() {
	m.clearedmilestones = true
}

// MilestonesCleared reports if the "milestones" edge to the ProjectMilestone entity was cleared.
func (m *ProjectMutation) MilestonesCleared() bool {
	return m.clearedmilestones
}

// RemoveMilestoneIDs removes the "milestones" edge to the ProjectMilestone entity by IDs.
func (m *ProjectMutation) RemoveMilestoneIDs(ids ...int) {
	if m.removedmilestones == nil {
		m.removedmilestones = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.milestones, ids[i])
		m.removedmilestones[ids[i]] = struct{}{}
	}
}

// RemovedMilestones returns the removed IDs of the "milestones" edge to the ProjectMilestone entity.
func (m *ProjectMutation) RemovedMilestonesIDs() (ids []int) {
	for id := range m.removedmilestones {
		ids = append(ids, id)
	}
	return
}

// MilestonesIDs returns the "milestones" edge IDs in the mutation.
func (m *ProjectMutation) MilestonesIDs() (ids []int) {
	for id := range m.milestones {
		ids = append(ids, id)
	}
	return
}

// ResetMilestones resets all changes to the "milestones" edge.
func (m *ProjectMutation) ResetMilestones() {
	m.milestones = nil
	m.clearedmilestones = false
	m.removedmilestones = nil
}

// Where appends a list predicates to the ProjectMutation builder.
func (m *ProjectMutation) Where(ps ...predicate.Project) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ProjectMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ProjectMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Project, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ProjectMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ProjectMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Project).
func (m *ProjectMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ProjectMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.created_at != nil {
		fields = append(fields, project.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, project.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, project.FieldDeletedAt)
	}
	if m.name != nil {
		fields = append(fields, project.FieldName)
	}
	if m.description != nil {
		fields = append(fields, project.FieldDescription)
	}
	if m.planned_start_date != nil {
		fields = append(fields, project.FieldPlannedStartDate)
	}
	if m.actual_start_date != nil {
		fields = append(fields, project.FieldActualStartDate)
	}
	if m.planned_end_date != nil {
		fields = append(fields, project.FieldPlannedEndDate)
	}
	if m.actual_end_date != nil {
		fields = append(fields, project.FieldActualEndDate)
	}
	if m.progress != nil {
		fields = append(fields, project.FieldProgress)
	}
	if m.status != nil {
		fields = append(fields, project.FieldStatus)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ProjectMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case project.FieldCreatedAt:
		return m.CreatedAt()
	case project.FieldUpdatedAt:
		return m.UpdatedAt()
	case project.FieldDeletedAt:
		return m.DeletedAt()
	case project.FieldName:
		return m.Name()
	case project.FieldDescription:
		return m.Description()
	case project.FieldPlannedStartDate:
		return m.PlannedStartDate()
	case project.FieldActualStartDate:
		return m.ActualStartDate()
	case project.FieldPlannedEndDate:
		return m.PlannedEndDate()
	case project.FieldActualEndDate:
		return m.ActualEndDate()
	case project.FieldProgress:
		return m.Progress()
	case project.FieldStatus:
		return m.Status()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ProjectMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case project.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case project.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case project.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case project.FieldName:
		return m.OldName(ctx)
	case project.FieldDescription:
		return m.OldDescription(ctx)
	case project.FieldPlannedStartDate:
		return m.OldPlannedStartDate(ctx)
	case project.FieldActualStartDate:
		return m.OldActualStartDate(ctx)
	case project.FieldPlannedEndDate:
		return m.OldPlannedEndDate(ctx)
	case project.FieldActualEndDate:
		return m.OldActualEndDate(ctx)
	case project.FieldProgress:
		return m.OldProgress(ctx)
	case project.FieldStatus:
		return m.OldStatus(ctx)
	}
	return nil, fmt.Errorf("unknown Project field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProjectMutation) SetField(name string, value ent.Value) error {
	switch name {
	case project.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case project.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case project.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case project.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case project.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case project.FieldPlannedStartDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPlannedStartDate(v)
		return nil
	case project.FieldActualStartDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetActualStartDate(v)
		return nil
	case project.FieldPlannedEndDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPlannedEndDate(v)
		return nil
	case project.FieldActualEndDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetActualEndDate(v)
		return nil
	case project.FieldProgress:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProgress(v)
		return nil
	case project.FieldStatus:
		v, ok := value.(project.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	}
	return fmt.Errorf("unknown Project field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ProjectMutation) AddedFields() []string {
	var fields []string
	if m.addprogress != nil {
		fields = append(fields, project.FieldProgress)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ProjectMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case project.FieldProgress:
		return m.AddedProgress()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProjectMutation) AddField(name string, value ent.Value) error {
	switch name {
	case project.FieldProgress:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddProgress(v)
		return nil
	}
	return fmt.Errorf("unknown Project numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ProjectMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(project.FieldDeletedAt) {
		fields = append(fields, project.FieldDeletedAt)
	}
	if m.FieldCleared(project.FieldActualStartDate) {
		fields = append(fields, project.FieldActualStartDate)
	}
	if m.FieldCleared(project.FieldActualEndDate) {
		fields = append(fields, project.FieldActualEndDate)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ProjectMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ProjectMutation) ClearField(name string) error {
	switch name {
	case project.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case project.FieldActualStartDate:
		m.ClearActualStartDate()
		return nil
	case project.FieldActualEndDate:
		m.ClearActualEndDate()
		return nil
	}
	return fmt.Errorf("unknown Project nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ProjectMutation) ResetField(name string) error {
	switch name {
	case project.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case project.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case project.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case project.FieldName:
		m.ResetName()
		return nil
	case project.FieldDescription:
		m.ResetDescription()
		return nil
	case project.FieldPlannedStartDate:
		m.ResetPlannedStartDate()
		return nil
	case project.FieldActualStartDate:
		m.ResetActualStartDate()
		return nil
	case project.FieldPlannedEndDate:
		m.ResetPlannedEndDate()
		return nil
	case project.FieldActualEndDate:
		m.ResetActualEndDate()
		return nil
	case project.FieldProgress:
		m.ResetProgress()
		return nil
	case project.FieldStatus:
		m.ResetStatus()
		return nil
	}
	return fmt.Errorf("unknown Project field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ProjectMutation) AddedEdges() []string {
	edges := make([]string, 0, 5)
	if m.company != nil {
		edges = append(edges, project.EdgeCompany)
	}
	if m.created_by != nil {
		edges = append(edges, project.EdgeCreatedBy)
	}
	if m.leader != nil {
		edges = append(edges, project.EdgeLeader)
	}
	if m.tasks != nil {
		edges = append(edges, project.EdgeTasks)
	}
	if m.milestones != nil {
		edges = append(edges, project.EdgeMilestones)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ProjectMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case project.EdgeCompany:
		if id := m.company; id != nil {
			return []ent.Value{*id}
		}
	case project.EdgeCreatedBy:
		if id := m.created_by; id != nil {
			return []ent.Value{*id}
		}
	case project.EdgeLeader:
		if id := m.leader; id != nil {
			return []ent.Value{*id}
		}
	case project.EdgeTasks:
		ids := make([]ent.Value, 0, len(m.tasks))
		for id := range m.tasks {
			ids = append(ids, id)
		}
		return ids
	case project.EdgeMilestones:
		ids := make([]ent.Value, 0, len(m.milestones))
		for id := range m.milestones {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ProjectMutation) RemovedEdges() []string {
	edges := make([]string, 0, 5)
	if m.removedtasks != nil {
		edges = append(edges, project.EdgeTasks)
	}
	if m.removedmilestones != nil {
		edges = append(edges, project.EdgeMilestones)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ProjectMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case project.EdgeTasks:
		ids := make([]ent.Value, 0, len(m.removedtasks))
		for id := range m.removedtasks {
			ids = append(ids, id)
		}
		return ids
	case project.EdgeMilestones:
		ids := make([]ent.Value, 0, len(m.removedmilestones))
		for id := range m.removedmilestones {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ProjectMutation) ClearedEdges() []string {
	edges := make([]string, 0, 5)
	if m.clearedcompany {
		edges = append(edges, project.EdgeCompany)
	}
	if m.clearedcreated_by {
		edges = append(edges, project.EdgeCreatedBy)
	}
	if m.clearedleader {
		edges = append(edges, project.EdgeLeader)
	}
	if m.clearedtasks {
		edges = append(edges, project.EdgeTasks)
	}
	if m.clearedmilestones {
		edges = append(edges, project.EdgeMilestones)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ProjectMutation) EdgeCleared(name string) bool {
	switch name {
	case project.EdgeCompany:
		return m.clearedcompany
	case project.EdgeCreatedBy:
		return m.clearedcreated_by
	case project.EdgeLeader:
		return m.clearedleader
	case project.EdgeTasks:
		return m.clearedtasks
	case project.EdgeMilestones:
		return m.clearedmilestones
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ProjectMutation) ClearEdge(name string) error {
	switch name {
	case project.EdgeCompany:
		m.ClearCompany()
		return nil
	case project.EdgeCreatedBy:
		m.ClearCreatedBy()
		return nil
	case project.EdgeLeader:
		m.ClearLeader()
		return nil
	}
	return fmt.Errorf("unknown Project unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ProjectMutation) ResetEdge(name string) error {
	switch name {
	case project.EdgeCompany:
		m.ResetCompany()
		return nil
	case project.EdgeCreatedBy:
		m.ResetCreatedBy()
		return nil
	case project.EdgeLeader:
		m.ResetLeader()
		return nil
	case project.EdgeTasks:
		m.ResetTasks()
		return nil
	case project.EdgeMilestones:
		m.ResetMilestones()
		return nil
	}
	return fmt.Errorf("unknown Project edge %s", name)
}

// ProjectMilestoneMutation represents an operation that mutates the ProjectMilestone nodes in the graph.
type ProjectMilestoneMutation struct {
	config
	op             Op
	typ            string
	id             *int
	name           *string
	due_date       *time.Time
	clearedFields  map[string]struct{}
	project        *int
	clearedproject bool
	done           bool
	oldValue       func(context.Context) (*ProjectMilestone, error)
	predicates     []predicate.ProjectMilestone
}

var _ ent.Mutation = (*ProjectMilestoneMutation)(nil)

// projectmilestoneOption allows management of the mutation configuration using functional options.
type projectmilestoneOption func(*ProjectMilestoneMutation)

// newProjectMilestoneMutation creates new mutation for the ProjectMilestone entity.
func newProjectMilestoneMutation(c config, op Op, opts ...projectmilestoneOption) *ProjectMilestoneMutation {
	m := &ProjectMilestoneMutation{
		config:        c,
		op:            op,
		typ:           TypeProjectMilestone,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withProjectMilestoneID sets the ID field of the mutation.
func withProjectMilestoneID(id int) projectmilestoneOption {
	return func(m *ProjectMilestoneMutation) {
		var (
			err   error
			once  sync.Once
			value *ProjectMilestone
		)
		m.oldValue = func(ctx context.Context) (*ProjectMilestone, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ProjectMilestone.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withProjectMilestone sets the old ProjectMilestone of the mutation.
func withProjectMilestone(node *ProjectMilestone) projectmilestoneOption {
	return func(m *ProjectMilestoneMutation) {
		m.oldValue = func(context.Context) (*ProjectMilestone, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ProjectMilestoneMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ProjectMilestoneMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("generated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ProjectMilestoneMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ProjectMilestoneMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ProjectMilestone.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *ProjectMilestoneMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ProjectMilestoneMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the ProjectMilestone entity.
// If the ProjectMilestone object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectMilestoneMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ProjectMilestoneMutation) ResetName() {
	m.name = nil
}

// SetDueDate sets the "due_date" field.
func (m *ProjectMilestoneMutation) SetDueDate(t time.Time) {
	m.due_date = &t
}

// DueDate returns the value of the "due_date" field in the mutation.
func (m *ProjectMilestoneMutation) DueDate() (r time.Time, exists bool) {
	v := m.due_date
	if v == nil {
		return
	}
	return *v, true
}

// OldDueDate returns the old "due_date" field's value of the ProjectMilestone entity.
// If the ProjectMilestone object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectMilestoneMutation) OldDueDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDueDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDueDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDueDate: %w", err)
	}
	return oldValue.DueDate, nil
}

// ResetDueDate resets all changes to the "due_date" field.
func (m *ProjectMilestoneMutation) ResetDueDate() {
	m.due_date = nil
}

// SetProjectID sets the "project" edge to the Project entity by id.
func (m *ProjectMilestoneMutation) SetProjectID(id int) {
	m.project = &id
}

// ClearProject clears the "project" edge to the Project entity.
func (m *ProjectMilestoneMutation) ClearProject() {
	m.clearedproject = true
}

// ProjectCleared reports if the "project" edge to the Project entity was cleared.
func (m *ProjectMilestoneMutation) ProjectCleared() bool {
	return m.clearedproject
}

// ProjectID returns the "project" edge ID in the mutation.
func (m *ProjectMilestoneMutation) ProjectID() (id int, exists bool) {
	if m.project != nil {
		return *m.project, true
	}
	return
}

// ProjectIDs returns the "project" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProjectID instead. It exists only for internal usage by the builders.
func (m *ProjectMilestoneMutation) ProjectIDs() (ids []int) {
	if id := m.project; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProject resets all changes to the "project" edge.
func (m *ProjectMilestoneMutation) ResetProject() {
	m.project = nil
	m.clearedproject = false
}

// Where appends a list predicates to the ProjectMilestoneMutation builder.
func (m *ProjectMilestoneMutation) Where(ps ...predicate.ProjectMilestone) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ProjectMilestoneMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ProjectMilestoneMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ProjectMilestone, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ProjectMilestoneMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ProjectMilestoneMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ProjectMilestone).
func (m *ProjectMilestoneMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ProjectMilestoneMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.name != nil {
		fields = append(fields, projectmilestone.FieldName)
	}
	if m.due_date != nil {
		fields = append(fields, projectmilestone.FieldDueDate)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ProjectMilestoneMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case projectmilestone.FieldName:
		return m.Name()
	case projectmilestone.FieldDueDate:
		return m.DueDate()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ProjectMilestoneMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case projectmilestone.FieldName:
		return m.OldName(ctx)
	case projectmilestone.FieldDueDate:
		return m.OldDueDate(ctx)
	}
	return nil, fmt.Errorf("unknown ProjectMilestone field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProjectMilestoneMutation) SetField(name string, value ent.Value) error {
	switch name {
	case projectmilestone.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case projectmilestone.FieldDueDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDueDate(v)
		return nil
	}
	return fmt.Errorf("unknown ProjectMilestone field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ProjectMilestoneMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ProjectMilestoneMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProjectMilestoneMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ProjectMilestone numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ProjectMilestoneMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ProjectMilestoneMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ProjectMilestoneMutation) ClearField(name string) error {
	return fmt.Errorf("unknown ProjectMilestone nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ProjectMilestoneMutation) ResetField(name string) error {
	switch name {
	case projectmilestone.FieldName:
		m.ResetName()
		return nil
	case projectmilestone.FieldDueDate:
		m.ResetDueDate()
		return nil
	}
	return fmt.Errorf("unknown ProjectMilestone field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ProjectMilestoneMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.project != nil {
		edges = append(edges, projectmilestone.EdgeProject)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ProjectMilestoneMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case projectmilestone.EdgeProject:
		if id := m.project; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ProjectMilestoneMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ProjectMilestoneMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ProjectMilestoneMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedproject {
		edges = append(edges, projectmilestone.EdgeProject)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ProjectMilestoneMutation) EdgeCleared(name string) bool {
	switch name {
	case projectmilestone.EdgeProject:
		return m.clearedproject
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ProjectMilestoneMutation) ClearEdge(name string) error {
	switch name {
	case projectmilestone.EdgeProject:
		m.ClearProject()
		return nil
	}
	return fmt.Errorf("unknown ProjectMilestone unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ProjectMilestoneMutation) ResetEdge(name string) error {
	switch name {
	case projectmilestone.EdgeProject:
		m.ResetProject()
		return nil
	}
	return fmt.Errorf("unknown ProjectMilestone edge %s", name)
}

// ProjectTaskMutation represents an operation that mutates the ProjectTask nodes in the graph.
type ProjectTaskMutation struct {
	config
	op                  Op
	typ                 string
	id                  *int
	created_at          *time.Time
	updated_at          *time.Time
	deleted_at          *time.Time
	assignee_name       *string
	description         *string
	due_date            *time.Time
	end_date            *time.Time
	location            *string
	name                *string
	start_date          *time.Time
	status              *projecttask.Status
	clearedFields       map[string]struct{}
	project             *int
	clearedproject      bool
	assignee            *int
	clearedassignee     bool
	participants        map[int]struct{}
	removedparticipants map[int]struct{}
	clearedparticipants bool
	created_by          *int
	clearedcreated_by   bool
	work_shifts         map[int]struct{}
	removedwork_shifts  map[int]struct{}
	clearedwork_shifts  bool
	done                bool
	oldValue            func(context.Context) (*ProjectTask, error)
	predicates          []predicate.ProjectTask
}

var _ ent.Mutation = (*ProjectTaskMutation)(nil)

// projecttaskOption allows management of the mutation configuration using functional options.
type projecttaskOption func(*ProjectTaskMutation)

// newProjectTaskMutation creates new mutation for the ProjectTask entity.
func newProjectTaskMutation(c config, op Op, opts ...projecttaskOption) *ProjectTaskMutation {
	m := &ProjectTaskMutation{
		config:        c,
		op:            op,
		typ:           TypeProjectTask,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withProjectTaskID sets the ID field of the mutation.
func withProjectTaskID(id int) projecttaskOption {
	return func(m *ProjectTaskMutation) {
		var (
			err   error
			once  sync.Once
			value *ProjectTask
		)
		m.oldValue = func(ctx context.Context) (*ProjectTask, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ProjectTask.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withProjectTask sets the old ProjectTask of the mutation.
func withProjectTask(node *ProjectTask) projecttaskOption {
	return func(m *ProjectTaskMutation) {
		m.oldValue = func(context.Context) (*ProjectTask, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ProjectTaskMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ProjectTaskMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("generated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ProjectTaskMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ProjectTaskMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ProjectTask.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *ProjectTaskMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ProjectTaskMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ProjectTask entity.
// If the ProjectTask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectTaskMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ProjectTaskMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ProjectTaskMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ProjectTaskMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the ProjectTask entity.
// If the ProjectTask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectTaskMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ProjectTaskMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *ProjectTaskMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *ProjectTaskMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the ProjectTask entity.
// If the ProjectTask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectTaskMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *ProjectTaskMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[projecttask.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *ProjectTaskMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[projecttask.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *ProjectTaskMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, projecttask.FieldDeletedAt)
}

// SetAssigneeName sets the "assignee_name" field.
func (m *ProjectTaskMutation) SetAssigneeName(s string) {
	m.assignee_name = &s
}

// AssigneeName returns the value of the "assignee_name" field in the mutation.
func (m *ProjectTaskMutation) AssigneeName() (r string, exists bool) {
	v := m.assignee_name
	if v == nil {
		return
	}
	return *v, true
}

// OldAssigneeName returns the old "assignee_name" field's value of the ProjectTask entity.
// If the ProjectTask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectTaskMutation) OldAssigneeName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAssigneeName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAssigneeName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAssigneeName: %w", err)
	}
	return oldValue.AssigneeName, nil
}

// ResetAssigneeName resets all changes to the "assignee_name" field.
func (m *ProjectTaskMutation) ResetAssigneeName() {
	m.assignee_name = nil
}

// SetDescription sets the "description" field.
func (m *ProjectTaskMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *ProjectTaskMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the ProjectTask entity.
// If the ProjectTask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectTaskMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *ProjectTaskMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[projecttask.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *ProjectTaskMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[projecttask.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *ProjectTaskMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, projecttask.FieldDescription)
}

// SetDueDate sets the "due_date" field.
func (m *ProjectTaskMutation) SetDueDate(t time.Time) {
	m.due_date = &t
}

// DueDate returns the value of the "due_date" field in the mutation.
func (m *ProjectTaskMutation) DueDate() (r time.Time, exists bool) {
	v := m.due_date
	if v == nil {
		return
	}
	return *v, true
}

// OldDueDate returns the old "due_date" field's value of the ProjectTask entity.
// If the ProjectTask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectTaskMutation) OldDueDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDueDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDueDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDueDate: %w", err)
	}
	return oldValue.DueDate, nil
}

// ResetDueDate resets all changes to the "due_date" field.
func (m *ProjectTaskMutation) ResetDueDate() {
	m.due_date = nil
}

// SetEndDate sets the "end_date" field.
func (m *ProjectTaskMutation) SetEndDate(t time.Time) {
	m.end_date = &t
}

// EndDate returns the value of the "end_date" field in the mutation.
func (m *ProjectTaskMutation) EndDate() (r time.Time, exists bool) {
	v := m.end_date
	if v == nil {
		return
	}
	return *v, true
}

// OldEndDate returns the old "end_date" field's value of the ProjectTask entity.
// If the ProjectTask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectTaskMutation) OldEndDate(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEndDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEndDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEndDate: %w", err)
	}
	return oldValue.EndDate, nil
}

// ClearEndDate clears the value of the "end_date" field.
func (m *ProjectTaskMutation) ClearEndDate() {
	m.end_date = nil
	m.clearedFields[projecttask.FieldEndDate] = struct{}{}
}

// EndDateCleared returns if the "end_date" field was cleared in this mutation.
func (m *ProjectTaskMutation) EndDateCleared() bool {
	_, ok := m.clearedFields[projecttask.FieldEndDate]
	return ok
}

// ResetEndDate resets all changes to the "end_date" field.
func (m *ProjectTaskMutation) ResetEndDate() {
	m.end_date = nil
	delete(m.clearedFields, projecttask.FieldEndDate)
}

// SetLocation sets the "location" field.
func (m *ProjectTaskMutation) SetLocation(s string) {
	m.location = &s
}

// Location returns the value of the "location" field in the mutation.
func (m *ProjectTaskMutation) Location() (r string, exists bool) {
	v := m.location
	if v == nil {
		return
	}
	return *v, true
}

// OldLocation returns the old "location" field's value of the ProjectTask entity.
// If the ProjectTask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectTaskMutation) OldLocation(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLocation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLocation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLocation: %w", err)
	}
	return oldValue.Location, nil
}

// ClearLocation clears the value of the "location" field.
func (m *ProjectTaskMutation) ClearLocation() {
	m.location = nil
	m.clearedFields[projecttask.FieldLocation] = struct{}{}
}

// LocationCleared returns if the "location" field was cleared in this mutation.
func (m *ProjectTaskMutation) LocationCleared() bool {
	_, ok := m.clearedFields[projecttask.FieldLocation]
	return ok
}

// ResetLocation resets all changes to the "location" field.
func (m *ProjectTaskMutation) ResetLocation() {
	m.location = nil
	delete(m.clearedFields, projecttask.FieldLocation)
}

// SetName sets the "name" field.
func (m *ProjectTaskMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ProjectTaskMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the ProjectTask entity.
// If the ProjectTask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectTaskMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ProjectTaskMutation) ResetName() {
	m.name = nil
}

// SetStartDate sets the "start_date" field.
func (m *ProjectTaskMutation) SetStartDate(t time.Time) {
	m.start_date = &t
}

// StartDate returns the value of the "start_date" field in the mutation.
func (m *ProjectTaskMutation) StartDate() (r time.Time, exists bool) {
	v := m.start_date
	if v == nil {
		return
	}
	return *v, true
}

// OldStartDate returns the old "start_date" field's value of the ProjectTask entity.
// If the ProjectTask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectTaskMutation) OldStartDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartDate: %w", err)
	}
	return oldValue.StartDate, nil
}

// ResetStartDate resets all changes to the "start_date" field.
func (m *ProjectTaskMutation) ResetStartDate() {
	m.start_date = nil
}

// SetStatus sets the "status" field.
func (m *ProjectTaskMutation) SetStatus(pr projecttask.Status) {
	m.status = &pr
}

// Status returns the value of the "status" field in the mutation.
func (m *ProjectTaskMutation) Status() (r projecttask.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the ProjectTask entity.
// If the ProjectTask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectTaskMutation) OldStatus(ctx context.Context) (v projecttask.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *ProjectTaskMutation) ResetStatus() {
	m.status = nil
}

// SetProjectID sets the "project" edge to the Project entity by id.
func (m *ProjectTaskMutation) SetProjectID(id int) {
	m.project = &id
}

// ClearProject clears the "project" edge to the Project entity.
func (m *ProjectTaskMutation) ClearProject() {
	m.clearedproject = true
}

// ProjectCleared reports if the "project" edge to the Project entity was cleared.
func (m *ProjectTaskMutation) ProjectCleared() bool {
	return m.clearedproject
}

// ProjectID returns the "project" edge ID in the mutation.
func (m *ProjectTaskMutation) ProjectID() (id int, exists bool) {
	if m.project != nil {
		return *m.project, true
	}
	return
}

// ProjectIDs returns the "project" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProjectID instead. It exists only for internal usage by the builders.
func (m *ProjectTaskMutation) ProjectIDs() (ids []int) {
	if id := m.project; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProject resets all changes to the "project" edge.
func (m *ProjectTaskMutation) ResetProject() {
	m.project = nil
	m.clearedproject = false
}

// SetAssigneeID sets the "assignee" edge to the User entity by id.
func (m *ProjectTaskMutation) SetAssigneeID(id int) {
	m.assignee = &id
}

// ClearAssignee clears the "assignee" edge to the User entity.
func (m *ProjectTaskMutation) ClearAssignee() {
	m.clearedassignee = true
}

// AssigneeCleared reports if the "assignee" edge to the User entity was cleared.
func (m *ProjectTaskMutation) AssigneeCleared() bool {
	return m.clearedassignee
}

// AssigneeID returns the "assignee" edge ID in the mutation.
func (m *ProjectTaskMutation) AssigneeID() (id int, exists bool) {
	if m.assignee != nil {
		return *m.assignee, true
	}
	return
}

// AssigneeIDs returns the "assignee" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AssigneeID instead. It exists only for internal usage by the builders.
func (m *ProjectTaskMutation) AssigneeIDs() (ids []int) {
	if id := m.assignee; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAssignee resets all changes to the "assignee" edge.
func (m *ProjectTaskMutation) ResetAssignee() {
	m.assignee = nil
	m.clearedassignee = false
}

// AddParticipantIDs adds the "participants" edge to the User entity by ids.
func (m *ProjectTaskMutation) AddParticipantIDs(ids ...int) {
	if m.participants == nil {
		m.participants = make(map[int]struct{})
	}
	for i := range ids {
		m.participants[ids[i]] = struct{}{}
	}
}

// ClearParticipants clears the "participants" edge to the User entity.
func (m *ProjectTaskMutation) ClearParticipants() {
	m.clearedparticipants = true
}

// ParticipantsCleared reports if the "participants" edge to the User entity was cleared.
func (m *ProjectTaskMutation) ParticipantsCleared() bool {
	return m.clearedparticipants
}

// RemoveParticipantIDs removes the "participants" edge to the User entity by IDs.
func (m *ProjectTaskMutation) RemoveParticipantIDs(ids ...int) {
	if m.removedparticipants == nil {
		m.removedparticipants = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.participants, ids[i])
		m.removedparticipants[ids[i]] = struct{}{}
	}
}

// RemovedParticipants returns the removed IDs of the "participants" edge to the User entity.
func (m *ProjectTaskMutation) RemovedParticipantsIDs() (ids []int) {
	for id := range m.removedparticipants {
		ids = append(ids, id)
	}
	return
}

// ParticipantsIDs returns the "participants" edge IDs in the mutation.
func (m *ProjectTaskMutation) ParticipantsIDs() (ids []int) {
	for id := range m.participants {
		ids = append(ids, id)
	}
	return
}

// ResetParticipants resets all changes to the "participants" edge.
func (m *ProjectTaskMutation) ResetParticipants() {
	m.participants = nil
	m.clearedparticipants = false
	m.removedparticipants = nil
}

// SetCreatedByID sets the "created_by" edge to the User entity by id.
func (m *ProjectTaskMutation) SetCreatedByID(id int) {
	m.created_by = &id
}

// ClearCreatedBy clears the "created_by" edge to the User entity.
func (m *ProjectTaskMutation) ClearCreatedBy() {
	m.clearedcreated_by = true
}

// CreatedByCleared reports if the "created_by" edge to the User entity was cleared.
func (m *ProjectTaskMutation) CreatedByCleared() bool {
	return m.clearedcreated_by
}

// CreatedByID returns the "created_by" edge ID in the mutation.
func (m *ProjectTaskMutation) CreatedByID() (id int, exists bool) {
	if m.created_by != nil {
		return *m.created_by, true
	}
	return
}

// CreatedByIDs returns the "created_by" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CreatedByID instead. It exists only for internal usage by the builders.
func (m *ProjectTaskMutation) CreatedByIDs() (ids []int) {
	if id := m.created_by; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCreatedBy resets all changes to the "created_by" edge.
func (m *ProjectTaskMutation) ResetCreatedBy() {
	m.created_by = nil
	m.clearedcreated_by = false
}

// AddWorkShiftIDs adds the "work_shifts" edge to the Workshift entity by ids.
func (m *ProjectTaskMutation) AddWorkShiftIDs(ids ...int) {
	if m.work_shifts == nil {
		m.work_shifts = make(map[int]struct{})
	}
	for i := range ids {
		m.work_shifts[ids[i]] = struct{}{}
	}
}

// ClearWorkShifts clears the "work_shifts" edge to the Workshift entity.
func (m *ProjectTaskMutation) ClearWorkShifts() {
	m.clearedwork_shifts = true
}

// WorkShiftsCleared reports if the "work_shifts" edge to the Workshift entity was cleared.
func (m *ProjectTaskMutation) WorkShiftsCleared() bool {
	return m.clearedwork_shifts
}

// RemoveWorkShiftIDs removes the "work_shifts" edge to the Workshift entity by IDs.
func (m *ProjectTaskMutation) RemoveWorkShiftIDs(ids ...int) {
	if m.removedwork_shifts == nil {
		m.removedwork_shifts = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.work_shifts, ids[i])
		m.removedwork_shifts[ids[i]] = struct{}{}
	}
}

// RemovedWorkShifts returns the removed IDs of the "work_shifts" edge to the Workshift entity.
func (m *ProjectTaskMutation) RemovedWorkShiftsIDs() (ids []int) {
	for id := range m.removedwork_shifts {
		ids = append(ids, id)
	}
	return
}

// WorkShiftsIDs returns the "work_shifts" edge IDs in the mutation.
func (m *ProjectTaskMutation) WorkShiftsIDs() (ids []int) {
	for id := range m.work_shifts {
		ids = append(ids, id)
	}
	return
}

// ResetWorkShifts resets all changes to the "work_shifts" edge.
func (m *ProjectTaskMutation) ResetWorkShifts() {
	m.work_shifts = nil
	m.clearedwork_shifts = false
	m.removedwork_shifts = nil
}

// Where appends a list predicates to the ProjectTaskMutation builder.
func (m *ProjectTaskMutation) Where(ps ...predicate.ProjectTask) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ProjectTaskMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ProjectTaskMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ProjectTask, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ProjectTaskMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ProjectTaskMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ProjectTask).
func (m *ProjectTaskMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ProjectTaskMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.created_at != nil {
		fields = append(fields, projecttask.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, projecttask.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, projecttask.FieldDeletedAt)
	}
	if m.assignee_name != nil {
		fields = append(fields, projecttask.FieldAssigneeName)
	}
	if m.description != nil {
		fields = append(fields, projecttask.FieldDescription)
	}
	if m.due_date != nil {
		fields = append(fields, projecttask.FieldDueDate)
	}
	if m.end_date != nil {
		fields = append(fields, projecttask.FieldEndDate)
	}
	if m.location != nil {
		fields = append(fields, projecttask.FieldLocation)
	}
	if m.name != nil {
		fields = append(fields, projecttask.FieldName)
	}
	if m.start_date != nil {
		fields = append(fields, projecttask.FieldStartDate)
	}
	if m.status != nil {
		fields = append(fields, projecttask.FieldStatus)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ProjectTaskMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case projecttask.FieldCreatedAt:
		return m.CreatedAt()
	case projecttask.FieldUpdatedAt:
		return m.UpdatedAt()
	case projecttask.FieldDeletedAt:
		return m.DeletedAt()
	case projecttask.FieldAssigneeName:
		return m.AssigneeName()
	case projecttask.FieldDescription:
		return m.Description()
	case projecttask.FieldDueDate:
		return m.DueDate()
	case projecttask.FieldEndDate:
		return m.EndDate()
	case projecttask.FieldLocation:
		return m.Location()
	case projecttask.FieldName:
		return m.Name()
	case projecttask.FieldStartDate:
		return m.StartDate()
	case projecttask.FieldStatus:
		return m.Status()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ProjectTaskMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case projecttask.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case projecttask.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case projecttask.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case projecttask.FieldAssigneeName:
		return m.OldAssigneeName(ctx)
	case projecttask.FieldDescription:
		return m.OldDescription(ctx)
	case projecttask.FieldDueDate:
		return m.OldDueDate(ctx)
	case projecttask.FieldEndDate:
		return m.OldEndDate(ctx)
	case projecttask.FieldLocation:
		return m.OldLocation(ctx)
	case projecttask.FieldName:
		return m.OldName(ctx)
	case projecttask.FieldStartDate:
		return m.OldStartDate(ctx)
	case projecttask.FieldStatus:
		return m.OldStatus(ctx)
	}
	return nil, fmt.Errorf("unknown ProjectTask field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProjectTaskMutation) SetField(name string, value ent.Value) error {
	switch name {
	case projecttask.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case projecttask.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case projecttask.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case projecttask.FieldAssigneeName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAssigneeName(v)
		return nil
	case projecttask.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case projecttask.FieldDueDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDueDate(v)
		return nil
	case projecttask.FieldEndDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEndDate(v)
		return nil
	case projecttask.FieldLocation:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLocation(v)
		return nil
	case projecttask.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case projecttask.FieldStartDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartDate(v)
		return nil
	case projecttask.FieldStatus:
		v, ok := value.(projecttask.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	}
	return fmt.Errorf("unknown ProjectTask field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ProjectTaskMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ProjectTaskMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProjectTaskMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ProjectTask numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ProjectTaskMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(projecttask.FieldDeletedAt) {
		fields = append(fields, projecttask.FieldDeletedAt)
	}
	if m.FieldCleared(projecttask.FieldDescription) {
		fields = append(fields, projecttask.FieldDescription)
	}
	if m.FieldCleared(projecttask.FieldEndDate) {
		fields = append(fields, projecttask.FieldEndDate)
	}
	if m.FieldCleared(projecttask.FieldLocation) {
		fields = append(fields, projecttask.FieldLocation)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ProjectTaskMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ProjectTaskMutation) ClearField(name string) error {
	switch name {
	case projecttask.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case projecttask.FieldDescription:
		m.ClearDescription()
		return nil
	case projecttask.FieldEndDate:
		m.ClearEndDate()
		return nil
	case projecttask.FieldLocation:
		m.ClearLocation()
		return nil
	}
	return fmt.Errorf("unknown ProjectTask nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ProjectTaskMutation) ResetField(name string) error {
	switch name {
	case projecttask.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case projecttask.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case projecttask.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case projecttask.FieldAssigneeName:
		m.ResetAssigneeName()
		return nil
	case projecttask.FieldDescription:
		m.ResetDescription()
		return nil
	case projecttask.FieldDueDate:
		m.ResetDueDate()
		return nil
	case projecttask.FieldEndDate:
		m.ResetEndDate()
		return nil
	case projecttask.FieldLocation:
		m.ResetLocation()
		return nil
	case projecttask.FieldName:
		m.ResetName()
		return nil
	case projecttask.FieldStartDate:
		m.ResetStartDate()
		return nil
	case projecttask.FieldStatus:
		m.ResetStatus()
		return nil
	}
	return fmt.Errorf("unknown ProjectTask field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ProjectTaskMutation) AddedEdges() []string {
	edges := make([]string, 0, 5)
	if m.project != nil {
		edges = append(edges, projecttask.EdgeProject)
	}
	if m.assignee != nil {
		edges = append(edges, projecttask.EdgeAssignee)
	}
	if m.participants != nil {
		edges = append(edges, projecttask.EdgeParticipants)
	}
	if m.created_by != nil {
		edges = append(edges, projecttask.EdgeCreatedBy)
	}
	if m.work_shifts != nil {
		edges = append(edges, projecttask.EdgeWorkShifts)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ProjectTaskMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case projecttask.EdgeProject:
		if id := m.project; id != nil {
			return []ent.Value{*id}
		}
	case projecttask.EdgeAssignee:
		if id := m.assignee; id != nil {
			return []ent.Value{*id}
		}
	case projecttask.EdgeParticipants:
		ids := make([]ent.Value, 0, len(m.participants))
		for id := range m.participants {
			ids = append(ids, id)
		}
		return ids
	case projecttask.EdgeCreatedBy:
		if id := m.created_by; id != nil {
			return []ent.Value{*id}
		}
	case projecttask.EdgeWorkShifts:
		ids := make([]ent.Value, 0, len(m.work_shifts))
		for id := range m.work_shifts {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ProjectTaskMutation) RemovedEdges() []string {
	edges := make([]string, 0, 5)
	if m.removedparticipants != nil {
		edges = append(edges, projecttask.EdgeParticipants)
	}
	if m.removedwork_shifts != nil {
		edges = append(edges, projecttask.EdgeWorkShifts)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ProjectTaskMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case projecttask.EdgeParticipants:
		ids := make([]ent.Value, 0, len(m.removedparticipants))
		for id := range m.removedparticipants {
			ids = append(ids, id)
		}
		return ids
	case projecttask.EdgeWorkShifts:
		ids := make([]ent.Value, 0, len(m.removedwork_shifts))
		for id := range m.removedwork_shifts {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ProjectTaskMutation) ClearedEdges() []string {
	edges := make([]string, 0, 5)
	if m.clearedproject {
		edges = append(edges, projecttask.EdgeProject)
	}
	if m.clearedassignee {
		edges = append(edges, projecttask.EdgeAssignee)
	}
	if m.clearedparticipants {
		edges = append(edges, projecttask.EdgeParticipants)
	}
	if m.clearedcreated_by {
		edges = append(edges, projecttask.EdgeCreatedBy)
	}
	if m.clearedwork_shifts {
		edges = append(edges, projecttask.EdgeWorkShifts)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ProjectTaskMutation) EdgeCleared(name string) bool {
	switch name {
	case projecttask.EdgeProject:
		return m.clearedproject
	case projecttask.EdgeAssignee:
		return m.clearedassignee
	case projecttask.EdgeParticipants:
		return m.clearedparticipants
	case projecttask.EdgeCreatedBy:
		return m.clearedcreated_by
	case projecttask.EdgeWorkShifts:
		return m.clearedwork_shifts
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ProjectTaskMutation) ClearEdge(name string) error {
	switch name {
	case projecttask.EdgeProject:
		m.ClearProject()
		return nil
	case projecttask.EdgeAssignee:
		m.ClearAssignee()
		return nil
	case projecttask.EdgeCreatedBy:
		m.ClearCreatedBy()
		return nil
	}
	return fmt.Errorf("unknown ProjectTask unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ProjectTaskMutation) ResetEdge(name string) error {
	switch name {
	case projecttask.EdgeProject:
		m.ResetProject()
		return nil
	case projecttask.EdgeAssignee:
		m.ResetAssignee()
		return nil
	case projecttask.EdgeParticipants:
		m.ResetParticipants()
		return nil
	case projecttask.EdgeCreatedBy:
		m.ResetCreatedBy()
		return nil
	case projecttask.EdgeWorkShifts:
		m.ResetWorkShifts()
		return nil
	}
	return fmt.Errorf("unknown ProjectTask edge %s", name)
}

// ReceivableMutation represents an operation that mutates the Receivable nodes in the graph.
type ReceivableMutation struct {
	config
	op                     Op
	typ                    string
	id                     *int
	created_at             *time.Time
	updated_at             *time.Time
	deleted_at             *time.Time
	entry_group            *int
	addentry_group         *int
	date                   *time.Time
	name                   *string
	amount_in_default      *float64
	addamount_in_default   *float64
	outstanding_balance    *float64
	addoutstanding_balance *float64
	total_transaction      *float64
	addtotal_transaction   *float64
	due_date               *time.Time
	status                 *receivable.Status
	clearedFields          map[string]struct{}
	company                *int
	clearedcompany         bool
	invoice                *int
	clearedinvoice         bool
	done                   bool
	oldValue               func(context.Context) (*Receivable, error)
	predicates             []predicate.Receivable
}

var _ ent.Mutation = (*ReceivableMutation)(nil)

// receivableOption allows management of the mutation configuration using functional options.
type receivableOption func(*ReceivableMutation)

// newReceivableMutation creates new mutation for the Receivable entity.
func newReceivableMutation(c config, op Op, opts ...receivableOption) *ReceivableMutation {
	m := &ReceivableMutation{
		config:        c,
		op:            op,
		typ:           TypeReceivable,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withReceivableID sets the ID field of the mutation.
func withReceivableID(id int) receivableOption {
	return func(m *ReceivableMutation) {
		var (
			err   error
			once  sync.Once
			value *Receivable
		)
		m.oldValue = func(ctx context.Context) (*Receivable, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Receivable.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withReceivable sets the old Receivable of the mutation.
func withReceivable(node *Receivable) receivableOption {
	return func(m *ReceivableMutation) {
		m.oldValue = func(context.Context) (*Receivable, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ReceivableMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ReceivableMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("generated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ReceivableMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ReceivableMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Receivable.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *ReceivableMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ReceivableMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Receivable entity.
// If the Receivable object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReceivableMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ReceivableMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ReceivableMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ReceivableMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Receivable entity.
// If the Receivable object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReceivableMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ReceivableMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *ReceivableMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *ReceivableMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Receivable entity.
// If the Receivable object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReceivableMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *ReceivableMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[receivable.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *ReceivableMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[receivable.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *ReceivableMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, receivable.FieldDeletedAt)
}

// SetEntryGroup sets the "entry_group" field.
func (m *ReceivableMutation) SetEntryGroup(i int) {
	m.entry_group = &i
	m.addentry_group = nil
}

// EntryGroup returns the value of the "entry_group" field in the mutation.
func (m *ReceivableMutation) EntryGroup() (r int, exists bool) {
	v := m.entry_group
	if v == nil {
		return
	}
	return *v, true
}

// OldEntryGroup returns the old "entry_group" field's value of the Receivable entity.
// If the Receivable object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReceivableMutation) OldEntryGroup(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEntryGroup is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEntryGroup requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEntryGroup: %w", err)
	}
	return oldValue.EntryGroup, nil
}

// AddEntryGroup adds i to the "entry_group" field.
func (m *ReceivableMutation) AddEntryGroup(i int) {
	if m.addentry_group != nil {
		*m.addentry_group += i
	} else {
		m.addentry_group = &i
	}
}

// AddedEntryGroup returns the value that was added to the "entry_group" field in this mutation.
func (m *ReceivableMutation) AddedEntryGroup() (r int, exists bool) {
	v := m.addentry_group
	if v == nil {
		return
	}
	return *v, true
}

// ResetEntryGroup resets all changes to the "entry_group" field.
func (m *ReceivableMutation) ResetEntryGroup() {
	m.entry_group = nil
	m.addentry_group = nil
}

// SetDate sets the "date" field.
func (m *ReceivableMutation) SetDate(t time.Time) {
	m.date = &t
}

// Date returns the value of the "date" field in the mutation.
func (m *ReceivableMutation) Date() (r time.Time, exists bool) {
	v := m.date
	if v == nil {
		return
	}
	return *v, true
}

// OldDate returns the old "date" field's value of the Receivable entity.
// If the Receivable object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReceivableMutation) OldDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDate: %w", err)
	}
	return oldValue.Date, nil
}

// ResetDate resets all changes to the "date" field.
func (m *ReceivableMutation) ResetDate() {
	m.date = nil
}

// SetName sets the "name" field.
func (m *ReceivableMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ReceivableMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Receivable entity.
// If the Receivable object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReceivableMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ReceivableMutation) ResetName() {
	m.name = nil
}

// SetAmountInDefault sets the "amount_in_default" field.
func (m *ReceivableMutation) SetAmountInDefault(f float64) {
	m.amount_in_default = &f
	m.addamount_in_default = nil
}

// AmountInDefault returns the value of the "amount_in_default" field in the mutation.
func (m *ReceivableMutation) AmountInDefault() (r float64, exists bool) {
	v := m.amount_in_default
	if v == nil {
		return
	}
	return *v, true
}

// OldAmountInDefault returns the old "amount_in_default" field's value of the Receivable entity.
// If the Receivable object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReceivableMutation) OldAmountInDefault(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAmountInDefault is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAmountInDefault requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAmountInDefault: %w", err)
	}
	return oldValue.AmountInDefault, nil
}

// AddAmountInDefault adds f to the "amount_in_default" field.
func (m *ReceivableMutation) AddAmountInDefault(f float64) {
	if m.addamount_in_default != nil {
		*m.addamount_in_default += f
	} else {
		m.addamount_in_default = &f
	}
}

// AddedAmountInDefault returns the value that was added to the "amount_in_default" field in this mutation.
func (m *ReceivableMutation) AddedAmountInDefault() (r float64, exists bool) {
	v := m.addamount_in_default
	if v == nil {
		return
	}
	return *v, true
}

// ResetAmountInDefault resets all changes to the "amount_in_default" field.
func (m *ReceivableMutation) ResetAmountInDefault() {
	m.amount_in_default = nil
	m.addamount_in_default = nil
}

// SetOutstandingBalance sets the "outstanding_balance" field.
func (m *ReceivableMutation) SetOutstandingBalance(f float64) {
	m.outstanding_balance = &f
	m.addoutstanding_balance = nil
}

// OutstandingBalance returns the value of the "outstanding_balance" field in the mutation.
func (m *ReceivableMutation) OutstandingBalance() (r float64, exists bool) {
	v := m.outstanding_balance
	if v == nil {
		return
	}
	return *v, true
}

// OldOutstandingBalance returns the old "outstanding_balance" field's value of the Receivable entity.
// If the Receivable object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReceivableMutation) OldOutstandingBalance(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOutstandingBalance is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOutstandingBalance requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOutstandingBalance: %w", err)
	}
	return oldValue.OutstandingBalance, nil
}

// AddOutstandingBalance adds f to the "outstanding_balance" field.
func (m *ReceivableMutation) AddOutstandingBalance(f float64) {
	if m.addoutstanding_balance != nil {
		*m.addoutstanding_balance += f
	} else {
		m.addoutstanding_balance = &f
	}
}

// AddedOutstandingBalance returns the value that was added to the "outstanding_balance" field in this mutation.
func (m *ReceivableMutation) AddedOutstandingBalance() (r float64, exists bool) {
	v := m.addoutstanding_balance
	if v == nil {
		return
	}
	return *v, true
}

// ResetOutstandingBalance resets all changes to the "outstanding_balance" field.
func (m *ReceivableMutation) ResetOutstandingBalance() {
	m.outstanding_balance = nil
	m.addoutstanding_balance = nil
}

// SetTotalTransaction sets the "total_transaction" field.
func (m *ReceivableMutation) SetTotalTransaction(f float64) {
	m.total_transaction = &f
	m.addtotal_transaction = nil
}

// TotalTransaction returns the value of the "total_transaction" field in the mutation.
func (m *ReceivableMutation) TotalTransaction() (r float64, exists bool) {
	v := m.total_transaction
	if v == nil {
		return
	}
	return *v, true
}

// OldTotalTransaction returns the old "total_transaction" field's value of the Receivable entity.
// If the Receivable object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReceivableMutation) OldTotalTransaction(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTotalTransaction is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTotalTransaction requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTotalTransaction: %w", err)
	}
	return oldValue.TotalTransaction, nil
}

// AddTotalTransaction adds f to the "total_transaction" field.
func (m *ReceivableMutation) AddTotalTransaction(f float64) {
	if m.addtotal_transaction != nil {
		*m.addtotal_transaction += f
	} else {
		m.addtotal_transaction = &f
	}
}

// AddedTotalTransaction returns the value that was added to the "total_transaction" field in this mutation.
func (m *ReceivableMutation) AddedTotalTransaction() (r float64, exists bool) {
	v := m.addtotal_transaction
	if v == nil {
		return
	}
	return *v, true
}

// ResetTotalTransaction resets all changes to the "total_transaction" field.
func (m *ReceivableMutation) ResetTotalTransaction() {
	m.total_transaction = nil
	m.addtotal_transaction = nil
}

// SetDueDate sets the "due_date" field.
func (m *ReceivableMutation) SetDueDate(t time.Time) {
	m.due_date = &t
}

// DueDate returns the value of the "due_date" field in the mutation.
func (m *ReceivableMutation) DueDate() (r time.Time, exists bool) {
	v := m.due_date
	if v == nil {
		return
	}
	return *v, true
}

// OldDueDate returns the old "due_date" field's value of the Receivable entity.
// If the Receivable object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReceivableMutation) OldDueDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDueDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDueDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDueDate: %w", err)
	}
	return oldValue.DueDate, nil
}

// ResetDueDate resets all changes to the "due_date" field.
func (m *ReceivableMutation) ResetDueDate() {
	m.due_date = nil
}

// SetStatus sets the "status" field.
func (m *ReceivableMutation) SetStatus(r receivable.Status) {
	m.status = &r
}

// Status returns the value of the "status" field in the mutation.
func (m *ReceivableMutation) Status() (r receivable.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Receivable entity.
// If the Receivable object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReceivableMutation) OldStatus(ctx context.Context) (v receivable.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *ReceivableMutation) ResetStatus() {
	m.status = nil
}

// SetCompanyID sets the "company" edge to the Company entity by id.
func (m *ReceivableMutation) SetCompanyID(id int) {
	m.company = &id
}

// ClearCompany clears the "company" edge to the Company entity.
func (m *ReceivableMutation) ClearCompany() {
	m.clearedcompany = true
}

// CompanyCleared reports if the "company" edge to the Company entity was cleared.
func (m *ReceivableMutation) CompanyCleared() bool {
	return m.clearedcompany
}

// CompanyID returns the "company" edge ID in the mutation.
func (m *ReceivableMutation) CompanyID() (id int, exists bool) {
	if m.company != nil {
		return *m.company, true
	}
	return
}

// CompanyIDs returns the "company" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CompanyID instead. It exists only for internal usage by the builders.
func (m *ReceivableMutation) CompanyIDs() (ids []int) {
	if id := m.company; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCompany resets all changes to the "company" edge.
func (m *ReceivableMutation) ResetCompany() {
	m.company = nil
	m.clearedcompany = false
}

// SetInvoiceID sets the "invoice" edge to the Invoice entity by id.
func (m *ReceivableMutation) SetInvoiceID(id int) {
	m.invoice = &id
}

// ClearInvoice clears the "invoice" edge to the Invoice entity.
func (m *ReceivableMutation) ClearInvoice() {
	m.clearedinvoice = true
}

// InvoiceCleared reports if the "invoice" edge to the Invoice entity was cleared.
func (m *ReceivableMutation) InvoiceCleared() bool {
	return m.clearedinvoice
}

// InvoiceID returns the "invoice" edge ID in the mutation.
func (m *ReceivableMutation) InvoiceID() (id int, exists bool) {
	if m.invoice != nil {
		return *m.invoice, true
	}
	return
}

// InvoiceIDs returns the "invoice" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// InvoiceID instead. It exists only for internal usage by the builders.
func (m *ReceivableMutation) InvoiceIDs() (ids []int) {
	if id := m.invoice; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetInvoice resets all changes to the "invoice" edge.
func (m *ReceivableMutation) ResetInvoice() {
	m.invoice = nil
	m.clearedinvoice = false
}

// Where appends a list predicates to the ReceivableMutation builder.
func (m *ReceivableMutation) Where(ps ...predicate.Receivable) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ReceivableMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ReceivableMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Receivable, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ReceivableMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ReceivableMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Receivable).
func (m *ReceivableMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ReceivableMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.created_at != nil {
		fields = append(fields, receivable.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, receivable.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, receivable.FieldDeletedAt)
	}
	if m.entry_group != nil {
		fields = append(fields, receivable.FieldEntryGroup)
	}
	if m.date != nil {
		fields = append(fields, receivable.FieldDate)
	}
	if m.name != nil {
		fields = append(fields, receivable.FieldName)
	}
	if m.amount_in_default != nil {
		fields = append(fields, receivable.FieldAmountInDefault)
	}
	if m.outstanding_balance != nil {
		fields = append(fields, receivable.FieldOutstandingBalance)
	}
	if m.total_transaction != nil {
		fields = append(fields, receivable.FieldTotalTransaction)
	}
	if m.due_date != nil {
		fields = append(fields, receivable.FieldDueDate)
	}
	if m.status != nil {
		fields = append(fields, receivable.FieldStatus)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ReceivableMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case receivable.FieldCreatedAt:
		return m.CreatedAt()
	case receivable.FieldUpdatedAt:
		return m.UpdatedAt()
	case receivable.FieldDeletedAt:
		return m.DeletedAt()
	case receivable.FieldEntryGroup:
		return m.EntryGroup()
	case receivable.FieldDate:
		return m.Date()
	case receivable.FieldName:
		return m.Name()
	case receivable.FieldAmountInDefault:
		return m.AmountInDefault()
	case receivable.FieldOutstandingBalance:
		return m.OutstandingBalance()
	case receivable.FieldTotalTransaction:
		return m.TotalTransaction()
	case receivable.FieldDueDate:
		return m.DueDate()
	case receivable.FieldStatus:
		return m.Status()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ReceivableMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case receivable.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case receivable.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case receivable.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case receivable.FieldEntryGroup:
		return m.OldEntryGroup(ctx)
	case receivable.FieldDate:
		return m.OldDate(ctx)
	case receivable.FieldName:
		return m.OldName(ctx)
	case receivable.FieldAmountInDefault:
		return m.OldAmountInDefault(ctx)
	case receivable.FieldOutstandingBalance:
		return m.OldOutstandingBalance(ctx)
	case receivable.FieldTotalTransaction:
		return m.OldTotalTransaction(ctx)
	case receivable.FieldDueDate:
		return m.OldDueDate(ctx)
	case receivable.FieldStatus:
		return m.OldStatus(ctx)
	}
	return nil, fmt.Errorf("unknown Receivable field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ReceivableMutation) SetField(name string, value ent.Value) error {
	switch name {
	case receivable.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case receivable.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case receivable.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case receivable.FieldEntryGroup:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEntryGroup(v)
		return nil
	case receivable.FieldDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDate(v)
		return nil
	case receivable.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case receivable.FieldAmountInDefault:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAmountInDefault(v)
		return nil
	case receivable.FieldOutstandingBalance:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOutstandingBalance(v)
		return nil
	case receivable.FieldTotalTransaction:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTotalTransaction(v)
		return nil
	case receivable.FieldDueDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDueDate(v)
		return nil
	case receivable.FieldStatus:
		v, ok := value.(receivable.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	}
	return fmt.Errorf("unknown Receivable field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ReceivableMutation) AddedFields() []string {
	var fields []string
	if m.addentry_group != nil {
		fields = append(fields, receivable.FieldEntryGroup)
	}
	if m.addamount_in_default != nil {
		fields = append(fields, receivable.FieldAmountInDefault)
	}
	if m.addoutstanding_balance != nil {
		fields = append(fields, receivable.FieldOutstandingBalance)
	}
	if m.addtotal_transaction != nil {
		fields = append(fields, receivable.FieldTotalTransaction)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ReceivableMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case receivable.FieldEntryGroup:
		return m.AddedEntryGroup()
	case receivable.FieldAmountInDefault:
		return m.AddedAmountInDefault()
	case receivable.FieldOutstandingBalance:
		return m.AddedOutstandingBalance()
	case receivable.FieldTotalTransaction:
		return m.AddedTotalTransaction()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ReceivableMutation) AddField(name string, value ent.Value) error {
	switch name {
	case receivable.FieldEntryGroup:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddEntryGroup(v)
		return nil
	case receivable.FieldAmountInDefault:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAmountInDefault(v)
		return nil
	case receivable.FieldOutstandingBalance:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOutstandingBalance(v)
		return nil
	case receivable.FieldTotalTransaction:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTotalTransaction(v)
		return nil
	}
	return fmt.Errorf("unknown Receivable numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ReceivableMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(receivable.FieldDeletedAt) {
		fields = append(fields, receivable.FieldDeletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ReceivableMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ReceivableMutation) ClearField(name string) error {
	switch name {
	case receivable.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown Receivable nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ReceivableMutation) ResetField(name string) error {
	switch name {
	case receivable.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case receivable.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case receivable.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case receivable.FieldEntryGroup:
		m.ResetEntryGroup()
		return nil
	case receivable.FieldDate:
		m.ResetDate()
		return nil
	case receivable.FieldName:
		m.ResetName()
		return nil
	case receivable.FieldAmountInDefault:
		m.ResetAmountInDefault()
		return nil
	case receivable.FieldOutstandingBalance:
		m.ResetOutstandingBalance()
		return nil
	case receivable.FieldTotalTransaction:
		m.ResetTotalTransaction()
		return nil
	case receivable.FieldDueDate:
		m.ResetDueDate()
		return nil
	case receivable.FieldStatus:
		m.ResetStatus()
		return nil
	}
	return fmt.Errorf("unknown Receivable field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ReceivableMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.company != nil {
		edges = append(edges, receivable.EdgeCompany)
	}
	if m.invoice != nil {
		edges = append(edges, receivable.EdgeInvoice)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ReceivableMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case receivable.EdgeCompany:
		if id := m.company; id != nil {
			return []ent.Value{*id}
		}
	case receivable.EdgeInvoice:
		if id := m.invoice; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ReceivableMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ReceivableMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ReceivableMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedcompany {
		edges = append(edges, receivable.EdgeCompany)
	}
	if m.clearedinvoice {
		edges = append(edges, receivable.EdgeInvoice)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ReceivableMutation) EdgeCleared(name string) bool {
	switch name {
	case receivable.EdgeCompany:
		return m.clearedcompany
	case receivable.EdgeInvoice:
		return m.clearedinvoice
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ReceivableMutation) ClearEdge(name string) error {
	switch name {
	case receivable.EdgeCompany:
		m.ClearCompany()
		return nil
	case receivable.EdgeInvoice:
		m.ClearInvoice()
		return nil
	}
	return fmt.Errorf("unknown Receivable unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ReceivableMutation) ResetEdge(name string) error {
	switch name {
	case receivable.EdgeCompany:
		m.ResetCompany()
		return nil
	case receivable.EdgeInvoice:
		m.ResetInvoice()
		return nil
	}
	return fmt.Errorf("unknown Receivable edge %s", name)
}

// SupplierMutation represents an operation that mutates the Supplier nodes in the graph.
type SupplierMutation struct {
	config
	op              Op
	typ             string
	id              *int
	created_at      *time.Time
	updated_at      *time.Time
	deleted_at      *time.Time
	address         *string
	city            *string
	country         *string
	description     *string
	email           *string
	is_default      *bool
	name            *string
	phone           *string
	tax_id          *string
	clearedFields   map[string]struct{}
	company         *int
	clearedcompany  bool
	loans           map[int]struct{}
	removedloans    map[int]struct{}
	clearedloans    bool
	payables        map[int]struct{}
	removedpayables map[int]struct{}
	clearedpayables bool
	done            bool
	oldValue        func(context.Context) (*Supplier, error)
	predicates      []predicate.Supplier
}

var _ ent.Mutation = (*SupplierMutation)(nil)

// supplierOption allows management of the mutation configuration using functional options.
type supplierOption func(*SupplierMutation)

// newSupplierMutation creates new mutation for the Supplier entity.
func newSupplierMutation(c config, op Op, opts ...supplierOption) *SupplierMutation {
	m := &SupplierMutation{
		config:        c,
		op:            op,
		typ:           TypeSupplier,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSupplierID sets the ID field of the mutation.
func withSupplierID(id int) supplierOption {
	return func(m *SupplierMutation) {
		var (
			err   error
			once  sync.Once
			value *Supplier
		)
		m.oldValue = func(ctx context.Context) (*Supplier, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Supplier.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSupplier sets the old Supplier of the mutation.
func withSupplier(node *Supplier) supplierOption {
	return func(m *SupplierMutation) {
		m.oldValue = func(context.Context) (*Supplier, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SupplierMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SupplierMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("generated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SupplierMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SupplierMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Supplier.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *SupplierMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *SupplierMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Supplier entity.
// If the Supplier object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SupplierMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *SupplierMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *SupplierMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *SupplierMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Supplier entity.
// If the Supplier object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SupplierMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *SupplierMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *SupplierMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *SupplierMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Supplier entity.
// If the Supplier object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SupplierMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *SupplierMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[supplier.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *SupplierMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[supplier.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *SupplierMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, supplier.FieldDeletedAt)
}

// SetAddress sets the "address" field.
func (m *SupplierMutation) SetAddress(s string) {
	m.address = &s
}

// Address returns the value of the "address" field in the mutation.
func (m *SupplierMutation) Address() (r string, exists bool) {
	v := m.address
	if v == nil {
		return
	}
	return *v, true
}

// OldAddress returns the old "address" field's value of the Supplier entity.
// If the Supplier object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SupplierMutation) OldAddress(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAddress: %w", err)
	}
	return oldValue.Address, nil
}

// ClearAddress clears the value of the "address" field.
func (m *SupplierMutation) ClearAddress() {
	m.address = nil
	m.clearedFields[supplier.FieldAddress] = struct{}{}
}

// AddressCleared returns if the "address" field was cleared in this mutation.
func (m *SupplierMutation) AddressCleared() bool {
	_, ok := m.clearedFields[supplier.FieldAddress]
	return ok
}

// ResetAddress resets all changes to the "address" field.
func (m *SupplierMutation) ResetAddress() {
	m.address = nil
	delete(m.clearedFields, supplier.FieldAddress)
}

// SetCity sets the "city" field.
func (m *SupplierMutation) SetCity(s string) {
	m.city = &s
}

// City returns the value of the "city" field in the mutation.
func (m *SupplierMutation) City() (r string, exists bool) {
	v := m.city
	if v == nil {
		return
	}
	return *v, true
}

// OldCity returns the old "city" field's value of the Supplier entity.
// If the Supplier object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SupplierMutation) OldCity(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCity: %w", err)
	}
	return oldValue.City, nil
}

// ClearCity clears the value of the "city" field.
func (m *SupplierMutation) ClearCity() {
	m.city = nil
	m.clearedFields[supplier.FieldCity] = struct{}{}
}

// CityCleared returns if the "city" field was cleared in this mutation.
func (m *SupplierMutation) CityCleared() bool {
	_, ok := m.clearedFields[supplier.FieldCity]
	return ok
}

// ResetCity resets all changes to the "city" field.
func (m *SupplierMutation) ResetCity() {
	m.city = nil
	delete(m.clearedFields, supplier.FieldCity)
}

// SetCountry sets the "country" field.
func (m *SupplierMutation) SetCountry(s string) {
	m.country = &s
}

// Country returns the value of the "country" field in the mutation.
func (m *SupplierMutation) Country() (r string, exists bool) {
	v := m.country
	if v == nil {
		return
	}
	return *v, true
}

// OldCountry returns the old "country" field's value of the Supplier entity.
// If the Supplier object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SupplierMutation) OldCountry(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCountry is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCountry requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCountry: %w", err)
	}
	return oldValue.Country, nil
}

// ClearCountry clears the value of the "country" field.
func (m *SupplierMutation) ClearCountry() {
	m.country = nil
	m.clearedFields[supplier.FieldCountry] = struct{}{}
}

// CountryCleared returns if the "country" field was cleared in this mutation.
func (m *SupplierMutation) CountryCleared() bool {
	_, ok := m.clearedFields[supplier.FieldCountry]
	return ok
}

// ResetCountry resets all changes to the "country" field.
func (m *SupplierMutation) ResetCountry() {
	m.country = nil
	delete(m.clearedFields, supplier.FieldCountry)
}

// SetDescription sets the "description" field.
func (m *SupplierMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *SupplierMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Supplier entity.
// If the Supplier object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SupplierMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *SupplierMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[supplier.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *SupplierMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[supplier.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *SupplierMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, supplier.FieldDescription)
}

// SetEmail sets the "email" field.
func (m *SupplierMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *SupplierMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the Supplier entity.
// If the Supplier object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SupplierMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ClearEmail clears the value of the "email" field.
func (m *SupplierMutation) ClearEmail() {
	m.email = nil
	m.clearedFields[supplier.FieldEmail] = struct{}{}
}

// EmailCleared returns if the "email" field was cleared in this mutation.
func (m *SupplierMutation) EmailCleared() bool {
	_, ok := m.clearedFields[supplier.FieldEmail]
	return ok
}

// ResetEmail resets all changes to the "email" field.
func (m *SupplierMutation) ResetEmail() {
	m.email = nil
	delete(m.clearedFields, supplier.FieldEmail)
}

// SetIsDefault sets the "is_default" field.
func (m *SupplierMutation) SetIsDefault(b bool) {
	m.is_default = &b
}

// IsDefault returns the value of the "is_default" field in the mutation.
func (m *SupplierMutation) IsDefault() (r bool, exists bool) {
	v := m.is_default
	if v == nil {
		return
	}
	return *v, true
}

// OldIsDefault returns the old "is_default" field's value of the Supplier entity.
// If the Supplier object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SupplierMutation) OldIsDefault(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsDefault is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsDefault requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsDefault: %w", err)
	}
	return oldValue.IsDefault, nil
}

// ClearIsDefault clears the value of the "is_default" field.
func (m *SupplierMutation) ClearIsDefault() {
	m.is_default = nil
	m.clearedFields[supplier.FieldIsDefault] = struct{}{}
}

// IsDefaultCleared returns if the "is_default" field was cleared in this mutation.
func (m *SupplierMutation) IsDefaultCleared() bool {
	_, ok := m.clearedFields[supplier.FieldIsDefault]
	return ok
}

// ResetIsDefault resets all changes to the "is_default" field.
func (m *SupplierMutation) ResetIsDefault() {
	m.is_default = nil
	delete(m.clearedFields, supplier.FieldIsDefault)
}

// SetName sets the "name" field.
func (m *SupplierMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *SupplierMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Supplier entity.
// If the Supplier object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SupplierMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *SupplierMutation) ResetName() {
	m.name = nil
}

// SetPhone sets the "phone" field.
func (m *SupplierMutation) SetPhone(s string) {
	m.phone = &s
}

// Phone returns the value of the "phone" field in the mutation.
func (m *SupplierMutation) Phone() (r string, exists bool) {
	v := m.phone
	if v == nil {
		return
	}
	return *v, true
}

// OldPhone returns the old "phone" field's value of the Supplier entity.
// If the Supplier object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SupplierMutation) OldPhone(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPhone is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPhone requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPhone: %w", err)
	}
	return oldValue.Phone, nil
}

// ClearPhone clears the value of the "phone" field.
func (m *SupplierMutation) ClearPhone() {
	m.phone = nil
	m.clearedFields[supplier.FieldPhone] = struct{}{}
}

// PhoneCleared returns if the "phone" field was cleared in this mutation.
func (m *SupplierMutation) PhoneCleared() bool {
	_, ok := m.clearedFields[supplier.FieldPhone]
	return ok
}

// ResetPhone resets all changes to the "phone" field.
func (m *SupplierMutation) ResetPhone() {
	m.phone = nil
	delete(m.clearedFields, supplier.FieldPhone)
}

// SetTaxID sets the "tax_id" field.
func (m *SupplierMutation) SetTaxID(s string) {
	m.tax_id = &s
}

// TaxID returns the value of the "tax_id" field in the mutation.
func (m *SupplierMutation) TaxID() (r string, exists bool) {
	v := m.tax_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTaxID returns the old "tax_id" field's value of the Supplier entity.
// If the Supplier object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SupplierMutation) OldTaxID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTaxID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTaxID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTaxID: %w", err)
	}
	return oldValue.TaxID, nil
}

// ClearTaxID clears the value of the "tax_id" field.
func (m *SupplierMutation) ClearTaxID() {
	m.tax_id = nil
	m.clearedFields[supplier.FieldTaxID] = struct{}{}
}

// TaxIDCleared returns if the "tax_id" field was cleared in this mutation.
func (m *SupplierMutation) TaxIDCleared() bool {
	_, ok := m.clearedFields[supplier.FieldTaxID]
	return ok
}

// ResetTaxID resets all changes to the "tax_id" field.
func (m *SupplierMutation) ResetTaxID() {
	m.tax_id = nil
	delete(m.clearedFields, supplier.FieldTaxID)
}

// SetCompanyID sets the "company" edge to the Company entity by id.
func (m *SupplierMutation) SetCompanyID(id int) {
	m.company = &id
}

// ClearCompany clears the "company" edge to the Company entity.
func (m *SupplierMutation) ClearCompany() {
	m.clearedcompany = true
}

// CompanyCleared reports if the "company" edge to the Company entity was cleared.
func (m *SupplierMutation) CompanyCleared() bool {
	return m.clearedcompany
}

// CompanyID returns the "company" edge ID in the mutation.
func (m *SupplierMutation) CompanyID() (id int, exists bool) {
	if m.company != nil {
		return *m.company, true
	}
	return
}

// CompanyIDs returns the "company" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CompanyID instead. It exists only for internal usage by the builders.
func (m *SupplierMutation) CompanyIDs() (ids []int) {
	if id := m.company; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCompany resets all changes to the "company" edge.
func (m *SupplierMutation) ResetCompany() {
	m.company = nil
	m.clearedcompany = false
}

// AddLoanIDs adds the "loans" edge to the Loan entity by ids.
func (m *SupplierMutation) AddLoanIDs(ids ...int) {
	if m.loans == nil {
		m.loans = make(map[int]struct{})
	}
	for i := range ids {
		m.loans[ids[i]] = struct{}{}
	}
}

// ClearLoans clears the "loans" edge to the Loan entity.
func (m *SupplierMutation) ClearLoans() {
	m.clearedloans = true
}

// LoansCleared reports if the "loans" edge to the Loan entity was cleared.
func (m *SupplierMutation) LoansCleared() bool {
	return m.clearedloans
}

// RemoveLoanIDs removes the "loans" edge to the Loan entity by IDs.
func (m *SupplierMutation) RemoveLoanIDs(ids ...int) {
	if m.removedloans == nil {
		m.removedloans = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.loans, ids[i])
		m.removedloans[ids[i]] = struct{}{}
	}
}

// RemovedLoans returns the removed IDs of the "loans" edge to the Loan entity.
func (m *SupplierMutation) RemovedLoansIDs() (ids []int) {
	for id := range m.removedloans {
		ids = append(ids, id)
	}
	return
}

// LoansIDs returns the "loans" edge IDs in the mutation.
func (m *SupplierMutation) LoansIDs() (ids []int) {
	for id := range m.loans {
		ids = append(ids, id)
	}
	return
}

// ResetLoans resets all changes to the "loans" edge.
func (m *SupplierMutation) ResetLoans() {
	m.loans = nil
	m.clearedloans = false
	m.removedloans = nil
}

// AddPayableIDs adds the "payables" edge to the Payable entity by ids.
func (m *SupplierMutation) AddPayableIDs(ids ...int) {
	if m.payables == nil {
		m.payables = make(map[int]struct{})
	}
	for i := range ids {
		m.payables[ids[i]] = struct{}{}
	}
}

// ClearPayables clears the "payables" edge to the Payable entity.
func (m *SupplierMutation) ClearPayables() {
	m.clearedpayables = true
}

// PayablesCleared reports if the "payables" edge to the Payable entity was cleared.
func (m *SupplierMutation) PayablesCleared() bool {
	return m.clearedpayables
}

// RemovePayableIDs removes the "payables" edge to the Payable entity by IDs.
func (m *SupplierMutation) RemovePayableIDs(ids ...int) {
	if m.removedpayables == nil {
		m.removedpayables = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.payables, ids[i])
		m.removedpayables[ids[i]] = struct{}{}
	}
}

// RemovedPayables returns the removed IDs of the "payables" edge to the Payable entity.
func (m *SupplierMutation) RemovedPayablesIDs() (ids []int) {
	for id := range m.removedpayables {
		ids = append(ids, id)
	}
	return
}

// PayablesIDs returns the "payables" edge IDs in the mutation.
func (m *SupplierMutation) PayablesIDs() (ids []int) {
	for id := range m.payables {
		ids = append(ids, id)
	}
	return
}

// ResetPayables resets all changes to the "payables" edge.
func (m *SupplierMutation) ResetPayables() {
	m.payables = nil
	m.clearedpayables = false
	m.removedpayables = nil
}

// Where appends a list predicates to the SupplierMutation builder.
func (m *SupplierMutation) Where(ps ...predicate.Supplier) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SupplierMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SupplierMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Supplier, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SupplierMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SupplierMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Supplier).
func (m *SupplierMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SupplierMutation) Fields() []string {
	fields := make([]string, 0, 12)
	if m.created_at != nil {
		fields = append(fields, supplier.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, supplier.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, supplier.FieldDeletedAt)
	}
	if m.address != nil {
		fields = append(fields, supplier.FieldAddress)
	}
	if m.city != nil {
		fields = append(fields, supplier.FieldCity)
	}
	if m.country != nil {
		fields = append(fields, supplier.FieldCountry)
	}
	if m.description != nil {
		fields = append(fields, supplier.FieldDescription)
	}
	if m.email != nil {
		fields = append(fields, supplier.FieldEmail)
	}
	if m.is_default != nil {
		fields = append(fields, supplier.FieldIsDefault)
	}
	if m.name != nil {
		fields = append(fields, supplier.FieldName)
	}
	if m.phone != nil {
		fields = append(fields, supplier.FieldPhone)
	}
	if m.tax_id != nil {
		fields = append(fields, supplier.FieldTaxID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SupplierMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case supplier.FieldCreatedAt:
		return m.CreatedAt()
	case supplier.FieldUpdatedAt:
		return m.UpdatedAt()
	case supplier.FieldDeletedAt:
		return m.DeletedAt()
	case supplier.FieldAddress:
		return m.Address()
	case supplier.FieldCity:
		return m.City()
	case supplier.FieldCountry:
		return m.Country()
	case supplier.FieldDescription:
		return m.Description()
	case supplier.FieldEmail:
		return m.Email()
	case supplier.FieldIsDefault:
		return m.IsDefault()
	case supplier.FieldName:
		return m.Name()
	case supplier.FieldPhone:
		return m.Phone()
	case supplier.FieldTaxID:
		return m.TaxID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SupplierMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case supplier.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case supplier.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case supplier.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case supplier.FieldAddress:
		return m.OldAddress(ctx)
	case supplier.FieldCity:
		return m.OldCity(ctx)
	case supplier.FieldCountry:
		return m.OldCountry(ctx)
	case supplier.FieldDescription:
		return m.OldDescription(ctx)
	case supplier.FieldEmail:
		return m.OldEmail(ctx)
	case supplier.FieldIsDefault:
		return m.OldIsDefault(ctx)
	case supplier.FieldName:
		return m.OldName(ctx)
	case supplier.FieldPhone:
		return m.OldPhone(ctx)
	case supplier.FieldTaxID:
		return m.OldTaxID(ctx)
	}
	return nil, fmt.Errorf("unknown Supplier field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SupplierMutation) SetField(name string, value ent.Value) error {
	switch name {
	case supplier.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case supplier.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case supplier.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case supplier.FieldAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAddress(v)
		return nil
	case supplier.FieldCity:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCity(v)
		return nil
	case supplier.FieldCountry:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCountry(v)
		return nil
	case supplier.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case supplier.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case supplier.FieldIsDefault:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsDefault(v)
		return nil
	case supplier.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case supplier.FieldPhone:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPhone(v)
		return nil
	case supplier.FieldTaxID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTaxID(v)
		return nil
	}
	return fmt.Errorf("unknown Supplier field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SupplierMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SupplierMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SupplierMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Supplier numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SupplierMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(supplier.FieldDeletedAt) {
		fields = append(fields, supplier.FieldDeletedAt)
	}
	if m.FieldCleared(supplier.FieldAddress) {
		fields = append(fields, supplier.FieldAddress)
	}
	if m.FieldCleared(supplier.FieldCity) {
		fields = append(fields, supplier.FieldCity)
	}
	if m.FieldCleared(supplier.FieldCountry) {
		fields = append(fields, supplier.FieldCountry)
	}
	if m.FieldCleared(supplier.FieldDescription) {
		fields = append(fields, supplier.FieldDescription)
	}
	if m.FieldCleared(supplier.FieldEmail) {
		fields = append(fields, supplier.FieldEmail)
	}
	if m.FieldCleared(supplier.FieldIsDefault) {
		fields = append(fields, supplier.FieldIsDefault)
	}
	if m.FieldCleared(supplier.FieldPhone) {
		fields = append(fields, supplier.FieldPhone)
	}
	if m.FieldCleared(supplier.FieldTaxID) {
		fields = append(fields, supplier.FieldTaxID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SupplierMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SupplierMutation) ClearField(name string) error {
	switch name {
	case supplier.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case supplier.FieldAddress:
		m.ClearAddress()
		return nil
	case supplier.FieldCity:
		m.ClearCity()
		return nil
	case supplier.FieldCountry:
		m.ClearCountry()
		return nil
	case supplier.FieldDescription:
		m.ClearDescription()
		return nil
	case supplier.FieldEmail:
		m.ClearEmail()
		return nil
	case supplier.FieldIsDefault:
		m.ClearIsDefault()
		return nil
	case supplier.FieldPhone:
		m.ClearPhone()
		return nil
	case supplier.FieldTaxID:
		m.ClearTaxID()
		return nil
	}
	return fmt.Errorf("unknown Supplier nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SupplierMutation) ResetField(name string) error {
	switch name {
	case supplier.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case supplier.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case supplier.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case supplier.FieldAddress:
		m.ResetAddress()
		return nil
	case supplier.FieldCity:
		m.ResetCity()
		return nil
	case supplier.FieldCountry:
		m.ResetCountry()
		return nil
	case supplier.FieldDescription:
		m.ResetDescription()
		return nil
	case supplier.FieldEmail:
		m.ResetEmail()
		return nil
	case supplier.FieldIsDefault:
		m.ResetIsDefault()
		return nil
	case supplier.FieldName:
		m.ResetName()
		return nil
	case supplier.FieldPhone:
		m.ResetPhone()
		return nil
	case supplier.FieldTaxID:
		m.ResetTaxID()
		return nil
	}
	return fmt.Errorf("unknown Supplier field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SupplierMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.company != nil {
		edges = append(edges, supplier.EdgeCompany)
	}
	if m.loans != nil {
		edges = append(edges, supplier.EdgeLoans)
	}
	if m.payables != nil {
		edges = append(edges, supplier.EdgePayables)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SupplierMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case supplier.EdgeCompany:
		if id := m.company; id != nil {
			return []ent.Value{*id}
		}
	case supplier.EdgeLoans:
		ids := make([]ent.Value, 0, len(m.loans))
		for id := range m.loans {
			ids = append(ids, id)
		}
		return ids
	case supplier.EdgePayables:
		ids := make([]ent.Value, 0, len(m.payables))
		for id := range m.payables {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SupplierMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedloans != nil {
		edges = append(edges, supplier.EdgeLoans)
	}
	if m.removedpayables != nil {
		edges = append(edges, supplier.EdgePayables)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SupplierMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case supplier.EdgeLoans:
		ids := make([]ent.Value, 0, len(m.removedloans))
		for id := range m.removedloans {
			ids = append(ids, id)
		}
		return ids
	case supplier.EdgePayables:
		ids := make([]ent.Value, 0, len(m.removedpayables))
		for id := range m.removedpayables {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SupplierMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedcompany {
		edges = append(edges, supplier.EdgeCompany)
	}
	if m.clearedloans {
		edges = append(edges, supplier.EdgeLoans)
	}
	if m.clearedpayables {
		edges = append(edges, supplier.EdgePayables)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SupplierMutation) EdgeCleared(name string) bool {
	switch name {
	case supplier.EdgeCompany:
		return m.clearedcompany
	case supplier.EdgeLoans:
		return m.clearedloans
	case supplier.EdgePayables:
		return m.clearedpayables
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SupplierMutation) ClearEdge(name string) error {
	switch name {
	case supplier.EdgeCompany:
		m.ClearCompany()
		return nil
	}
	return fmt.Errorf("unknown Supplier unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SupplierMutation) ResetEdge(name string) error {
	switch name {
	case supplier.EdgeCompany:
		m.ResetCompany()
		return nil
	case supplier.EdgeLoans:
		m.ResetLoans()
		return nil
	case supplier.EdgePayables:
		m.ResetPayables()
		return nil
	}
	return fmt.Errorf("unknown Supplier edge %s", name)
}

// TokenMutation represents an operation that mutates the Token nodes in the graph.
type TokenMutation struct {
	config
	op             Op
	typ            string
	id             *int
	expiry         *time.Time
	category       *token.Category
	token          *string
	clearedFields  map[string]struct{}
	company        *int
	clearedcompany bool
	user           *int
	cleareduser    bool
	done           bool
	oldValue       func(context.Context) (*Token, error)
	predicates     []predicate.Token
}

var _ ent.Mutation = (*TokenMutation)(nil)

// tokenOption allows management of the mutation configuration using functional options.
type tokenOption func(*TokenMutation)

// newTokenMutation creates new mutation for the Token entity.
func newTokenMutation(c config, op Op, opts ...tokenOption) *TokenMutation {
	m := &TokenMutation{
		config:        c,
		op:            op,
		typ:           TypeToken,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTokenID sets the ID field of the mutation.
func withTokenID(id int) tokenOption {
	return func(m *TokenMutation) {
		var (
			err   error
			once  sync.Once
			value *Token
		)
		m.oldValue = func(ctx context.Context) (*Token, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Token.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withToken sets the old Token of the mutation.
func withToken(node *Token) tokenOption {
	return func(m *TokenMutation) {
		m.oldValue = func(context.Context) (*Token, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TokenMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TokenMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("generated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TokenMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TokenMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Token.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetExpiry sets the "expiry" field.
func (m *TokenMutation) SetExpiry(t time.Time) {
	m.expiry = &t
}

// Expiry returns the value of the "expiry" field in the mutation.
func (m *TokenMutation) Expiry() (r time.Time, exists bool) {
	v := m.expiry
	if v == nil {
		return
	}
	return *v, true
}

// OldExpiry returns the old "expiry" field's value of the Token entity.
// If the Token object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TokenMutation) OldExpiry(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExpiry is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExpiry requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpiry: %w", err)
	}
	return oldValue.Expiry, nil
}

// ResetExpiry resets all changes to the "expiry" field.
func (m *TokenMutation) ResetExpiry() {
	m.expiry = nil
}

// SetCategory sets the "category" field.
func (m *TokenMutation) SetCategory(t token.Category) {
	m.category = &t
}

// Category returns the value of the "category" field in the mutation.
func (m *TokenMutation) Category() (r token.Category, exists bool) {
	v := m.category
	if v == nil {
		return
	}
	return *v, true
}

// OldCategory returns the old "category" field's value of the Token entity.
// If the Token object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TokenMutation) OldCategory(ctx context.Context) (v token.Category, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCategory is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCategory requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCategory: %w", err)
	}
	return oldValue.Category, nil
}

// ResetCategory resets all changes to the "category" field.
func (m *TokenMutation) ResetCategory() {
	m.category = nil
}

// SetToken sets the "token" field.
func (m *TokenMutation) SetToken(s string) {
	m.token = &s
}

// Token returns the value of the "token" field in the mutation.
func (m *TokenMutation) Token() (r string, exists bool) {
	v := m.token
	if v == nil {
		return
	}
	return *v, true
}

// OldToken returns the old "token" field's value of the Token entity.
// If the Token object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TokenMutation) OldToken(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldToken is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldToken requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldToken: %w", err)
	}
	return oldValue.Token, nil
}

// ResetToken resets all changes to the "token" field.
func (m *TokenMutation) ResetToken() {
	m.token = nil
}

// SetCompanyID sets the "company" edge to the Company entity by id.
func (m *TokenMutation) SetCompanyID(id int) {
	m.company = &id
}

// ClearCompany clears the "company" edge to the Company entity.
func (m *TokenMutation) ClearCompany() {
	m.clearedcompany = true
}

// CompanyCleared reports if the "company" edge to the Company entity was cleared.
func (m *TokenMutation) CompanyCleared() bool {
	return m.clearedcompany
}

// CompanyID returns the "company" edge ID in the mutation.
func (m *TokenMutation) CompanyID() (id int, exists bool) {
	if m.company != nil {
		return *m.company, true
	}
	return
}

// CompanyIDs returns the "company" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CompanyID instead. It exists only for internal usage by the builders.
func (m *TokenMutation) CompanyIDs() (ids []int) {
	if id := m.company; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCompany resets all changes to the "company" edge.
func (m *TokenMutation) ResetCompany() {
	m.company = nil
	m.clearedcompany = false
}

// SetUserID sets the "user" edge to the User entity by id.
func (m *TokenMutation) SetUserID(id int) {
	m.user = &id
}

// ClearUser clears the "user" edge to the User entity.
func (m *TokenMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *TokenMutation) UserCleared() bool {
	return m.cleareduser
}

// UserID returns the "user" edge ID in the mutation.
func (m *TokenMutation) UserID() (id int, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *TokenMutation) UserIDs() (ids []int) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *TokenMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the TokenMutation builder.
func (m *TokenMutation) Where(ps ...predicate.Token) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TokenMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TokenMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Token, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TokenMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TokenMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Token).
func (m *TokenMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TokenMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.expiry != nil {
		fields = append(fields, token.FieldExpiry)
	}
	if m.category != nil {
		fields = append(fields, token.FieldCategory)
	}
	if m.token != nil {
		fields = append(fields, token.FieldToken)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TokenMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case token.FieldExpiry:
		return m.Expiry()
	case token.FieldCategory:
		return m.Category()
	case token.FieldToken:
		return m.Token()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TokenMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case token.FieldExpiry:
		return m.OldExpiry(ctx)
	case token.FieldCategory:
		return m.OldCategory(ctx)
	case token.FieldToken:
		return m.OldToken(ctx)
	}
	return nil, fmt.Errorf("unknown Token field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TokenMutation) SetField(name string, value ent.Value) error {
	switch name {
	case token.FieldExpiry:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpiry(v)
		return nil
	case token.FieldCategory:
		v, ok := value.(token.Category)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCategory(v)
		return nil
	case token.FieldToken:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetToken(v)
		return nil
	}
	return fmt.Errorf("unknown Token field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TokenMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TokenMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TokenMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Token numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TokenMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TokenMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TokenMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Token nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TokenMutation) ResetField(name string) error {
	switch name {
	case token.FieldExpiry:
		m.ResetExpiry()
		return nil
	case token.FieldCategory:
		m.ResetCategory()
		return nil
	case token.FieldToken:
		m.ResetToken()
		return nil
	}
	return fmt.Errorf("unknown Token field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TokenMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.company != nil {
		edges = append(edges, token.EdgeCompany)
	}
	if m.user != nil {
		edges = append(edges, token.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TokenMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case token.EdgeCompany:
		if id := m.company; id != nil {
			return []ent.Value{*id}
		}
	case token.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TokenMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TokenMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TokenMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedcompany {
		edges = append(edges, token.EdgeCompany)
	}
	if m.cleareduser {
		edges = append(edges, token.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TokenMutation) EdgeCleared(name string) bool {
	switch name {
	case token.EdgeCompany:
		return m.clearedcompany
	case token.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TokenMutation) ClearEdge(name string) error {
	switch name {
	case token.EdgeCompany:
		m.ClearCompany()
		return nil
	case token.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown Token unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TokenMutation) ResetEdge(name string) error {
	switch name {
	case token.EdgeCompany:
		m.ResetCompany()
		return nil
	case token.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown Token edge %s", name)
}

// TreasuryMutation represents an operation that mutates the Treasury nodes in the graph.
type TreasuryMutation struct {
	config
	op             Op
	typ            string
	id             *int
	created_at     *time.Time
	updated_at     *time.Time
	deleted_at     *time.Time
	balance        *float64
	addbalance     *float64
	clearedFields  map[string]struct{}
	company        *int
	clearedcompany bool
	done           bool
	oldValue       func(context.Context) (*Treasury, error)
	predicates     []predicate.Treasury
}

var _ ent.Mutation = (*TreasuryMutation)(nil)

// treasuryOption allows management of the mutation configuration using functional options.
type treasuryOption func(*TreasuryMutation)

// newTreasuryMutation creates new mutation for the Treasury entity.
func newTreasuryMutation(c config, op Op, opts ...treasuryOption) *TreasuryMutation {
	m := &TreasuryMutation{
		config:        c,
		op:            op,
		typ:           TypeTreasury,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTreasuryID sets the ID field of the mutation.
func withTreasuryID(id int) treasuryOption {
	return func(m *TreasuryMutation) {
		var (
			err   error
			once  sync.Once
			value *Treasury
		)
		m.oldValue = func(ctx context.Context) (*Treasury, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Treasury.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTreasury sets the old Treasury of the mutation.
func withTreasury(node *Treasury) treasuryOption {
	return func(m *TreasuryMutation) {
		m.oldValue = func(context.Context) (*Treasury, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TreasuryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TreasuryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("generated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TreasuryMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TreasuryMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Treasury.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *TreasuryMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *TreasuryMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Treasury entity.
// If the Treasury object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TreasuryMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *TreasuryMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *TreasuryMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *TreasuryMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Treasury entity.
// If the Treasury object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TreasuryMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *TreasuryMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *TreasuryMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *TreasuryMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Treasury entity.
// If the Treasury object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TreasuryMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *TreasuryMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[treasury.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *TreasuryMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[treasury.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *TreasuryMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, treasury.FieldDeletedAt)
}

// SetBalance sets the "balance" field.
func (m *TreasuryMutation) SetBalance(f float64) {
	m.balance = &f
	m.addbalance = nil
}

// Balance returns the value of the "balance" field in the mutation.
func (m *TreasuryMutation) Balance() (r float64, exists bool) {
	v := m.balance
	if v == nil {
		return
	}
	return *v, true
}

// OldBalance returns the old "balance" field's value of the Treasury entity.
// If the Treasury object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TreasuryMutation) OldBalance(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBalance is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBalance requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBalance: %w", err)
	}
	return oldValue.Balance, nil
}

// AddBalance adds f to the "balance" field.
func (m *TreasuryMutation) AddBalance(f float64) {
	if m.addbalance != nil {
		*m.addbalance += f
	} else {
		m.addbalance = &f
	}
}

// AddedBalance returns the value that was added to the "balance" field in this mutation.
func (m *TreasuryMutation) AddedBalance() (r float64, exists bool) {
	v := m.addbalance
	if v == nil {
		return
	}
	return *v, true
}

// ResetBalance resets all changes to the "balance" field.
func (m *TreasuryMutation) ResetBalance() {
	m.balance = nil
	m.addbalance = nil
}

// SetCompanyID sets the "company" edge to the Company entity by id.
func (m *TreasuryMutation) SetCompanyID(id int) {
	m.company = &id
}

// ClearCompany clears the "company" edge to the Company entity.
func (m *TreasuryMutation) ClearCompany() {
	m.clearedcompany = true
}

// CompanyCleared reports if the "company" edge to the Company entity was cleared.
func (m *TreasuryMutation) CompanyCleared() bool {
	return m.clearedcompany
}

// CompanyID returns the "company" edge ID in the mutation.
func (m *TreasuryMutation) CompanyID() (id int, exists bool) {
	if m.company != nil {
		return *m.company, true
	}
	return
}

// CompanyIDs returns the "company" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CompanyID instead. It exists only for internal usage by the builders.
func (m *TreasuryMutation) CompanyIDs() (ids []int) {
	if id := m.company; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCompany resets all changes to the "company" edge.
func (m *TreasuryMutation) ResetCompany() {
	m.company = nil
	m.clearedcompany = false
}

// Where appends a list predicates to the TreasuryMutation builder.
func (m *TreasuryMutation) Where(ps ...predicate.Treasury) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TreasuryMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TreasuryMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Treasury, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TreasuryMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TreasuryMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Treasury).
func (m *TreasuryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TreasuryMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.created_at != nil {
		fields = append(fields, treasury.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, treasury.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, treasury.FieldDeletedAt)
	}
	if m.balance != nil {
		fields = append(fields, treasury.FieldBalance)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TreasuryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case treasury.FieldCreatedAt:
		return m.CreatedAt()
	case treasury.FieldUpdatedAt:
		return m.UpdatedAt()
	case treasury.FieldDeletedAt:
		return m.DeletedAt()
	case treasury.FieldBalance:
		return m.Balance()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TreasuryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case treasury.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case treasury.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case treasury.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case treasury.FieldBalance:
		return m.OldBalance(ctx)
	}
	return nil, fmt.Errorf("unknown Treasury field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TreasuryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case treasury.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case treasury.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case treasury.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case treasury.FieldBalance:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBalance(v)
		return nil
	}
	return fmt.Errorf("unknown Treasury field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TreasuryMutation) AddedFields() []string {
	var fields []string
	if m.addbalance != nil {
		fields = append(fields, treasury.FieldBalance)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TreasuryMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case treasury.FieldBalance:
		return m.AddedBalance()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TreasuryMutation) AddField(name string, value ent.Value) error {
	switch name {
	case treasury.FieldBalance:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddBalance(v)
		return nil
	}
	return fmt.Errorf("unknown Treasury numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TreasuryMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(treasury.FieldDeletedAt) {
		fields = append(fields, treasury.FieldDeletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TreasuryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TreasuryMutation) ClearField(name string) error {
	switch name {
	case treasury.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown Treasury nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TreasuryMutation) ResetField(name string) error {
	switch name {
	case treasury.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case treasury.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case treasury.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case treasury.FieldBalance:
		m.ResetBalance()
		return nil
	}
	return fmt.Errorf("unknown Treasury field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TreasuryMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.company != nil {
		edges = append(edges, treasury.EdgeCompany)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TreasuryMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case treasury.EdgeCompany:
		if id := m.company; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TreasuryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TreasuryMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TreasuryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedcompany {
		edges = append(edges, treasury.EdgeCompany)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TreasuryMutation) EdgeCleared(name string) bool {
	switch name {
	case treasury.EdgeCompany:
		return m.clearedcompany
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TreasuryMutation) ClearEdge(name string) error {
	switch name {
	case treasury.EdgeCompany:
		m.ClearCompany()
		return nil
	}
	return fmt.Errorf("unknown Treasury unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TreasuryMutation) ResetEdge(name string) error {
	switch name {
	case treasury.EdgeCompany:
		m.ResetCompany()
		return nil
	}
	return fmt.Errorf("unknown Treasury edge %s", name)
}

// UserMutation represents an operation that mutates the User nodes in the graph.
type UserMutation struct {
	config
	op                                  Op
	typ                                 string
	id                                  *int
	created_at                          *time.Time
	updated_at                          *time.Time
	deleted_at                          *time.Time
	device                              *string
	is_demo_user                        *bool
	firebase_UID                        *string
	fcm_token                           *string
	expo_push_token                     *string
	email                               *string
	name                                *string
	address                             *string
	avatar                              *string
	photo_URL                           *string
	department                          *string
	phone                               *string
	birthdate                           *time.Time
	last_login                          *time.Time
	gender                              *user.Gender
	active                              *bool
	clearedFields                       map[string]struct{}
	accounting_entries                  map[int]struct{}
	removedaccounting_entries           map[int]struct{}
	clearedaccounting_entries           bool
	company                             map[int]struct{}
	removedcompany                      map[int]struct{}
	clearedcompany                      bool
	assigned_roles                      map[int]struct{}
	removedassigned_roles               map[int]struct{}
	clearedassigned_roles               bool
	subordinates                        map[int]struct{}
	removedsubordinates                 map[int]struct{}
	clearedsubordinates                 bool
	leader                              *int
	clearedleader                       bool
	created_member_signup_tokens        map[int]struct{}
	removedcreated_member_signup_tokens map[int]struct{}
	clearedcreated_member_signup_tokens bool
	employee                            *int
	clearedemployee                     bool
	issued_invoices                     map[int]struct{}
	removedissued_invoices              map[int]struct{}
	clearedissued_invoices              bool
	created_projects                    map[int]struct{}
	removedcreated_projects             map[int]struct{}
	clearedcreated_projects             bool
	leadered_projects                   map[int]struct{}
	removedleadered_projects            map[int]struct{}
	clearedleadered_projects            bool
	assigned_project_tasks              map[int]struct{}
	removedassigned_project_tasks       map[int]struct{}
	clearedassigned_project_tasks       bool
	participated_project_tasks          map[int]struct{}
	removedparticipated_project_tasks   map[int]struct{}
	clearedparticipated_project_tasks   bool
	created_tasks                       map[int]struct{}
	removedcreated_tasks                map[int]struct{}
	clearedcreated_tasks                bool
	tokens                              map[int]struct{}
	removedtokens                       map[int]struct{}
	clearedtokens                       bool
	approved_work_shifts                map[int]struct{}
	removedapproved_work_shifts         map[int]struct{}
	clearedapproved_work_shifts         bool
	work_shifts                         map[int]struct{}
	removedwork_shifts                  map[int]struct{}
	clearedwork_shifts                  bool
	uploaded_documents                  map[int]struct{}
	removeduploaded_documents           map[int]struct{}
	cleareduploaded_documents           bool
	approved_documents                  map[int]struct{}
	removedapproved_documents           map[int]struct{}
	clearedapproved_documents           bool
	done                                bool
	oldValue                            func(context.Context) (*User, error)
	predicates                          []predicate.User
}

var _ ent.Mutation = (*UserMutation)(nil)

// userOption allows management of the mutation configuration using functional options.
type userOption func(*UserMutation)

// newUserMutation creates new mutation for the User entity.
func newUserMutation(c config, op Op, opts ...userOption) *UserMutation {
	m := &UserMutation{
		config:        c,
		op:            op,
		typ:           TypeUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserID sets the ID field of the mutation.
func withUserID(id int) userOption {
	return func(m *UserMutation) {
		var (
			err   error
			once  sync.Once
			value *User
		)
		m.oldValue = func(ctx context.Context) (*User, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().User.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUser sets the old User of the mutation.
func withUser(node *User) userOption {
	return func(m *UserMutation) {
		m.oldValue = func(context.Context) (*User, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("generated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().User.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *UserMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UserMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UserMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *UserMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *UserMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *UserMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *UserMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *UserMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *UserMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[user.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *UserMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[user.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *UserMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, user.FieldDeletedAt)
}

// SetDevice sets the "device" field.
func (m *UserMutation) SetDevice(s string) {
	m.device = &s
}

// Device returns the value of the "device" field in the mutation.
func (m *UserMutation) Device() (r string, exists bool) {
	v := m.device
	if v == nil {
		return
	}
	return *v, true
}

// OldDevice returns the old "device" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldDevice(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDevice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDevice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDevice: %w", err)
	}
	return oldValue.Device, nil
}

// ClearDevice clears the value of the "device" field.
func (m *UserMutation) ClearDevice() {
	m.device = nil
	m.clearedFields[user.FieldDevice] = struct{}{}
}

// DeviceCleared returns if the "device" field was cleared in this mutation.
func (m *UserMutation) DeviceCleared() bool {
	_, ok := m.clearedFields[user.FieldDevice]
	return ok
}

// ResetDevice resets all changes to the "device" field.
func (m *UserMutation) ResetDevice() {
	m.device = nil
	delete(m.clearedFields, user.FieldDevice)
}

// SetIsDemoUser sets the "is_demo_user" field.
func (m *UserMutation) SetIsDemoUser(b bool) {
	m.is_demo_user = &b
}

// IsDemoUser returns the value of the "is_demo_user" field in the mutation.
func (m *UserMutation) IsDemoUser() (r bool, exists bool) {
	v := m.is_demo_user
	if v == nil {
		return
	}
	return *v, true
}

// OldIsDemoUser returns the old "is_demo_user" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldIsDemoUser(ctx context.Context) (v *bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsDemoUser is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsDemoUser requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsDemoUser: %w", err)
	}
	return oldValue.IsDemoUser, nil
}

// ClearIsDemoUser clears the value of the "is_demo_user" field.
func (m *UserMutation) ClearIsDemoUser() {
	m.is_demo_user = nil
	m.clearedFields[user.FieldIsDemoUser] = struct{}{}
}

// IsDemoUserCleared returns if the "is_demo_user" field was cleared in this mutation.
func (m *UserMutation) IsDemoUserCleared() bool {
	_, ok := m.clearedFields[user.FieldIsDemoUser]
	return ok
}

// ResetIsDemoUser resets all changes to the "is_demo_user" field.
func (m *UserMutation) ResetIsDemoUser() {
	m.is_demo_user = nil
	delete(m.clearedFields, user.FieldIsDemoUser)
}

// SetFirebaseUID sets the "firebase_UID" field.
func (m *UserMutation) SetFirebaseUID(s string) {
	m.firebase_UID = &s
}

// FirebaseUID returns the value of the "firebase_UID" field in the mutation.
func (m *UserMutation) FirebaseUID() (r string, exists bool) {
	v := m.firebase_UID
	if v == nil {
		return
	}
	return *v, true
}

// OldFirebaseUID returns the old "firebase_UID" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldFirebaseUID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFirebaseUID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFirebaseUID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFirebaseUID: %w", err)
	}
	return oldValue.FirebaseUID, nil
}

// ResetFirebaseUID resets all changes to the "firebase_UID" field.
func (m *UserMutation) ResetFirebaseUID() {
	m.firebase_UID = nil
}

// SetFcmToken sets the "fcm_token" field.
func (m *UserMutation) SetFcmToken(s string) {
	m.fcm_token = &s
}

// FcmToken returns the value of the "fcm_token" field in the mutation.
func (m *UserMutation) FcmToken() (r string, exists bool) {
	v := m.fcm_token
	if v == nil {
		return
	}
	return *v, true
}

// OldFcmToken returns the old "fcm_token" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldFcmToken(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFcmToken is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFcmToken requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFcmToken: %w", err)
	}
	return oldValue.FcmToken, nil
}

// ClearFcmToken clears the value of the "fcm_token" field.
func (m *UserMutation) ClearFcmToken() {
	m.fcm_token = nil
	m.clearedFields[user.FieldFcmToken] = struct{}{}
}

// FcmTokenCleared returns if the "fcm_token" field was cleared in this mutation.
func (m *UserMutation) FcmTokenCleared() bool {
	_, ok := m.clearedFields[user.FieldFcmToken]
	return ok
}

// ResetFcmToken resets all changes to the "fcm_token" field.
func (m *UserMutation) ResetFcmToken() {
	m.fcm_token = nil
	delete(m.clearedFields, user.FieldFcmToken)
}

// SetExpoPushToken sets the "expo_push_token" field.
func (m *UserMutation) SetExpoPushToken(s string) {
	m.expo_push_token = &s
}

// ExpoPushToken returns the value of the "expo_push_token" field in the mutation.
func (m *UserMutation) ExpoPushToken() (r string, exists bool) {
	v := m.expo_push_token
	if v == nil {
		return
	}
	return *v, true
}

// OldExpoPushToken returns the old "expo_push_token" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldExpoPushToken(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExpoPushToken is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExpoPushToken requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpoPushToken: %w", err)
	}
	return oldValue.ExpoPushToken, nil
}

// ClearExpoPushToken clears the value of the "expo_push_token" field.
func (m *UserMutation) ClearExpoPushToken() {
	m.expo_push_token = nil
	m.clearedFields[user.FieldExpoPushToken] = struct{}{}
}

// ExpoPushTokenCleared returns if the "expo_push_token" field was cleared in this mutation.
func (m *UserMutation) ExpoPushTokenCleared() bool {
	_, ok := m.clearedFields[user.FieldExpoPushToken]
	return ok
}

// ResetExpoPushToken resets all changes to the "expo_push_token" field.
func (m *UserMutation) ResetExpoPushToken() {
	m.expo_push_token = nil
	delete(m.clearedFields, user.FieldExpoPushToken)
}

// SetEmail sets the "email" field.
func (m *UserMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *UserMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ResetEmail resets all changes to the "email" field.
func (m *UserMutation) ResetEmail() {
	m.email = nil
}

// SetName sets the "name" field.
func (m *UserMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *UserMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *UserMutation) ResetName() {
	m.name = nil
}

// SetAddress sets the "address" field.
func (m *UserMutation) SetAddress(s string) {
	m.address = &s
}

// Address returns the value of the "address" field in the mutation.
func (m *UserMutation) Address() (r string, exists bool) {
	v := m.address
	if v == nil {
		return
	}
	return *v, true
}

// OldAddress returns the old "address" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldAddress(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAddress: %w", err)
	}
	return oldValue.Address, nil
}

// ClearAddress clears the value of the "address" field.
func (m *UserMutation) ClearAddress() {
	m.address = nil
	m.clearedFields[user.FieldAddress] = struct{}{}
}

// AddressCleared returns if the "address" field was cleared in this mutation.
func (m *UserMutation) AddressCleared() bool {
	_, ok := m.clearedFields[user.FieldAddress]
	return ok
}

// ResetAddress resets all changes to the "address" field.
func (m *UserMutation) ResetAddress() {
	m.address = nil
	delete(m.clearedFields, user.FieldAddress)
}

// SetAvatar sets the "avatar" field.
func (m *UserMutation) SetAvatar(s string) {
	m.avatar = &s
}

// Avatar returns the value of the "avatar" field in the mutation.
func (m *UserMutation) Avatar() (r string, exists bool) {
	v := m.avatar
	if v == nil {
		return
	}
	return *v, true
}

// OldAvatar returns the old "avatar" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldAvatar(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAvatar is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAvatar requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAvatar: %w", err)
	}
	return oldValue.Avatar, nil
}

// ClearAvatar clears the value of the "avatar" field.
func (m *UserMutation) ClearAvatar() {
	m.avatar = nil
	m.clearedFields[user.FieldAvatar] = struct{}{}
}

// AvatarCleared returns if the "avatar" field was cleared in this mutation.
func (m *UserMutation) AvatarCleared() bool {
	_, ok := m.clearedFields[user.FieldAvatar]
	return ok
}

// ResetAvatar resets all changes to the "avatar" field.
func (m *UserMutation) ResetAvatar() {
	m.avatar = nil
	delete(m.clearedFields, user.FieldAvatar)
}

// SetPhotoURL sets the "photo_URL" field.
func (m *UserMutation) SetPhotoURL(s string) {
	m.photo_URL = &s
}

// PhotoURL returns the value of the "photo_URL" field in the mutation.
func (m *UserMutation) PhotoURL() (r string, exists bool) {
	v := m.photo_URL
	if v == nil {
		return
	}
	return *v, true
}

// OldPhotoURL returns the old "photo_URL" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldPhotoURL(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPhotoURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPhotoURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPhotoURL: %w", err)
	}
	return oldValue.PhotoURL, nil
}

// ClearPhotoURL clears the value of the "photo_URL" field.
func (m *UserMutation) ClearPhotoURL() {
	m.photo_URL = nil
	m.clearedFields[user.FieldPhotoURL] = struct{}{}
}

// PhotoURLCleared returns if the "photo_URL" field was cleared in this mutation.
func (m *UserMutation) PhotoURLCleared() bool {
	_, ok := m.clearedFields[user.FieldPhotoURL]
	return ok
}

// ResetPhotoURL resets all changes to the "photo_URL" field.
func (m *UserMutation) ResetPhotoURL() {
	m.photo_URL = nil
	delete(m.clearedFields, user.FieldPhotoURL)
}

// SetDepartment sets the "department" field.
func (m *UserMutation) SetDepartment(s string) {
	m.department = &s
}

// Department returns the value of the "department" field in the mutation.
func (m *UserMutation) Department() (r string, exists bool) {
	v := m.department
	if v == nil {
		return
	}
	return *v, true
}

// OldDepartment returns the old "department" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldDepartment(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDepartment is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDepartment requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDepartment: %w", err)
	}
	return oldValue.Department, nil
}

// ClearDepartment clears the value of the "department" field.
func (m *UserMutation) ClearDepartment() {
	m.department = nil
	m.clearedFields[user.FieldDepartment] = struct{}{}
}

// DepartmentCleared returns if the "department" field was cleared in this mutation.
func (m *UserMutation) DepartmentCleared() bool {
	_, ok := m.clearedFields[user.FieldDepartment]
	return ok
}

// ResetDepartment resets all changes to the "department" field.
func (m *UserMutation) ResetDepartment() {
	m.department = nil
	delete(m.clearedFields, user.FieldDepartment)
}

// SetPhone sets the "phone" field.
func (m *UserMutation) SetPhone(s string) {
	m.phone = &s
}

// Phone returns the value of the "phone" field in the mutation.
func (m *UserMutation) Phone() (r string, exists bool) {
	v := m.phone
	if v == nil {
		return
	}
	return *v, true
}

// OldPhone returns the old "phone" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldPhone(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPhone is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPhone requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPhone: %w", err)
	}
	return oldValue.Phone, nil
}

// ClearPhone clears the value of the "phone" field.
func (m *UserMutation) ClearPhone() {
	m.phone = nil
	m.clearedFields[user.FieldPhone] = struct{}{}
}

// PhoneCleared returns if the "phone" field was cleared in this mutation.
func (m *UserMutation) PhoneCleared() bool {
	_, ok := m.clearedFields[user.FieldPhone]
	return ok
}

// ResetPhone resets all changes to the "phone" field.
func (m *UserMutation) ResetPhone() {
	m.phone = nil
	delete(m.clearedFields, user.FieldPhone)
}

// SetBirthdate sets the "birthdate" field.
func (m *UserMutation) SetBirthdate(t time.Time) {
	m.birthdate = &t
}

// Birthdate returns the value of the "birthdate" field in the mutation.
func (m *UserMutation) Birthdate() (r time.Time, exists bool) {
	v := m.birthdate
	if v == nil {
		return
	}
	return *v, true
}

// OldBirthdate returns the old "birthdate" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldBirthdate(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBirthdate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBirthdate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBirthdate: %w", err)
	}
	return oldValue.Birthdate, nil
}

// ClearBirthdate clears the value of the "birthdate" field.
func (m *UserMutation) ClearBirthdate() {
	m.birthdate = nil
	m.clearedFields[user.FieldBirthdate] = struct{}{}
}

// BirthdateCleared returns if the "birthdate" field was cleared in this mutation.
func (m *UserMutation) BirthdateCleared() bool {
	_, ok := m.clearedFields[user.FieldBirthdate]
	return ok
}

// ResetBirthdate resets all changes to the "birthdate" field.
func (m *UserMutation) ResetBirthdate() {
	m.birthdate = nil
	delete(m.clearedFields, user.FieldBirthdate)
}

// SetLastLogin sets the "last_login" field.
func (m *UserMutation) SetLastLogin(t time.Time) {
	m.last_login = &t
}

// LastLogin returns the value of the "last_login" field in the mutation.
func (m *UserMutation) LastLogin() (r time.Time, exists bool) {
	v := m.last_login
	if v == nil {
		return
	}
	return *v, true
}

// OldLastLogin returns the old "last_login" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldLastLogin(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastLogin is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastLogin requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastLogin: %w", err)
	}
	return oldValue.LastLogin, nil
}

// ClearLastLogin clears the value of the "last_login" field.
func (m *UserMutation) ClearLastLogin() {
	m.last_login = nil
	m.clearedFields[user.FieldLastLogin] = struct{}{}
}

// LastLoginCleared returns if the "last_login" field was cleared in this mutation.
func (m *UserMutation) LastLoginCleared() bool {
	_, ok := m.clearedFields[user.FieldLastLogin]
	return ok
}

// ResetLastLogin resets all changes to the "last_login" field.
func (m *UserMutation) ResetLastLogin() {
	m.last_login = nil
	delete(m.clearedFields, user.FieldLastLogin)
}

// SetGender sets the "gender" field.
func (m *UserMutation) SetGender(u user.Gender) {
	m.gender = &u
}

// Gender returns the value of the "gender" field in the mutation.
func (m *UserMutation) Gender() (r user.Gender, exists bool) {
	v := m.gender
	if v == nil {
		return
	}
	return *v, true
}

// OldGender returns the old "gender" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldGender(ctx context.Context) (v user.Gender, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGender is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGender requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGender: %w", err)
	}
	return oldValue.Gender, nil
}

// ResetGender resets all changes to the "gender" field.
func (m *UserMutation) ResetGender() {
	m.gender = nil
}

// SetActive sets the "active" field.
func (m *UserMutation) SetActive(b bool) {
	m.active = &b
}

// Active returns the value of the "active" field in the mutation.
func (m *UserMutation) Active() (r bool, exists bool) {
	v := m.active
	if v == nil {
		return
	}
	return *v, true
}

// OldActive returns the old "active" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldActive(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldActive is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldActive requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldActive: %w", err)
	}
	return oldValue.Active, nil
}

// ResetActive resets all changes to the "active" field.
func (m *UserMutation) ResetActive() {
	m.active = nil
}

// AddAccountingEntryIDs adds the "accounting_entries" edge to the AccountingEntry entity by ids.
func (m *UserMutation) AddAccountingEntryIDs(ids ...int) {
	if m.accounting_entries == nil {
		m.accounting_entries = make(map[int]struct{})
	}
	for i := range ids {
		m.accounting_entries[ids[i]] = struct{}{}
	}
}

// ClearAccountingEntries clears the "accounting_entries" edge to the AccountingEntry entity.
func (m *UserMutation) ClearAccountingEntries() {
	m.clearedaccounting_entries = true
}

// AccountingEntriesCleared reports if the "accounting_entries" edge to the AccountingEntry entity was cleared.
func (m *UserMutation) AccountingEntriesCleared() bool {
	return m.clearedaccounting_entries
}

// RemoveAccountingEntryIDs removes the "accounting_entries" edge to the AccountingEntry entity by IDs.
func (m *UserMutation) RemoveAccountingEntryIDs(ids ...int) {
	if m.removedaccounting_entries == nil {
		m.removedaccounting_entries = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.accounting_entries, ids[i])
		m.removedaccounting_entries[ids[i]] = struct{}{}
	}
}

// RemovedAccountingEntries returns the removed IDs of the "accounting_entries" edge to the AccountingEntry entity.
func (m *UserMutation) RemovedAccountingEntriesIDs() (ids []int) {
	for id := range m.removedaccounting_entries {
		ids = append(ids, id)
	}
	return
}

// AccountingEntriesIDs returns the "accounting_entries" edge IDs in the mutation.
func (m *UserMutation) AccountingEntriesIDs() (ids []int) {
	for id := range m.accounting_entries {
		ids = append(ids, id)
	}
	return
}

// ResetAccountingEntries resets all changes to the "accounting_entries" edge.
func (m *UserMutation) ResetAccountingEntries() {
	m.accounting_entries = nil
	m.clearedaccounting_entries = false
	m.removedaccounting_entries = nil
}

// AddCompanyIDs adds the "company" edge to the Company entity by ids.
func (m *UserMutation) AddCompanyIDs(ids ...int) {
	if m.company == nil {
		m.company = make(map[int]struct{})
	}
	for i := range ids {
		m.company[ids[i]] = struct{}{}
	}
}

// ClearCompany clears the "company" edge to the Company entity.
func (m *UserMutation) ClearCompany() {
	m.clearedcompany = true
}

// CompanyCleared reports if the "company" edge to the Company entity was cleared.
func (m *UserMutation) CompanyCleared() bool {
	return m.clearedcompany
}

// RemoveCompanyIDs removes the "company" edge to the Company entity by IDs.
func (m *UserMutation) RemoveCompanyIDs(ids ...int) {
	if m.removedcompany == nil {
		m.removedcompany = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.company, ids[i])
		m.removedcompany[ids[i]] = struct{}{}
	}
}

// RemovedCompany returns the removed IDs of the "company" edge to the Company entity.
func (m *UserMutation) RemovedCompanyIDs() (ids []int) {
	for id := range m.removedcompany {
		ids = append(ids, id)
	}
	return
}

// CompanyIDs returns the "company" edge IDs in the mutation.
func (m *UserMutation) CompanyIDs() (ids []int) {
	for id := range m.company {
		ids = append(ids, id)
	}
	return
}

// ResetCompany resets all changes to the "company" edge.
func (m *UserMutation) ResetCompany() {
	m.company = nil
	m.clearedcompany = false
	m.removedcompany = nil
}

// AddAssignedRoleIDs adds the "assigned_roles" edge to the UserRole entity by ids.
func (m *UserMutation) AddAssignedRoleIDs(ids ...int) {
	if m.assigned_roles == nil {
		m.assigned_roles = make(map[int]struct{})
	}
	for i := range ids {
		m.assigned_roles[ids[i]] = struct{}{}
	}
}

// ClearAssignedRoles clears the "assigned_roles" edge to the UserRole entity.
func (m *UserMutation) ClearAssignedRoles() {
	m.clearedassigned_roles = true
}

// AssignedRolesCleared reports if the "assigned_roles" edge to the UserRole entity was cleared.
func (m *UserMutation) AssignedRolesCleared() bool {
	return m.clearedassigned_roles
}

// RemoveAssignedRoleIDs removes the "assigned_roles" edge to the UserRole entity by IDs.
func (m *UserMutation) RemoveAssignedRoleIDs(ids ...int) {
	if m.removedassigned_roles == nil {
		m.removedassigned_roles = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.assigned_roles, ids[i])
		m.removedassigned_roles[ids[i]] = struct{}{}
	}
}

// RemovedAssignedRoles returns the removed IDs of the "assigned_roles" edge to the UserRole entity.
func (m *UserMutation) RemovedAssignedRolesIDs() (ids []int) {
	for id := range m.removedassigned_roles {
		ids = append(ids, id)
	}
	return
}

// AssignedRolesIDs returns the "assigned_roles" edge IDs in the mutation.
func (m *UserMutation) AssignedRolesIDs() (ids []int) {
	for id := range m.assigned_roles {
		ids = append(ids, id)
	}
	return
}

// ResetAssignedRoles resets all changes to the "assigned_roles" edge.
func (m *UserMutation) ResetAssignedRoles() {
	m.assigned_roles = nil
	m.clearedassigned_roles = false
	m.removedassigned_roles = nil
}

// AddSubordinateIDs adds the "subordinates" edge to the User entity by ids.
func (m *UserMutation) AddSubordinateIDs(ids ...int) {
	if m.subordinates == nil {
		m.subordinates = make(map[int]struct{})
	}
	for i := range ids {
		m.subordinates[ids[i]] = struct{}{}
	}
}

// ClearSubordinates clears the "subordinates" edge to the User entity.
func (m *UserMutation) ClearSubordinates() {
	m.clearedsubordinates = true
}

// SubordinatesCleared reports if the "subordinates" edge to the User entity was cleared.
func (m *UserMutation) SubordinatesCleared() bool {
	return m.clearedsubordinates
}

// RemoveSubordinateIDs removes the "subordinates" edge to the User entity by IDs.
func (m *UserMutation) RemoveSubordinateIDs(ids ...int) {
	if m.removedsubordinates == nil {
		m.removedsubordinates = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.subordinates, ids[i])
		m.removedsubordinates[ids[i]] = struct{}{}
	}
}

// RemovedSubordinates returns the removed IDs of the "subordinates" edge to the User entity.
func (m *UserMutation) RemovedSubordinatesIDs() (ids []int) {
	for id := range m.removedsubordinates {
		ids = append(ids, id)
	}
	return
}

// SubordinatesIDs returns the "subordinates" edge IDs in the mutation.
func (m *UserMutation) SubordinatesIDs() (ids []int) {
	for id := range m.subordinates {
		ids = append(ids, id)
	}
	return
}

// ResetSubordinates resets all changes to the "subordinates" edge.
func (m *UserMutation) ResetSubordinates() {
	m.subordinates = nil
	m.clearedsubordinates = false
	m.removedsubordinates = nil
}

// SetLeaderID sets the "leader" edge to the User entity by id.
func (m *UserMutation) SetLeaderID(id int) {
	m.leader = &id
}

// ClearLeader clears the "leader" edge to the User entity.
func (m *UserMutation) ClearLeader() {
	m.clearedleader = true
}

// LeaderCleared reports if the "leader" edge to the User entity was cleared.
func (m *UserMutation) LeaderCleared() bool {
	return m.clearedleader
}

// LeaderID returns the "leader" edge ID in the mutation.
func (m *UserMutation) LeaderID() (id int, exists bool) {
	if m.leader != nil {
		return *m.leader, true
	}
	return
}

// LeaderIDs returns the "leader" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// LeaderID instead. It exists only for internal usage by the builders.
func (m *UserMutation) LeaderIDs() (ids []int) {
	if id := m.leader; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetLeader resets all changes to the "leader" edge.
func (m *UserMutation) ResetLeader() {
	m.leader = nil
	m.clearedleader = false
}

// AddCreatedMemberSignupTokenIDs adds the "created_member_signup_tokens" edge to the MemberSignupToken entity by ids.
func (m *UserMutation) AddCreatedMemberSignupTokenIDs(ids ...int) {
	if m.created_member_signup_tokens == nil {
		m.created_member_signup_tokens = make(map[int]struct{})
	}
	for i := range ids {
		m.created_member_signup_tokens[ids[i]] = struct{}{}
	}
}

// ClearCreatedMemberSignupTokens clears the "created_member_signup_tokens" edge to the MemberSignupToken entity.
func (m *UserMutation) ClearCreatedMemberSignupTokens() {
	m.clearedcreated_member_signup_tokens = true
}

// CreatedMemberSignupTokensCleared reports if the "created_member_signup_tokens" edge to the MemberSignupToken entity was cleared.
func (m *UserMutation) CreatedMemberSignupTokensCleared() bool {
	return m.clearedcreated_member_signup_tokens
}

// RemoveCreatedMemberSignupTokenIDs removes the "created_member_signup_tokens" edge to the MemberSignupToken entity by IDs.
func (m *UserMutation) RemoveCreatedMemberSignupTokenIDs(ids ...int) {
	if m.removedcreated_member_signup_tokens == nil {
		m.removedcreated_member_signup_tokens = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.created_member_signup_tokens, ids[i])
		m.removedcreated_member_signup_tokens[ids[i]] = struct{}{}
	}
}

// RemovedCreatedMemberSignupTokens returns the removed IDs of the "created_member_signup_tokens" edge to the MemberSignupToken entity.
func (m *UserMutation) RemovedCreatedMemberSignupTokensIDs() (ids []int) {
	for id := range m.removedcreated_member_signup_tokens {
		ids = append(ids, id)
	}
	return
}

// CreatedMemberSignupTokensIDs returns the "created_member_signup_tokens" edge IDs in the mutation.
func (m *UserMutation) CreatedMemberSignupTokensIDs() (ids []int) {
	for id := range m.created_member_signup_tokens {
		ids = append(ids, id)
	}
	return
}

// ResetCreatedMemberSignupTokens resets all changes to the "created_member_signup_tokens" edge.
func (m *UserMutation) ResetCreatedMemberSignupTokens() {
	m.created_member_signup_tokens = nil
	m.clearedcreated_member_signup_tokens = false
	m.removedcreated_member_signup_tokens = nil
}

// SetEmployeeID sets the "employee" edge to the Employee entity by id.
func (m *UserMutation) SetEmployeeID(id int) {
	m.employee = &id
}

// ClearEmployee clears the "employee" edge to the Employee entity.
func (m *UserMutation) ClearEmployee() {
	m.clearedemployee = true
}

// EmployeeCleared reports if the "employee" edge to the Employee entity was cleared.
func (m *UserMutation) EmployeeCleared() bool {
	return m.clearedemployee
}

// EmployeeID returns the "employee" edge ID in the mutation.
func (m *UserMutation) EmployeeID() (id int, exists bool) {
	if m.employee != nil {
		return *m.employee, true
	}
	return
}

// EmployeeIDs returns the "employee" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// EmployeeID instead. It exists only for internal usage by the builders.
func (m *UserMutation) EmployeeIDs() (ids []int) {
	if id := m.employee; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEmployee resets all changes to the "employee" edge.
func (m *UserMutation) ResetEmployee() {
	m.employee = nil
	m.clearedemployee = false
}

// AddIssuedInvoiceIDs adds the "issued_invoices" edge to the Invoice entity by ids.
func (m *UserMutation) AddIssuedInvoiceIDs(ids ...int) {
	if m.issued_invoices == nil {
		m.issued_invoices = make(map[int]struct{})
	}
	for i := range ids {
		m.issued_invoices[ids[i]] = struct{}{}
	}
}

// ClearIssuedInvoices clears the "issued_invoices" edge to the Invoice entity.
func (m *UserMutation) ClearIssuedInvoices() {
	m.clearedissued_invoices = true
}

// IssuedInvoicesCleared reports if the "issued_invoices" edge to the Invoice entity was cleared.
func (m *UserMutation) IssuedInvoicesCleared() bool {
	return m.clearedissued_invoices
}

// RemoveIssuedInvoiceIDs removes the "issued_invoices" edge to the Invoice entity by IDs.
func (m *UserMutation) RemoveIssuedInvoiceIDs(ids ...int) {
	if m.removedissued_invoices == nil {
		m.removedissued_invoices = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.issued_invoices, ids[i])
		m.removedissued_invoices[ids[i]] = struct{}{}
	}
}

// RemovedIssuedInvoices returns the removed IDs of the "issued_invoices" edge to the Invoice entity.
func (m *UserMutation) RemovedIssuedInvoicesIDs() (ids []int) {
	for id := range m.removedissued_invoices {
		ids = append(ids, id)
	}
	return
}

// IssuedInvoicesIDs returns the "issued_invoices" edge IDs in the mutation.
func (m *UserMutation) IssuedInvoicesIDs() (ids []int) {
	for id := range m.issued_invoices {
		ids = append(ids, id)
	}
	return
}

// ResetIssuedInvoices resets all changes to the "issued_invoices" edge.
func (m *UserMutation) ResetIssuedInvoices() {
	m.issued_invoices = nil
	m.clearedissued_invoices = false
	m.removedissued_invoices = nil
}

// AddCreatedProjectIDs adds the "created_projects" edge to the Project entity by ids.
func (m *UserMutation) AddCreatedProjectIDs(ids ...int) {
	if m.created_projects == nil {
		m.created_projects = make(map[int]struct{})
	}
	for i := range ids {
		m.created_projects[ids[i]] = struct{}{}
	}
}

// ClearCreatedProjects clears the "created_projects" edge to the Project entity.
func (m *UserMutation) ClearCreatedProjects() {
	m.clearedcreated_projects = true
}

// CreatedProjectsCleared reports if the "created_projects" edge to the Project entity was cleared.
func (m *UserMutation) CreatedProjectsCleared() bool {
	return m.clearedcreated_projects
}

// RemoveCreatedProjectIDs removes the "created_projects" edge to the Project entity by IDs.
func (m *UserMutation) RemoveCreatedProjectIDs(ids ...int) {
	if m.removedcreated_projects == nil {
		m.removedcreated_projects = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.created_projects, ids[i])
		m.removedcreated_projects[ids[i]] = struct{}{}
	}
}

// RemovedCreatedProjects returns the removed IDs of the "created_projects" edge to the Project entity.
func (m *UserMutation) RemovedCreatedProjectsIDs() (ids []int) {
	for id := range m.removedcreated_projects {
		ids = append(ids, id)
	}
	return
}

// CreatedProjectsIDs returns the "created_projects" edge IDs in the mutation.
func (m *UserMutation) CreatedProjectsIDs() (ids []int) {
	for id := range m.created_projects {
		ids = append(ids, id)
	}
	return
}

// ResetCreatedProjects resets all changes to the "created_projects" edge.
func (m *UserMutation) ResetCreatedProjects() {
	m.created_projects = nil
	m.clearedcreated_projects = false
	m.removedcreated_projects = nil
}

// AddLeaderedProjectIDs adds the "leadered_projects" edge to the Project entity by ids.
func (m *UserMutation) AddLeaderedProjectIDs(ids ...int) {
	if m.leadered_projects == nil {
		m.leadered_projects = make(map[int]struct{})
	}
	for i := range ids {
		m.leadered_projects[ids[i]] = struct{}{}
	}
}

// ClearLeaderedProjects clears the "leadered_projects" edge to the Project entity.
func (m *UserMutation) ClearLeaderedProjects() {
	m.clearedleadered_projects = true
}

// LeaderedProjectsCleared reports if the "leadered_projects" edge to the Project entity was cleared.
func (m *UserMutation) LeaderedProjectsCleared() bool {
	return m.clearedleadered_projects
}

// RemoveLeaderedProjectIDs removes the "leadered_projects" edge to the Project entity by IDs.
func (m *UserMutation) RemoveLeaderedProjectIDs(ids ...int) {
	if m.removedleadered_projects == nil {
		m.removedleadered_projects = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.leadered_projects, ids[i])
		m.removedleadered_projects[ids[i]] = struct{}{}
	}
}

// RemovedLeaderedProjects returns the removed IDs of the "leadered_projects" edge to the Project entity.
func (m *UserMutation) RemovedLeaderedProjectsIDs() (ids []int) {
	for id := range m.removedleadered_projects {
		ids = append(ids, id)
	}
	return
}

// LeaderedProjectsIDs returns the "leadered_projects" edge IDs in the mutation.
func (m *UserMutation) LeaderedProjectsIDs() (ids []int) {
	for id := range m.leadered_projects {
		ids = append(ids, id)
	}
	return
}

// ResetLeaderedProjects resets all changes to the "leadered_projects" edge.
func (m *UserMutation) ResetLeaderedProjects() {
	m.leadered_projects = nil
	m.clearedleadered_projects = false
	m.removedleadered_projects = nil
}

// AddAssignedProjectTaskIDs adds the "assigned_project_tasks" edge to the ProjectTask entity by ids.
func (m *UserMutation) AddAssignedProjectTaskIDs(ids ...int) {
	if m.assigned_project_tasks == nil {
		m.assigned_project_tasks = make(map[int]struct{})
	}
	for i := range ids {
		m.assigned_project_tasks[ids[i]] = struct{}{}
	}
}

// ClearAssignedProjectTasks clears the "assigned_project_tasks" edge to the ProjectTask entity.
func (m *UserMutation) ClearAssignedProjectTasks() {
	m.clearedassigned_project_tasks = true
}

// AssignedProjectTasksCleared reports if the "assigned_project_tasks" edge to the ProjectTask entity was cleared.
func (m *UserMutation) AssignedProjectTasksCleared() bool {
	return m.clearedassigned_project_tasks
}

// RemoveAssignedProjectTaskIDs removes the "assigned_project_tasks" edge to the ProjectTask entity by IDs.
func (m *UserMutation) RemoveAssignedProjectTaskIDs(ids ...int) {
	if m.removedassigned_project_tasks == nil {
		m.removedassigned_project_tasks = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.assigned_project_tasks, ids[i])
		m.removedassigned_project_tasks[ids[i]] = struct{}{}
	}
}

// RemovedAssignedProjectTasks returns the removed IDs of the "assigned_project_tasks" edge to the ProjectTask entity.
func (m *UserMutation) RemovedAssignedProjectTasksIDs() (ids []int) {
	for id := range m.removedassigned_project_tasks {
		ids = append(ids, id)
	}
	return
}

// AssignedProjectTasksIDs returns the "assigned_project_tasks" edge IDs in the mutation.
func (m *UserMutation) AssignedProjectTasksIDs() (ids []int) {
	for id := range m.assigned_project_tasks {
		ids = append(ids, id)
	}
	return
}

// ResetAssignedProjectTasks resets all changes to the "assigned_project_tasks" edge.
func (m *UserMutation) ResetAssignedProjectTasks() {
	m.assigned_project_tasks = nil
	m.clearedassigned_project_tasks = false
	m.removedassigned_project_tasks = nil
}

// AddParticipatedProjectTaskIDs adds the "participated_project_tasks" edge to the ProjectTask entity by ids.
func (m *UserMutation) AddParticipatedProjectTaskIDs(ids ...int) {
	if m.participated_project_tasks == nil {
		m.participated_project_tasks = make(map[int]struct{})
	}
	for i := range ids {
		m.participated_project_tasks[ids[i]] = struct{}{}
	}
}

// ClearParticipatedProjectTasks clears the "participated_project_tasks" edge to the ProjectTask entity.
func (m *UserMutation) ClearParticipatedProjectTasks() {
	m.clearedparticipated_project_tasks = true
}

// ParticipatedProjectTasksCleared reports if the "participated_project_tasks" edge to the ProjectTask entity was cleared.
func (m *UserMutation) ParticipatedProjectTasksCleared() bool {
	return m.clearedparticipated_project_tasks
}

// RemoveParticipatedProjectTaskIDs removes the "participated_project_tasks" edge to the ProjectTask entity by IDs.
func (m *UserMutation) RemoveParticipatedProjectTaskIDs(ids ...int) {
	if m.removedparticipated_project_tasks == nil {
		m.removedparticipated_project_tasks = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.participated_project_tasks, ids[i])
		m.removedparticipated_project_tasks[ids[i]] = struct{}{}
	}
}

// RemovedParticipatedProjectTasks returns the removed IDs of the "participated_project_tasks" edge to the ProjectTask entity.
func (m *UserMutation) RemovedParticipatedProjectTasksIDs() (ids []int) {
	for id := range m.removedparticipated_project_tasks {
		ids = append(ids, id)
	}
	return
}

// ParticipatedProjectTasksIDs returns the "participated_project_tasks" edge IDs in the mutation.
func (m *UserMutation) ParticipatedProjectTasksIDs() (ids []int) {
	for id := range m.participated_project_tasks {
		ids = append(ids, id)
	}
	return
}

// ResetParticipatedProjectTasks resets all changes to the "participated_project_tasks" edge.
func (m *UserMutation) ResetParticipatedProjectTasks() {
	m.participated_project_tasks = nil
	m.clearedparticipated_project_tasks = false
	m.removedparticipated_project_tasks = nil
}

// AddCreatedTaskIDs adds the "created_tasks" edge to the ProjectTask entity by ids.
func (m *UserMutation) AddCreatedTaskIDs(ids ...int) {
	if m.created_tasks == nil {
		m.created_tasks = make(map[int]struct{})
	}
	for i := range ids {
		m.created_tasks[ids[i]] = struct{}{}
	}
}

// ClearCreatedTasks clears the "created_tasks" edge to the ProjectTask entity.
func (m *UserMutation) ClearCreatedTasks() {
	m.clearedcreated_tasks = true
}

// CreatedTasksCleared reports if the "created_tasks" edge to the ProjectTask entity was cleared.
func (m *UserMutation) CreatedTasksCleared() bool {
	return m.clearedcreated_tasks
}

// RemoveCreatedTaskIDs removes the "created_tasks" edge to the ProjectTask entity by IDs.
func (m *UserMutation) RemoveCreatedTaskIDs(ids ...int) {
	if m.removedcreated_tasks == nil {
		m.removedcreated_tasks = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.created_tasks, ids[i])
		m.removedcreated_tasks[ids[i]] = struct{}{}
	}
}

// RemovedCreatedTasks returns the removed IDs of the "created_tasks" edge to the ProjectTask entity.
func (m *UserMutation) RemovedCreatedTasksIDs() (ids []int) {
	for id := range m.removedcreated_tasks {
		ids = append(ids, id)
	}
	return
}

// CreatedTasksIDs returns the "created_tasks" edge IDs in the mutation.
func (m *UserMutation) CreatedTasksIDs() (ids []int) {
	for id := range m.created_tasks {
		ids = append(ids, id)
	}
	return
}

// ResetCreatedTasks resets all changes to the "created_tasks" edge.
func (m *UserMutation) ResetCreatedTasks() {
	m.created_tasks = nil
	m.clearedcreated_tasks = false
	m.removedcreated_tasks = nil
}

// AddTokenIDs adds the "tokens" edge to the Token entity by ids.
func (m *UserMutation) AddTokenIDs(ids ...int) {
	if m.tokens == nil {
		m.tokens = make(map[int]struct{})
	}
	for i := range ids {
		m.tokens[ids[i]] = struct{}{}
	}
}

// ClearTokens clears the "tokens" edge to the Token entity.
func (m *UserMutation) ClearTokens() {
	m.clearedtokens = true
}

// TokensCleared reports if the "tokens" edge to the Token entity was cleared.
func (m *UserMutation) TokensCleared() bool {
	return m.clearedtokens
}

// RemoveTokenIDs removes the "tokens" edge to the Token entity by IDs.
func (m *UserMutation) RemoveTokenIDs(ids ...int) {
	if m.removedtokens == nil {
		m.removedtokens = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.tokens, ids[i])
		m.removedtokens[ids[i]] = struct{}{}
	}
}

// RemovedTokens returns the removed IDs of the "tokens" edge to the Token entity.
func (m *UserMutation) RemovedTokensIDs() (ids []int) {
	for id := range m.removedtokens {
		ids = append(ids, id)
	}
	return
}

// TokensIDs returns the "tokens" edge IDs in the mutation.
func (m *UserMutation) TokensIDs() (ids []int) {
	for id := range m.tokens {
		ids = append(ids, id)
	}
	return
}

// ResetTokens resets all changes to the "tokens" edge.
func (m *UserMutation) ResetTokens() {
	m.tokens = nil
	m.clearedtokens = false
	m.removedtokens = nil
}

// AddApprovedWorkShiftIDs adds the "approved_work_shifts" edge to the Workshift entity by ids.
func (m *UserMutation) AddApprovedWorkShiftIDs(ids ...int) {
	if m.approved_work_shifts == nil {
		m.approved_work_shifts = make(map[int]struct{})
	}
	for i := range ids {
		m.approved_work_shifts[ids[i]] = struct{}{}
	}
}

// ClearApprovedWorkShifts clears the "approved_work_shifts" edge to the Workshift entity.
func (m *UserMutation) ClearApprovedWorkShifts() {
	m.clearedapproved_work_shifts = true
}

// ApprovedWorkShiftsCleared reports if the "approved_work_shifts" edge to the Workshift entity was cleared.
func (m *UserMutation) ApprovedWorkShiftsCleared() bool {
	return m.clearedapproved_work_shifts
}

// RemoveApprovedWorkShiftIDs removes the "approved_work_shifts" edge to the Workshift entity by IDs.
func (m *UserMutation) RemoveApprovedWorkShiftIDs(ids ...int) {
	if m.removedapproved_work_shifts == nil {
		m.removedapproved_work_shifts = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.approved_work_shifts, ids[i])
		m.removedapproved_work_shifts[ids[i]] = struct{}{}
	}
}

// RemovedApprovedWorkShifts returns the removed IDs of the "approved_work_shifts" edge to the Workshift entity.
func (m *UserMutation) RemovedApprovedWorkShiftsIDs() (ids []int) {
	for id := range m.removedapproved_work_shifts {
		ids = append(ids, id)
	}
	return
}

// ApprovedWorkShiftsIDs returns the "approved_work_shifts" edge IDs in the mutation.
func (m *UserMutation) ApprovedWorkShiftsIDs() (ids []int) {
	for id := range m.approved_work_shifts {
		ids = append(ids, id)
	}
	return
}

// ResetApprovedWorkShifts resets all changes to the "approved_work_shifts" edge.
func (m *UserMutation) ResetApprovedWorkShifts() {
	m.approved_work_shifts = nil
	m.clearedapproved_work_shifts = false
	m.removedapproved_work_shifts = nil
}

// AddWorkShiftIDs adds the "work_shifts" edge to the Workshift entity by ids.
func (m *UserMutation) AddWorkShiftIDs(ids ...int) {
	if m.work_shifts == nil {
		m.work_shifts = make(map[int]struct{})
	}
	for i := range ids {
		m.work_shifts[ids[i]] = struct{}{}
	}
}

// ClearWorkShifts clears the "work_shifts" edge to the Workshift entity.
func (m *UserMutation) ClearWorkShifts() {
	m.clearedwork_shifts = true
}

// WorkShiftsCleared reports if the "work_shifts" edge to the Workshift entity was cleared.
func (m *UserMutation) WorkShiftsCleared() bool {
	return m.clearedwork_shifts
}

// RemoveWorkShiftIDs removes the "work_shifts" edge to the Workshift entity by IDs.
func (m *UserMutation) RemoveWorkShiftIDs(ids ...int) {
	if m.removedwork_shifts == nil {
		m.removedwork_shifts = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.work_shifts, ids[i])
		m.removedwork_shifts[ids[i]] = struct{}{}
	}
}

// RemovedWorkShifts returns the removed IDs of the "work_shifts" edge to the Workshift entity.
func (m *UserMutation) RemovedWorkShiftsIDs() (ids []int) {
	for id := range m.removedwork_shifts {
		ids = append(ids, id)
	}
	return
}

// WorkShiftsIDs returns the "work_shifts" edge IDs in the mutation.
func (m *UserMutation) WorkShiftsIDs() (ids []int) {
	for id := range m.work_shifts {
		ids = append(ids, id)
	}
	return
}

// ResetWorkShifts resets all changes to the "work_shifts" edge.
func (m *UserMutation) ResetWorkShifts() {
	m.work_shifts = nil
	m.clearedwork_shifts = false
	m.removedwork_shifts = nil
}

// AddUploadedDocumentIDs adds the "uploaded_documents" edge to the CompanyDocument entity by ids.
func (m *UserMutation) AddUploadedDocumentIDs(ids ...int) {
	if m.uploaded_documents == nil {
		m.uploaded_documents = make(map[int]struct{})
	}
	for i := range ids {
		m.uploaded_documents[ids[i]] = struct{}{}
	}
}

// ClearUploadedDocuments clears the "uploaded_documents" edge to the CompanyDocument entity.
func (m *UserMutation) ClearUploadedDocuments() {
	m.cleareduploaded_documents = true
}

// UploadedDocumentsCleared reports if the "uploaded_documents" edge to the CompanyDocument entity was cleared.
func (m *UserMutation) UploadedDocumentsCleared() bool {
	return m.cleareduploaded_documents
}

// RemoveUploadedDocumentIDs removes the "uploaded_documents" edge to the CompanyDocument entity by IDs.
func (m *UserMutation) RemoveUploadedDocumentIDs(ids ...int) {
	if m.removeduploaded_documents == nil {
		m.removeduploaded_documents = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.uploaded_documents, ids[i])
		m.removeduploaded_documents[ids[i]] = struct{}{}
	}
}

// RemovedUploadedDocuments returns the removed IDs of the "uploaded_documents" edge to the CompanyDocument entity.
func (m *UserMutation) RemovedUploadedDocumentsIDs() (ids []int) {
	for id := range m.removeduploaded_documents {
		ids = append(ids, id)
	}
	return
}

// UploadedDocumentsIDs returns the "uploaded_documents" edge IDs in the mutation.
func (m *UserMutation) UploadedDocumentsIDs() (ids []int) {
	for id := range m.uploaded_documents {
		ids = append(ids, id)
	}
	return
}

// ResetUploadedDocuments resets all changes to the "uploaded_documents" edge.
func (m *UserMutation) ResetUploadedDocuments() {
	m.uploaded_documents = nil
	m.cleareduploaded_documents = false
	m.removeduploaded_documents = nil
}

// AddApprovedDocumentIDs adds the "approved_documents" edge to the CompanyDocument entity by ids.
func (m *UserMutation) AddApprovedDocumentIDs(ids ...int) {
	if m.approved_documents == nil {
		m.approved_documents = make(map[int]struct{})
	}
	for i := range ids {
		m.approved_documents[ids[i]] = struct{}{}
	}
}

// ClearApprovedDocuments clears the "approved_documents" edge to the CompanyDocument entity.
func (m *UserMutation) ClearApprovedDocuments() {
	m.clearedapproved_documents = true
}

// ApprovedDocumentsCleared reports if the "approved_documents" edge to the CompanyDocument entity was cleared.
func (m *UserMutation) ApprovedDocumentsCleared() bool {
	return m.clearedapproved_documents
}

// RemoveApprovedDocumentIDs removes the "approved_documents" edge to the CompanyDocument entity by IDs.
func (m *UserMutation) RemoveApprovedDocumentIDs(ids ...int) {
	if m.removedapproved_documents == nil {
		m.removedapproved_documents = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.approved_documents, ids[i])
		m.removedapproved_documents[ids[i]] = struct{}{}
	}
}

// RemovedApprovedDocuments returns the removed IDs of the "approved_documents" edge to the CompanyDocument entity.
func (m *UserMutation) RemovedApprovedDocumentsIDs() (ids []int) {
	for id := range m.removedapproved_documents {
		ids = append(ids, id)
	}
	return
}

// ApprovedDocumentsIDs returns the "approved_documents" edge IDs in the mutation.
func (m *UserMutation) ApprovedDocumentsIDs() (ids []int) {
	for id := range m.approved_documents {
		ids = append(ids, id)
	}
	return
}

// ResetApprovedDocuments resets all changes to the "approved_documents" edge.
func (m *UserMutation) ResetApprovedDocuments() {
	m.approved_documents = nil
	m.clearedapproved_documents = false
	m.removedapproved_documents = nil
}

// Where appends a list predicates to the UserMutation builder.
func (m *UserMutation) Where(ps ...predicate.User) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.User, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (User).
func (m *UserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserMutation) Fields() []string {
	fields := make([]string, 0, 19)
	if m.created_at != nil {
		fields = append(fields, user.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, user.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, user.FieldDeletedAt)
	}
	if m.device != nil {
		fields = append(fields, user.FieldDevice)
	}
	if m.is_demo_user != nil {
		fields = append(fields, user.FieldIsDemoUser)
	}
	if m.firebase_UID != nil {
		fields = append(fields, user.FieldFirebaseUID)
	}
	if m.fcm_token != nil {
		fields = append(fields, user.FieldFcmToken)
	}
	if m.expo_push_token != nil {
		fields = append(fields, user.FieldExpoPushToken)
	}
	if m.email != nil {
		fields = append(fields, user.FieldEmail)
	}
	if m.name != nil {
		fields = append(fields, user.FieldName)
	}
	if m.address != nil {
		fields = append(fields, user.FieldAddress)
	}
	if m.avatar != nil {
		fields = append(fields, user.FieldAvatar)
	}
	if m.photo_URL != nil {
		fields = append(fields, user.FieldPhotoURL)
	}
	if m.department != nil {
		fields = append(fields, user.FieldDepartment)
	}
	if m.phone != nil {
		fields = append(fields, user.FieldPhone)
	}
	if m.birthdate != nil {
		fields = append(fields, user.FieldBirthdate)
	}
	if m.last_login != nil {
		fields = append(fields, user.FieldLastLogin)
	}
	if m.gender != nil {
		fields = append(fields, user.FieldGender)
	}
	if m.active != nil {
		fields = append(fields, user.FieldActive)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case user.FieldCreatedAt:
		return m.CreatedAt()
	case user.FieldUpdatedAt:
		return m.UpdatedAt()
	case user.FieldDeletedAt:
		return m.DeletedAt()
	case user.FieldDevice:
		return m.Device()
	case user.FieldIsDemoUser:
		return m.IsDemoUser()
	case user.FieldFirebaseUID:
		return m.FirebaseUID()
	case user.FieldFcmToken:
		return m.FcmToken()
	case user.FieldExpoPushToken:
		return m.ExpoPushToken()
	case user.FieldEmail:
		return m.Email()
	case user.FieldName:
		return m.Name()
	case user.FieldAddress:
		return m.Address()
	case user.FieldAvatar:
		return m.Avatar()
	case user.FieldPhotoURL:
		return m.PhotoURL()
	case user.FieldDepartment:
		return m.Department()
	case user.FieldPhone:
		return m.Phone()
	case user.FieldBirthdate:
		return m.Birthdate()
	case user.FieldLastLogin:
		return m.LastLogin()
	case user.FieldGender:
		return m.Gender()
	case user.FieldActive:
		return m.Active()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case user.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case user.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case user.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case user.FieldDevice:
		return m.OldDevice(ctx)
	case user.FieldIsDemoUser:
		return m.OldIsDemoUser(ctx)
	case user.FieldFirebaseUID:
		return m.OldFirebaseUID(ctx)
	case user.FieldFcmToken:
		return m.OldFcmToken(ctx)
	case user.FieldExpoPushToken:
		return m.OldExpoPushToken(ctx)
	case user.FieldEmail:
		return m.OldEmail(ctx)
	case user.FieldName:
		return m.OldName(ctx)
	case user.FieldAddress:
		return m.OldAddress(ctx)
	case user.FieldAvatar:
		return m.OldAvatar(ctx)
	case user.FieldPhotoURL:
		return m.OldPhotoURL(ctx)
	case user.FieldDepartment:
		return m.OldDepartment(ctx)
	case user.FieldPhone:
		return m.OldPhone(ctx)
	case user.FieldBirthdate:
		return m.OldBirthdate(ctx)
	case user.FieldLastLogin:
		return m.OldLastLogin(ctx)
	case user.FieldGender:
		return m.OldGender(ctx)
	case user.FieldActive:
		return m.OldActive(ctx)
	}
	return nil, fmt.Errorf("unknown User field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case user.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case user.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case user.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case user.FieldDevice:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDevice(v)
		return nil
	case user.FieldIsDemoUser:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsDemoUser(v)
		return nil
	case user.FieldFirebaseUID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFirebaseUID(v)
		return nil
	case user.FieldFcmToken:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFcmToken(v)
		return nil
	case user.FieldExpoPushToken:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpoPushToken(v)
		return nil
	case user.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case user.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case user.FieldAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAddress(v)
		return nil
	case user.FieldAvatar:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAvatar(v)
		return nil
	case user.FieldPhotoURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPhotoURL(v)
		return nil
	case user.FieldDepartment:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDepartment(v)
		return nil
	case user.FieldPhone:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPhone(v)
		return nil
	case user.FieldBirthdate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBirthdate(v)
		return nil
	case user.FieldLastLogin:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastLogin(v)
		return nil
	case user.FieldGender:
		v, ok := value.(user.Gender)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGender(v)
		return nil
	case user.FieldActive:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetActive(v)
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown User numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(user.FieldDeletedAt) {
		fields = append(fields, user.FieldDeletedAt)
	}
	if m.FieldCleared(user.FieldDevice) {
		fields = append(fields, user.FieldDevice)
	}
	if m.FieldCleared(user.FieldIsDemoUser) {
		fields = append(fields, user.FieldIsDemoUser)
	}
	if m.FieldCleared(user.FieldFcmToken) {
		fields = append(fields, user.FieldFcmToken)
	}
	if m.FieldCleared(user.FieldExpoPushToken) {
		fields = append(fields, user.FieldExpoPushToken)
	}
	if m.FieldCleared(user.FieldAddress) {
		fields = append(fields, user.FieldAddress)
	}
	if m.FieldCleared(user.FieldAvatar) {
		fields = append(fields, user.FieldAvatar)
	}
	if m.FieldCleared(user.FieldPhotoURL) {
		fields = append(fields, user.FieldPhotoURL)
	}
	if m.FieldCleared(user.FieldDepartment) {
		fields = append(fields, user.FieldDepartment)
	}
	if m.FieldCleared(user.FieldPhone) {
		fields = append(fields, user.FieldPhone)
	}
	if m.FieldCleared(user.FieldBirthdate) {
		fields = append(fields, user.FieldBirthdate)
	}
	if m.FieldCleared(user.FieldLastLogin) {
		fields = append(fields, user.FieldLastLogin)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserMutation) ClearField(name string) error {
	switch name {
	case user.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case user.FieldDevice:
		m.ClearDevice()
		return nil
	case user.FieldIsDemoUser:
		m.ClearIsDemoUser()
		return nil
	case user.FieldFcmToken:
		m.ClearFcmToken()
		return nil
	case user.FieldExpoPushToken:
		m.ClearExpoPushToken()
		return nil
	case user.FieldAddress:
		m.ClearAddress()
		return nil
	case user.FieldAvatar:
		m.ClearAvatar()
		return nil
	case user.FieldPhotoURL:
		m.ClearPhotoURL()
		return nil
	case user.FieldDepartment:
		m.ClearDepartment()
		return nil
	case user.FieldPhone:
		m.ClearPhone()
		return nil
	case user.FieldBirthdate:
		m.ClearBirthdate()
		return nil
	case user.FieldLastLogin:
		m.ClearLastLogin()
		return nil
	}
	return fmt.Errorf("unknown User nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserMutation) ResetField(name string) error {
	switch name {
	case user.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case user.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case user.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case user.FieldDevice:
		m.ResetDevice()
		return nil
	case user.FieldIsDemoUser:
		m.ResetIsDemoUser()
		return nil
	case user.FieldFirebaseUID:
		m.ResetFirebaseUID()
		return nil
	case user.FieldFcmToken:
		m.ResetFcmToken()
		return nil
	case user.FieldExpoPushToken:
		m.ResetExpoPushToken()
		return nil
	case user.FieldEmail:
		m.ResetEmail()
		return nil
	case user.FieldName:
		m.ResetName()
		return nil
	case user.FieldAddress:
		m.ResetAddress()
		return nil
	case user.FieldAvatar:
		m.ResetAvatar()
		return nil
	case user.FieldPhotoURL:
		m.ResetPhotoURL()
		return nil
	case user.FieldDepartment:
		m.ResetDepartment()
		return nil
	case user.FieldPhone:
		m.ResetPhone()
		return nil
	case user.FieldBirthdate:
		m.ResetBirthdate()
		return nil
	case user.FieldLastLogin:
		m.ResetLastLogin()
		return nil
	case user.FieldGender:
		m.ResetGender()
		return nil
	case user.FieldActive:
		m.ResetActive()
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserMutation) AddedEdges() []string {
	edges := make([]string, 0, 18)
	if m.accounting_entries != nil {
		edges = append(edges, user.EdgeAccountingEntries)
	}
	if m.company != nil {
		edges = append(edges, user.EdgeCompany)
	}
	if m.assigned_roles != nil {
		edges = append(edges, user.EdgeAssignedRoles)
	}
	if m.subordinates != nil {
		edges = append(edges, user.EdgeSubordinates)
	}
	if m.leader != nil {
		edges = append(edges, user.EdgeLeader)
	}
	if m.created_member_signup_tokens != nil {
		edges = append(edges, user.EdgeCreatedMemberSignupTokens)
	}
	if m.employee != nil {
		edges = append(edges, user.EdgeEmployee)
	}
	if m.issued_invoices != nil {
		edges = append(edges, user.EdgeIssuedInvoices)
	}
	if m.created_projects != nil {
		edges = append(edges, user.EdgeCreatedProjects)
	}
	if m.leadered_projects != nil {
		edges = append(edges, user.EdgeLeaderedProjects)
	}
	if m.assigned_project_tasks != nil {
		edges = append(edges, user.EdgeAssignedProjectTasks)
	}
	if m.participated_project_tasks != nil {
		edges = append(edges, user.EdgeParticipatedProjectTasks)
	}
	if m.created_tasks != nil {
		edges = append(edges, user.EdgeCreatedTasks)
	}
	if m.tokens != nil {
		edges = append(edges, user.EdgeTokens)
	}
	if m.approved_work_shifts != nil {
		edges = append(edges, user.EdgeApprovedWorkShifts)
	}
	if m.work_shifts != nil {
		edges = append(edges, user.EdgeWorkShifts)
	}
	if m.uploaded_documents != nil {
		edges = append(edges, user.EdgeUploadedDocuments)
	}
	if m.approved_documents != nil {
		edges = append(edges, user.EdgeApprovedDocuments)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeAccountingEntries:
		ids := make([]ent.Value, 0, len(m.accounting_entries))
		for id := range m.accounting_entries {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeCompany:
		ids := make([]ent.Value, 0, len(m.company))
		for id := range m.company {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeAssignedRoles:
		ids := make([]ent.Value, 0, len(m.assigned_roles))
		for id := range m.assigned_roles {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeSubordinates:
		ids := make([]ent.Value, 0, len(m.subordinates))
		for id := range m.subordinates {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeLeader:
		if id := m.leader; id != nil {
			return []ent.Value{*id}
		}
	case user.EdgeCreatedMemberSignupTokens:
		ids := make([]ent.Value, 0, len(m.created_member_signup_tokens))
		for id := range m.created_member_signup_tokens {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeEmployee:
		if id := m.employee; id != nil {
			return []ent.Value{*id}
		}
	case user.EdgeIssuedInvoices:
		ids := make([]ent.Value, 0, len(m.issued_invoices))
		for id := range m.issued_invoices {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeCreatedProjects:
		ids := make([]ent.Value, 0, len(m.created_projects))
		for id := range m.created_projects {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeLeaderedProjects:
		ids := make([]ent.Value, 0, len(m.leadered_projects))
		for id := range m.leadered_projects {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeAssignedProjectTasks:
		ids := make([]ent.Value, 0, len(m.assigned_project_tasks))
		for id := range m.assigned_project_tasks {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeParticipatedProjectTasks:
		ids := make([]ent.Value, 0, len(m.participated_project_tasks))
		for id := range m.participated_project_tasks {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeCreatedTasks:
		ids := make([]ent.Value, 0, len(m.created_tasks))
		for id := range m.created_tasks {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeTokens:
		ids := make([]ent.Value, 0, len(m.tokens))
		for id := range m.tokens {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeApprovedWorkShifts:
		ids := make([]ent.Value, 0, len(m.approved_work_shifts))
		for id := range m.approved_work_shifts {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeWorkShifts:
		ids := make([]ent.Value, 0, len(m.work_shifts))
		for id := range m.work_shifts {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeUploadedDocuments:
		ids := make([]ent.Value, 0, len(m.uploaded_documents))
		for id := range m.uploaded_documents {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeApprovedDocuments:
		ids := make([]ent.Value, 0, len(m.approved_documents))
		for id := range m.approved_documents {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 18)
	if m.removedaccounting_entries != nil {
		edges = append(edges, user.EdgeAccountingEntries)
	}
	if m.removedcompany != nil {
		edges = append(edges, user.EdgeCompany)
	}
	if m.removedassigned_roles != nil {
		edges = append(edges, user.EdgeAssignedRoles)
	}
	if m.removedsubordinates != nil {
		edges = append(edges, user.EdgeSubordinates)
	}
	if m.removedcreated_member_signup_tokens != nil {
		edges = append(edges, user.EdgeCreatedMemberSignupTokens)
	}
	if m.removedissued_invoices != nil {
		edges = append(edges, user.EdgeIssuedInvoices)
	}
	if m.removedcreated_projects != nil {
		edges = append(edges, user.EdgeCreatedProjects)
	}
	if m.removedleadered_projects != nil {
		edges = append(edges, user.EdgeLeaderedProjects)
	}
	if m.removedassigned_project_tasks != nil {
		edges = append(edges, user.EdgeAssignedProjectTasks)
	}
	if m.removedparticipated_project_tasks != nil {
		edges = append(edges, user.EdgeParticipatedProjectTasks)
	}
	if m.removedcreated_tasks != nil {
		edges = append(edges, user.EdgeCreatedTasks)
	}
	if m.removedtokens != nil {
		edges = append(edges, user.EdgeTokens)
	}
	if m.removedapproved_work_shifts != nil {
		edges = append(edges, user.EdgeApprovedWorkShifts)
	}
	if m.removedwork_shifts != nil {
		edges = append(edges, user.EdgeWorkShifts)
	}
	if m.removeduploaded_documents != nil {
		edges = append(edges, user.EdgeUploadedDocuments)
	}
	if m.removedapproved_documents != nil {
		edges = append(edges, user.EdgeApprovedDocuments)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeAccountingEntries:
		ids := make([]ent.Value, 0, len(m.removedaccounting_entries))
		for id := range m.removedaccounting_entries {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeCompany:
		ids := make([]ent.Value, 0, len(m.removedcompany))
		for id := range m.removedcompany {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeAssignedRoles:
		ids := make([]ent.Value, 0, len(m.removedassigned_roles))
		for id := range m.removedassigned_roles {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeSubordinates:
		ids := make([]ent.Value, 0, len(m.removedsubordinates))
		for id := range m.removedsubordinates {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeCreatedMemberSignupTokens:
		ids := make([]ent.Value, 0, len(m.removedcreated_member_signup_tokens))
		for id := range m.removedcreated_member_signup_tokens {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeIssuedInvoices:
		ids := make([]ent.Value, 0, len(m.removedissued_invoices))
		for id := range m.removedissued_invoices {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeCreatedProjects:
		ids := make([]ent.Value, 0, len(m.removedcreated_projects))
		for id := range m.removedcreated_projects {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeLeaderedProjects:
		ids := make([]ent.Value, 0, len(m.removedleadered_projects))
		for id := range m.removedleadered_projects {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeAssignedProjectTasks:
		ids := make([]ent.Value, 0, len(m.removedassigned_project_tasks))
		for id := range m.removedassigned_project_tasks {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeParticipatedProjectTasks:
		ids := make([]ent.Value, 0, len(m.removedparticipated_project_tasks))
		for id := range m.removedparticipated_project_tasks {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeCreatedTasks:
		ids := make([]ent.Value, 0, len(m.removedcreated_tasks))
		for id := range m.removedcreated_tasks {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeTokens:
		ids := make([]ent.Value, 0, len(m.removedtokens))
		for id := range m.removedtokens {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeApprovedWorkShifts:
		ids := make([]ent.Value, 0, len(m.removedapproved_work_shifts))
		for id := range m.removedapproved_work_shifts {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeWorkShifts:
		ids := make([]ent.Value, 0, len(m.removedwork_shifts))
		for id := range m.removedwork_shifts {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeUploadedDocuments:
		ids := make([]ent.Value, 0, len(m.removeduploaded_documents))
		for id := range m.removeduploaded_documents {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeApprovedDocuments:
		ids := make([]ent.Value, 0, len(m.removedapproved_documents))
		for id := range m.removedapproved_documents {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 18)
	if m.clearedaccounting_entries {
		edges = append(edges, user.EdgeAccountingEntries)
	}
	if m.clearedcompany {
		edges = append(edges, user.EdgeCompany)
	}
	if m.clearedassigned_roles {
		edges = append(edges, user.EdgeAssignedRoles)
	}
	if m.clearedsubordinates {
		edges = append(edges, user.EdgeSubordinates)
	}
	if m.clearedleader {
		edges = append(edges, user.EdgeLeader)
	}
	if m.clearedcreated_member_signup_tokens {
		edges = append(edges, user.EdgeCreatedMemberSignupTokens)
	}
	if m.clearedemployee {
		edges = append(edges, user.EdgeEmployee)
	}
	if m.clearedissued_invoices {
		edges = append(edges, user.EdgeIssuedInvoices)
	}
	if m.clearedcreated_projects {
		edges = append(edges, user.EdgeCreatedProjects)
	}
	if m.clearedleadered_projects {
		edges = append(edges, user.EdgeLeaderedProjects)
	}
	if m.clearedassigned_project_tasks {
		edges = append(edges, user.EdgeAssignedProjectTasks)
	}
	if m.clearedparticipated_project_tasks {
		edges = append(edges, user.EdgeParticipatedProjectTasks)
	}
	if m.clearedcreated_tasks {
		edges = append(edges, user.EdgeCreatedTasks)
	}
	if m.clearedtokens {
		edges = append(edges, user.EdgeTokens)
	}
	if m.clearedapproved_work_shifts {
		edges = append(edges, user.EdgeApprovedWorkShifts)
	}
	if m.clearedwork_shifts {
		edges = append(edges, user.EdgeWorkShifts)
	}
	if m.cleareduploaded_documents {
		edges = append(edges, user.EdgeUploadedDocuments)
	}
	if m.clearedapproved_documents {
		edges = append(edges, user.EdgeApprovedDocuments)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserMutation) EdgeCleared(name string) bool {
	switch name {
	case user.EdgeAccountingEntries:
		return m.clearedaccounting_entries
	case user.EdgeCompany:
		return m.clearedcompany
	case user.EdgeAssignedRoles:
		return m.clearedassigned_roles
	case user.EdgeSubordinates:
		return m.clearedsubordinates
	case user.EdgeLeader:
		return m.clearedleader
	case user.EdgeCreatedMemberSignupTokens:
		return m.clearedcreated_member_signup_tokens
	case user.EdgeEmployee:
		return m.clearedemployee
	case user.EdgeIssuedInvoices:
		return m.clearedissued_invoices
	case user.EdgeCreatedProjects:
		return m.clearedcreated_projects
	case user.EdgeLeaderedProjects:
		return m.clearedleadered_projects
	case user.EdgeAssignedProjectTasks:
		return m.clearedassigned_project_tasks
	case user.EdgeParticipatedProjectTasks:
		return m.clearedparticipated_project_tasks
	case user.EdgeCreatedTasks:
		return m.clearedcreated_tasks
	case user.EdgeTokens:
		return m.clearedtokens
	case user.EdgeApprovedWorkShifts:
		return m.clearedapproved_work_shifts
	case user.EdgeWorkShifts:
		return m.clearedwork_shifts
	case user.EdgeUploadedDocuments:
		return m.cleareduploaded_documents
	case user.EdgeApprovedDocuments:
		return m.clearedapproved_documents
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserMutation) ClearEdge(name string) error {
	switch name {
	case user.EdgeLeader:
		m.ClearLeader()
		return nil
	case user.EdgeEmployee:
		m.ClearEmployee()
		return nil
	}
	return fmt.Errorf("unknown User unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserMutation) ResetEdge(name string) error {
	switch name {
	case user.EdgeAccountingEntries:
		m.ResetAccountingEntries()
		return nil
	case user.EdgeCompany:
		m.ResetCompany()
		return nil
	case user.EdgeAssignedRoles:
		m.ResetAssignedRoles()
		return nil
	case user.EdgeSubordinates:
		m.ResetSubordinates()
		return nil
	case user.EdgeLeader:
		m.ResetLeader()
		return nil
	case user.EdgeCreatedMemberSignupTokens:
		m.ResetCreatedMemberSignupTokens()
		return nil
	case user.EdgeEmployee:
		m.ResetEmployee()
		return nil
	case user.EdgeIssuedInvoices:
		m.ResetIssuedInvoices()
		return nil
	case user.EdgeCreatedProjects:
		m.ResetCreatedProjects()
		return nil
	case user.EdgeLeaderedProjects:
		m.ResetLeaderedProjects()
		return nil
	case user.EdgeAssignedProjectTasks:
		m.ResetAssignedProjectTasks()
		return nil
	case user.EdgeParticipatedProjectTasks:
		m.ResetParticipatedProjectTasks()
		return nil
	case user.EdgeCreatedTasks:
		m.ResetCreatedTasks()
		return nil
	case user.EdgeTokens:
		m.ResetTokens()
		return nil
	case user.EdgeApprovedWorkShifts:
		m.ResetApprovedWorkShifts()
		return nil
	case user.EdgeWorkShifts:
		m.ResetWorkShifts()
		return nil
	case user.EdgeUploadedDocuments:
		m.ResetUploadedDocuments()
		return nil
	case user.EdgeApprovedDocuments:
		m.ResetApprovedDocuments()
		return nil
	}
	return fmt.Errorf("unknown User edge %s", name)
}

// UserRoleMutation represents an operation that mutates the UserRole nodes in the graph.
type UserRoleMutation struct {
	config
	op             Op
	typ            string
	id             *int
	role           *userrole.Role
	notes          *string
	clearedFields  map[string]struct{}
	company        *int
	clearedcompany bool
	user           *int
	cleareduser    bool
	done           bool
	oldValue       func(context.Context) (*UserRole, error)
	predicates     []predicate.UserRole
}

var _ ent.Mutation = (*UserRoleMutation)(nil)

// userroleOption allows management of the mutation configuration using functional options.
type userroleOption func(*UserRoleMutation)

// newUserRoleMutation creates new mutation for the UserRole entity.
func newUserRoleMutation(c config, op Op, opts ...userroleOption) *UserRoleMutation {
	m := &UserRoleMutation{
		config:        c,
		op:            op,
		typ:           TypeUserRole,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserRoleID sets the ID field of the mutation.
func withUserRoleID(id int) userroleOption {
	return func(m *UserRoleMutation) {
		var (
			err   error
			once  sync.Once
			value *UserRole
		)
		m.oldValue = func(ctx context.Context) (*UserRole, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().UserRole.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUserRole sets the old UserRole of the mutation.
func withUserRole(node *UserRole) userroleOption {
	return func(m *UserRoleMutation) {
		m.oldValue = func(context.Context) (*UserRole, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserRoleMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserRoleMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("generated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserRoleMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserRoleMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().UserRole.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetRole sets the "role" field.
func (m *UserRoleMutation) SetRole(u userrole.Role) {
	m.role = &u
}

// Role returns the value of the "role" field in the mutation.
func (m *UserRoleMutation) Role() (r userrole.Role, exists bool) {
	v := m.role
	if v == nil {
		return
	}
	return *v, true
}

// OldRole returns the old "role" field's value of the UserRole entity.
// If the UserRole object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserRoleMutation) OldRole(ctx context.Context) (v userrole.Role, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRole is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRole requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRole: %w", err)
	}
	return oldValue.Role, nil
}

// ResetRole resets all changes to the "role" field.
func (m *UserRoleMutation) ResetRole() {
	m.role = nil
}

// SetNotes sets the "notes" field.
func (m *UserRoleMutation) SetNotes(s string) {
	m.notes = &s
}

// Notes returns the value of the "notes" field in the mutation.
func (m *UserRoleMutation) Notes() (r string, exists bool) {
	v := m.notes
	if v == nil {
		return
	}
	return *v, true
}

// OldNotes returns the old "notes" field's value of the UserRole entity.
// If the UserRole object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserRoleMutation) OldNotes(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNotes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNotes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNotes: %w", err)
	}
	return oldValue.Notes, nil
}

// ResetNotes resets all changes to the "notes" field.
func (m *UserRoleMutation) ResetNotes() {
	m.notes = nil
}

// SetCompanyID sets the "company" edge to the Company entity by id.
func (m *UserRoleMutation) SetCompanyID(id int) {
	m.company = &id
}

// ClearCompany clears the "company" edge to the Company entity.
func (m *UserRoleMutation) ClearCompany() {
	m.clearedcompany = true
}

// CompanyCleared reports if the "company" edge to the Company entity was cleared.
func (m *UserRoleMutation) CompanyCleared() bool {
	return m.clearedcompany
}

// CompanyID returns the "company" edge ID in the mutation.
func (m *UserRoleMutation) CompanyID() (id int, exists bool) {
	if m.company != nil {
		return *m.company, true
	}
	return
}

// CompanyIDs returns the "company" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CompanyID instead. It exists only for internal usage by the builders.
func (m *UserRoleMutation) CompanyIDs() (ids []int) {
	if id := m.company; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCompany resets all changes to the "company" edge.
func (m *UserRoleMutation) ResetCompany() {
	m.company = nil
	m.clearedcompany = false
}

// SetUserID sets the "user" edge to the User entity by id.
func (m *UserRoleMutation) SetUserID(id int) {
	m.user = &id
}

// ClearUser clears the "user" edge to the User entity.
func (m *UserRoleMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *UserRoleMutation) UserCleared() bool {
	return m.cleareduser
}

// UserID returns the "user" edge ID in the mutation.
func (m *UserRoleMutation) UserID() (id int, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *UserRoleMutation) UserIDs() (ids []int) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *UserRoleMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the UserRoleMutation builder.
func (m *UserRoleMutation) Where(ps ...predicate.UserRole) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserRoleMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserRoleMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.UserRole, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserRoleMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserRoleMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (UserRole).
func (m *UserRoleMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserRoleMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.role != nil {
		fields = append(fields, userrole.FieldRole)
	}
	if m.notes != nil {
		fields = append(fields, userrole.FieldNotes)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserRoleMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case userrole.FieldRole:
		return m.Role()
	case userrole.FieldNotes:
		return m.Notes()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserRoleMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case userrole.FieldRole:
		return m.OldRole(ctx)
	case userrole.FieldNotes:
		return m.OldNotes(ctx)
	}
	return nil, fmt.Errorf("unknown UserRole field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserRoleMutation) SetField(name string, value ent.Value) error {
	switch name {
	case userrole.FieldRole:
		v, ok := value.(userrole.Role)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRole(v)
		return nil
	case userrole.FieldNotes:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNotes(v)
		return nil
	}
	return fmt.Errorf("unknown UserRole field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserRoleMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserRoleMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserRoleMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown UserRole numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserRoleMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserRoleMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserRoleMutation) ClearField(name string) error {
	return fmt.Errorf("unknown UserRole nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserRoleMutation) ResetField(name string) error {
	switch name {
	case userrole.FieldRole:
		m.ResetRole()
		return nil
	case userrole.FieldNotes:
		m.ResetNotes()
		return nil
	}
	return fmt.Errorf("unknown UserRole field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserRoleMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.company != nil {
		edges = append(edges, userrole.EdgeCompany)
	}
	if m.user != nil {
		edges = append(edges, userrole.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserRoleMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case userrole.EdgeCompany:
		if id := m.company; id != nil {
			return []ent.Value{*id}
		}
	case userrole.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserRoleMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserRoleMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserRoleMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedcompany {
		edges = append(edges, userrole.EdgeCompany)
	}
	if m.cleareduser {
		edges = append(edges, userrole.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserRoleMutation) EdgeCleared(name string) bool {
	switch name {
	case userrole.EdgeCompany:
		return m.clearedcompany
	case userrole.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserRoleMutation) ClearEdge(name string) error {
	switch name {
	case userrole.EdgeCompany:
		m.ClearCompany()
		return nil
	case userrole.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown UserRole unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserRoleMutation) ResetEdge(name string) error {
	switch name {
	case userrole.EdgeCompany:
		m.ResetCompany()
		return nil
	case userrole.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown UserRole edge %s", name)
}

// WorkshiftMutation represents an operation that mutates the Workshift nodes in the graph.
type WorkshiftMutation struct {
	config
	op                  Op
	typ                 string
	id                  *int
	created_at          *time.Time
	updated_at          *time.Time
	deleted_at          *time.Time
	approved_at         *time.Time
	clock_in            *time.Time
	clock_out           *time.Time
	clock_in_location   *string
	clock_out_location  *string
	description         *string
	note                *string
	status              *workshift.Status
	clearedFields       map[string]struct{}
	company             *int
	clearedcompany      bool
	user                *int
	cleareduser         bool
	approved_by         *int
	clearedapproved_by  bool
	task                *int
	clearedtask         bool
	edit_request        *int
	clearededit_request bool
	work_shift          *int
	clearedwork_shift   bool
	done                bool
	oldValue            func(context.Context) (*Workshift, error)
	predicates          []predicate.Workshift
}

var _ ent.Mutation = (*WorkshiftMutation)(nil)

// workshiftOption allows management of the mutation configuration using functional options.
type workshiftOption func(*WorkshiftMutation)

// newWorkshiftMutation creates new mutation for the Workshift entity.
func newWorkshiftMutation(c config, op Op, opts ...workshiftOption) *WorkshiftMutation {
	m := &WorkshiftMutation{
		config:        c,
		op:            op,
		typ:           TypeWorkshift,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withWorkshiftID sets the ID field of the mutation.
func withWorkshiftID(id int) workshiftOption {
	return func(m *WorkshiftMutation) {
		var (
			err   error
			once  sync.Once
			value *Workshift
		)
		m.oldValue = func(ctx context.Context) (*Workshift, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Workshift.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withWorkshift sets the old Workshift of the mutation.
func withWorkshift(node *Workshift) workshiftOption {
	return func(m *WorkshiftMutation) {
		m.oldValue = func(context.Context) (*Workshift, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m WorkshiftMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m WorkshiftMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("generated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *WorkshiftMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *WorkshiftMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Workshift.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *WorkshiftMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *WorkshiftMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Workshift entity.
// If the Workshift object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkshiftMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *WorkshiftMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *WorkshiftMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *WorkshiftMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Workshift entity.
// If the Workshift object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkshiftMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *WorkshiftMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *WorkshiftMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *WorkshiftMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Workshift entity.
// If the Workshift object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkshiftMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *WorkshiftMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[workshift.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *WorkshiftMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[workshift.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *WorkshiftMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, workshift.FieldDeletedAt)
}

// SetApprovedAt sets the "approved_at" field.
func (m *WorkshiftMutation) SetApprovedAt(t time.Time) {
	m.approved_at = &t
}

// ApprovedAt returns the value of the "approved_at" field in the mutation.
func (m *WorkshiftMutation) ApprovedAt() (r time.Time, exists bool) {
	v := m.approved_at
	if v == nil {
		return
	}
	return *v, true
}

// OldApprovedAt returns the old "approved_at" field's value of the Workshift entity.
// If the Workshift object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkshiftMutation) OldApprovedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldApprovedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldApprovedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldApprovedAt: %w", err)
	}
	return oldValue.ApprovedAt, nil
}

// ClearApprovedAt clears the value of the "approved_at" field.
func (m *WorkshiftMutation) ClearApprovedAt() {
	m.approved_at = nil
	m.clearedFields[workshift.FieldApprovedAt] = struct{}{}
}

// ApprovedAtCleared returns if the "approved_at" field was cleared in this mutation.
func (m *WorkshiftMutation) ApprovedAtCleared() bool {
	_, ok := m.clearedFields[workshift.FieldApprovedAt]
	return ok
}

// ResetApprovedAt resets all changes to the "approved_at" field.
func (m *WorkshiftMutation) ResetApprovedAt() {
	m.approved_at = nil
	delete(m.clearedFields, workshift.FieldApprovedAt)
}

// SetClockIn sets the "clock_in" field.
func (m *WorkshiftMutation) SetClockIn(t time.Time) {
	m.clock_in = &t
}

// ClockIn returns the value of the "clock_in" field in the mutation.
func (m *WorkshiftMutation) ClockIn() (r time.Time, exists bool) {
	v := m.clock_in
	if v == nil {
		return
	}
	return *v, true
}

// OldClockIn returns the old "clock_in" field's value of the Workshift entity.
// If the Workshift object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkshiftMutation) OldClockIn(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClockIn is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClockIn requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClockIn: %w", err)
	}
	return oldValue.ClockIn, nil
}

// ResetClockIn resets all changes to the "clock_in" field.
func (m *WorkshiftMutation) ResetClockIn() {
	m.clock_in = nil
}

// SetClockOut sets the "clock_out" field.
func (m *WorkshiftMutation) SetClockOut(t time.Time) {
	m.clock_out = &t
}

// ClockOut returns the value of the "clock_out" field in the mutation.
func (m *WorkshiftMutation) ClockOut() (r time.Time, exists bool) {
	v := m.clock_out
	if v == nil {
		return
	}
	return *v, true
}

// OldClockOut returns the old "clock_out" field's value of the Workshift entity.
// If the Workshift object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkshiftMutation) OldClockOut(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClockOut is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClockOut requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClockOut: %w", err)
	}
	return oldValue.ClockOut, nil
}

// ClearClockOut clears the value of the "clock_out" field.
func (m *WorkshiftMutation) ClearClockOut() {
	m.clock_out = nil
	m.clearedFields[workshift.FieldClockOut] = struct{}{}
}

// ClockOutCleared returns if the "clock_out" field was cleared in this mutation.
func (m *WorkshiftMutation) ClockOutCleared() bool {
	_, ok := m.clearedFields[workshift.FieldClockOut]
	return ok
}

// ResetClockOut resets all changes to the "clock_out" field.
func (m *WorkshiftMutation) ResetClockOut() {
	m.clock_out = nil
	delete(m.clearedFields, workshift.FieldClockOut)
}

// SetClockInLocation sets the "clock_in_location" field.
func (m *WorkshiftMutation) SetClockInLocation(s string) {
	m.clock_in_location = &s
}

// ClockInLocation returns the value of the "clock_in_location" field in the mutation.
func (m *WorkshiftMutation) ClockInLocation() (r string, exists bool) {
	v := m.clock_in_location
	if v == nil {
		return
	}
	return *v, true
}

// OldClockInLocation returns the old "clock_in_location" field's value of the Workshift entity.
// If the Workshift object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkshiftMutation) OldClockInLocation(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClockInLocation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClockInLocation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClockInLocation: %w", err)
	}
	return oldValue.ClockInLocation, nil
}

// ResetClockInLocation resets all changes to the "clock_in_location" field.
func (m *WorkshiftMutation) ResetClockInLocation() {
	m.clock_in_location = nil
}

// SetClockOutLocation sets the "clock_out_location" field.
func (m *WorkshiftMutation) SetClockOutLocation(s string) {
	m.clock_out_location = &s
}

// ClockOutLocation returns the value of the "clock_out_location" field in the mutation.
func (m *WorkshiftMutation) ClockOutLocation() (r string, exists bool) {
	v := m.clock_out_location
	if v == nil {
		return
	}
	return *v, true
}

// OldClockOutLocation returns the old "clock_out_location" field's value of the Workshift entity.
// If the Workshift object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkshiftMutation) OldClockOutLocation(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClockOutLocation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClockOutLocation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClockOutLocation: %w", err)
	}
	return oldValue.ClockOutLocation, nil
}

// ClearClockOutLocation clears the value of the "clock_out_location" field.
func (m *WorkshiftMutation) ClearClockOutLocation() {
	m.clock_out_location = nil
	m.clearedFields[workshift.FieldClockOutLocation] = struct{}{}
}

// ClockOutLocationCleared returns if the "clock_out_location" field was cleared in this mutation.
func (m *WorkshiftMutation) ClockOutLocationCleared() bool {
	_, ok := m.clearedFields[workshift.FieldClockOutLocation]
	return ok
}

// ResetClockOutLocation resets all changes to the "clock_out_location" field.
func (m *WorkshiftMutation) ResetClockOutLocation() {
	m.clock_out_location = nil
	delete(m.clearedFields, workshift.FieldClockOutLocation)
}

// SetDescription sets the "description" field.
func (m *WorkshiftMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *WorkshiftMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Workshift entity.
// If the Workshift object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkshiftMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *WorkshiftMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[workshift.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *WorkshiftMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[workshift.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *WorkshiftMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, workshift.FieldDescription)
}

// SetNote sets the "note" field.
func (m *WorkshiftMutation) SetNote(s string) {
	m.note = &s
}

// Note returns the value of the "note" field in the mutation.
func (m *WorkshiftMutation) Note() (r string, exists bool) {
	v := m.note
	if v == nil {
		return
	}
	return *v, true
}

// OldNote returns the old "note" field's value of the Workshift entity.
// If the Workshift object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkshiftMutation) OldNote(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNote is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNote requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNote: %w", err)
	}
	return oldValue.Note, nil
}

// ClearNote clears the value of the "note" field.
func (m *WorkshiftMutation) ClearNote() {
	m.note = nil
	m.clearedFields[workshift.FieldNote] = struct{}{}
}

// NoteCleared returns if the "note" field was cleared in this mutation.
func (m *WorkshiftMutation) NoteCleared() bool {
	_, ok := m.clearedFields[workshift.FieldNote]
	return ok
}

// ResetNote resets all changes to the "note" field.
func (m *WorkshiftMutation) ResetNote() {
	m.note = nil
	delete(m.clearedFields, workshift.FieldNote)
}

// SetStatus sets the "status" field.
func (m *WorkshiftMutation) SetStatus(w workshift.Status) {
	m.status = &w
}

// Status returns the value of the "status" field in the mutation.
func (m *WorkshiftMutation) Status() (r workshift.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Workshift entity.
// If the Workshift object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkshiftMutation) OldStatus(ctx context.Context) (v workshift.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *WorkshiftMutation) ResetStatus() {
	m.status = nil
}

// SetCompanyID sets the "company" edge to the Company entity by id.
func (m *WorkshiftMutation) SetCompanyID(id int) {
	m.company = &id
}

// ClearCompany clears the "company" edge to the Company entity.
func (m *WorkshiftMutation) ClearCompany() {
	m.clearedcompany = true
}

// CompanyCleared reports if the "company" edge to the Company entity was cleared.
func (m *WorkshiftMutation) CompanyCleared() bool {
	return m.clearedcompany
}

// CompanyID returns the "company" edge ID in the mutation.
func (m *WorkshiftMutation) CompanyID() (id int, exists bool) {
	if m.company != nil {
		return *m.company, true
	}
	return
}

// CompanyIDs returns the "company" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CompanyID instead. It exists only for internal usage by the builders.
func (m *WorkshiftMutation) CompanyIDs() (ids []int) {
	if id := m.company; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCompany resets all changes to the "company" edge.
func (m *WorkshiftMutation) ResetCompany() {
	m.company = nil
	m.clearedcompany = false
}

// SetUserID sets the "user" edge to the User entity by id.
func (m *WorkshiftMutation) SetUserID(id int) {
	m.user = &id
}

// ClearUser clears the "user" edge to the User entity.
func (m *WorkshiftMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *WorkshiftMutation) UserCleared() bool {
	return m.cleareduser
}

// UserID returns the "user" edge ID in the mutation.
func (m *WorkshiftMutation) UserID() (id int, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *WorkshiftMutation) UserIDs() (ids []int) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *WorkshiftMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// SetApprovedByID sets the "approved_by" edge to the User entity by id.
func (m *WorkshiftMutation) SetApprovedByID(id int) {
	m.approved_by = &id
}

// ClearApprovedBy clears the "approved_by" edge to the User entity.
func (m *WorkshiftMutation) ClearApprovedBy() {
	m.clearedapproved_by = true
}

// ApprovedByCleared reports if the "approved_by" edge to the User entity was cleared.
func (m *WorkshiftMutation) ApprovedByCleared() bool {
	return m.clearedapproved_by
}

// ApprovedByID returns the "approved_by" edge ID in the mutation.
func (m *WorkshiftMutation) ApprovedByID() (id int, exists bool) {
	if m.approved_by != nil {
		return *m.approved_by, true
	}
	return
}

// ApprovedByIDs returns the "approved_by" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ApprovedByID instead. It exists only for internal usage by the builders.
func (m *WorkshiftMutation) ApprovedByIDs() (ids []int) {
	if id := m.approved_by; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetApprovedBy resets all changes to the "approved_by" edge.
func (m *WorkshiftMutation) ResetApprovedBy() {
	m.approved_by = nil
	m.clearedapproved_by = false
}

// SetTaskID sets the "task" edge to the ProjectTask entity by id.
func (m *WorkshiftMutation) SetTaskID(id int) {
	m.task = &id
}

// ClearTask clears the "task" edge to the ProjectTask entity.
func (m *WorkshiftMutation) ClearTask() {
	m.clearedtask = true
}

// TaskCleared reports if the "task" edge to the ProjectTask entity was cleared.
func (m *WorkshiftMutation) TaskCleared() bool {
	return m.clearedtask
}

// TaskID returns the "task" edge ID in the mutation.
func (m *WorkshiftMutation) TaskID() (id int, exists bool) {
	if m.task != nil {
		return *m.task, true
	}
	return
}

// TaskIDs returns the "task" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TaskID instead. It exists only for internal usage by the builders.
func (m *WorkshiftMutation) TaskIDs() (ids []int) {
	if id := m.task; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTask resets all changes to the "task" edge.
func (m *WorkshiftMutation) ResetTask() {
	m.task = nil
	m.clearedtask = false
}

// SetEditRequestID sets the "edit_request" edge to the Workshift entity by id.
func (m *WorkshiftMutation) SetEditRequestID(id int) {
	m.edit_request = &id
}

// ClearEditRequest clears the "edit_request" edge to the Workshift entity.
func (m *WorkshiftMutation) ClearEditRequest() {
	m.clearededit_request = true
}

// EditRequestCleared reports if the "edit_request" edge to the Workshift entity was cleared.
func (m *WorkshiftMutation) EditRequestCleared() bool {
	return m.clearededit_request
}

// EditRequestID returns the "edit_request" edge ID in the mutation.
func (m *WorkshiftMutation) EditRequestID() (id int, exists bool) {
	if m.edit_request != nil {
		return *m.edit_request, true
	}
	return
}

// EditRequestIDs returns the "edit_request" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// EditRequestID instead. It exists only for internal usage by the builders.
func (m *WorkshiftMutation) EditRequestIDs() (ids []int) {
	if id := m.edit_request; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEditRequest resets all changes to the "edit_request" edge.
func (m *WorkshiftMutation) ResetEditRequest() {
	m.edit_request = nil
	m.clearededit_request = false
}

// SetWorkShiftID sets the "work_shift" edge to the Workshift entity by id.
func (m *WorkshiftMutation) SetWorkShiftID(id int) {
	m.work_shift = &id
}

// ClearWorkShift clears the "work_shift" edge to the Workshift entity.
func (m *WorkshiftMutation) ClearWorkShift() {
	m.clearedwork_shift = true
}

// WorkShiftCleared reports if the "work_shift" edge to the Workshift entity was cleared.
func (m *WorkshiftMutation) WorkShiftCleared() bool {
	return m.clearedwork_shift
}

// WorkShiftID returns the "work_shift" edge ID in the mutation.
func (m *WorkshiftMutation) WorkShiftID() (id int, exists bool) {
	if m.work_shift != nil {
		return *m.work_shift, true
	}
	return
}

// WorkShiftIDs returns the "work_shift" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// WorkShiftID instead. It exists only for internal usage by the builders.
func (m *WorkshiftMutation) WorkShiftIDs() (ids []int) {
	if id := m.work_shift; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetWorkShift resets all changes to the "work_shift" edge.
func (m *WorkshiftMutation) ResetWorkShift() {
	m.work_shift = nil
	m.clearedwork_shift = false
}

// Where appends a list predicates to the WorkshiftMutation builder.
func (m *WorkshiftMutation) Where(ps ...predicate.Workshift) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the WorkshiftMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *WorkshiftMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Workshift, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *WorkshiftMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *WorkshiftMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Workshift).
func (m *WorkshiftMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *WorkshiftMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.created_at != nil {
		fields = append(fields, workshift.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, workshift.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, workshift.FieldDeletedAt)
	}
	if m.approved_at != nil {
		fields = append(fields, workshift.FieldApprovedAt)
	}
	if m.clock_in != nil {
		fields = append(fields, workshift.FieldClockIn)
	}
	if m.clock_out != nil {
		fields = append(fields, workshift.FieldClockOut)
	}
	if m.clock_in_location != nil {
		fields = append(fields, workshift.FieldClockInLocation)
	}
	if m.clock_out_location != nil {
		fields = append(fields, workshift.FieldClockOutLocation)
	}
	if m.description != nil {
		fields = append(fields, workshift.FieldDescription)
	}
	if m.note != nil {
		fields = append(fields, workshift.FieldNote)
	}
	if m.status != nil {
		fields = append(fields, workshift.FieldStatus)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *WorkshiftMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case workshift.FieldCreatedAt:
		return m.CreatedAt()
	case workshift.FieldUpdatedAt:
		return m.UpdatedAt()
	case workshift.FieldDeletedAt:
		return m.DeletedAt()
	case workshift.FieldApprovedAt:
		return m.ApprovedAt()
	case workshift.FieldClockIn:
		return m.ClockIn()
	case workshift.FieldClockOut:
		return m.ClockOut()
	case workshift.FieldClockInLocation:
		return m.ClockInLocation()
	case workshift.FieldClockOutLocation:
		return m.ClockOutLocation()
	case workshift.FieldDescription:
		return m.Description()
	case workshift.FieldNote:
		return m.Note()
	case workshift.FieldStatus:
		return m.Status()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *WorkshiftMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case workshift.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case workshift.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case workshift.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case workshift.FieldApprovedAt:
		return m.OldApprovedAt(ctx)
	case workshift.FieldClockIn:
		return m.OldClockIn(ctx)
	case workshift.FieldClockOut:
		return m.OldClockOut(ctx)
	case workshift.FieldClockInLocation:
		return m.OldClockInLocation(ctx)
	case workshift.FieldClockOutLocation:
		return m.OldClockOutLocation(ctx)
	case workshift.FieldDescription:
		return m.OldDescription(ctx)
	case workshift.FieldNote:
		return m.OldNote(ctx)
	case workshift.FieldStatus:
		return m.OldStatus(ctx)
	}
	return nil, fmt.Errorf("unknown Workshift field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WorkshiftMutation) SetField(name string, value ent.Value) error {
	switch name {
	case workshift.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case workshift.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case workshift.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case workshift.FieldApprovedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetApprovedAt(v)
		return nil
	case workshift.FieldClockIn:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClockIn(v)
		return nil
	case workshift.FieldClockOut:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClockOut(v)
		return nil
	case workshift.FieldClockInLocation:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClockInLocation(v)
		return nil
	case workshift.FieldClockOutLocation:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClockOutLocation(v)
		return nil
	case workshift.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case workshift.FieldNote:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNote(v)
		return nil
	case workshift.FieldStatus:
		v, ok := value.(workshift.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	}
	return fmt.Errorf("unknown Workshift field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *WorkshiftMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *WorkshiftMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WorkshiftMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Workshift numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *WorkshiftMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(workshift.FieldDeletedAt) {
		fields = append(fields, workshift.FieldDeletedAt)
	}
	if m.FieldCleared(workshift.FieldApprovedAt) {
		fields = append(fields, workshift.FieldApprovedAt)
	}
	if m.FieldCleared(workshift.FieldClockOut) {
		fields = append(fields, workshift.FieldClockOut)
	}
	if m.FieldCleared(workshift.FieldClockOutLocation) {
		fields = append(fields, workshift.FieldClockOutLocation)
	}
	if m.FieldCleared(workshift.FieldDescription) {
		fields = append(fields, workshift.FieldDescription)
	}
	if m.FieldCleared(workshift.FieldNote) {
		fields = append(fields, workshift.FieldNote)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *WorkshiftMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *WorkshiftMutation) ClearField(name string) error {
	switch name {
	case workshift.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case workshift.FieldApprovedAt:
		m.ClearApprovedAt()
		return nil
	case workshift.FieldClockOut:
		m.ClearClockOut()
		return nil
	case workshift.FieldClockOutLocation:
		m.ClearClockOutLocation()
		return nil
	case workshift.FieldDescription:
		m.ClearDescription()
		return nil
	case workshift.FieldNote:
		m.ClearNote()
		return nil
	}
	return fmt.Errorf("unknown Workshift nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *WorkshiftMutation) ResetField(name string) error {
	switch name {
	case workshift.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case workshift.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case workshift.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case workshift.FieldApprovedAt:
		m.ResetApprovedAt()
		return nil
	case workshift.FieldClockIn:
		m.ResetClockIn()
		return nil
	case workshift.FieldClockOut:
		m.ResetClockOut()
		return nil
	case workshift.FieldClockInLocation:
		m.ResetClockInLocation()
		return nil
	case workshift.FieldClockOutLocation:
		m.ResetClockOutLocation()
		return nil
	case workshift.FieldDescription:
		m.ResetDescription()
		return nil
	case workshift.FieldNote:
		m.ResetNote()
		return nil
	case workshift.FieldStatus:
		m.ResetStatus()
		return nil
	}
	return fmt.Errorf("unknown Workshift field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *WorkshiftMutation) AddedEdges() []string {
	edges := make([]string, 0, 6)
	if m.company != nil {
		edges = append(edges, workshift.EdgeCompany)
	}
	if m.user != nil {
		edges = append(edges, workshift.EdgeUser)
	}
	if m.approved_by != nil {
		edges = append(edges, workshift.EdgeApprovedBy)
	}
	if m.task != nil {
		edges = append(edges, workshift.EdgeTask)
	}
	if m.edit_request != nil {
		edges = append(edges, workshift.EdgeEditRequest)
	}
	if m.work_shift != nil {
		edges = append(edges, workshift.EdgeWorkShift)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *WorkshiftMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case workshift.EdgeCompany:
		if id := m.company; id != nil {
			return []ent.Value{*id}
		}
	case workshift.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case workshift.EdgeApprovedBy:
		if id := m.approved_by; id != nil {
			return []ent.Value{*id}
		}
	case workshift.EdgeTask:
		if id := m.task; id != nil {
			return []ent.Value{*id}
		}
	case workshift.EdgeEditRequest:
		if id := m.edit_request; id != nil {
			return []ent.Value{*id}
		}
	case workshift.EdgeWorkShift:
		if id := m.work_shift; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *WorkshiftMutation) RemovedEdges() []string {
	edges := make([]string, 0, 6)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *WorkshiftMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *WorkshiftMutation) ClearedEdges() []string {
	edges := make([]string, 0, 6)
	if m.clearedcompany {
		edges = append(edges, workshift.EdgeCompany)
	}
	if m.cleareduser {
		edges = append(edges, workshift.EdgeUser)
	}
	if m.clearedapproved_by {
		edges = append(edges, workshift.EdgeApprovedBy)
	}
	if m.clearedtask {
		edges = append(edges, workshift.EdgeTask)
	}
	if m.clearededit_request {
		edges = append(edges, workshift.EdgeEditRequest)
	}
	if m.clearedwork_shift {
		edges = append(edges, workshift.EdgeWorkShift)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *WorkshiftMutation) EdgeCleared(name string) bool {
	switch name {
	case workshift.EdgeCompany:
		return m.clearedcompany
	case workshift.EdgeUser:
		return m.cleareduser
	case workshift.EdgeApprovedBy:
		return m.clearedapproved_by
	case workshift.EdgeTask:
		return m.clearedtask
	case workshift.EdgeEditRequest:
		return m.clearededit_request
	case workshift.EdgeWorkShift:
		return m.clearedwork_shift
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *WorkshiftMutation) ClearEdge(name string) error {
	switch name {
	case workshift.EdgeCompany:
		m.ClearCompany()
		return nil
	case workshift.EdgeUser:
		m.ClearUser()
		return nil
	case workshift.EdgeApprovedBy:
		m.ClearApprovedBy()
		return nil
	case workshift.EdgeTask:
		m.ClearTask()
		return nil
	case workshift.EdgeEditRequest:
		m.ClearEditRequest()
		return nil
	case workshift.EdgeWorkShift:
		m.ClearWorkShift()
		return nil
	}
	return fmt.Errorf("unknown Workshift unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *WorkshiftMutation) ResetEdge(name string) error {
	switch name {
	case workshift.EdgeCompany:
		m.ResetCompany()
		return nil
	case workshift.EdgeUser:
		m.ResetUser()
		return nil
	case workshift.EdgeApprovedBy:
		m.ResetApprovedBy()
		return nil
	case workshift.EdgeTask:
		m.ResetTask()
		return nil
	case workshift.EdgeEditRequest:
		m.ResetEditRequest()
		return nil
	case workshift.EdgeWorkShift:
		m.ResetWorkShift()
		return nil
	}
	return fmt.Errorf("unknown Workshift edge %s", name)
}
