// Code generated by ent, DO NOT EDIT.

package generated

import (
	"context"
	"errors"
	"fmt"
	"mazza/ent/generated/accountingentry"
	"mazza/ent/generated/company"
	"mazza/ent/generated/companydocument"
	"mazza/ent/generated/customer"
	"mazza/ent/generated/employee"
	"mazza/ent/generated/file"
	"mazza/ent/generated/payable"
	"mazza/ent/generated/predicate"
	"mazza/ent/generated/product"
	"mazza/ent/generated/project"
	"mazza/ent/generated/projectmilestone"
	"mazza/ent/generated/projecttask"
	"mazza/ent/generated/receivable"
	"mazza/ent/generated/supplier"
	"mazza/ent/generated/token"
	"mazza/ent/generated/treasury"
	"mazza/ent/generated/user"
	"mazza/ent/generated/userrole"
	"mazza/ent/generated/workshift"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeAccountingEntry  = "AccountingEntry"
	TypeCompany          = "Company"
	TypeCompanyDocument  = "CompanyDocument"
	TypeCustomer         = "Customer"
	TypeEmployee         = "Employee"
	TypeFile             = "File"
	TypePayable          = "Payable"
	TypeProduct          = "Product"
	TypeProject          = "Project"
	TypeProjectMilestone = "ProjectMilestone"
	TypeProjectTask      = "ProjectTask"
	TypeReceivable       = "Receivable"
	TypeSupplier         = "Supplier"
	TypeToken            = "Token"
	TypeTreasury         = "Treasury"
	TypeUser             = "User"
	TypeUserRole         = "UserRole"
	TypeWorkshift        = "Workshift"
)

// AccountingEntryMutation represents an operation that mutates the AccountingEntry nodes in the graph.
type AccountingEntryMutation struct {
	config
	op             Op
	typ            string
	id             *int
	createdAt      *time.Time
	updatedAt      *time.Time
	deletedAt      *time.Time
	number         *int
	addnumber      *int
	group          *int
	addgroup       *int
	date           *time.Time
	account        *string
	label          *string
	amount         *float64
	addamount      *float64
	description    *string
	accountType    *accountingentry.AccountType
	category       *string
	isDebit        *bool
	isReversal     *bool
	reversed       *bool
	clearedFields  map[string]struct{}
	company        *int
	clearedcompany bool
	user           *int
	cleareduser    bool
	done           bool
	oldValue       func(context.Context) (*AccountingEntry, error)
	predicates     []predicate.AccountingEntry
}

var _ ent.Mutation = (*AccountingEntryMutation)(nil)

// accountingentryOption allows management of the mutation configuration using functional options.
type accountingentryOption func(*AccountingEntryMutation)

// newAccountingEntryMutation creates new mutation for the AccountingEntry entity.
func newAccountingEntryMutation(c config, op Op, opts ...accountingentryOption) *AccountingEntryMutation {
	m := &AccountingEntryMutation{
		config:        c,
		op:            op,
		typ:           TypeAccountingEntry,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAccountingEntryID sets the ID field of the mutation.
func withAccountingEntryID(id int) accountingentryOption {
	return func(m *AccountingEntryMutation) {
		var (
			err   error
			once  sync.Once
			value *AccountingEntry
		)
		m.oldValue = func(ctx context.Context) (*AccountingEntry, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AccountingEntry.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAccountingEntry sets the old AccountingEntry of the mutation.
func withAccountingEntry(node *AccountingEntry) accountingentryOption {
	return func(m *AccountingEntryMutation) {
		m.oldValue = func(context.Context) (*AccountingEntry, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AccountingEntryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AccountingEntryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("generated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AccountingEntryMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AccountingEntryMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AccountingEntry.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "createdAt" field.
func (m *AccountingEntryMutation) SetCreatedAt(t time.Time) {
	m.createdAt = &t
}

// CreatedAt returns the value of the "createdAt" field in the mutation.
func (m *AccountingEntryMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.createdAt
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "createdAt" field's value of the AccountingEntry entity.
// If the AccountingEntry object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountingEntryMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "createdAt" field.
func (m *AccountingEntryMutation) ResetCreatedAt() {
	m.createdAt = nil
}

// SetUpdatedAt sets the "updatedAt" field.
func (m *AccountingEntryMutation) SetUpdatedAt(t time.Time) {
	m.updatedAt = &t
}

// UpdatedAt returns the value of the "updatedAt" field in the mutation.
func (m *AccountingEntryMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updatedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updatedAt" field's value of the AccountingEntry entity.
// If the AccountingEntry object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountingEntryMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updatedAt" field.
func (m *AccountingEntryMutation) ResetUpdatedAt() {
	m.updatedAt = nil
}

// SetDeletedAt sets the "deletedAt" field.
func (m *AccountingEntryMutation) SetDeletedAt(t time.Time) {
	m.deletedAt = &t
}

// DeletedAt returns the value of the "deletedAt" field in the mutation.
func (m *AccountingEntryMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deletedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deletedAt" field's value of the AccountingEntry entity.
// If the AccountingEntry object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountingEntryMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deletedAt" field.
func (m *AccountingEntryMutation) ClearDeletedAt() {
	m.deletedAt = nil
	m.clearedFields[accountingentry.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deletedAt" field was cleared in this mutation.
func (m *AccountingEntryMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[accountingentry.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deletedAt" field.
func (m *AccountingEntryMutation) ResetDeletedAt() {
	m.deletedAt = nil
	delete(m.clearedFields, accountingentry.FieldDeletedAt)
}

// SetNumber sets the "number" field.
func (m *AccountingEntryMutation) SetNumber(i int) {
	m.number = &i
	m.addnumber = nil
}

// Number returns the value of the "number" field in the mutation.
func (m *AccountingEntryMutation) Number() (r int, exists bool) {
	v := m.number
	if v == nil {
		return
	}
	return *v, true
}

// OldNumber returns the old "number" field's value of the AccountingEntry entity.
// If the AccountingEntry object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountingEntryMutation) OldNumber(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNumber: %w", err)
	}
	return oldValue.Number, nil
}

// AddNumber adds i to the "number" field.
func (m *AccountingEntryMutation) AddNumber(i int) {
	if m.addnumber != nil {
		*m.addnumber += i
	} else {
		m.addnumber = &i
	}
}

// AddedNumber returns the value that was added to the "number" field in this mutation.
func (m *AccountingEntryMutation) AddedNumber() (r int, exists bool) {
	v := m.addnumber
	if v == nil {
		return
	}
	return *v, true
}

// ResetNumber resets all changes to the "number" field.
func (m *AccountingEntryMutation) ResetNumber() {
	m.number = nil
	m.addnumber = nil
}

// SetGroup sets the "group" field.
func (m *AccountingEntryMutation) SetGroup(i int) {
	m.group = &i
	m.addgroup = nil
}

// Group returns the value of the "group" field in the mutation.
func (m *AccountingEntryMutation) Group() (r int, exists bool) {
	v := m.group
	if v == nil {
		return
	}
	return *v, true
}

// OldGroup returns the old "group" field's value of the AccountingEntry entity.
// If the AccountingEntry object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountingEntryMutation) OldGroup(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGroup is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGroup requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGroup: %w", err)
	}
	return oldValue.Group, nil
}

// AddGroup adds i to the "group" field.
func (m *AccountingEntryMutation) AddGroup(i int) {
	if m.addgroup != nil {
		*m.addgroup += i
	} else {
		m.addgroup = &i
	}
}

// AddedGroup returns the value that was added to the "group" field in this mutation.
func (m *AccountingEntryMutation) AddedGroup() (r int, exists bool) {
	v := m.addgroup
	if v == nil {
		return
	}
	return *v, true
}

// ResetGroup resets all changes to the "group" field.
func (m *AccountingEntryMutation) ResetGroup() {
	m.group = nil
	m.addgroup = nil
}

// SetDate sets the "date" field.
func (m *AccountingEntryMutation) SetDate(t time.Time) {
	m.date = &t
}

// Date returns the value of the "date" field in the mutation.
func (m *AccountingEntryMutation) Date() (r time.Time, exists bool) {
	v := m.date
	if v == nil {
		return
	}
	return *v, true
}

// OldDate returns the old "date" field's value of the AccountingEntry entity.
// If the AccountingEntry object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountingEntryMutation) OldDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDate: %w", err)
	}
	return oldValue.Date, nil
}

// ResetDate resets all changes to the "date" field.
func (m *AccountingEntryMutation) ResetDate() {
	m.date = nil
}

// SetAccount sets the "account" field.
func (m *AccountingEntryMutation) SetAccount(s string) {
	m.account = &s
}

// Account returns the value of the "account" field in the mutation.
func (m *AccountingEntryMutation) Account() (r string, exists bool) {
	v := m.account
	if v == nil {
		return
	}
	return *v, true
}

// OldAccount returns the old "account" field's value of the AccountingEntry entity.
// If the AccountingEntry object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountingEntryMutation) OldAccount(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAccount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAccount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAccount: %w", err)
	}
	return oldValue.Account, nil
}

// ResetAccount resets all changes to the "account" field.
func (m *AccountingEntryMutation) ResetAccount() {
	m.account = nil
}

// SetLabel sets the "label" field.
func (m *AccountingEntryMutation) SetLabel(s string) {
	m.label = &s
}

// Label returns the value of the "label" field in the mutation.
func (m *AccountingEntryMutation) Label() (r string, exists bool) {
	v := m.label
	if v == nil {
		return
	}
	return *v, true
}

// OldLabel returns the old "label" field's value of the AccountingEntry entity.
// If the AccountingEntry object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountingEntryMutation) OldLabel(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLabel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLabel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLabel: %w", err)
	}
	return oldValue.Label, nil
}

// ResetLabel resets all changes to the "label" field.
func (m *AccountingEntryMutation) ResetLabel() {
	m.label = nil
}

// SetAmount sets the "amount" field.
func (m *AccountingEntryMutation) SetAmount(f float64) {
	m.amount = &f
	m.addamount = nil
}

// Amount returns the value of the "amount" field in the mutation.
func (m *AccountingEntryMutation) Amount() (r float64, exists bool) {
	v := m.amount
	if v == nil {
		return
	}
	return *v, true
}

// OldAmount returns the old "amount" field's value of the AccountingEntry entity.
// If the AccountingEntry object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountingEntryMutation) OldAmount(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAmount: %w", err)
	}
	return oldValue.Amount, nil
}

// AddAmount adds f to the "amount" field.
func (m *AccountingEntryMutation) AddAmount(f float64) {
	if m.addamount != nil {
		*m.addamount += f
	} else {
		m.addamount = &f
	}
}

// AddedAmount returns the value that was added to the "amount" field in this mutation.
func (m *AccountingEntryMutation) AddedAmount() (r float64, exists bool) {
	v := m.addamount
	if v == nil {
		return
	}
	return *v, true
}

// ResetAmount resets all changes to the "amount" field.
func (m *AccountingEntryMutation) ResetAmount() {
	m.amount = nil
	m.addamount = nil
}

// SetDescription sets the "description" field.
func (m *AccountingEntryMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *AccountingEntryMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the AccountingEntry entity.
// If the AccountingEntry object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountingEntryMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *AccountingEntryMutation) ResetDescription() {
	m.description = nil
}

// SetAccountType sets the "accountType" field.
func (m *AccountingEntryMutation) SetAccountType(at accountingentry.AccountType) {
	m.accountType = &at
}

// AccountType returns the value of the "accountType" field in the mutation.
func (m *AccountingEntryMutation) AccountType() (r accountingentry.AccountType, exists bool) {
	v := m.accountType
	if v == nil {
		return
	}
	return *v, true
}

// OldAccountType returns the old "accountType" field's value of the AccountingEntry entity.
// If the AccountingEntry object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountingEntryMutation) OldAccountType(ctx context.Context) (v accountingentry.AccountType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAccountType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAccountType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAccountType: %w", err)
	}
	return oldValue.AccountType, nil
}

// ResetAccountType resets all changes to the "accountType" field.
func (m *AccountingEntryMutation) ResetAccountType() {
	m.accountType = nil
}

// SetCategory sets the "category" field.
func (m *AccountingEntryMutation) SetCategory(s string) {
	m.category = &s
}

// Category returns the value of the "category" field in the mutation.
func (m *AccountingEntryMutation) Category() (r string, exists bool) {
	v := m.category
	if v == nil {
		return
	}
	return *v, true
}

// OldCategory returns the old "category" field's value of the AccountingEntry entity.
// If the AccountingEntry object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountingEntryMutation) OldCategory(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCategory is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCategory requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCategory: %w", err)
	}
	return oldValue.Category, nil
}

// ResetCategory resets all changes to the "category" field.
func (m *AccountingEntryMutation) ResetCategory() {
	m.category = nil
}

// SetIsDebit sets the "isDebit" field.
func (m *AccountingEntryMutation) SetIsDebit(b bool) {
	m.isDebit = &b
}

// IsDebit returns the value of the "isDebit" field in the mutation.
func (m *AccountingEntryMutation) IsDebit() (r bool, exists bool) {
	v := m.isDebit
	if v == nil {
		return
	}
	return *v, true
}

// OldIsDebit returns the old "isDebit" field's value of the AccountingEntry entity.
// If the AccountingEntry object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountingEntryMutation) OldIsDebit(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsDebit is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsDebit requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsDebit: %w", err)
	}
	return oldValue.IsDebit, nil
}

// ResetIsDebit resets all changes to the "isDebit" field.
func (m *AccountingEntryMutation) ResetIsDebit() {
	m.isDebit = nil
}

// SetIsReversal sets the "isReversal" field.
func (m *AccountingEntryMutation) SetIsReversal(b bool) {
	m.isReversal = &b
}

// IsReversal returns the value of the "isReversal" field in the mutation.
func (m *AccountingEntryMutation) IsReversal() (r bool, exists bool) {
	v := m.isReversal
	if v == nil {
		return
	}
	return *v, true
}

// OldIsReversal returns the old "isReversal" field's value of the AccountingEntry entity.
// If the AccountingEntry object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountingEntryMutation) OldIsReversal(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsReversal is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsReversal requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsReversal: %w", err)
	}
	return oldValue.IsReversal, nil
}

// ResetIsReversal resets all changes to the "isReversal" field.
func (m *AccountingEntryMutation) ResetIsReversal() {
	m.isReversal = nil
}

// SetReversed sets the "reversed" field.
func (m *AccountingEntryMutation) SetReversed(b bool) {
	m.reversed = &b
}

// Reversed returns the value of the "reversed" field in the mutation.
func (m *AccountingEntryMutation) Reversed() (r bool, exists bool) {
	v := m.reversed
	if v == nil {
		return
	}
	return *v, true
}

// OldReversed returns the old "reversed" field's value of the AccountingEntry entity.
// If the AccountingEntry object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountingEntryMutation) OldReversed(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReversed is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReversed requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReversed: %w", err)
	}
	return oldValue.Reversed, nil
}

// ResetReversed resets all changes to the "reversed" field.
func (m *AccountingEntryMutation) ResetReversed() {
	m.reversed = nil
}

// SetCompanyID sets the "company" edge to the Company entity by id.
func (m *AccountingEntryMutation) SetCompanyID(id int) {
	m.company = &id
}

// ClearCompany clears the "company" edge to the Company entity.
func (m *AccountingEntryMutation) ClearCompany() {
	m.clearedcompany = true
}

// CompanyCleared reports if the "company" edge to the Company entity was cleared.
func (m *AccountingEntryMutation) CompanyCleared() bool {
	return m.clearedcompany
}

// CompanyID returns the "company" edge ID in the mutation.
func (m *AccountingEntryMutation) CompanyID() (id int, exists bool) {
	if m.company != nil {
		return *m.company, true
	}
	return
}

// CompanyIDs returns the "company" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CompanyID instead. It exists only for internal usage by the builders.
func (m *AccountingEntryMutation) CompanyIDs() (ids []int) {
	if id := m.company; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCompany resets all changes to the "company" edge.
func (m *AccountingEntryMutation) ResetCompany() {
	m.company = nil
	m.clearedcompany = false
}

// SetUserID sets the "user" edge to the User entity by id.
func (m *AccountingEntryMutation) SetUserID(id int) {
	m.user = &id
}

// ClearUser clears the "user" edge to the User entity.
func (m *AccountingEntryMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *AccountingEntryMutation) UserCleared() bool {
	return m.cleareduser
}

// UserID returns the "user" edge ID in the mutation.
func (m *AccountingEntryMutation) UserID() (id int, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *AccountingEntryMutation) UserIDs() (ids []int) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *AccountingEntryMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the AccountingEntryMutation builder.
func (m *AccountingEntryMutation) Where(ps ...predicate.AccountingEntry) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AccountingEntryMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AccountingEntryMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.AccountingEntry, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AccountingEntryMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AccountingEntryMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (AccountingEntry).
func (m *AccountingEntryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AccountingEntryMutation) Fields() []string {
	fields := make([]string, 0, 15)
	if m.createdAt != nil {
		fields = append(fields, accountingentry.FieldCreatedAt)
	}
	if m.updatedAt != nil {
		fields = append(fields, accountingentry.FieldUpdatedAt)
	}
	if m.deletedAt != nil {
		fields = append(fields, accountingentry.FieldDeletedAt)
	}
	if m.number != nil {
		fields = append(fields, accountingentry.FieldNumber)
	}
	if m.group != nil {
		fields = append(fields, accountingentry.FieldGroup)
	}
	if m.date != nil {
		fields = append(fields, accountingentry.FieldDate)
	}
	if m.account != nil {
		fields = append(fields, accountingentry.FieldAccount)
	}
	if m.label != nil {
		fields = append(fields, accountingentry.FieldLabel)
	}
	if m.amount != nil {
		fields = append(fields, accountingentry.FieldAmount)
	}
	if m.description != nil {
		fields = append(fields, accountingentry.FieldDescription)
	}
	if m.accountType != nil {
		fields = append(fields, accountingentry.FieldAccountType)
	}
	if m.category != nil {
		fields = append(fields, accountingentry.FieldCategory)
	}
	if m.isDebit != nil {
		fields = append(fields, accountingentry.FieldIsDebit)
	}
	if m.isReversal != nil {
		fields = append(fields, accountingentry.FieldIsReversal)
	}
	if m.reversed != nil {
		fields = append(fields, accountingentry.FieldReversed)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AccountingEntryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case accountingentry.FieldCreatedAt:
		return m.CreatedAt()
	case accountingentry.FieldUpdatedAt:
		return m.UpdatedAt()
	case accountingentry.FieldDeletedAt:
		return m.DeletedAt()
	case accountingentry.FieldNumber:
		return m.Number()
	case accountingentry.FieldGroup:
		return m.Group()
	case accountingentry.FieldDate:
		return m.Date()
	case accountingentry.FieldAccount:
		return m.Account()
	case accountingentry.FieldLabel:
		return m.Label()
	case accountingentry.FieldAmount:
		return m.Amount()
	case accountingentry.FieldDescription:
		return m.Description()
	case accountingentry.FieldAccountType:
		return m.AccountType()
	case accountingentry.FieldCategory:
		return m.Category()
	case accountingentry.FieldIsDebit:
		return m.IsDebit()
	case accountingentry.FieldIsReversal:
		return m.IsReversal()
	case accountingentry.FieldReversed:
		return m.Reversed()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AccountingEntryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case accountingentry.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case accountingentry.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case accountingentry.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case accountingentry.FieldNumber:
		return m.OldNumber(ctx)
	case accountingentry.FieldGroup:
		return m.OldGroup(ctx)
	case accountingentry.FieldDate:
		return m.OldDate(ctx)
	case accountingentry.FieldAccount:
		return m.OldAccount(ctx)
	case accountingentry.FieldLabel:
		return m.OldLabel(ctx)
	case accountingentry.FieldAmount:
		return m.OldAmount(ctx)
	case accountingentry.FieldDescription:
		return m.OldDescription(ctx)
	case accountingentry.FieldAccountType:
		return m.OldAccountType(ctx)
	case accountingentry.FieldCategory:
		return m.OldCategory(ctx)
	case accountingentry.FieldIsDebit:
		return m.OldIsDebit(ctx)
	case accountingentry.FieldIsReversal:
		return m.OldIsReversal(ctx)
	case accountingentry.FieldReversed:
		return m.OldReversed(ctx)
	}
	return nil, fmt.Errorf("unknown AccountingEntry field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AccountingEntryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case accountingentry.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case accountingentry.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case accountingentry.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case accountingentry.FieldNumber:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNumber(v)
		return nil
	case accountingentry.FieldGroup:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGroup(v)
		return nil
	case accountingentry.FieldDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDate(v)
		return nil
	case accountingentry.FieldAccount:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAccount(v)
		return nil
	case accountingentry.FieldLabel:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLabel(v)
		return nil
	case accountingentry.FieldAmount:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAmount(v)
		return nil
	case accountingentry.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case accountingentry.FieldAccountType:
		v, ok := value.(accountingentry.AccountType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAccountType(v)
		return nil
	case accountingentry.FieldCategory:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCategory(v)
		return nil
	case accountingentry.FieldIsDebit:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsDebit(v)
		return nil
	case accountingentry.FieldIsReversal:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsReversal(v)
		return nil
	case accountingentry.FieldReversed:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReversed(v)
		return nil
	}
	return fmt.Errorf("unknown AccountingEntry field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AccountingEntryMutation) AddedFields() []string {
	var fields []string
	if m.addnumber != nil {
		fields = append(fields, accountingentry.FieldNumber)
	}
	if m.addgroup != nil {
		fields = append(fields, accountingentry.FieldGroup)
	}
	if m.addamount != nil {
		fields = append(fields, accountingentry.FieldAmount)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AccountingEntryMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case accountingentry.FieldNumber:
		return m.AddedNumber()
	case accountingentry.FieldGroup:
		return m.AddedGroup()
	case accountingentry.FieldAmount:
		return m.AddedAmount()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AccountingEntryMutation) AddField(name string, value ent.Value) error {
	switch name {
	case accountingentry.FieldNumber:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddNumber(v)
		return nil
	case accountingentry.FieldGroup:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddGroup(v)
		return nil
	case accountingentry.FieldAmount:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAmount(v)
		return nil
	}
	return fmt.Errorf("unknown AccountingEntry numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AccountingEntryMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(accountingentry.FieldDeletedAt) {
		fields = append(fields, accountingentry.FieldDeletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AccountingEntryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AccountingEntryMutation) ClearField(name string) error {
	switch name {
	case accountingentry.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown AccountingEntry nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AccountingEntryMutation) ResetField(name string) error {
	switch name {
	case accountingentry.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case accountingentry.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case accountingentry.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case accountingentry.FieldNumber:
		m.ResetNumber()
		return nil
	case accountingentry.FieldGroup:
		m.ResetGroup()
		return nil
	case accountingentry.FieldDate:
		m.ResetDate()
		return nil
	case accountingentry.FieldAccount:
		m.ResetAccount()
		return nil
	case accountingentry.FieldLabel:
		m.ResetLabel()
		return nil
	case accountingentry.FieldAmount:
		m.ResetAmount()
		return nil
	case accountingentry.FieldDescription:
		m.ResetDescription()
		return nil
	case accountingentry.FieldAccountType:
		m.ResetAccountType()
		return nil
	case accountingentry.FieldCategory:
		m.ResetCategory()
		return nil
	case accountingentry.FieldIsDebit:
		m.ResetIsDebit()
		return nil
	case accountingentry.FieldIsReversal:
		m.ResetIsReversal()
		return nil
	case accountingentry.FieldReversed:
		m.ResetReversed()
		return nil
	}
	return fmt.Errorf("unknown AccountingEntry field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AccountingEntryMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.company != nil {
		edges = append(edges, accountingentry.EdgeCompany)
	}
	if m.user != nil {
		edges = append(edges, accountingentry.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AccountingEntryMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case accountingentry.EdgeCompany:
		if id := m.company; id != nil {
			return []ent.Value{*id}
		}
	case accountingentry.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AccountingEntryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AccountingEntryMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AccountingEntryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedcompany {
		edges = append(edges, accountingentry.EdgeCompany)
	}
	if m.cleareduser {
		edges = append(edges, accountingentry.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AccountingEntryMutation) EdgeCleared(name string) bool {
	switch name {
	case accountingentry.EdgeCompany:
		return m.clearedcompany
	case accountingentry.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AccountingEntryMutation) ClearEdge(name string) error {
	switch name {
	case accountingentry.EdgeCompany:
		m.ClearCompany()
		return nil
	case accountingentry.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown AccountingEntry unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AccountingEntryMutation) ResetEdge(name string) error {
	switch name {
	case accountingentry.EdgeCompany:
		m.ResetCompany()
		return nil
	case accountingentry.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown AccountingEntry edge %s", name)
}

// CompanyMutation represents an operation that mutates the Company nodes in the graph.
type CompanyMutation struct {
	config
	op                       Op
	typ                      string
	id                       *int
	createdAt                *time.Time
	updatedAt                *time.Time
	deletedAt                *time.Time
	address                  *string
	baseCurrency             *string
	ceoName                  *string
	city                     *string
	country                  *string
	establishedAt            *time.Time
	description              *string
	email                    *string
	industry                 *string
	lastEntryDate            *time.Time
	lastInvoiceNumber        *int32
	addlastInvoiceNumber     *int32
	logo                     *string
	name                     *string
	numberOfEmployees        *int32
	addnumberOfEmployees     *int32
	phone                    *string
	sector                   *string
	taxId                    *string
	vatRate                  *float64
	addvatRate               *float64
	website                  *string
	incompleteSetup          *bool
	clearedFields            map[string]struct{}
	availableRoles           map[int]struct{}
	removedavailableRoles    map[int]struct{}
	clearedavailableRoles    bool
	accountingEntries        map[int]struct{}
	removedaccountingEntries map[int]struct{}
	clearedaccountingEntries bool
	customers                map[int]struct{}
	removedcustomers         map[int]struct{}
	clearedcustomers         bool
	documents                map[int]struct{}
	removeddocuments         map[int]struct{}
	cleareddocuments         bool
	employees                map[int]struct{}
	removedemployees         map[int]struct{}
	clearedemployees         bool
	files                    map[int]struct{}
	removedfiles             map[int]struct{}
	clearedfiles             bool
	products                 map[int]struct{}
	removedproducts          map[int]struct{}
	clearedproducts          bool
	projects                 map[int]struct{}
	removedprojects          map[int]struct{}
	clearedprojects          bool
	payables                 map[int]struct{}
	removedpayables          map[int]struct{}
	clearedpayables          bool
	receivables              map[int]struct{}
	removedreceivables       map[int]struct{}
	clearedreceivables       bool
	suppliers                map[int]struct{}
	removedsuppliers         map[int]struct{}
	clearedsuppliers         bool
	tokens                   map[int]struct{}
	removedtokens            map[int]struct{}
	clearedtokens            bool
	treasuries               map[int]struct{}
	removedtreasuries        map[int]struct{}
	clearedtreasuries        bool
	workShifts               map[int]struct{}
	removedworkShifts        map[int]struct{}
	clearedworkShifts        bool
	users                    map[int]struct{}
	removedusers             map[int]struct{}
	clearedusers             bool
	daughterCompanies        map[int]struct{}
	removeddaughterCompanies map[int]struct{}
	cleareddaughterCompanies bool
	parentCompany            *int
	clearedparentCompany     bool
	done                     bool
	oldValue                 func(context.Context) (*Company, error)
	predicates               []predicate.Company
}

var _ ent.Mutation = (*CompanyMutation)(nil)

// companyOption allows management of the mutation configuration using functional options.
type companyOption func(*CompanyMutation)

// newCompanyMutation creates new mutation for the Company entity.
func newCompanyMutation(c config, op Op, opts ...companyOption) *CompanyMutation {
	m := &CompanyMutation{
		config:        c,
		op:            op,
		typ:           TypeCompany,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCompanyID sets the ID field of the mutation.
func withCompanyID(id int) companyOption {
	return func(m *CompanyMutation) {
		var (
			err   error
			once  sync.Once
			value *Company
		)
		m.oldValue = func(ctx context.Context) (*Company, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Company.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCompany sets the old Company of the mutation.
func withCompany(node *Company) companyOption {
	return func(m *CompanyMutation) {
		m.oldValue = func(context.Context) (*Company, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CompanyMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CompanyMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("generated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CompanyMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CompanyMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Company.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "createdAt" field.
func (m *CompanyMutation) SetCreatedAt(t time.Time) {
	m.createdAt = &t
}

// CreatedAt returns the value of the "createdAt" field in the mutation.
func (m *CompanyMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.createdAt
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "createdAt" field's value of the Company entity.
// If the Company object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CompanyMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "createdAt" field.
func (m *CompanyMutation) ResetCreatedAt() {
	m.createdAt = nil
}

// SetUpdatedAt sets the "updatedAt" field.
func (m *CompanyMutation) SetUpdatedAt(t time.Time) {
	m.updatedAt = &t
}

// UpdatedAt returns the value of the "updatedAt" field in the mutation.
func (m *CompanyMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updatedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updatedAt" field's value of the Company entity.
// If the Company object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CompanyMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updatedAt" field.
func (m *CompanyMutation) ResetUpdatedAt() {
	m.updatedAt = nil
}

// SetDeletedAt sets the "deletedAt" field.
func (m *CompanyMutation) SetDeletedAt(t time.Time) {
	m.deletedAt = &t
}

// DeletedAt returns the value of the "deletedAt" field in the mutation.
func (m *CompanyMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deletedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deletedAt" field's value of the Company entity.
// If the Company object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CompanyMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deletedAt" field.
func (m *CompanyMutation) ClearDeletedAt() {
	m.deletedAt = nil
	m.clearedFields[company.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deletedAt" field was cleared in this mutation.
func (m *CompanyMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[company.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deletedAt" field.
func (m *CompanyMutation) ResetDeletedAt() {
	m.deletedAt = nil
	delete(m.clearedFields, company.FieldDeletedAt)
}

// SetAddress sets the "address" field.
func (m *CompanyMutation) SetAddress(s string) {
	m.address = &s
}

// Address returns the value of the "address" field in the mutation.
func (m *CompanyMutation) Address() (r string, exists bool) {
	v := m.address
	if v == nil {
		return
	}
	return *v, true
}

// OldAddress returns the old "address" field's value of the Company entity.
// If the Company object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CompanyMutation) OldAddress(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAddress: %w", err)
	}
	return oldValue.Address, nil
}

// ClearAddress clears the value of the "address" field.
func (m *CompanyMutation) ClearAddress() {
	m.address = nil
	m.clearedFields[company.FieldAddress] = struct{}{}
}

// AddressCleared returns if the "address" field was cleared in this mutation.
func (m *CompanyMutation) AddressCleared() bool {
	_, ok := m.clearedFields[company.FieldAddress]
	return ok
}

// ResetAddress resets all changes to the "address" field.
func (m *CompanyMutation) ResetAddress() {
	m.address = nil
	delete(m.clearedFields, company.FieldAddress)
}

// SetBaseCurrency sets the "baseCurrency" field.
func (m *CompanyMutation) SetBaseCurrency(s string) {
	m.baseCurrency = &s
}

// BaseCurrency returns the value of the "baseCurrency" field in the mutation.
func (m *CompanyMutation) BaseCurrency() (r string, exists bool) {
	v := m.baseCurrency
	if v == nil {
		return
	}
	return *v, true
}

// OldBaseCurrency returns the old "baseCurrency" field's value of the Company entity.
// If the Company object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CompanyMutation) OldBaseCurrency(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBaseCurrency is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBaseCurrency requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBaseCurrency: %w", err)
	}
	return oldValue.BaseCurrency, nil
}

// ResetBaseCurrency resets all changes to the "baseCurrency" field.
func (m *CompanyMutation) ResetBaseCurrency() {
	m.baseCurrency = nil
}

// SetCeoName sets the "ceoName" field.
func (m *CompanyMutation) SetCeoName(s string) {
	m.ceoName = &s
}

// CeoName returns the value of the "ceoName" field in the mutation.
func (m *CompanyMutation) CeoName() (r string, exists bool) {
	v := m.ceoName
	if v == nil {
		return
	}
	return *v, true
}

// OldCeoName returns the old "ceoName" field's value of the Company entity.
// If the Company object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CompanyMutation) OldCeoName(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCeoName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCeoName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCeoName: %w", err)
	}
	return oldValue.CeoName, nil
}

// ClearCeoName clears the value of the "ceoName" field.
func (m *CompanyMutation) ClearCeoName() {
	m.ceoName = nil
	m.clearedFields[company.FieldCeoName] = struct{}{}
}

// CeoNameCleared returns if the "ceoName" field was cleared in this mutation.
func (m *CompanyMutation) CeoNameCleared() bool {
	_, ok := m.clearedFields[company.FieldCeoName]
	return ok
}

// ResetCeoName resets all changes to the "ceoName" field.
func (m *CompanyMutation) ResetCeoName() {
	m.ceoName = nil
	delete(m.clearedFields, company.FieldCeoName)
}

// SetCity sets the "city" field.
func (m *CompanyMutation) SetCity(s string) {
	m.city = &s
}

// City returns the value of the "city" field in the mutation.
func (m *CompanyMutation) City() (r string, exists bool) {
	v := m.city
	if v == nil {
		return
	}
	return *v, true
}

// OldCity returns the old "city" field's value of the Company entity.
// If the Company object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CompanyMutation) OldCity(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCity: %w", err)
	}
	return oldValue.City, nil
}

// ResetCity resets all changes to the "city" field.
func (m *CompanyMutation) ResetCity() {
	m.city = nil
}

// SetCountry sets the "country" field.
func (m *CompanyMutation) SetCountry(s string) {
	m.country = &s
}

// Country returns the value of the "country" field in the mutation.
func (m *CompanyMutation) Country() (r string, exists bool) {
	v := m.country
	if v == nil {
		return
	}
	return *v, true
}

// OldCountry returns the old "country" field's value of the Company entity.
// If the Company object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CompanyMutation) OldCountry(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCountry is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCountry requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCountry: %w", err)
	}
	return oldValue.Country, nil
}

// ResetCountry resets all changes to the "country" field.
func (m *CompanyMutation) ResetCountry() {
	m.country = nil
}

// SetEstablishedAt sets the "establishedAt" field.
func (m *CompanyMutation) SetEstablishedAt(t time.Time) {
	m.establishedAt = &t
}

// EstablishedAt returns the value of the "establishedAt" field in the mutation.
func (m *CompanyMutation) EstablishedAt() (r time.Time, exists bool) {
	v := m.establishedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldEstablishedAt returns the old "establishedAt" field's value of the Company entity.
// If the Company object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CompanyMutation) OldEstablishedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEstablishedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEstablishedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEstablishedAt: %w", err)
	}
	return oldValue.EstablishedAt, nil
}

// ResetEstablishedAt resets all changes to the "establishedAt" field.
func (m *CompanyMutation) ResetEstablishedAt() {
	m.establishedAt = nil
}

// SetDescription sets the "description" field.
func (m *CompanyMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *CompanyMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Company entity.
// If the Company object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CompanyMutation) OldDescription(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *CompanyMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[company.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *CompanyMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[company.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *CompanyMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, company.FieldDescription)
}

// SetEmail sets the "email" field.
func (m *CompanyMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *CompanyMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the Company entity.
// If the Company object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CompanyMutation) OldEmail(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ClearEmail clears the value of the "email" field.
func (m *CompanyMutation) ClearEmail() {
	m.email = nil
	m.clearedFields[company.FieldEmail] = struct{}{}
}

// EmailCleared returns if the "email" field was cleared in this mutation.
func (m *CompanyMutation) EmailCleared() bool {
	_, ok := m.clearedFields[company.FieldEmail]
	return ok
}

// ResetEmail resets all changes to the "email" field.
func (m *CompanyMutation) ResetEmail() {
	m.email = nil
	delete(m.clearedFields, company.FieldEmail)
}

// SetIndustry sets the "industry" field.
func (m *CompanyMutation) SetIndustry(s string) {
	m.industry = &s
}

// Industry returns the value of the "industry" field in the mutation.
func (m *CompanyMutation) Industry() (r string, exists bool) {
	v := m.industry
	if v == nil {
		return
	}
	return *v, true
}

// OldIndustry returns the old "industry" field's value of the Company entity.
// If the Company object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CompanyMutation) OldIndustry(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIndustry is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIndustry requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIndustry: %w", err)
	}
	return oldValue.Industry, nil
}

// ClearIndustry clears the value of the "industry" field.
func (m *CompanyMutation) ClearIndustry() {
	m.industry = nil
	m.clearedFields[company.FieldIndustry] = struct{}{}
}

// IndustryCleared returns if the "industry" field was cleared in this mutation.
func (m *CompanyMutation) IndustryCleared() bool {
	_, ok := m.clearedFields[company.FieldIndustry]
	return ok
}

// ResetIndustry resets all changes to the "industry" field.
func (m *CompanyMutation) ResetIndustry() {
	m.industry = nil
	delete(m.clearedFields, company.FieldIndustry)
}

// SetLastEntryDate sets the "lastEntryDate" field.
func (m *CompanyMutation) SetLastEntryDate(t time.Time) {
	m.lastEntryDate = &t
}

// LastEntryDate returns the value of the "lastEntryDate" field in the mutation.
func (m *CompanyMutation) LastEntryDate() (r time.Time, exists bool) {
	v := m.lastEntryDate
	if v == nil {
		return
	}
	return *v, true
}

// OldLastEntryDate returns the old "lastEntryDate" field's value of the Company entity.
// If the Company object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CompanyMutation) OldLastEntryDate(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastEntryDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastEntryDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastEntryDate: %w", err)
	}
	return oldValue.LastEntryDate, nil
}

// ResetLastEntryDate resets all changes to the "lastEntryDate" field.
func (m *CompanyMutation) ResetLastEntryDate() {
	m.lastEntryDate = nil
}

// SetLastInvoiceNumber sets the "lastInvoiceNumber" field.
func (m *CompanyMutation) SetLastInvoiceNumber(i int32) {
	m.lastInvoiceNumber = &i
	m.addlastInvoiceNumber = nil
}

// LastInvoiceNumber returns the value of the "lastInvoiceNumber" field in the mutation.
func (m *CompanyMutation) LastInvoiceNumber() (r int32, exists bool) {
	v := m.lastInvoiceNumber
	if v == nil {
		return
	}
	return *v, true
}

// OldLastInvoiceNumber returns the old "lastInvoiceNumber" field's value of the Company entity.
// If the Company object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CompanyMutation) OldLastInvoiceNumber(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastInvoiceNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastInvoiceNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastInvoiceNumber: %w", err)
	}
	return oldValue.LastInvoiceNumber, nil
}

// AddLastInvoiceNumber adds i to the "lastInvoiceNumber" field.
func (m *CompanyMutation) AddLastInvoiceNumber(i int32) {
	if m.addlastInvoiceNumber != nil {
		*m.addlastInvoiceNumber += i
	} else {
		m.addlastInvoiceNumber = &i
	}
}

// AddedLastInvoiceNumber returns the value that was added to the "lastInvoiceNumber" field in this mutation.
func (m *CompanyMutation) AddedLastInvoiceNumber() (r int32, exists bool) {
	v := m.addlastInvoiceNumber
	if v == nil {
		return
	}
	return *v, true
}

// ClearLastInvoiceNumber clears the value of the "lastInvoiceNumber" field.
func (m *CompanyMutation) ClearLastInvoiceNumber() {
	m.lastInvoiceNumber = nil
	m.addlastInvoiceNumber = nil
	m.clearedFields[company.FieldLastInvoiceNumber] = struct{}{}
}

// LastInvoiceNumberCleared returns if the "lastInvoiceNumber" field was cleared in this mutation.
func (m *CompanyMutation) LastInvoiceNumberCleared() bool {
	_, ok := m.clearedFields[company.FieldLastInvoiceNumber]
	return ok
}

// ResetLastInvoiceNumber resets all changes to the "lastInvoiceNumber" field.
func (m *CompanyMutation) ResetLastInvoiceNumber() {
	m.lastInvoiceNumber = nil
	m.addlastInvoiceNumber = nil
	delete(m.clearedFields, company.FieldLastInvoiceNumber)
}

// SetLogo sets the "logo" field.
func (m *CompanyMutation) SetLogo(s string) {
	m.logo = &s
}

// Logo returns the value of the "logo" field in the mutation.
func (m *CompanyMutation) Logo() (r string, exists bool) {
	v := m.logo
	if v == nil {
		return
	}
	return *v, true
}

// OldLogo returns the old "logo" field's value of the Company entity.
// If the Company object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CompanyMutation) OldLogo(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLogo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLogo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLogo: %w", err)
	}
	return oldValue.Logo, nil
}

// ClearLogo clears the value of the "logo" field.
func (m *CompanyMutation) ClearLogo() {
	m.logo = nil
	m.clearedFields[company.FieldLogo] = struct{}{}
}

// LogoCleared returns if the "logo" field was cleared in this mutation.
func (m *CompanyMutation) LogoCleared() bool {
	_, ok := m.clearedFields[company.FieldLogo]
	return ok
}

// ResetLogo resets all changes to the "logo" field.
func (m *CompanyMutation) ResetLogo() {
	m.logo = nil
	delete(m.clearedFields, company.FieldLogo)
}

// SetName sets the "name" field.
func (m *CompanyMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *CompanyMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Company entity.
// If the Company object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CompanyMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *CompanyMutation) ResetName() {
	m.name = nil
}

// SetNumberOfEmployees sets the "numberOfEmployees" field.
func (m *CompanyMutation) SetNumberOfEmployees(i int32) {
	m.numberOfEmployees = &i
	m.addnumberOfEmployees = nil
}

// NumberOfEmployees returns the value of the "numberOfEmployees" field in the mutation.
func (m *CompanyMutation) NumberOfEmployees() (r int32, exists bool) {
	v := m.numberOfEmployees
	if v == nil {
		return
	}
	return *v, true
}

// OldNumberOfEmployees returns the old "numberOfEmployees" field's value of the Company entity.
// If the Company object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CompanyMutation) OldNumberOfEmployees(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNumberOfEmployees is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNumberOfEmployees requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNumberOfEmployees: %w", err)
	}
	return oldValue.NumberOfEmployees, nil
}

// AddNumberOfEmployees adds i to the "numberOfEmployees" field.
func (m *CompanyMutation) AddNumberOfEmployees(i int32) {
	if m.addnumberOfEmployees != nil {
		*m.addnumberOfEmployees += i
	} else {
		m.addnumberOfEmployees = &i
	}
}

// AddedNumberOfEmployees returns the value that was added to the "numberOfEmployees" field in this mutation.
func (m *CompanyMutation) AddedNumberOfEmployees() (r int32, exists bool) {
	v := m.addnumberOfEmployees
	if v == nil {
		return
	}
	return *v, true
}

// ResetNumberOfEmployees resets all changes to the "numberOfEmployees" field.
func (m *CompanyMutation) ResetNumberOfEmployees() {
	m.numberOfEmployees = nil
	m.addnumberOfEmployees = nil
}

// SetPhone sets the "phone" field.
func (m *CompanyMutation) SetPhone(s string) {
	m.phone = &s
}

// Phone returns the value of the "phone" field in the mutation.
func (m *CompanyMutation) Phone() (r string, exists bool) {
	v := m.phone
	if v == nil {
		return
	}
	return *v, true
}

// OldPhone returns the old "phone" field's value of the Company entity.
// If the Company object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CompanyMutation) OldPhone(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPhone is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPhone requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPhone: %w", err)
	}
	return oldValue.Phone, nil
}

// ClearPhone clears the value of the "phone" field.
func (m *CompanyMutation) ClearPhone() {
	m.phone = nil
	m.clearedFields[company.FieldPhone] = struct{}{}
}

// PhoneCleared returns if the "phone" field was cleared in this mutation.
func (m *CompanyMutation) PhoneCleared() bool {
	_, ok := m.clearedFields[company.FieldPhone]
	return ok
}

// ResetPhone resets all changes to the "phone" field.
func (m *CompanyMutation) ResetPhone() {
	m.phone = nil
	delete(m.clearedFields, company.FieldPhone)
}

// SetSector sets the "sector" field.
func (m *CompanyMutation) SetSector(s string) {
	m.sector = &s
}

// Sector returns the value of the "sector" field in the mutation.
func (m *CompanyMutation) Sector() (r string, exists bool) {
	v := m.sector
	if v == nil {
		return
	}
	return *v, true
}

// OldSector returns the old "sector" field's value of the Company entity.
// If the Company object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CompanyMutation) OldSector(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSector is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSector requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSector: %w", err)
	}
	return oldValue.Sector, nil
}

// ClearSector clears the value of the "sector" field.
func (m *CompanyMutation) ClearSector() {
	m.sector = nil
	m.clearedFields[company.FieldSector] = struct{}{}
}

// SectorCleared returns if the "sector" field was cleared in this mutation.
func (m *CompanyMutation) SectorCleared() bool {
	_, ok := m.clearedFields[company.FieldSector]
	return ok
}

// ResetSector resets all changes to the "sector" field.
func (m *CompanyMutation) ResetSector() {
	m.sector = nil
	delete(m.clearedFields, company.FieldSector)
}

// SetTaxId sets the "taxId" field.
func (m *CompanyMutation) SetTaxId(s string) {
	m.taxId = &s
}

// TaxId returns the value of the "taxId" field in the mutation.
func (m *CompanyMutation) TaxId() (r string, exists bool) {
	v := m.taxId
	if v == nil {
		return
	}
	return *v, true
}

// OldTaxId returns the old "taxId" field's value of the Company entity.
// If the Company object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CompanyMutation) OldTaxId(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTaxId is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTaxId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTaxId: %w", err)
	}
	return oldValue.TaxId, nil
}

// ResetTaxId resets all changes to the "taxId" field.
func (m *CompanyMutation) ResetTaxId() {
	m.taxId = nil
}

// SetVatRate sets the "vatRate" field.
func (m *CompanyMutation) SetVatRate(f float64) {
	m.vatRate = &f
	m.addvatRate = nil
}

// VatRate returns the value of the "vatRate" field in the mutation.
func (m *CompanyMutation) VatRate() (r float64, exists bool) {
	v := m.vatRate
	if v == nil {
		return
	}
	return *v, true
}

// OldVatRate returns the old "vatRate" field's value of the Company entity.
// If the Company object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CompanyMutation) OldVatRate(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVatRate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVatRate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVatRate: %w", err)
	}
	return oldValue.VatRate, nil
}

// AddVatRate adds f to the "vatRate" field.
func (m *CompanyMutation) AddVatRate(f float64) {
	if m.addvatRate != nil {
		*m.addvatRate += f
	} else {
		m.addvatRate = &f
	}
}

// AddedVatRate returns the value that was added to the "vatRate" field in this mutation.
func (m *CompanyMutation) AddedVatRate() (r float64, exists bool) {
	v := m.addvatRate
	if v == nil {
		return
	}
	return *v, true
}

// ResetVatRate resets all changes to the "vatRate" field.
func (m *CompanyMutation) ResetVatRate() {
	m.vatRate = nil
	m.addvatRate = nil
}

// SetWebsite sets the "website" field.
func (m *CompanyMutation) SetWebsite(s string) {
	m.website = &s
}

// Website returns the value of the "website" field in the mutation.
func (m *CompanyMutation) Website() (r string, exists bool) {
	v := m.website
	if v == nil {
		return
	}
	return *v, true
}

// OldWebsite returns the old "website" field's value of the Company entity.
// If the Company object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CompanyMutation) OldWebsite(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWebsite is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWebsite requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWebsite: %w", err)
	}
	return oldValue.Website, nil
}

// ClearWebsite clears the value of the "website" field.
func (m *CompanyMutation) ClearWebsite() {
	m.website = nil
	m.clearedFields[company.FieldWebsite] = struct{}{}
}

// WebsiteCleared returns if the "website" field was cleared in this mutation.
func (m *CompanyMutation) WebsiteCleared() bool {
	_, ok := m.clearedFields[company.FieldWebsite]
	return ok
}

// ResetWebsite resets all changes to the "website" field.
func (m *CompanyMutation) ResetWebsite() {
	m.website = nil
	delete(m.clearedFields, company.FieldWebsite)
}

// SetIncompleteSetup sets the "incompleteSetup" field.
func (m *CompanyMutation) SetIncompleteSetup(b bool) {
	m.incompleteSetup = &b
}

// IncompleteSetup returns the value of the "incompleteSetup" field in the mutation.
func (m *CompanyMutation) IncompleteSetup() (r bool, exists bool) {
	v := m.incompleteSetup
	if v == nil {
		return
	}
	return *v, true
}

// OldIncompleteSetup returns the old "incompleteSetup" field's value of the Company entity.
// If the Company object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CompanyMutation) OldIncompleteSetup(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIncompleteSetup is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIncompleteSetup requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIncompleteSetup: %w", err)
	}
	return oldValue.IncompleteSetup, nil
}

// ClearIncompleteSetup clears the value of the "incompleteSetup" field.
func (m *CompanyMutation) ClearIncompleteSetup() {
	m.incompleteSetup = nil
	m.clearedFields[company.FieldIncompleteSetup] = struct{}{}
}

// IncompleteSetupCleared returns if the "incompleteSetup" field was cleared in this mutation.
func (m *CompanyMutation) IncompleteSetupCleared() bool {
	_, ok := m.clearedFields[company.FieldIncompleteSetup]
	return ok
}

// ResetIncompleteSetup resets all changes to the "incompleteSetup" field.
func (m *CompanyMutation) ResetIncompleteSetup() {
	m.incompleteSetup = nil
	delete(m.clearedFields, company.FieldIncompleteSetup)
}

// AddAvailableRoleIDs adds the "availableRoles" edge to the UserRole entity by ids.
func (m *CompanyMutation) AddAvailableRoleIDs(ids ...int) {
	if m.availableRoles == nil {
		m.availableRoles = make(map[int]struct{})
	}
	for i := range ids {
		m.availableRoles[ids[i]] = struct{}{}
	}
}

// ClearAvailableRoles clears the "availableRoles" edge to the UserRole entity.
func (m *CompanyMutation) ClearAvailableRoles() {
	m.clearedavailableRoles = true
}

// AvailableRolesCleared reports if the "availableRoles" edge to the UserRole entity was cleared.
func (m *CompanyMutation) AvailableRolesCleared() bool {
	return m.clearedavailableRoles
}

// RemoveAvailableRoleIDs removes the "availableRoles" edge to the UserRole entity by IDs.
func (m *CompanyMutation) RemoveAvailableRoleIDs(ids ...int) {
	if m.removedavailableRoles == nil {
		m.removedavailableRoles = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.availableRoles, ids[i])
		m.removedavailableRoles[ids[i]] = struct{}{}
	}
}

// RemovedAvailableRoles returns the removed IDs of the "availableRoles" edge to the UserRole entity.
func (m *CompanyMutation) RemovedAvailableRolesIDs() (ids []int) {
	for id := range m.removedavailableRoles {
		ids = append(ids, id)
	}
	return
}

// AvailableRolesIDs returns the "availableRoles" edge IDs in the mutation.
func (m *CompanyMutation) AvailableRolesIDs() (ids []int) {
	for id := range m.availableRoles {
		ids = append(ids, id)
	}
	return
}

// ResetAvailableRoles resets all changes to the "availableRoles" edge.
func (m *CompanyMutation) ResetAvailableRoles() {
	m.availableRoles = nil
	m.clearedavailableRoles = false
	m.removedavailableRoles = nil
}

// AddAccountingEntryIDs adds the "accountingEntries" edge to the AccountingEntry entity by ids.
func (m *CompanyMutation) AddAccountingEntryIDs(ids ...int) {
	if m.accountingEntries == nil {
		m.accountingEntries = make(map[int]struct{})
	}
	for i := range ids {
		m.accountingEntries[ids[i]] = struct{}{}
	}
}

// ClearAccountingEntries clears the "accountingEntries" edge to the AccountingEntry entity.
func (m *CompanyMutation) ClearAccountingEntries() {
	m.clearedaccountingEntries = true
}

// AccountingEntriesCleared reports if the "accountingEntries" edge to the AccountingEntry entity was cleared.
func (m *CompanyMutation) AccountingEntriesCleared() bool {
	return m.clearedaccountingEntries
}

// RemoveAccountingEntryIDs removes the "accountingEntries" edge to the AccountingEntry entity by IDs.
func (m *CompanyMutation) RemoveAccountingEntryIDs(ids ...int) {
	if m.removedaccountingEntries == nil {
		m.removedaccountingEntries = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.accountingEntries, ids[i])
		m.removedaccountingEntries[ids[i]] = struct{}{}
	}
}

// RemovedAccountingEntries returns the removed IDs of the "accountingEntries" edge to the AccountingEntry entity.
func (m *CompanyMutation) RemovedAccountingEntriesIDs() (ids []int) {
	for id := range m.removedaccountingEntries {
		ids = append(ids, id)
	}
	return
}

// AccountingEntriesIDs returns the "accountingEntries" edge IDs in the mutation.
func (m *CompanyMutation) AccountingEntriesIDs() (ids []int) {
	for id := range m.accountingEntries {
		ids = append(ids, id)
	}
	return
}

// ResetAccountingEntries resets all changes to the "accountingEntries" edge.
func (m *CompanyMutation) ResetAccountingEntries() {
	m.accountingEntries = nil
	m.clearedaccountingEntries = false
	m.removedaccountingEntries = nil
}

// AddCustomerIDs adds the "customers" edge to the Customer entity by ids.
func (m *CompanyMutation) AddCustomerIDs(ids ...int) {
	if m.customers == nil {
		m.customers = make(map[int]struct{})
	}
	for i := range ids {
		m.customers[ids[i]] = struct{}{}
	}
}

// ClearCustomers clears the "customers" edge to the Customer entity.
func (m *CompanyMutation) ClearCustomers() {
	m.clearedcustomers = true
}

// CustomersCleared reports if the "customers" edge to the Customer entity was cleared.
func (m *CompanyMutation) CustomersCleared() bool {
	return m.clearedcustomers
}

// RemoveCustomerIDs removes the "customers" edge to the Customer entity by IDs.
func (m *CompanyMutation) RemoveCustomerIDs(ids ...int) {
	if m.removedcustomers == nil {
		m.removedcustomers = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.customers, ids[i])
		m.removedcustomers[ids[i]] = struct{}{}
	}
}

// RemovedCustomers returns the removed IDs of the "customers" edge to the Customer entity.
func (m *CompanyMutation) RemovedCustomersIDs() (ids []int) {
	for id := range m.removedcustomers {
		ids = append(ids, id)
	}
	return
}

// CustomersIDs returns the "customers" edge IDs in the mutation.
func (m *CompanyMutation) CustomersIDs() (ids []int) {
	for id := range m.customers {
		ids = append(ids, id)
	}
	return
}

// ResetCustomers resets all changes to the "customers" edge.
func (m *CompanyMutation) ResetCustomers() {
	m.customers = nil
	m.clearedcustomers = false
	m.removedcustomers = nil
}

// AddDocumentIDs adds the "documents" edge to the CompanyDocument entity by ids.
func (m *CompanyMutation) AddDocumentIDs(ids ...int) {
	if m.documents == nil {
		m.documents = make(map[int]struct{})
	}
	for i := range ids {
		m.documents[ids[i]] = struct{}{}
	}
}

// ClearDocuments clears the "documents" edge to the CompanyDocument entity.
func (m *CompanyMutation) ClearDocuments() {
	m.cleareddocuments = true
}

// DocumentsCleared reports if the "documents" edge to the CompanyDocument entity was cleared.
func (m *CompanyMutation) DocumentsCleared() bool {
	return m.cleareddocuments
}

// RemoveDocumentIDs removes the "documents" edge to the CompanyDocument entity by IDs.
func (m *CompanyMutation) RemoveDocumentIDs(ids ...int) {
	if m.removeddocuments == nil {
		m.removeddocuments = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.documents, ids[i])
		m.removeddocuments[ids[i]] = struct{}{}
	}
}

// RemovedDocuments returns the removed IDs of the "documents" edge to the CompanyDocument entity.
func (m *CompanyMutation) RemovedDocumentsIDs() (ids []int) {
	for id := range m.removeddocuments {
		ids = append(ids, id)
	}
	return
}

// DocumentsIDs returns the "documents" edge IDs in the mutation.
func (m *CompanyMutation) DocumentsIDs() (ids []int) {
	for id := range m.documents {
		ids = append(ids, id)
	}
	return
}

// ResetDocuments resets all changes to the "documents" edge.
func (m *CompanyMutation) ResetDocuments() {
	m.documents = nil
	m.cleareddocuments = false
	m.removeddocuments = nil
}

// AddEmployeeIDs adds the "employees" edge to the Employee entity by ids.
func (m *CompanyMutation) AddEmployeeIDs(ids ...int) {
	if m.employees == nil {
		m.employees = make(map[int]struct{})
	}
	for i := range ids {
		m.employees[ids[i]] = struct{}{}
	}
}

// ClearEmployees clears the "employees" edge to the Employee entity.
func (m *CompanyMutation) ClearEmployees() {
	m.clearedemployees = true
}

// EmployeesCleared reports if the "employees" edge to the Employee entity was cleared.
func (m *CompanyMutation) EmployeesCleared() bool {
	return m.clearedemployees
}

// RemoveEmployeeIDs removes the "employees" edge to the Employee entity by IDs.
func (m *CompanyMutation) RemoveEmployeeIDs(ids ...int) {
	if m.removedemployees == nil {
		m.removedemployees = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.employees, ids[i])
		m.removedemployees[ids[i]] = struct{}{}
	}
}

// RemovedEmployees returns the removed IDs of the "employees" edge to the Employee entity.
func (m *CompanyMutation) RemovedEmployeesIDs() (ids []int) {
	for id := range m.removedemployees {
		ids = append(ids, id)
	}
	return
}

// EmployeesIDs returns the "employees" edge IDs in the mutation.
func (m *CompanyMutation) EmployeesIDs() (ids []int) {
	for id := range m.employees {
		ids = append(ids, id)
	}
	return
}

// ResetEmployees resets all changes to the "employees" edge.
func (m *CompanyMutation) ResetEmployees() {
	m.employees = nil
	m.clearedemployees = false
	m.removedemployees = nil
}

// AddFileIDs adds the "files" edge to the File entity by ids.
func (m *CompanyMutation) AddFileIDs(ids ...int) {
	if m.files == nil {
		m.files = make(map[int]struct{})
	}
	for i := range ids {
		m.files[ids[i]] = struct{}{}
	}
}

// ClearFiles clears the "files" edge to the File entity.
func (m *CompanyMutation) ClearFiles() {
	m.clearedfiles = true
}

// FilesCleared reports if the "files" edge to the File entity was cleared.
func (m *CompanyMutation) FilesCleared() bool {
	return m.clearedfiles
}

// RemoveFileIDs removes the "files" edge to the File entity by IDs.
func (m *CompanyMutation) RemoveFileIDs(ids ...int) {
	if m.removedfiles == nil {
		m.removedfiles = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.files, ids[i])
		m.removedfiles[ids[i]] = struct{}{}
	}
}

// RemovedFiles returns the removed IDs of the "files" edge to the File entity.
func (m *CompanyMutation) RemovedFilesIDs() (ids []int) {
	for id := range m.removedfiles {
		ids = append(ids, id)
	}
	return
}

// FilesIDs returns the "files" edge IDs in the mutation.
func (m *CompanyMutation) FilesIDs() (ids []int) {
	for id := range m.files {
		ids = append(ids, id)
	}
	return
}

// ResetFiles resets all changes to the "files" edge.
func (m *CompanyMutation) ResetFiles() {
	m.files = nil
	m.clearedfiles = false
	m.removedfiles = nil
}

// AddProductIDs adds the "products" edge to the Product entity by ids.
func (m *CompanyMutation) AddProductIDs(ids ...int) {
	if m.products == nil {
		m.products = make(map[int]struct{})
	}
	for i := range ids {
		m.products[ids[i]] = struct{}{}
	}
}

// ClearProducts clears the "products" edge to the Product entity.
func (m *CompanyMutation) ClearProducts() {
	m.clearedproducts = true
}

// ProductsCleared reports if the "products" edge to the Product entity was cleared.
func (m *CompanyMutation) ProductsCleared() bool {
	return m.clearedproducts
}

// RemoveProductIDs removes the "products" edge to the Product entity by IDs.
func (m *CompanyMutation) RemoveProductIDs(ids ...int) {
	if m.removedproducts == nil {
		m.removedproducts = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.products, ids[i])
		m.removedproducts[ids[i]] = struct{}{}
	}
}

// RemovedProducts returns the removed IDs of the "products" edge to the Product entity.
func (m *CompanyMutation) RemovedProductsIDs() (ids []int) {
	for id := range m.removedproducts {
		ids = append(ids, id)
	}
	return
}

// ProductsIDs returns the "products" edge IDs in the mutation.
func (m *CompanyMutation) ProductsIDs() (ids []int) {
	for id := range m.products {
		ids = append(ids, id)
	}
	return
}

// ResetProducts resets all changes to the "products" edge.
func (m *CompanyMutation) ResetProducts() {
	m.products = nil
	m.clearedproducts = false
	m.removedproducts = nil
}

// AddProjectIDs adds the "projects" edge to the Project entity by ids.
func (m *CompanyMutation) AddProjectIDs(ids ...int) {
	if m.projects == nil {
		m.projects = make(map[int]struct{})
	}
	for i := range ids {
		m.projects[ids[i]] = struct{}{}
	}
}

// ClearProjects clears the "projects" edge to the Project entity.
func (m *CompanyMutation) ClearProjects() {
	m.clearedprojects = true
}

// ProjectsCleared reports if the "projects" edge to the Project entity was cleared.
func (m *CompanyMutation) ProjectsCleared() bool {
	return m.clearedprojects
}

// RemoveProjectIDs removes the "projects" edge to the Project entity by IDs.
func (m *CompanyMutation) RemoveProjectIDs(ids ...int) {
	if m.removedprojects == nil {
		m.removedprojects = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.projects, ids[i])
		m.removedprojects[ids[i]] = struct{}{}
	}
}

// RemovedProjects returns the removed IDs of the "projects" edge to the Project entity.
func (m *CompanyMutation) RemovedProjectsIDs() (ids []int) {
	for id := range m.removedprojects {
		ids = append(ids, id)
	}
	return
}

// ProjectsIDs returns the "projects" edge IDs in the mutation.
func (m *CompanyMutation) ProjectsIDs() (ids []int) {
	for id := range m.projects {
		ids = append(ids, id)
	}
	return
}

// ResetProjects resets all changes to the "projects" edge.
func (m *CompanyMutation) ResetProjects() {
	m.projects = nil
	m.clearedprojects = false
	m.removedprojects = nil
}

// AddPayableIDs adds the "payables" edge to the Payable entity by ids.
func (m *CompanyMutation) AddPayableIDs(ids ...int) {
	if m.payables == nil {
		m.payables = make(map[int]struct{})
	}
	for i := range ids {
		m.payables[ids[i]] = struct{}{}
	}
}

// ClearPayables clears the "payables" edge to the Payable entity.
func (m *CompanyMutation) ClearPayables() {
	m.clearedpayables = true
}

// PayablesCleared reports if the "payables" edge to the Payable entity was cleared.
func (m *CompanyMutation) PayablesCleared() bool {
	return m.clearedpayables
}

// RemovePayableIDs removes the "payables" edge to the Payable entity by IDs.
func (m *CompanyMutation) RemovePayableIDs(ids ...int) {
	if m.removedpayables == nil {
		m.removedpayables = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.payables, ids[i])
		m.removedpayables[ids[i]] = struct{}{}
	}
}

// RemovedPayables returns the removed IDs of the "payables" edge to the Payable entity.
func (m *CompanyMutation) RemovedPayablesIDs() (ids []int) {
	for id := range m.removedpayables {
		ids = append(ids, id)
	}
	return
}

// PayablesIDs returns the "payables" edge IDs in the mutation.
func (m *CompanyMutation) PayablesIDs() (ids []int) {
	for id := range m.payables {
		ids = append(ids, id)
	}
	return
}

// ResetPayables resets all changes to the "payables" edge.
func (m *CompanyMutation) ResetPayables() {
	m.payables = nil
	m.clearedpayables = false
	m.removedpayables = nil
}

// AddReceivableIDs adds the "receivables" edge to the Receivable entity by ids.
func (m *CompanyMutation) AddReceivableIDs(ids ...int) {
	if m.receivables == nil {
		m.receivables = make(map[int]struct{})
	}
	for i := range ids {
		m.receivables[ids[i]] = struct{}{}
	}
}

// ClearReceivables clears the "receivables" edge to the Receivable entity.
func (m *CompanyMutation) ClearReceivables() {
	m.clearedreceivables = true
}

// ReceivablesCleared reports if the "receivables" edge to the Receivable entity was cleared.
func (m *CompanyMutation) ReceivablesCleared() bool {
	return m.clearedreceivables
}

// RemoveReceivableIDs removes the "receivables" edge to the Receivable entity by IDs.
func (m *CompanyMutation) RemoveReceivableIDs(ids ...int) {
	if m.removedreceivables == nil {
		m.removedreceivables = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.receivables, ids[i])
		m.removedreceivables[ids[i]] = struct{}{}
	}
}

// RemovedReceivables returns the removed IDs of the "receivables" edge to the Receivable entity.
func (m *CompanyMutation) RemovedReceivablesIDs() (ids []int) {
	for id := range m.removedreceivables {
		ids = append(ids, id)
	}
	return
}

// ReceivablesIDs returns the "receivables" edge IDs in the mutation.
func (m *CompanyMutation) ReceivablesIDs() (ids []int) {
	for id := range m.receivables {
		ids = append(ids, id)
	}
	return
}

// ResetReceivables resets all changes to the "receivables" edge.
func (m *CompanyMutation) ResetReceivables() {
	m.receivables = nil
	m.clearedreceivables = false
	m.removedreceivables = nil
}

// AddSupplierIDs adds the "suppliers" edge to the Supplier entity by ids.
func (m *CompanyMutation) AddSupplierIDs(ids ...int) {
	if m.suppliers == nil {
		m.suppliers = make(map[int]struct{})
	}
	for i := range ids {
		m.suppliers[ids[i]] = struct{}{}
	}
}

// ClearSuppliers clears the "suppliers" edge to the Supplier entity.
func (m *CompanyMutation) ClearSuppliers() {
	m.clearedsuppliers = true
}

// SuppliersCleared reports if the "suppliers" edge to the Supplier entity was cleared.
func (m *CompanyMutation) SuppliersCleared() bool {
	return m.clearedsuppliers
}

// RemoveSupplierIDs removes the "suppliers" edge to the Supplier entity by IDs.
func (m *CompanyMutation) RemoveSupplierIDs(ids ...int) {
	if m.removedsuppliers == nil {
		m.removedsuppliers = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.suppliers, ids[i])
		m.removedsuppliers[ids[i]] = struct{}{}
	}
}

// RemovedSuppliers returns the removed IDs of the "suppliers" edge to the Supplier entity.
func (m *CompanyMutation) RemovedSuppliersIDs() (ids []int) {
	for id := range m.removedsuppliers {
		ids = append(ids, id)
	}
	return
}

// SuppliersIDs returns the "suppliers" edge IDs in the mutation.
func (m *CompanyMutation) SuppliersIDs() (ids []int) {
	for id := range m.suppliers {
		ids = append(ids, id)
	}
	return
}

// ResetSuppliers resets all changes to the "suppliers" edge.
func (m *CompanyMutation) ResetSuppliers() {
	m.suppliers = nil
	m.clearedsuppliers = false
	m.removedsuppliers = nil
}

// AddTokenIDs adds the "tokens" edge to the Token entity by ids.
func (m *CompanyMutation) AddTokenIDs(ids ...int) {
	if m.tokens == nil {
		m.tokens = make(map[int]struct{})
	}
	for i := range ids {
		m.tokens[ids[i]] = struct{}{}
	}
}

// ClearTokens clears the "tokens" edge to the Token entity.
func (m *CompanyMutation) ClearTokens() {
	m.clearedtokens = true
}

// TokensCleared reports if the "tokens" edge to the Token entity was cleared.
func (m *CompanyMutation) TokensCleared() bool {
	return m.clearedtokens
}

// RemoveTokenIDs removes the "tokens" edge to the Token entity by IDs.
func (m *CompanyMutation) RemoveTokenIDs(ids ...int) {
	if m.removedtokens == nil {
		m.removedtokens = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.tokens, ids[i])
		m.removedtokens[ids[i]] = struct{}{}
	}
}

// RemovedTokens returns the removed IDs of the "tokens" edge to the Token entity.
func (m *CompanyMutation) RemovedTokensIDs() (ids []int) {
	for id := range m.removedtokens {
		ids = append(ids, id)
	}
	return
}

// TokensIDs returns the "tokens" edge IDs in the mutation.
func (m *CompanyMutation) TokensIDs() (ids []int) {
	for id := range m.tokens {
		ids = append(ids, id)
	}
	return
}

// ResetTokens resets all changes to the "tokens" edge.
func (m *CompanyMutation) ResetTokens() {
	m.tokens = nil
	m.clearedtokens = false
	m.removedtokens = nil
}

// AddTreasuryIDs adds the "treasuries" edge to the Treasury entity by ids.
func (m *CompanyMutation) AddTreasuryIDs(ids ...int) {
	if m.treasuries == nil {
		m.treasuries = make(map[int]struct{})
	}
	for i := range ids {
		m.treasuries[ids[i]] = struct{}{}
	}
}

// ClearTreasuries clears the "treasuries" edge to the Treasury entity.
func (m *CompanyMutation) ClearTreasuries() {
	m.clearedtreasuries = true
}

// TreasuriesCleared reports if the "treasuries" edge to the Treasury entity was cleared.
func (m *CompanyMutation) TreasuriesCleared() bool {
	return m.clearedtreasuries
}

// RemoveTreasuryIDs removes the "treasuries" edge to the Treasury entity by IDs.
func (m *CompanyMutation) RemoveTreasuryIDs(ids ...int) {
	if m.removedtreasuries == nil {
		m.removedtreasuries = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.treasuries, ids[i])
		m.removedtreasuries[ids[i]] = struct{}{}
	}
}

// RemovedTreasuries returns the removed IDs of the "treasuries" edge to the Treasury entity.
func (m *CompanyMutation) RemovedTreasuriesIDs() (ids []int) {
	for id := range m.removedtreasuries {
		ids = append(ids, id)
	}
	return
}

// TreasuriesIDs returns the "treasuries" edge IDs in the mutation.
func (m *CompanyMutation) TreasuriesIDs() (ids []int) {
	for id := range m.treasuries {
		ids = append(ids, id)
	}
	return
}

// ResetTreasuries resets all changes to the "treasuries" edge.
func (m *CompanyMutation) ResetTreasuries() {
	m.treasuries = nil
	m.clearedtreasuries = false
	m.removedtreasuries = nil
}

// AddWorkShiftIDs adds the "workShifts" edge to the Workshift entity by ids.
func (m *CompanyMutation) AddWorkShiftIDs(ids ...int) {
	if m.workShifts == nil {
		m.workShifts = make(map[int]struct{})
	}
	for i := range ids {
		m.workShifts[ids[i]] = struct{}{}
	}
}

// ClearWorkShifts clears the "workShifts" edge to the Workshift entity.
func (m *CompanyMutation) ClearWorkShifts() {
	m.clearedworkShifts = true
}

// WorkShiftsCleared reports if the "workShifts" edge to the Workshift entity was cleared.
func (m *CompanyMutation) WorkShiftsCleared() bool {
	return m.clearedworkShifts
}

// RemoveWorkShiftIDs removes the "workShifts" edge to the Workshift entity by IDs.
func (m *CompanyMutation) RemoveWorkShiftIDs(ids ...int) {
	if m.removedworkShifts == nil {
		m.removedworkShifts = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.workShifts, ids[i])
		m.removedworkShifts[ids[i]] = struct{}{}
	}
}

// RemovedWorkShifts returns the removed IDs of the "workShifts" edge to the Workshift entity.
func (m *CompanyMutation) RemovedWorkShiftsIDs() (ids []int) {
	for id := range m.removedworkShifts {
		ids = append(ids, id)
	}
	return
}

// WorkShiftsIDs returns the "workShifts" edge IDs in the mutation.
func (m *CompanyMutation) WorkShiftsIDs() (ids []int) {
	for id := range m.workShifts {
		ids = append(ids, id)
	}
	return
}

// ResetWorkShifts resets all changes to the "workShifts" edge.
func (m *CompanyMutation) ResetWorkShifts() {
	m.workShifts = nil
	m.clearedworkShifts = false
	m.removedworkShifts = nil
}

// AddUserIDs adds the "users" edge to the User entity by ids.
func (m *CompanyMutation) AddUserIDs(ids ...int) {
	if m.users == nil {
		m.users = make(map[int]struct{})
	}
	for i := range ids {
		m.users[ids[i]] = struct{}{}
	}
}

// ClearUsers clears the "users" edge to the User entity.
func (m *CompanyMutation) ClearUsers() {
	m.clearedusers = true
}

// UsersCleared reports if the "users" edge to the User entity was cleared.
func (m *CompanyMutation) UsersCleared() bool {
	return m.clearedusers
}

// RemoveUserIDs removes the "users" edge to the User entity by IDs.
func (m *CompanyMutation) RemoveUserIDs(ids ...int) {
	if m.removedusers == nil {
		m.removedusers = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.users, ids[i])
		m.removedusers[ids[i]] = struct{}{}
	}
}

// RemovedUsers returns the removed IDs of the "users" edge to the User entity.
func (m *CompanyMutation) RemovedUsersIDs() (ids []int) {
	for id := range m.removedusers {
		ids = append(ids, id)
	}
	return
}

// UsersIDs returns the "users" edge IDs in the mutation.
func (m *CompanyMutation) UsersIDs() (ids []int) {
	for id := range m.users {
		ids = append(ids, id)
	}
	return
}

// ResetUsers resets all changes to the "users" edge.
func (m *CompanyMutation) ResetUsers() {
	m.users = nil
	m.clearedusers = false
	m.removedusers = nil
}

// AddDaughterCompanyIDs adds the "daughterCompanies" edge to the Company entity by ids.
func (m *CompanyMutation) AddDaughterCompanyIDs(ids ...int) {
	if m.daughterCompanies == nil {
		m.daughterCompanies = make(map[int]struct{})
	}
	for i := range ids {
		m.daughterCompanies[ids[i]] = struct{}{}
	}
}

// ClearDaughterCompanies clears the "daughterCompanies" edge to the Company entity.
func (m *CompanyMutation) ClearDaughterCompanies() {
	m.cleareddaughterCompanies = true
}

// DaughterCompaniesCleared reports if the "daughterCompanies" edge to the Company entity was cleared.
func (m *CompanyMutation) DaughterCompaniesCleared() bool {
	return m.cleareddaughterCompanies
}

// RemoveDaughterCompanyIDs removes the "daughterCompanies" edge to the Company entity by IDs.
func (m *CompanyMutation) RemoveDaughterCompanyIDs(ids ...int) {
	if m.removeddaughterCompanies == nil {
		m.removeddaughterCompanies = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.daughterCompanies, ids[i])
		m.removeddaughterCompanies[ids[i]] = struct{}{}
	}
}

// RemovedDaughterCompanies returns the removed IDs of the "daughterCompanies" edge to the Company entity.
func (m *CompanyMutation) RemovedDaughterCompaniesIDs() (ids []int) {
	for id := range m.removeddaughterCompanies {
		ids = append(ids, id)
	}
	return
}

// DaughterCompaniesIDs returns the "daughterCompanies" edge IDs in the mutation.
func (m *CompanyMutation) DaughterCompaniesIDs() (ids []int) {
	for id := range m.daughterCompanies {
		ids = append(ids, id)
	}
	return
}

// ResetDaughterCompanies resets all changes to the "daughterCompanies" edge.
func (m *CompanyMutation) ResetDaughterCompanies() {
	m.daughterCompanies = nil
	m.cleareddaughterCompanies = false
	m.removeddaughterCompanies = nil
}

// SetParentCompanyID sets the "parentCompany" edge to the Company entity by id.
func (m *CompanyMutation) SetParentCompanyID(id int) {
	m.parentCompany = &id
}

// ClearParentCompany clears the "parentCompany" edge to the Company entity.
func (m *CompanyMutation) ClearParentCompany() {
	m.clearedparentCompany = true
}

// ParentCompanyCleared reports if the "parentCompany" edge to the Company entity was cleared.
func (m *CompanyMutation) ParentCompanyCleared() bool {
	return m.clearedparentCompany
}

// ParentCompanyID returns the "parentCompany" edge ID in the mutation.
func (m *CompanyMutation) ParentCompanyID() (id int, exists bool) {
	if m.parentCompany != nil {
		return *m.parentCompany, true
	}
	return
}

// ParentCompanyIDs returns the "parentCompany" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ParentCompanyID instead. It exists only for internal usage by the builders.
func (m *CompanyMutation) ParentCompanyIDs() (ids []int) {
	if id := m.parentCompany; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetParentCompany resets all changes to the "parentCompany" edge.
func (m *CompanyMutation) ResetParentCompany() {
	m.parentCompany = nil
	m.clearedparentCompany = false
}

// Where appends a list predicates to the CompanyMutation builder.
func (m *CompanyMutation) Where(ps ...predicate.Company) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CompanyMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CompanyMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Company, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CompanyMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CompanyMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Company).
func (m *CompanyMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CompanyMutation) Fields() []string {
	fields := make([]string, 0, 23)
	if m.createdAt != nil {
		fields = append(fields, company.FieldCreatedAt)
	}
	if m.updatedAt != nil {
		fields = append(fields, company.FieldUpdatedAt)
	}
	if m.deletedAt != nil {
		fields = append(fields, company.FieldDeletedAt)
	}
	if m.address != nil {
		fields = append(fields, company.FieldAddress)
	}
	if m.baseCurrency != nil {
		fields = append(fields, company.FieldBaseCurrency)
	}
	if m.ceoName != nil {
		fields = append(fields, company.FieldCeoName)
	}
	if m.city != nil {
		fields = append(fields, company.FieldCity)
	}
	if m.country != nil {
		fields = append(fields, company.FieldCountry)
	}
	if m.establishedAt != nil {
		fields = append(fields, company.FieldEstablishedAt)
	}
	if m.description != nil {
		fields = append(fields, company.FieldDescription)
	}
	if m.email != nil {
		fields = append(fields, company.FieldEmail)
	}
	if m.industry != nil {
		fields = append(fields, company.FieldIndustry)
	}
	if m.lastEntryDate != nil {
		fields = append(fields, company.FieldLastEntryDate)
	}
	if m.lastInvoiceNumber != nil {
		fields = append(fields, company.FieldLastInvoiceNumber)
	}
	if m.logo != nil {
		fields = append(fields, company.FieldLogo)
	}
	if m.name != nil {
		fields = append(fields, company.FieldName)
	}
	if m.numberOfEmployees != nil {
		fields = append(fields, company.FieldNumberOfEmployees)
	}
	if m.phone != nil {
		fields = append(fields, company.FieldPhone)
	}
	if m.sector != nil {
		fields = append(fields, company.FieldSector)
	}
	if m.taxId != nil {
		fields = append(fields, company.FieldTaxId)
	}
	if m.vatRate != nil {
		fields = append(fields, company.FieldVatRate)
	}
	if m.website != nil {
		fields = append(fields, company.FieldWebsite)
	}
	if m.incompleteSetup != nil {
		fields = append(fields, company.FieldIncompleteSetup)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CompanyMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case company.FieldCreatedAt:
		return m.CreatedAt()
	case company.FieldUpdatedAt:
		return m.UpdatedAt()
	case company.FieldDeletedAt:
		return m.DeletedAt()
	case company.FieldAddress:
		return m.Address()
	case company.FieldBaseCurrency:
		return m.BaseCurrency()
	case company.FieldCeoName:
		return m.CeoName()
	case company.FieldCity:
		return m.City()
	case company.FieldCountry:
		return m.Country()
	case company.FieldEstablishedAt:
		return m.EstablishedAt()
	case company.FieldDescription:
		return m.Description()
	case company.FieldEmail:
		return m.Email()
	case company.FieldIndustry:
		return m.Industry()
	case company.FieldLastEntryDate:
		return m.LastEntryDate()
	case company.FieldLastInvoiceNumber:
		return m.LastInvoiceNumber()
	case company.FieldLogo:
		return m.Logo()
	case company.FieldName:
		return m.Name()
	case company.FieldNumberOfEmployees:
		return m.NumberOfEmployees()
	case company.FieldPhone:
		return m.Phone()
	case company.FieldSector:
		return m.Sector()
	case company.FieldTaxId:
		return m.TaxId()
	case company.FieldVatRate:
		return m.VatRate()
	case company.FieldWebsite:
		return m.Website()
	case company.FieldIncompleteSetup:
		return m.IncompleteSetup()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CompanyMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case company.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case company.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case company.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case company.FieldAddress:
		return m.OldAddress(ctx)
	case company.FieldBaseCurrency:
		return m.OldBaseCurrency(ctx)
	case company.FieldCeoName:
		return m.OldCeoName(ctx)
	case company.FieldCity:
		return m.OldCity(ctx)
	case company.FieldCountry:
		return m.OldCountry(ctx)
	case company.FieldEstablishedAt:
		return m.OldEstablishedAt(ctx)
	case company.FieldDescription:
		return m.OldDescription(ctx)
	case company.FieldEmail:
		return m.OldEmail(ctx)
	case company.FieldIndustry:
		return m.OldIndustry(ctx)
	case company.FieldLastEntryDate:
		return m.OldLastEntryDate(ctx)
	case company.FieldLastInvoiceNumber:
		return m.OldLastInvoiceNumber(ctx)
	case company.FieldLogo:
		return m.OldLogo(ctx)
	case company.FieldName:
		return m.OldName(ctx)
	case company.FieldNumberOfEmployees:
		return m.OldNumberOfEmployees(ctx)
	case company.FieldPhone:
		return m.OldPhone(ctx)
	case company.FieldSector:
		return m.OldSector(ctx)
	case company.FieldTaxId:
		return m.OldTaxId(ctx)
	case company.FieldVatRate:
		return m.OldVatRate(ctx)
	case company.FieldWebsite:
		return m.OldWebsite(ctx)
	case company.FieldIncompleteSetup:
		return m.OldIncompleteSetup(ctx)
	}
	return nil, fmt.Errorf("unknown Company field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CompanyMutation) SetField(name string, value ent.Value) error {
	switch name {
	case company.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case company.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case company.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case company.FieldAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAddress(v)
		return nil
	case company.FieldBaseCurrency:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBaseCurrency(v)
		return nil
	case company.FieldCeoName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCeoName(v)
		return nil
	case company.FieldCity:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCity(v)
		return nil
	case company.FieldCountry:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCountry(v)
		return nil
	case company.FieldEstablishedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEstablishedAt(v)
		return nil
	case company.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case company.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case company.FieldIndustry:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIndustry(v)
		return nil
	case company.FieldLastEntryDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastEntryDate(v)
		return nil
	case company.FieldLastInvoiceNumber:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastInvoiceNumber(v)
		return nil
	case company.FieldLogo:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLogo(v)
		return nil
	case company.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case company.FieldNumberOfEmployees:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNumberOfEmployees(v)
		return nil
	case company.FieldPhone:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPhone(v)
		return nil
	case company.FieldSector:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSector(v)
		return nil
	case company.FieldTaxId:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTaxId(v)
		return nil
	case company.FieldVatRate:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVatRate(v)
		return nil
	case company.FieldWebsite:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWebsite(v)
		return nil
	case company.FieldIncompleteSetup:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIncompleteSetup(v)
		return nil
	}
	return fmt.Errorf("unknown Company field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CompanyMutation) AddedFields() []string {
	var fields []string
	if m.addlastInvoiceNumber != nil {
		fields = append(fields, company.FieldLastInvoiceNumber)
	}
	if m.addnumberOfEmployees != nil {
		fields = append(fields, company.FieldNumberOfEmployees)
	}
	if m.addvatRate != nil {
		fields = append(fields, company.FieldVatRate)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CompanyMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case company.FieldLastInvoiceNumber:
		return m.AddedLastInvoiceNumber()
	case company.FieldNumberOfEmployees:
		return m.AddedNumberOfEmployees()
	case company.FieldVatRate:
		return m.AddedVatRate()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CompanyMutation) AddField(name string, value ent.Value) error {
	switch name {
	case company.FieldLastInvoiceNumber:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLastInvoiceNumber(v)
		return nil
	case company.FieldNumberOfEmployees:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddNumberOfEmployees(v)
		return nil
	case company.FieldVatRate:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddVatRate(v)
		return nil
	}
	return fmt.Errorf("unknown Company numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CompanyMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(company.FieldDeletedAt) {
		fields = append(fields, company.FieldDeletedAt)
	}
	if m.FieldCleared(company.FieldAddress) {
		fields = append(fields, company.FieldAddress)
	}
	if m.FieldCleared(company.FieldCeoName) {
		fields = append(fields, company.FieldCeoName)
	}
	if m.FieldCleared(company.FieldDescription) {
		fields = append(fields, company.FieldDescription)
	}
	if m.FieldCleared(company.FieldEmail) {
		fields = append(fields, company.FieldEmail)
	}
	if m.FieldCleared(company.FieldIndustry) {
		fields = append(fields, company.FieldIndustry)
	}
	if m.FieldCleared(company.FieldLastInvoiceNumber) {
		fields = append(fields, company.FieldLastInvoiceNumber)
	}
	if m.FieldCleared(company.FieldLogo) {
		fields = append(fields, company.FieldLogo)
	}
	if m.FieldCleared(company.FieldPhone) {
		fields = append(fields, company.FieldPhone)
	}
	if m.FieldCleared(company.FieldSector) {
		fields = append(fields, company.FieldSector)
	}
	if m.FieldCleared(company.FieldWebsite) {
		fields = append(fields, company.FieldWebsite)
	}
	if m.FieldCleared(company.FieldIncompleteSetup) {
		fields = append(fields, company.FieldIncompleteSetup)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CompanyMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CompanyMutation) ClearField(name string) error {
	switch name {
	case company.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case company.FieldAddress:
		m.ClearAddress()
		return nil
	case company.FieldCeoName:
		m.ClearCeoName()
		return nil
	case company.FieldDescription:
		m.ClearDescription()
		return nil
	case company.FieldEmail:
		m.ClearEmail()
		return nil
	case company.FieldIndustry:
		m.ClearIndustry()
		return nil
	case company.FieldLastInvoiceNumber:
		m.ClearLastInvoiceNumber()
		return nil
	case company.FieldLogo:
		m.ClearLogo()
		return nil
	case company.FieldPhone:
		m.ClearPhone()
		return nil
	case company.FieldSector:
		m.ClearSector()
		return nil
	case company.FieldWebsite:
		m.ClearWebsite()
		return nil
	case company.FieldIncompleteSetup:
		m.ClearIncompleteSetup()
		return nil
	}
	return fmt.Errorf("unknown Company nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CompanyMutation) ResetField(name string) error {
	switch name {
	case company.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case company.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case company.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case company.FieldAddress:
		m.ResetAddress()
		return nil
	case company.FieldBaseCurrency:
		m.ResetBaseCurrency()
		return nil
	case company.FieldCeoName:
		m.ResetCeoName()
		return nil
	case company.FieldCity:
		m.ResetCity()
		return nil
	case company.FieldCountry:
		m.ResetCountry()
		return nil
	case company.FieldEstablishedAt:
		m.ResetEstablishedAt()
		return nil
	case company.FieldDescription:
		m.ResetDescription()
		return nil
	case company.FieldEmail:
		m.ResetEmail()
		return nil
	case company.FieldIndustry:
		m.ResetIndustry()
		return nil
	case company.FieldLastEntryDate:
		m.ResetLastEntryDate()
		return nil
	case company.FieldLastInvoiceNumber:
		m.ResetLastInvoiceNumber()
		return nil
	case company.FieldLogo:
		m.ResetLogo()
		return nil
	case company.FieldName:
		m.ResetName()
		return nil
	case company.FieldNumberOfEmployees:
		m.ResetNumberOfEmployees()
		return nil
	case company.FieldPhone:
		m.ResetPhone()
		return nil
	case company.FieldSector:
		m.ResetSector()
		return nil
	case company.FieldTaxId:
		m.ResetTaxId()
		return nil
	case company.FieldVatRate:
		m.ResetVatRate()
		return nil
	case company.FieldWebsite:
		m.ResetWebsite()
		return nil
	case company.FieldIncompleteSetup:
		m.ResetIncompleteSetup()
		return nil
	}
	return fmt.Errorf("unknown Company field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CompanyMutation) AddedEdges() []string {
	edges := make([]string, 0, 17)
	if m.availableRoles != nil {
		edges = append(edges, company.EdgeAvailableRoles)
	}
	if m.accountingEntries != nil {
		edges = append(edges, company.EdgeAccountingEntries)
	}
	if m.customers != nil {
		edges = append(edges, company.EdgeCustomers)
	}
	if m.documents != nil {
		edges = append(edges, company.EdgeDocuments)
	}
	if m.employees != nil {
		edges = append(edges, company.EdgeEmployees)
	}
	if m.files != nil {
		edges = append(edges, company.EdgeFiles)
	}
	if m.products != nil {
		edges = append(edges, company.EdgeProducts)
	}
	if m.projects != nil {
		edges = append(edges, company.EdgeProjects)
	}
	if m.payables != nil {
		edges = append(edges, company.EdgePayables)
	}
	if m.receivables != nil {
		edges = append(edges, company.EdgeReceivables)
	}
	if m.suppliers != nil {
		edges = append(edges, company.EdgeSuppliers)
	}
	if m.tokens != nil {
		edges = append(edges, company.EdgeTokens)
	}
	if m.treasuries != nil {
		edges = append(edges, company.EdgeTreasuries)
	}
	if m.workShifts != nil {
		edges = append(edges, company.EdgeWorkShifts)
	}
	if m.users != nil {
		edges = append(edges, company.EdgeUsers)
	}
	if m.daughterCompanies != nil {
		edges = append(edges, company.EdgeDaughterCompanies)
	}
	if m.parentCompany != nil {
		edges = append(edges, company.EdgeParentCompany)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CompanyMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case company.EdgeAvailableRoles:
		ids := make([]ent.Value, 0, len(m.availableRoles))
		for id := range m.availableRoles {
			ids = append(ids, id)
		}
		return ids
	case company.EdgeAccountingEntries:
		ids := make([]ent.Value, 0, len(m.accountingEntries))
		for id := range m.accountingEntries {
			ids = append(ids, id)
		}
		return ids
	case company.EdgeCustomers:
		ids := make([]ent.Value, 0, len(m.customers))
		for id := range m.customers {
			ids = append(ids, id)
		}
		return ids
	case company.EdgeDocuments:
		ids := make([]ent.Value, 0, len(m.documents))
		for id := range m.documents {
			ids = append(ids, id)
		}
		return ids
	case company.EdgeEmployees:
		ids := make([]ent.Value, 0, len(m.employees))
		for id := range m.employees {
			ids = append(ids, id)
		}
		return ids
	case company.EdgeFiles:
		ids := make([]ent.Value, 0, len(m.files))
		for id := range m.files {
			ids = append(ids, id)
		}
		return ids
	case company.EdgeProducts:
		ids := make([]ent.Value, 0, len(m.products))
		for id := range m.products {
			ids = append(ids, id)
		}
		return ids
	case company.EdgeProjects:
		ids := make([]ent.Value, 0, len(m.projects))
		for id := range m.projects {
			ids = append(ids, id)
		}
		return ids
	case company.EdgePayables:
		ids := make([]ent.Value, 0, len(m.payables))
		for id := range m.payables {
			ids = append(ids, id)
		}
		return ids
	case company.EdgeReceivables:
		ids := make([]ent.Value, 0, len(m.receivables))
		for id := range m.receivables {
			ids = append(ids, id)
		}
		return ids
	case company.EdgeSuppliers:
		ids := make([]ent.Value, 0, len(m.suppliers))
		for id := range m.suppliers {
			ids = append(ids, id)
		}
		return ids
	case company.EdgeTokens:
		ids := make([]ent.Value, 0, len(m.tokens))
		for id := range m.tokens {
			ids = append(ids, id)
		}
		return ids
	case company.EdgeTreasuries:
		ids := make([]ent.Value, 0, len(m.treasuries))
		for id := range m.treasuries {
			ids = append(ids, id)
		}
		return ids
	case company.EdgeWorkShifts:
		ids := make([]ent.Value, 0, len(m.workShifts))
		for id := range m.workShifts {
			ids = append(ids, id)
		}
		return ids
	case company.EdgeUsers:
		ids := make([]ent.Value, 0, len(m.users))
		for id := range m.users {
			ids = append(ids, id)
		}
		return ids
	case company.EdgeDaughterCompanies:
		ids := make([]ent.Value, 0, len(m.daughterCompanies))
		for id := range m.daughterCompanies {
			ids = append(ids, id)
		}
		return ids
	case company.EdgeParentCompany:
		if id := m.parentCompany; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CompanyMutation) RemovedEdges() []string {
	edges := make([]string, 0, 17)
	if m.removedavailableRoles != nil {
		edges = append(edges, company.EdgeAvailableRoles)
	}
	if m.removedaccountingEntries != nil {
		edges = append(edges, company.EdgeAccountingEntries)
	}
	if m.removedcustomers != nil {
		edges = append(edges, company.EdgeCustomers)
	}
	if m.removeddocuments != nil {
		edges = append(edges, company.EdgeDocuments)
	}
	if m.removedemployees != nil {
		edges = append(edges, company.EdgeEmployees)
	}
	if m.removedfiles != nil {
		edges = append(edges, company.EdgeFiles)
	}
	if m.removedproducts != nil {
		edges = append(edges, company.EdgeProducts)
	}
	if m.removedprojects != nil {
		edges = append(edges, company.EdgeProjects)
	}
	if m.removedpayables != nil {
		edges = append(edges, company.EdgePayables)
	}
	if m.removedreceivables != nil {
		edges = append(edges, company.EdgeReceivables)
	}
	if m.removedsuppliers != nil {
		edges = append(edges, company.EdgeSuppliers)
	}
	if m.removedtokens != nil {
		edges = append(edges, company.EdgeTokens)
	}
	if m.removedtreasuries != nil {
		edges = append(edges, company.EdgeTreasuries)
	}
	if m.removedworkShifts != nil {
		edges = append(edges, company.EdgeWorkShifts)
	}
	if m.removedusers != nil {
		edges = append(edges, company.EdgeUsers)
	}
	if m.removeddaughterCompanies != nil {
		edges = append(edges, company.EdgeDaughterCompanies)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CompanyMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case company.EdgeAvailableRoles:
		ids := make([]ent.Value, 0, len(m.removedavailableRoles))
		for id := range m.removedavailableRoles {
			ids = append(ids, id)
		}
		return ids
	case company.EdgeAccountingEntries:
		ids := make([]ent.Value, 0, len(m.removedaccountingEntries))
		for id := range m.removedaccountingEntries {
			ids = append(ids, id)
		}
		return ids
	case company.EdgeCustomers:
		ids := make([]ent.Value, 0, len(m.removedcustomers))
		for id := range m.removedcustomers {
			ids = append(ids, id)
		}
		return ids
	case company.EdgeDocuments:
		ids := make([]ent.Value, 0, len(m.removeddocuments))
		for id := range m.removeddocuments {
			ids = append(ids, id)
		}
		return ids
	case company.EdgeEmployees:
		ids := make([]ent.Value, 0, len(m.removedemployees))
		for id := range m.removedemployees {
			ids = append(ids, id)
		}
		return ids
	case company.EdgeFiles:
		ids := make([]ent.Value, 0, len(m.removedfiles))
		for id := range m.removedfiles {
			ids = append(ids, id)
		}
		return ids
	case company.EdgeProducts:
		ids := make([]ent.Value, 0, len(m.removedproducts))
		for id := range m.removedproducts {
			ids = append(ids, id)
		}
		return ids
	case company.EdgeProjects:
		ids := make([]ent.Value, 0, len(m.removedprojects))
		for id := range m.removedprojects {
			ids = append(ids, id)
		}
		return ids
	case company.EdgePayables:
		ids := make([]ent.Value, 0, len(m.removedpayables))
		for id := range m.removedpayables {
			ids = append(ids, id)
		}
		return ids
	case company.EdgeReceivables:
		ids := make([]ent.Value, 0, len(m.removedreceivables))
		for id := range m.removedreceivables {
			ids = append(ids, id)
		}
		return ids
	case company.EdgeSuppliers:
		ids := make([]ent.Value, 0, len(m.removedsuppliers))
		for id := range m.removedsuppliers {
			ids = append(ids, id)
		}
		return ids
	case company.EdgeTokens:
		ids := make([]ent.Value, 0, len(m.removedtokens))
		for id := range m.removedtokens {
			ids = append(ids, id)
		}
		return ids
	case company.EdgeTreasuries:
		ids := make([]ent.Value, 0, len(m.removedtreasuries))
		for id := range m.removedtreasuries {
			ids = append(ids, id)
		}
		return ids
	case company.EdgeWorkShifts:
		ids := make([]ent.Value, 0, len(m.removedworkShifts))
		for id := range m.removedworkShifts {
			ids = append(ids, id)
		}
		return ids
	case company.EdgeUsers:
		ids := make([]ent.Value, 0, len(m.removedusers))
		for id := range m.removedusers {
			ids = append(ids, id)
		}
		return ids
	case company.EdgeDaughterCompanies:
		ids := make([]ent.Value, 0, len(m.removeddaughterCompanies))
		for id := range m.removeddaughterCompanies {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CompanyMutation) ClearedEdges() []string {
	edges := make([]string, 0, 17)
	if m.clearedavailableRoles {
		edges = append(edges, company.EdgeAvailableRoles)
	}
	if m.clearedaccountingEntries {
		edges = append(edges, company.EdgeAccountingEntries)
	}
	if m.clearedcustomers {
		edges = append(edges, company.EdgeCustomers)
	}
	if m.cleareddocuments {
		edges = append(edges, company.EdgeDocuments)
	}
	if m.clearedemployees {
		edges = append(edges, company.EdgeEmployees)
	}
	if m.clearedfiles {
		edges = append(edges, company.EdgeFiles)
	}
	if m.clearedproducts {
		edges = append(edges, company.EdgeProducts)
	}
	if m.clearedprojects {
		edges = append(edges, company.EdgeProjects)
	}
	if m.clearedpayables {
		edges = append(edges, company.EdgePayables)
	}
	if m.clearedreceivables {
		edges = append(edges, company.EdgeReceivables)
	}
	if m.clearedsuppliers {
		edges = append(edges, company.EdgeSuppliers)
	}
	if m.clearedtokens {
		edges = append(edges, company.EdgeTokens)
	}
	if m.clearedtreasuries {
		edges = append(edges, company.EdgeTreasuries)
	}
	if m.clearedworkShifts {
		edges = append(edges, company.EdgeWorkShifts)
	}
	if m.clearedusers {
		edges = append(edges, company.EdgeUsers)
	}
	if m.cleareddaughterCompanies {
		edges = append(edges, company.EdgeDaughterCompanies)
	}
	if m.clearedparentCompany {
		edges = append(edges, company.EdgeParentCompany)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CompanyMutation) EdgeCleared(name string) bool {
	switch name {
	case company.EdgeAvailableRoles:
		return m.clearedavailableRoles
	case company.EdgeAccountingEntries:
		return m.clearedaccountingEntries
	case company.EdgeCustomers:
		return m.clearedcustomers
	case company.EdgeDocuments:
		return m.cleareddocuments
	case company.EdgeEmployees:
		return m.clearedemployees
	case company.EdgeFiles:
		return m.clearedfiles
	case company.EdgeProducts:
		return m.clearedproducts
	case company.EdgeProjects:
		return m.clearedprojects
	case company.EdgePayables:
		return m.clearedpayables
	case company.EdgeReceivables:
		return m.clearedreceivables
	case company.EdgeSuppliers:
		return m.clearedsuppliers
	case company.EdgeTokens:
		return m.clearedtokens
	case company.EdgeTreasuries:
		return m.clearedtreasuries
	case company.EdgeWorkShifts:
		return m.clearedworkShifts
	case company.EdgeUsers:
		return m.clearedusers
	case company.EdgeDaughterCompanies:
		return m.cleareddaughterCompanies
	case company.EdgeParentCompany:
		return m.clearedparentCompany
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CompanyMutation) ClearEdge(name string) error {
	switch name {
	case company.EdgeParentCompany:
		m.ClearParentCompany()
		return nil
	}
	return fmt.Errorf("unknown Company unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CompanyMutation) ResetEdge(name string) error {
	switch name {
	case company.EdgeAvailableRoles:
		m.ResetAvailableRoles()
		return nil
	case company.EdgeAccountingEntries:
		m.ResetAccountingEntries()
		return nil
	case company.EdgeCustomers:
		m.ResetCustomers()
		return nil
	case company.EdgeDocuments:
		m.ResetDocuments()
		return nil
	case company.EdgeEmployees:
		m.ResetEmployees()
		return nil
	case company.EdgeFiles:
		m.ResetFiles()
		return nil
	case company.EdgeProducts:
		m.ResetProducts()
		return nil
	case company.EdgeProjects:
		m.ResetProjects()
		return nil
	case company.EdgePayables:
		m.ResetPayables()
		return nil
	case company.EdgeReceivables:
		m.ResetReceivables()
		return nil
	case company.EdgeSuppliers:
		m.ResetSuppliers()
		return nil
	case company.EdgeTokens:
		m.ResetTokens()
		return nil
	case company.EdgeTreasuries:
		m.ResetTreasuries()
		return nil
	case company.EdgeWorkShifts:
		m.ResetWorkShifts()
		return nil
	case company.EdgeUsers:
		m.ResetUsers()
		return nil
	case company.EdgeDaughterCompanies:
		m.ResetDaughterCompanies()
		return nil
	case company.EdgeParentCompany:
		m.ResetParentCompany()
		return nil
	}
	return fmt.Errorf("unknown Company edge %s", name)
}

// CompanyDocumentMutation represents an operation that mutates the CompanyDocument nodes in the graph.
type CompanyDocumentMutation struct {
	config
	op                Op
	typ               string
	id                *int
	createdAt         *time.Time
	updatedAt         *time.Time
	deletedAt         *time.Time
	filename          *string
	title             *string
	keywords          *string
	category          *companydocument.Category
	size              *int
	addsize           *int
	fileType          *string
	status            *companydocument.Status
	url               *string
	storageURI        *string
	thumbnail         *string
	expiryDate        *time.Time
	clearedFields     map[string]struct{}
	company           *int
	clearedcompany    bool
	uploadedBy        *int
	cleareduploadedBy bool
	approvedBy        *int
	clearedapprovedBy bool
	done              bool
	oldValue          func(context.Context) (*CompanyDocument, error)
	predicates        []predicate.CompanyDocument
}

var _ ent.Mutation = (*CompanyDocumentMutation)(nil)

// companydocumentOption allows management of the mutation configuration using functional options.
type companydocumentOption func(*CompanyDocumentMutation)

// newCompanyDocumentMutation creates new mutation for the CompanyDocument entity.
func newCompanyDocumentMutation(c config, op Op, opts ...companydocumentOption) *CompanyDocumentMutation {
	m := &CompanyDocumentMutation{
		config:        c,
		op:            op,
		typ:           TypeCompanyDocument,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCompanyDocumentID sets the ID field of the mutation.
func withCompanyDocumentID(id int) companydocumentOption {
	return func(m *CompanyDocumentMutation) {
		var (
			err   error
			once  sync.Once
			value *CompanyDocument
		)
		m.oldValue = func(ctx context.Context) (*CompanyDocument, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().CompanyDocument.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCompanyDocument sets the old CompanyDocument of the mutation.
func withCompanyDocument(node *CompanyDocument) companydocumentOption {
	return func(m *CompanyDocumentMutation) {
		m.oldValue = func(context.Context) (*CompanyDocument, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CompanyDocumentMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CompanyDocumentMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("generated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CompanyDocumentMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CompanyDocumentMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().CompanyDocument.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "createdAt" field.
func (m *CompanyDocumentMutation) SetCreatedAt(t time.Time) {
	m.createdAt = &t
}

// CreatedAt returns the value of the "createdAt" field in the mutation.
func (m *CompanyDocumentMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.createdAt
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "createdAt" field's value of the CompanyDocument entity.
// If the CompanyDocument object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CompanyDocumentMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "createdAt" field.
func (m *CompanyDocumentMutation) ResetCreatedAt() {
	m.createdAt = nil
}

// SetUpdatedAt sets the "updatedAt" field.
func (m *CompanyDocumentMutation) SetUpdatedAt(t time.Time) {
	m.updatedAt = &t
}

// UpdatedAt returns the value of the "updatedAt" field in the mutation.
func (m *CompanyDocumentMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updatedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updatedAt" field's value of the CompanyDocument entity.
// If the CompanyDocument object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CompanyDocumentMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updatedAt" field.
func (m *CompanyDocumentMutation) ResetUpdatedAt() {
	m.updatedAt = nil
}

// SetDeletedAt sets the "deletedAt" field.
func (m *CompanyDocumentMutation) SetDeletedAt(t time.Time) {
	m.deletedAt = &t
}

// DeletedAt returns the value of the "deletedAt" field in the mutation.
func (m *CompanyDocumentMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deletedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deletedAt" field's value of the CompanyDocument entity.
// If the CompanyDocument object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CompanyDocumentMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deletedAt" field.
func (m *CompanyDocumentMutation) ClearDeletedAt() {
	m.deletedAt = nil
	m.clearedFields[companydocument.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deletedAt" field was cleared in this mutation.
func (m *CompanyDocumentMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[companydocument.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deletedAt" field.
func (m *CompanyDocumentMutation) ResetDeletedAt() {
	m.deletedAt = nil
	delete(m.clearedFields, companydocument.FieldDeletedAt)
}

// SetFilename sets the "filename" field.
func (m *CompanyDocumentMutation) SetFilename(s string) {
	m.filename = &s
}

// Filename returns the value of the "filename" field in the mutation.
func (m *CompanyDocumentMutation) Filename() (r string, exists bool) {
	v := m.filename
	if v == nil {
		return
	}
	return *v, true
}

// OldFilename returns the old "filename" field's value of the CompanyDocument entity.
// If the CompanyDocument object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CompanyDocumentMutation) OldFilename(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFilename is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFilename requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFilename: %w", err)
	}
	return oldValue.Filename, nil
}

// ResetFilename resets all changes to the "filename" field.
func (m *CompanyDocumentMutation) ResetFilename() {
	m.filename = nil
}

// SetTitle sets the "title" field.
func (m *CompanyDocumentMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *CompanyDocumentMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the CompanyDocument entity.
// If the CompanyDocument object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CompanyDocumentMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *CompanyDocumentMutation) ResetTitle() {
	m.title = nil
}

// SetKeywords sets the "keywords" field.
func (m *CompanyDocumentMutation) SetKeywords(s string) {
	m.keywords = &s
}

// Keywords returns the value of the "keywords" field in the mutation.
func (m *CompanyDocumentMutation) Keywords() (r string, exists bool) {
	v := m.keywords
	if v == nil {
		return
	}
	return *v, true
}

// OldKeywords returns the old "keywords" field's value of the CompanyDocument entity.
// If the CompanyDocument object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CompanyDocumentMutation) OldKeywords(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKeywords is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKeywords requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKeywords: %w", err)
	}
	return oldValue.Keywords, nil
}

// ResetKeywords resets all changes to the "keywords" field.
func (m *CompanyDocumentMutation) ResetKeywords() {
	m.keywords = nil
}

// SetCategory sets the "category" field.
func (m *CompanyDocumentMutation) SetCategory(c companydocument.Category) {
	m.category = &c
}

// Category returns the value of the "category" field in the mutation.
func (m *CompanyDocumentMutation) Category() (r companydocument.Category, exists bool) {
	v := m.category
	if v == nil {
		return
	}
	return *v, true
}

// OldCategory returns the old "category" field's value of the CompanyDocument entity.
// If the CompanyDocument object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CompanyDocumentMutation) OldCategory(ctx context.Context) (v companydocument.Category, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCategory is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCategory requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCategory: %w", err)
	}
	return oldValue.Category, nil
}

// ResetCategory resets all changes to the "category" field.
func (m *CompanyDocumentMutation) ResetCategory() {
	m.category = nil
}

// SetSize sets the "size" field.
func (m *CompanyDocumentMutation) SetSize(i int) {
	m.size = &i
	m.addsize = nil
}

// Size returns the value of the "size" field in the mutation.
func (m *CompanyDocumentMutation) Size() (r int, exists bool) {
	v := m.size
	if v == nil {
		return
	}
	return *v, true
}

// OldSize returns the old "size" field's value of the CompanyDocument entity.
// If the CompanyDocument object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CompanyDocumentMutation) OldSize(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSize is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSize requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSize: %w", err)
	}
	return oldValue.Size, nil
}

// AddSize adds i to the "size" field.
func (m *CompanyDocumentMutation) AddSize(i int) {
	if m.addsize != nil {
		*m.addsize += i
	} else {
		m.addsize = &i
	}
}

// AddedSize returns the value that was added to the "size" field in this mutation.
func (m *CompanyDocumentMutation) AddedSize() (r int, exists bool) {
	v := m.addsize
	if v == nil {
		return
	}
	return *v, true
}

// ResetSize resets all changes to the "size" field.
func (m *CompanyDocumentMutation) ResetSize() {
	m.size = nil
	m.addsize = nil
}

// SetFileType sets the "fileType" field.
func (m *CompanyDocumentMutation) SetFileType(s string) {
	m.fileType = &s
}

// FileType returns the value of the "fileType" field in the mutation.
func (m *CompanyDocumentMutation) FileType() (r string, exists bool) {
	v := m.fileType
	if v == nil {
		return
	}
	return *v, true
}

// OldFileType returns the old "fileType" field's value of the CompanyDocument entity.
// If the CompanyDocument object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CompanyDocumentMutation) OldFileType(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFileType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFileType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFileType: %w", err)
	}
	return oldValue.FileType, nil
}

// ResetFileType resets all changes to the "fileType" field.
func (m *CompanyDocumentMutation) ResetFileType() {
	m.fileType = nil
}

// SetStatus sets the "status" field.
func (m *CompanyDocumentMutation) SetStatus(c companydocument.Status) {
	m.status = &c
}

// Status returns the value of the "status" field in the mutation.
func (m *CompanyDocumentMutation) Status() (r companydocument.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the CompanyDocument entity.
// If the CompanyDocument object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CompanyDocumentMutation) OldStatus(ctx context.Context) (v companydocument.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *CompanyDocumentMutation) ResetStatus() {
	m.status = nil
}

// SetURL sets the "url" field.
func (m *CompanyDocumentMutation) SetURL(s string) {
	m.url = &s
}

// URL returns the value of the "url" field in the mutation.
func (m *CompanyDocumentMutation) URL() (r string, exists bool) {
	v := m.url
	if v == nil {
		return
	}
	return *v, true
}

// OldURL returns the old "url" field's value of the CompanyDocument entity.
// If the CompanyDocument object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CompanyDocumentMutation) OldURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldURL: %w", err)
	}
	return oldValue.URL, nil
}

// ResetURL resets all changes to the "url" field.
func (m *CompanyDocumentMutation) ResetURL() {
	m.url = nil
}

// SetStorageURI sets the "storageURI" field.
func (m *CompanyDocumentMutation) SetStorageURI(s string) {
	m.storageURI = &s
}

// StorageURI returns the value of the "storageURI" field in the mutation.
func (m *CompanyDocumentMutation) StorageURI() (r string, exists bool) {
	v := m.storageURI
	if v == nil {
		return
	}
	return *v, true
}

// OldStorageURI returns the old "storageURI" field's value of the CompanyDocument entity.
// If the CompanyDocument object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CompanyDocumentMutation) OldStorageURI(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStorageURI is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStorageURI requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStorageURI: %w", err)
	}
	return oldValue.StorageURI, nil
}

// ResetStorageURI resets all changes to the "storageURI" field.
func (m *CompanyDocumentMutation) ResetStorageURI() {
	m.storageURI = nil
}

// SetThumbnail sets the "thumbnail" field.
func (m *CompanyDocumentMutation) SetThumbnail(s string) {
	m.thumbnail = &s
}

// Thumbnail returns the value of the "thumbnail" field in the mutation.
func (m *CompanyDocumentMutation) Thumbnail() (r string, exists bool) {
	v := m.thumbnail
	if v == nil {
		return
	}
	return *v, true
}

// OldThumbnail returns the old "thumbnail" field's value of the CompanyDocument entity.
// If the CompanyDocument object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CompanyDocumentMutation) OldThumbnail(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldThumbnail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldThumbnail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldThumbnail: %w", err)
	}
	return oldValue.Thumbnail, nil
}

// ClearThumbnail clears the value of the "thumbnail" field.
func (m *CompanyDocumentMutation) ClearThumbnail() {
	m.thumbnail = nil
	m.clearedFields[companydocument.FieldThumbnail] = struct{}{}
}

// ThumbnailCleared returns if the "thumbnail" field was cleared in this mutation.
func (m *CompanyDocumentMutation) ThumbnailCleared() bool {
	_, ok := m.clearedFields[companydocument.FieldThumbnail]
	return ok
}

// ResetThumbnail resets all changes to the "thumbnail" field.
func (m *CompanyDocumentMutation) ResetThumbnail() {
	m.thumbnail = nil
	delete(m.clearedFields, companydocument.FieldThumbnail)
}

// SetExpiryDate sets the "expiryDate" field.
func (m *CompanyDocumentMutation) SetExpiryDate(t time.Time) {
	m.expiryDate = &t
}

// ExpiryDate returns the value of the "expiryDate" field in the mutation.
func (m *CompanyDocumentMutation) ExpiryDate() (r time.Time, exists bool) {
	v := m.expiryDate
	if v == nil {
		return
	}
	return *v, true
}

// OldExpiryDate returns the old "expiryDate" field's value of the CompanyDocument entity.
// If the CompanyDocument object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CompanyDocumentMutation) OldExpiryDate(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExpiryDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExpiryDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpiryDate: %w", err)
	}
	return oldValue.ExpiryDate, nil
}

// ResetExpiryDate resets all changes to the "expiryDate" field.
func (m *CompanyDocumentMutation) ResetExpiryDate() {
	m.expiryDate = nil
}

// SetCompanyID sets the "company" edge to the Company entity by id.
func (m *CompanyDocumentMutation) SetCompanyID(id int) {
	m.company = &id
}

// ClearCompany clears the "company" edge to the Company entity.
func (m *CompanyDocumentMutation) ClearCompany() {
	m.clearedcompany = true
}

// CompanyCleared reports if the "company" edge to the Company entity was cleared.
func (m *CompanyDocumentMutation) CompanyCleared() bool {
	return m.clearedcompany
}

// CompanyID returns the "company" edge ID in the mutation.
func (m *CompanyDocumentMutation) CompanyID() (id int, exists bool) {
	if m.company != nil {
		return *m.company, true
	}
	return
}

// CompanyIDs returns the "company" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CompanyID instead. It exists only for internal usage by the builders.
func (m *CompanyDocumentMutation) CompanyIDs() (ids []int) {
	if id := m.company; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCompany resets all changes to the "company" edge.
func (m *CompanyDocumentMutation) ResetCompany() {
	m.company = nil
	m.clearedcompany = false
}

// SetUploadedByID sets the "uploadedBy" edge to the User entity by id.
func (m *CompanyDocumentMutation) SetUploadedByID(id int) {
	m.uploadedBy = &id
}

// ClearUploadedBy clears the "uploadedBy" edge to the User entity.
func (m *CompanyDocumentMutation) ClearUploadedBy() {
	m.cleareduploadedBy = true
}

// UploadedByCleared reports if the "uploadedBy" edge to the User entity was cleared.
func (m *CompanyDocumentMutation) UploadedByCleared() bool {
	return m.cleareduploadedBy
}

// UploadedByID returns the "uploadedBy" edge ID in the mutation.
func (m *CompanyDocumentMutation) UploadedByID() (id int, exists bool) {
	if m.uploadedBy != nil {
		return *m.uploadedBy, true
	}
	return
}

// UploadedByIDs returns the "uploadedBy" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UploadedByID instead. It exists only for internal usage by the builders.
func (m *CompanyDocumentMutation) UploadedByIDs() (ids []int) {
	if id := m.uploadedBy; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUploadedBy resets all changes to the "uploadedBy" edge.
func (m *CompanyDocumentMutation) ResetUploadedBy() {
	m.uploadedBy = nil
	m.cleareduploadedBy = false
}

// SetApprovedByID sets the "approvedBy" edge to the User entity by id.
func (m *CompanyDocumentMutation) SetApprovedByID(id int) {
	m.approvedBy = &id
}

// ClearApprovedBy clears the "approvedBy" edge to the User entity.
func (m *CompanyDocumentMutation) ClearApprovedBy() {
	m.clearedapprovedBy = true
}

// ApprovedByCleared reports if the "approvedBy" edge to the User entity was cleared.
func (m *CompanyDocumentMutation) ApprovedByCleared() bool {
	return m.clearedapprovedBy
}

// ApprovedByID returns the "approvedBy" edge ID in the mutation.
func (m *CompanyDocumentMutation) ApprovedByID() (id int, exists bool) {
	if m.approvedBy != nil {
		return *m.approvedBy, true
	}
	return
}

// ApprovedByIDs returns the "approvedBy" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ApprovedByID instead. It exists only for internal usage by the builders.
func (m *CompanyDocumentMutation) ApprovedByIDs() (ids []int) {
	if id := m.approvedBy; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetApprovedBy resets all changes to the "approvedBy" edge.
func (m *CompanyDocumentMutation) ResetApprovedBy() {
	m.approvedBy = nil
	m.clearedapprovedBy = false
}

// Where appends a list predicates to the CompanyDocumentMutation builder.
func (m *CompanyDocumentMutation) Where(ps ...predicate.CompanyDocument) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CompanyDocumentMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CompanyDocumentMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.CompanyDocument, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CompanyDocumentMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CompanyDocumentMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (CompanyDocument).
func (m *CompanyDocumentMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CompanyDocumentMutation) Fields() []string {
	fields := make([]string, 0, 14)
	if m.createdAt != nil {
		fields = append(fields, companydocument.FieldCreatedAt)
	}
	if m.updatedAt != nil {
		fields = append(fields, companydocument.FieldUpdatedAt)
	}
	if m.deletedAt != nil {
		fields = append(fields, companydocument.FieldDeletedAt)
	}
	if m.filename != nil {
		fields = append(fields, companydocument.FieldFilename)
	}
	if m.title != nil {
		fields = append(fields, companydocument.FieldTitle)
	}
	if m.keywords != nil {
		fields = append(fields, companydocument.FieldKeywords)
	}
	if m.category != nil {
		fields = append(fields, companydocument.FieldCategory)
	}
	if m.size != nil {
		fields = append(fields, companydocument.FieldSize)
	}
	if m.fileType != nil {
		fields = append(fields, companydocument.FieldFileType)
	}
	if m.status != nil {
		fields = append(fields, companydocument.FieldStatus)
	}
	if m.url != nil {
		fields = append(fields, companydocument.FieldURL)
	}
	if m.storageURI != nil {
		fields = append(fields, companydocument.FieldStorageURI)
	}
	if m.thumbnail != nil {
		fields = append(fields, companydocument.FieldThumbnail)
	}
	if m.expiryDate != nil {
		fields = append(fields, companydocument.FieldExpiryDate)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CompanyDocumentMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case companydocument.FieldCreatedAt:
		return m.CreatedAt()
	case companydocument.FieldUpdatedAt:
		return m.UpdatedAt()
	case companydocument.FieldDeletedAt:
		return m.DeletedAt()
	case companydocument.FieldFilename:
		return m.Filename()
	case companydocument.FieldTitle:
		return m.Title()
	case companydocument.FieldKeywords:
		return m.Keywords()
	case companydocument.FieldCategory:
		return m.Category()
	case companydocument.FieldSize:
		return m.Size()
	case companydocument.FieldFileType:
		return m.FileType()
	case companydocument.FieldStatus:
		return m.Status()
	case companydocument.FieldURL:
		return m.URL()
	case companydocument.FieldStorageURI:
		return m.StorageURI()
	case companydocument.FieldThumbnail:
		return m.Thumbnail()
	case companydocument.FieldExpiryDate:
		return m.ExpiryDate()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CompanyDocumentMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case companydocument.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case companydocument.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case companydocument.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case companydocument.FieldFilename:
		return m.OldFilename(ctx)
	case companydocument.FieldTitle:
		return m.OldTitle(ctx)
	case companydocument.FieldKeywords:
		return m.OldKeywords(ctx)
	case companydocument.FieldCategory:
		return m.OldCategory(ctx)
	case companydocument.FieldSize:
		return m.OldSize(ctx)
	case companydocument.FieldFileType:
		return m.OldFileType(ctx)
	case companydocument.FieldStatus:
		return m.OldStatus(ctx)
	case companydocument.FieldURL:
		return m.OldURL(ctx)
	case companydocument.FieldStorageURI:
		return m.OldStorageURI(ctx)
	case companydocument.FieldThumbnail:
		return m.OldThumbnail(ctx)
	case companydocument.FieldExpiryDate:
		return m.OldExpiryDate(ctx)
	}
	return nil, fmt.Errorf("unknown CompanyDocument field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CompanyDocumentMutation) SetField(name string, value ent.Value) error {
	switch name {
	case companydocument.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case companydocument.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case companydocument.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case companydocument.FieldFilename:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFilename(v)
		return nil
	case companydocument.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case companydocument.FieldKeywords:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKeywords(v)
		return nil
	case companydocument.FieldCategory:
		v, ok := value.(companydocument.Category)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCategory(v)
		return nil
	case companydocument.FieldSize:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSize(v)
		return nil
	case companydocument.FieldFileType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFileType(v)
		return nil
	case companydocument.FieldStatus:
		v, ok := value.(companydocument.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case companydocument.FieldURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetURL(v)
		return nil
	case companydocument.FieldStorageURI:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStorageURI(v)
		return nil
	case companydocument.FieldThumbnail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetThumbnail(v)
		return nil
	case companydocument.FieldExpiryDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpiryDate(v)
		return nil
	}
	return fmt.Errorf("unknown CompanyDocument field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CompanyDocumentMutation) AddedFields() []string {
	var fields []string
	if m.addsize != nil {
		fields = append(fields, companydocument.FieldSize)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CompanyDocumentMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case companydocument.FieldSize:
		return m.AddedSize()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CompanyDocumentMutation) AddField(name string, value ent.Value) error {
	switch name {
	case companydocument.FieldSize:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSize(v)
		return nil
	}
	return fmt.Errorf("unknown CompanyDocument numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CompanyDocumentMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(companydocument.FieldDeletedAt) {
		fields = append(fields, companydocument.FieldDeletedAt)
	}
	if m.FieldCleared(companydocument.FieldThumbnail) {
		fields = append(fields, companydocument.FieldThumbnail)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CompanyDocumentMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CompanyDocumentMutation) ClearField(name string) error {
	switch name {
	case companydocument.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case companydocument.FieldThumbnail:
		m.ClearThumbnail()
		return nil
	}
	return fmt.Errorf("unknown CompanyDocument nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CompanyDocumentMutation) ResetField(name string) error {
	switch name {
	case companydocument.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case companydocument.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case companydocument.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case companydocument.FieldFilename:
		m.ResetFilename()
		return nil
	case companydocument.FieldTitle:
		m.ResetTitle()
		return nil
	case companydocument.FieldKeywords:
		m.ResetKeywords()
		return nil
	case companydocument.FieldCategory:
		m.ResetCategory()
		return nil
	case companydocument.FieldSize:
		m.ResetSize()
		return nil
	case companydocument.FieldFileType:
		m.ResetFileType()
		return nil
	case companydocument.FieldStatus:
		m.ResetStatus()
		return nil
	case companydocument.FieldURL:
		m.ResetURL()
		return nil
	case companydocument.FieldStorageURI:
		m.ResetStorageURI()
		return nil
	case companydocument.FieldThumbnail:
		m.ResetThumbnail()
		return nil
	case companydocument.FieldExpiryDate:
		m.ResetExpiryDate()
		return nil
	}
	return fmt.Errorf("unknown CompanyDocument field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CompanyDocumentMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.company != nil {
		edges = append(edges, companydocument.EdgeCompany)
	}
	if m.uploadedBy != nil {
		edges = append(edges, companydocument.EdgeUploadedBy)
	}
	if m.approvedBy != nil {
		edges = append(edges, companydocument.EdgeApprovedBy)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CompanyDocumentMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case companydocument.EdgeCompany:
		if id := m.company; id != nil {
			return []ent.Value{*id}
		}
	case companydocument.EdgeUploadedBy:
		if id := m.uploadedBy; id != nil {
			return []ent.Value{*id}
		}
	case companydocument.EdgeApprovedBy:
		if id := m.approvedBy; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CompanyDocumentMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CompanyDocumentMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CompanyDocumentMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedcompany {
		edges = append(edges, companydocument.EdgeCompany)
	}
	if m.cleareduploadedBy {
		edges = append(edges, companydocument.EdgeUploadedBy)
	}
	if m.clearedapprovedBy {
		edges = append(edges, companydocument.EdgeApprovedBy)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CompanyDocumentMutation) EdgeCleared(name string) bool {
	switch name {
	case companydocument.EdgeCompany:
		return m.clearedcompany
	case companydocument.EdgeUploadedBy:
		return m.cleareduploadedBy
	case companydocument.EdgeApprovedBy:
		return m.clearedapprovedBy
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CompanyDocumentMutation) ClearEdge(name string) error {
	switch name {
	case companydocument.EdgeCompany:
		m.ClearCompany()
		return nil
	case companydocument.EdgeUploadedBy:
		m.ClearUploadedBy()
		return nil
	case companydocument.EdgeApprovedBy:
		m.ClearApprovedBy()
		return nil
	}
	return fmt.Errorf("unknown CompanyDocument unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CompanyDocumentMutation) ResetEdge(name string) error {
	switch name {
	case companydocument.EdgeCompany:
		m.ResetCompany()
		return nil
	case companydocument.EdgeUploadedBy:
		m.ResetUploadedBy()
		return nil
	case companydocument.EdgeApprovedBy:
		m.ResetApprovedBy()
		return nil
	}
	return fmt.Errorf("unknown CompanyDocument edge %s", name)
}

// CustomerMutation represents an operation that mutates the Customer nodes in the graph.
type CustomerMutation struct {
	config
	op                 Op
	typ                string
	id                 *int
	createdAt          *time.Time
	updatedAt          *time.Time
	deletedAt          *time.Time
	address            *string
	city               *string
	country            *string
	description        *string
	email              *string
	isDefault          *bool
	name               *string
	phone              *string
	taxId              *string
	clearedFields      map[string]struct{}
	company            *int
	clearedcompany     bool
	receivables        map[int]struct{}
	removedreceivables map[int]struct{}
	clearedreceivables bool
	done               bool
	oldValue           func(context.Context) (*Customer, error)
	predicates         []predicate.Customer
}

var _ ent.Mutation = (*CustomerMutation)(nil)

// customerOption allows management of the mutation configuration using functional options.
type customerOption func(*CustomerMutation)

// newCustomerMutation creates new mutation for the Customer entity.
func newCustomerMutation(c config, op Op, opts ...customerOption) *CustomerMutation {
	m := &CustomerMutation{
		config:        c,
		op:            op,
		typ:           TypeCustomer,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCustomerID sets the ID field of the mutation.
func withCustomerID(id int) customerOption {
	return func(m *CustomerMutation) {
		var (
			err   error
			once  sync.Once
			value *Customer
		)
		m.oldValue = func(ctx context.Context) (*Customer, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Customer.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCustomer sets the old Customer of the mutation.
func withCustomer(node *Customer) customerOption {
	return func(m *CustomerMutation) {
		m.oldValue = func(context.Context) (*Customer, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CustomerMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CustomerMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("generated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CustomerMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CustomerMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Customer.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "createdAt" field.
func (m *CustomerMutation) SetCreatedAt(t time.Time) {
	m.createdAt = &t
}

// CreatedAt returns the value of the "createdAt" field in the mutation.
func (m *CustomerMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.createdAt
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "createdAt" field's value of the Customer entity.
// If the Customer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "createdAt" field.
func (m *CustomerMutation) ResetCreatedAt() {
	m.createdAt = nil
}

// SetUpdatedAt sets the "updatedAt" field.
func (m *CustomerMutation) SetUpdatedAt(t time.Time) {
	m.updatedAt = &t
}

// UpdatedAt returns the value of the "updatedAt" field in the mutation.
func (m *CustomerMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updatedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updatedAt" field's value of the Customer entity.
// If the Customer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updatedAt" field.
func (m *CustomerMutation) ResetUpdatedAt() {
	m.updatedAt = nil
}

// SetDeletedAt sets the "deletedAt" field.
func (m *CustomerMutation) SetDeletedAt(t time.Time) {
	m.deletedAt = &t
}

// DeletedAt returns the value of the "deletedAt" field in the mutation.
func (m *CustomerMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deletedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deletedAt" field's value of the Customer entity.
// If the Customer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deletedAt" field.
func (m *CustomerMutation) ClearDeletedAt() {
	m.deletedAt = nil
	m.clearedFields[customer.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deletedAt" field was cleared in this mutation.
func (m *CustomerMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[customer.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deletedAt" field.
func (m *CustomerMutation) ResetDeletedAt() {
	m.deletedAt = nil
	delete(m.clearedFields, customer.FieldDeletedAt)
}

// SetAddress sets the "address" field.
func (m *CustomerMutation) SetAddress(s string) {
	m.address = &s
}

// Address returns the value of the "address" field in the mutation.
func (m *CustomerMutation) Address() (r string, exists bool) {
	v := m.address
	if v == nil {
		return
	}
	return *v, true
}

// OldAddress returns the old "address" field's value of the Customer entity.
// If the Customer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerMutation) OldAddress(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAddress: %w", err)
	}
	return oldValue.Address, nil
}

// ResetAddress resets all changes to the "address" field.
func (m *CustomerMutation) ResetAddress() {
	m.address = nil
}

// SetCity sets the "city" field.
func (m *CustomerMutation) SetCity(s string) {
	m.city = &s
}

// City returns the value of the "city" field in the mutation.
func (m *CustomerMutation) City() (r string, exists bool) {
	v := m.city
	if v == nil {
		return
	}
	return *v, true
}

// OldCity returns the old "city" field's value of the Customer entity.
// If the Customer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerMutation) OldCity(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCity: %w", err)
	}
	return oldValue.City, nil
}

// ResetCity resets all changes to the "city" field.
func (m *CustomerMutation) ResetCity() {
	m.city = nil
}

// SetCountry sets the "country" field.
func (m *CustomerMutation) SetCountry(s string) {
	m.country = &s
}

// Country returns the value of the "country" field in the mutation.
func (m *CustomerMutation) Country() (r string, exists bool) {
	v := m.country
	if v == nil {
		return
	}
	return *v, true
}

// OldCountry returns the old "country" field's value of the Customer entity.
// If the Customer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerMutation) OldCountry(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCountry is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCountry requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCountry: %w", err)
	}
	return oldValue.Country, nil
}

// ResetCountry resets all changes to the "country" field.
func (m *CustomerMutation) ResetCountry() {
	m.country = nil
}

// SetDescription sets the "description" field.
func (m *CustomerMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *CustomerMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Customer entity.
// If the Customer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *CustomerMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[customer.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *CustomerMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[customer.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *CustomerMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, customer.FieldDescription)
}

// SetEmail sets the "email" field.
func (m *CustomerMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *CustomerMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the Customer entity.
// If the Customer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ClearEmail clears the value of the "email" field.
func (m *CustomerMutation) ClearEmail() {
	m.email = nil
	m.clearedFields[customer.FieldEmail] = struct{}{}
}

// EmailCleared returns if the "email" field was cleared in this mutation.
func (m *CustomerMutation) EmailCleared() bool {
	_, ok := m.clearedFields[customer.FieldEmail]
	return ok
}

// ResetEmail resets all changes to the "email" field.
func (m *CustomerMutation) ResetEmail() {
	m.email = nil
	delete(m.clearedFields, customer.FieldEmail)
}

// SetIsDefault sets the "isDefault" field.
func (m *CustomerMutation) SetIsDefault(b bool) {
	m.isDefault = &b
}

// IsDefault returns the value of the "isDefault" field in the mutation.
func (m *CustomerMutation) IsDefault() (r bool, exists bool) {
	v := m.isDefault
	if v == nil {
		return
	}
	return *v, true
}

// OldIsDefault returns the old "isDefault" field's value of the Customer entity.
// If the Customer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerMutation) OldIsDefault(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsDefault is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsDefault requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsDefault: %w", err)
	}
	return oldValue.IsDefault, nil
}

// ClearIsDefault clears the value of the "isDefault" field.
func (m *CustomerMutation) ClearIsDefault() {
	m.isDefault = nil
	m.clearedFields[customer.FieldIsDefault] = struct{}{}
}

// IsDefaultCleared returns if the "isDefault" field was cleared in this mutation.
func (m *CustomerMutation) IsDefaultCleared() bool {
	_, ok := m.clearedFields[customer.FieldIsDefault]
	return ok
}

// ResetIsDefault resets all changes to the "isDefault" field.
func (m *CustomerMutation) ResetIsDefault() {
	m.isDefault = nil
	delete(m.clearedFields, customer.FieldIsDefault)
}

// SetName sets the "name" field.
func (m *CustomerMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *CustomerMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Customer entity.
// If the Customer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *CustomerMutation) ResetName() {
	m.name = nil
}

// SetPhone sets the "phone" field.
func (m *CustomerMutation) SetPhone(s string) {
	m.phone = &s
}

// Phone returns the value of the "phone" field in the mutation.
func (m *CustomerMutation) Phone() (r string, exists bool) {
	v := m.phone
	if v == nil {
		return
	}
	return *v, true
}

// OldPhone returns the old "phone" field's value of the Customer entity.
// If the Customer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerMutation) OldPhone(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPhone is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPhone requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPhone: %w", err)
	}
	return oldValue.Phone, nil
}

// ResetPhone resets all changes to the "phone" field.
func (m *CustomerMutation) ResetPhone() {
	m.phone = nil
}

// SetTaxId sets the "taxId" field.
func (m *CustomerMutation) SetTaxId(s string) {
	m.taxId = &s
}

// TaxId returns the value of the "taxId" field in the mutation.
func (m *CustomerMutation) TaxId() (r string, exists bool) {
	v := m.taxId
	if v == nil {
		return
	}
	return *v, true
}

// OldTaxId returns the old "taxId" field's value of the Customer entity.
// If the Customer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerMutation) OldTaxId(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTaxId is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTaxId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTaxId: %w", err)
	}
	return oldValue.TaxId, nil
}

// ResetTaxId resets all changes to the "taxId" field.
func (m *CustomerMutation) ResetTaxId() {
	m.taxId = nil
}

// SetCompanyID sets the "company" edge to the Company entity by id.
func (m *CustomerMutation) SetCompanyID(id int) {
	m.company = &id
}

// ClearCompany clears the "company" edge to the Company entity.
func (m *CustomerMutation) ClearCompany() {
	m.clearedcompany = true
}

// CompanyCleared reports if the "company" edge to the Company entity was cleared.
func (m *CustomerMutation) CompanyCleared() bool {
	return m.clearedcompany
}

// CompanyID returns the "company" edge ID in the mutation.
func (m *CustomerMutation) CompanyID() (id int, exists bool) {
	if m.company != nil {
		return *m.company, true
	}
	return
}

// CompanyIDs returns the "company" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CompanyID instead. It exists only for internal usage by the builders.
func (m *CustomerMutation) CompanyIDs() (ids []int) {
	if id := m.company; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCompany resets all changes to the "company" edge.
func (m *CustomerMutation) ResetCompany() {
	m.company = nil
	m.clearedcompany = false
}

// AddReceivableIDs adds the "receivables" edge to the Receivable entity by ids.
func (m *CustomerMutation) AddReceivableIDs(ids ...int) {
	if m.receivables == nil {
		m.receivables = make(map[int]struct{})
	}
	for i := range ids {
		m.receivables[ids[i]] = struct{}{}
	}
}

// ClearReceivables clears the "receivables" edge to the Receivable entity.
func (m *CustomerMutation) ClearReceivables() {
	m.clearedreceivables = true
}

// ReceivablesCleared reports if the "receivables" edge to the Receivable entity was cleared.
func (m *CustomerMutation) ReceivablesCleared() bool {
	return m.clearedreceivables
}

// RemoveReceivableIDs removes the "receivables" edge to the Receivable entity by IDs.
func (m *CustomerMutation) RemoveReceivableIDs(ids ...int) {
	if m.removedreceivables == nil {
		m.removedreceivables = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.receivables, ids[i])
		m.removedreceivables[ids[i]] = struct{}{}
	}
}

// RemovedReceivables returns the removed IDs of the "receivables" edge to the Receivable entity.
func (m *CustomerMutation) RemovedReceivablesIDs() (ids []int) {
	for id := range m.removedreceivables {
		ids = append(ids, id)
	}
	return
}

// ReceivablesIDs returns the "receivables" edge IDs in the mutation.
func (m *CustomerMutation) ReceivablesIDs() (ids []int) {
	for id := range m.receivables {
		ids = append(ids, id)
	}
	return
}

// ResetReceivables resets all changes to the "receivables" edge.
func (m *CustomerMutation) ResetReceivables() {
	m.receivables = nil
	m.clearedreceivables = false
	m.removedreceivables = nil
}

// Where appends a list predicates to the CustomerMutation builder.
func (m *CustomerMutation) Where(ps ...predicate.Customer) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CustomerMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CustomerMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Customer, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CustomerMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CustomerMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Customer).
func (m *CustomerMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CustomerMutation) Fields() []string {
	fields := make([]string, 0, 12)
	if m.createdAt != nil {
		fields = append(fields, customer.FieldCreatedAt)
	}
	if m.updatedAt != nil {
		fields = append(fields, customer.FieldUpdatedAt)
	}
	if m.deletedAt != nil {
		fields = append(fields, customer.FieldDeletedAt)
	}
	if m.address != nil {
		fields = append(fields, customer.FieldAddress)
	}
	if m.city != nil {
		fields = append(fields, customer.FieldCity)
	}
	if m.country != nil {
		fields = append(fields, customer.FieldCountry)
	}
	if m.description != nil {
		fields = append(fields, customer.FieldDescription)
	}
	if m.email != nil {
		fields = append(fields, customer.FieldEmail)
	}
	if m.isDefault != nil {
		fields = append(fields, customer.FieldIsDefault)
	}
	if m.name != nil {
		fields = append(fields, customer.FieldName)
	}
	if m.phone != nil {
		fields = append(fields, customer.FieldPhone)
	}
	if m.taxId != nil {
		fields = append(fields, customer.FieldTaxId)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CustomerMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case customer.FieldCreatedAt:
		return m.CreatedAt()
	case customer.FieldUpdatedAt:
		return m.UpdatedAt()
	case customer.FieldDeletedAt:
		return m.DeletedAt()
	case customer.FieldAddress:
		return m.Address()
	case customer.FieldCity:
		return m.City()
	case customer.FieldCountry:
		return m.Country()
	case customer.FieldDescription:
		return m.Description()
	case customer.FieldEmail:
		return m.Email()
	case customer.FieldIsDefault:
		return m.IsDefault()
	case customer.FieldName:
		return m.Name()
	case customer.FieldPhone:
		return m.Phone()
	case customer.FieldTaxId:
		return m.TaxId()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CustomerMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case customer.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case customer.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case customer.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case customer.FieldAddress:
		return m.OldAddress(ctx)
	case customer.FieldCity:
		return m.OldCity(ctx)
	case customer.FieldCountry:
		return m.OldCountry(ctx)
	case customer.FieldDescription:
		return m.OldDescription(ctx)
	case customer.FieldEmail:
		return m.OldEmail(ctx)
	case customer.FieldIsDefault:
		return m.OldIsDefault(ctx)
	case customer.FieldName:
		return m.OldName(ctx)
	case customer.FieldPhone:
		return m.OldPhone(ctx)
	case customer.FieldTaxId:
		return m.OldTaxId(ctx)
	}
	return nil, fmt.Errorf("unknown Customer field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CustomerMutation) SetField(name string, value ent.Value) error {
	switch name {
	case customer.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case customer.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case customer.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case customer.FieldAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAddress(v)
		return nil
	case customer.FieldCity:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCity(v)
		return nil
	case customer.FieldCountry:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCountry(v)
		return nil
	case customer.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case customer.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case customer.FieldIsDefault:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsDefault(v)
		return nil
	case customer.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case customer.FieldPhone:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPhone(v)
		return nil
	case customer.FieldTaxId:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTaxId(v)
		return nil
	}
	return fmt.Errorf("unknown Customer field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CustomerMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CustomerMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CustomerMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Customer numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CustomerMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(customer.FieldDeletedAt) {
		fields = append(fields, customer.FieldDeletedAt)
	}
	if m.FieldCleared(customer.FieldDescription) {
		fields = append(fields, customer.FieldDescription)
	}
	if m.FieldCleared(customer.FieldEmail) {
		fields = append(fields, customer.FieldEmail)
	}
	if m.FieldCleared(customer.FieldIsDefault) {
		fields = append(fields, customer.FieldIsDefault)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CustomerMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CustomerMutation) ClearField(name string) error {
	switch name {
	case customer.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case customer.FieldDescription:
		m.ClearDescription()
		return nil
	case customer.FieldEmail:
		m.ClearEmail()
		return nil
	case customer.FieldIsDefault:
		m.ClearIsDefault()
		return nil
	}
	return fmt.Errorf("unknown Customer nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CustomerMutation) ResetField(name string) error {
	switch name {
	case customer.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case customer.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case customer.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case customer.FieldAddress:
		m.ResetAddress()
		return nil
	case customer.FieldCity:
		m.ResetCity()
		return nil
	case customer.FieldCountry:
		m.ResetCountry()
		return nil
	case customer.FieldDescription:
		m.ResetDescription()
		return nil
	case customer.FieldEmail:
		m.ResetEmail()
		return nil
	case customer.FieldIsDefault:
		m.ResetIsDefault()
		return nil
	case customer.FieldName:
		m.ResetName()
		return nil
	case customer.FieldPhone:
		m.ResetPhone()
		return nil
	case customer.FieldTaxId:
		m.ResetTaxId()
		return nil
	}
	return fmt.Errorf("unknown Customer field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CustomerMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.company != nil {
		edges = append(edges, customer.EdgeCompany)
	}
	if m.receivables != nil {
		edges = append(edges, customer.EdgeReceivables)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CustomerMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case customer.EdgeCompany:
		if id := m.company; id != nil {
			return []ent.Value{*id}
		}
	case customer.EdgeReceivables:
		ids := make([]ent.Value, 0, len(m.receivables))
		for id := range m.receivables {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CustomerMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedreceivables != nil {
		edges = append(edges, customer.EdgeReceivables)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CustomerMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case customer.EdgeReceivables:
		ids := make([]ent.Value, 0, len(m.removedreceivables))
		for id := range m.removedreceivables {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CustomerMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedcompany {
		edges = append(edges, customer.EdgeCompany)
	}
	if m.clearedreceivables {
		edges = append(edges, customer.EdgeReceivables)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CustomerMutation) EdgeCleared(name string) bool {
	switch name {
	case customer.EdgeCompany:
		return m.clearedcompany
	case customer.EdgeReceivables:
		return m.clearedreceivables
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CustomerMutation) ClearEdge(name string) error {
	switch name {
	case customer.EdgeCompany:
		m.ClearCompany()
		return nil
	}
	return fmt.Errorf("unknown Customer unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CustomerMutation) ResetEdge(name string) error {
	switch name {
	case customer.EdgeCompany:
		m.ResetCompany()
		return nil
	case customer.EdgeReceivables:
		m.ResetReceivables()
		return nil
	}
	return fmt.Errorf("unknown Customer edge %s", name)
}

// EmployeeMutation represents an operation that mutates the Employee nodes in the graph.
type EmployeeMutation struct {
	config
	op             Op
	typ            string
	id             *int
	createdAt      *time.Time
	updatedAt      *time.Time
	deletedAt      *time.Time
	name           *string
	gender         *employee.Gender
	position       *string
	email          *string
	phone          *string
	clearedFields  map[string]struct{}
	company        *int
	clearedcompany bool
	user           *int
	cleareduser    bool
	done           bool
	oldValue       func(context.Context) (*Employee, error)
	predicates     []predicate.Employee
}

var _ ent.Mutation = (*EmployeeMutation)(nil)

// employeeOption allows management of the mutation configuration using functional options.
type employeeOption func(*EmployeeMutation)

// newEmployeeMutation creates new mutation for the Employee entity.
func newEmployeeMutation(c config, op Op, opts ...employeeOption) *EmployeeMutation {
	m := &EmployeeMutation{
		config:        c,
		op:            op,
		typ:           TypeEmployee,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withEmployeeID sets the ID field of the mutation.
func withEmployeeID(id int) employeeOption {
	return func(m *EmployeeMutation) {
		var (
			err   error
			once  sync.Once
			value *Employee
		)
		m.oldValue = func(ctx context.Context) (*Employee, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Employee.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withEmployee sets the old Employee of the mutation.
func withEmployee(node *Employee) employeeOption {
	return func(m *EmployeeMutation) {
		m.oldValue = func(context.Context) (*Employee, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m EmployeeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m EmployeeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("generated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *EmployeeMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *EmployeeMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Employee.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "createdAt" field.
func (m *EmployeeMutation) SetCreatedAt(t time.Time) {
	m.createdAt = &t
}

// CreatedAt returns the value of the "createdAt" field in the mutation.
func (m *EmployeeMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.createdAt
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "createdAt" field's value of the Employee entity.
// If the Employee object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeeMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "createdAt" field.
func (m *EmployeeMutation) ResetCreatedAt() {
	m.createdAt = nil
}

// SetUpdatedAt sets the "updatedAt" field.
func (m *EmployeeMutation) SetUpdatedAt(t time.Time) {
	m.updatedAt = &t
}

// UpdatedAt returns the value of the "updatedAt" field in the mutation.
func (m *EmployeeMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updatedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updatedAt" field's value of the Employee entity.
// If the Employee object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeeMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updatedAt" field.
func (m *EmployeeMutation) ResetUpdatedAt() {
	m.updatedAt = nil
}

// SetDeletedAt sets the "deletedAt" field.
func (m *EmployeeMutation) SetDeletedAt(t time.Time) {
	m.deletedAt = &t
}

// DeletedAt returns the value of the "deletedAt" field in the mutation.
func (m *EmployeeMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deletedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deletedAt" field's value of the Employee entity.
// If the Employee object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeeMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deletedAt" field.
func (m *EmployeeMutation) ClearDeletedAt() {
	m.deletedAt = nil
	m.clearedFields[employee.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deletedAt" field was cleared in this mutation.
func (m *EmployeeMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[employee.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deletedAt" field.
func (m *EmployeeMutation) ResetDeletedAt() {
	m.deletedAt = nil
	delete(m.clearedFields, employee.FieldDeletedAt)
}

// SetName sets the "name" field.
func (m *EmployeeMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *EmployeeMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Employee entity.
// If the Employee object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeeMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *EmployeeMutation) ResetName() {
	m.name = nil
}

// SetGender sets the "gender" field.
func (m *EmployeeMutation) SetGender(e employee.Gender) {
	m.gender = &e
}

// Gender returns the value of the "gender" field in the mutation.
func (m *EmployeeMutation) Gender() (r employee.Gender, exists bool) {
	v := m.gender
	if v == nil {
		return
	}
	return *v, true
}

// OldGender returns the old "gender" field's value of the Employee entity.
// If the Employee object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeeMutation) OldGender(ctx context.Context) (v employee.Gender, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGender is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGender requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGender: %w", err)
	}
	return oldValue.Gender, nil
}

// ResetGender resets all changes to the "gender" field.
func (m *EmployeeMutation) ResetGender() {
	m.gender = nil
}

// SetPosition sets the "position" field.
func (m *EmployeeMutation) SetPosition(s string) {
	m.position = &s
}

// Position returns the value of the "position" field in the mutation.
func (m *EmployeeMutation) Position() (r string, exists bool) {
	v := m.position
	if v == nil {
		return
	}
	return *v, true
}

// OldPosition returns the old "position" field's value of the Employee entity.
// If the Employee object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeeMutation) OldPosition(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPosition is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPosition requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPosition: %w", err)
	}
	return oldValue.Position, nil
}

// ClearPosition clears the value of the "position" field.
func (m *EmployeeMutation) ClearPosition() {
	m.position = nil
	m.clearedFields[employee.FieldPosition] = struct{}{}
}

// PositionCleared returns if the "position" field was cleared in this mutation.
func (m *EmployeeMutation) PositionCleared() bool {
	_, ok := m.clearedFields[employee.FieldPosition]
	return ok
}

// ResetPosition resets all changes to the "position" field.
func (m *EmployeeMutation) ResetPosition() {
	m.position = nil
	delete(m.clearedFields, employee.FieldPosition)
}

// SetEmail sets the "email" field.
func (m *EmployeeMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *EmployeeMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the Employee entity.
// If the Employee object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeeMutation) OldEmail(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ClearEmail clears the value of the "email" field.
func (m *EmployeeMutation) ClearEmail() {
	m.email = nil
	m.clearedFields[employee.FieldEmail] = struct{}{}
}

// EmailCleared returns if the "email" field was cleared in this mutation.
func (m *EmployeeMutation) EmailCleared() bool {
	_, ok := m.clearedFields[employee.FieldEmail]
	return ok
}

// ResetEmail resets all changes to the "email" field.
func (m *EmployeeMutation) ResetEmail() {
	m.email = nil
	delete(m.clearedFields, employee.FieldEmail)
}

// SetPhone sets the "phone" field.
func (m *EmployeeMutation) SetPhone(s string) {
	m.phone = &s
}

// Phone returns the value of the "phone" field in the mutation.
func (m *EmployeeMutation) Phone() (r string, exists bool) {
	v := m.phone
	if v == nil {
		return
	}
	return *v, true
}

// OldPhone returns the old "phone" field's value of the Employee entity.
// If the Employee object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeeMutation) OldPhone(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPhone is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPhone requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPhone: %w", err)
	}
	return oldValue.Phone, nil
}

// ResetPhone resets all changes to the "phone" field.
func (m *EmployeeMutation) ResetPhone() {
	m.phone = nil
}

// SetCompanyID sets the "company" edge to the Company entity by id.
func (m *EmployeeMutation) SetCompanyID(id int) {
	m.company = &id
}

// ClearCompany clears the "company" edge to the Company entity.
func (m *EmployeeMutation) ClearCompany() {
	m.clearedcompany = true
}

// CompanyCleared reports if the "company" edge to the Company entity was cleared.
func (m *EmployeeMutation) CompanyCleared() bool {
	return m.clearedcompany
}

// CompanyID returns the "company" edge ID in the mutation.
func (m *EmployeeMutation) CompanyID() (id int, exists bool) {
	if m.company != nil {
		return *m.company, true
	}
	return
}

// CompanyIDs returns the "company" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CompanyID instead. It exists only for internal usage by the builders.
func (m *EmployeeMutation) CompanyIDs() (ids []int) {
	if id := m.company; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCompany resets all changes to the "company" edge.
func (m *EmployeeMutation) ResetCompany() {
	m.company = nil
	m.clearedcompany = false
}

// SetUserID sets the "user" edge to the User entity by id.
func (m *EmployeeMutation) SetUserID(id int) {
	m.user = &id
}

// ClearUser clears the "user" edge to the User entity.
func (m *EmployeeMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *EmployeeMutation) UserCleared() bool {
	return m.cleareduser
}

// UserID returns the "user" edge ID in the mutation.
func (m *EmployeeMutation) UserID() (id int, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *EmployeeMutation) UserIDs() (ids []int) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *EmployeeMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the EmployeeMutation builder.
func (m *EmployeeMutation) Where(ps ...predicate.Employee) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the EmployeeMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *EmployeeMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Employee, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *EmployeeMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *EmployeeMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Employee).
func (m *EmployeeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *EmployeeMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.createdAt != nil {
		fields = append(fields, employee.FieldCreatedAt)
	}
	if m.updatedAt != nil {
		fields = append(fields, employee.FieldUpdatedAt)
	}
	if m.deletedAt != nil {
		fields = append(fields, employee.FieldDeletedAt)
	}
	if m.name != nil {
		fields = append(fields, employee.FieldName)
	}
	if m.gender != nil {
		fields = append(fields, employee.FieldGender)
	}
	if m.position != nil {
		fields = append(fields, employee.FieldPosition)
	}
	if m.email != nil {
		fields = append(fields, employee.FieldEmail)
	}
	if m.phone != nil {
		fields = append(fields, employee.FieldPhone)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *EmployeeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case employee.FieldCreatedAt:
		return m.CreatedAt()
	case employee.FieldUpdatedAt:
		return m.UpdatedAt()
	case employee.FieldDeletedAt:
		return m.DeletedAt()
	case employee.FieldName:
		return m.Name()
	case employee.FieldGender:
		return m.Gender()
	case employee.FieldPosition:
		return m.Position()
	case employee.FieldEmail:
		return m.Email()
	case employee.FieldPhone:
		return m.Phone()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *EmployeeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case employee.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case employee.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case employee.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case employee.FieldName:
		return m.OldName(ctx)
	case employee.FieldGender:
		return m.OldGender(ctx)
	case employee.FieldPosition:
		return m.OldPosition(ctx)
	case employee.FieldEmail:
		return m.OldEmail(ctx)
	case employee.FieldPhone:
		return m.OldPhone(ctx)
	}
	return nil, fmt.Errorf("unknown Employee field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EmployeeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case employee.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case employee.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case employee.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case employee.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case employee.FieldGender:
		v, ok := value.(employee.Gender)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGender(v)
		return nil
	case employee.FieldPosition:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPosition(v)
		return nil
	case employee.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case employee.FieldPhone:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPhone(v)
		return nil
	}
	return fmt.Errorf("unknown Employee field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *EmployeeMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *EmployeeMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EmployeeMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Employee numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *EmployeeMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(employee.FieldDeletedAt) {
		fields = append(fields, employee.FieldDeletedAt)
	}
	if m.FieldCleared(employee.FieldPosition) {
		fields = append(fields, employee.FieldPosition)
	}
	if m.FieldCleared(employee.FieldEmail) {
		fields = append(fields, employee.FieldEmail)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *EmployeeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *EmployeeMutation) ClearField(name string) error {
	switch name {
	case employee.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case employee.FieldPosition:
		m.ClearPosition()
		return nil
	case employee.FieldEmail:
		m.ClearEmail()
		return nil
	}
	return fmt.Errorf("unknown Employee nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *EmployeeMutation) ResetField(name string) error {
	switch name {
	case employee.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case employee.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case employee.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case employee.FieldName:
		m.ResetName()
		return nil
	case employee.FieldGender:
		m.ResetGender()
		return nil
	case employee.FieldPosition:
		m.ResetPosition()
		return nil
	case employee.FieldEmail:
		m.ResetEmail()
		return nil
	case employee.FieldPhone:
		m.ResetPhone()
		return nil
	}
	return fmt.Errorf("unknown Employee field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *EmployeeMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.company != nil {
		edges = append(edges, employee.EdgeCompany)
	}
	if m.user != nil {
		edges = append(edges, employee.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *EmployeeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case employee.EdgeCompany:
		if id := m.company; id != nil {
			return []ent.Value{*id}
		}
	case employee.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *EmployeeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *EmployeeMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *EmployeeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedcompany {
		edges = append(edges, employee.EdgeCompany)
	}
	if m.cleareduser {
		edges = append(edges, employee.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *EmployeeMutation) EdgeCleared(name string) bool {
	switch name {
	case employee.EdgeCompany:
		return m.clearedcompany
	case employee.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *EmployeeMutation) ClearEdge(name string) error {
	switch name {
	case employee.EdgeCompany:
		m.ClearCompany()
		return nil
	case employee.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown Employee unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *EmployeeMutation) ResetEdge(name string) error {
	switch name {
	case employee.EdgeCompany:
		m.ResetCompany()
		return nil
	case employee.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown Employee edge %s", name)
}

// FileMutation represents an operation that mutates the File nodes in the graph.
type FileMutation struct {
	config
	op             Op
	typ            string
	id             *int
	createdAt      *time.Time
	updatedAt      *time.Time
	deletedAt      *time.Time
	category       *file.Category
	extension      *string
	size           *string
	uri            *string
	url            *string
	description    *string
	clearedFields  map[string]struct{}
	company        *int
	clearedcompany bool
	done           bool
	oldValue       func(context.Context) (*File, error)
	predicates     []predicate.File
}

var _ ent.Mutation = (*FileMutation)(nil)

// fileOption allows management of the mutation configuration using functional options.
type fileOption func(*FileMutation)

// newFileMutation creates new mutation for the File entity.
func newFileMutation(c config, op Op, opts ...fileOption) *FileMutation {
	m := &FileMutation{
		config:        c,
		op:            op,
		typ:           TypeFile,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withFileID sets the ID field of the mutation.
func withFileID(id int) fileOption {
	return func(m *FileMutation) {
		var (
			err   error
			once  sync.Once
			value *File
		)
		m.oldValue = func(ctx context.Context) (*File, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().File.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withFile sets the old File of the mutation.
func withFile(node *File) fileOption {
	return func(m *FileMutation) {
		m.oldValue = func(context.Context) (*File, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m FileMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m FileMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("generated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *FileMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *FileMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().File.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "createdAt" field.
func (m *FileMutation) SetCreatedAt(t time.Time) {
	m.createdAt = &t
}

// CreatedAt returns the value of the "createdAt" field in the mutation.
func (m *FileMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.createdAt
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "createdAt" field's value of the File entity.
// If the File object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "createdAt" field.
func (m *FileMutation) ResetCreatedAt() {
	m.createdAt = nil
}

// SetUpdatedAt sets the "updatedAt" field.
func (m *FileMutation) SetUpdatedAt(t time.Time) {
	m.updatedAt = &t
}

// UpdatedAt returns the value of the "updatedAt" field in the mutation.
func (m *FileMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updatedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updatedAt" field's value of the File entity.
// If the File object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updatedAt" field.
func (m *FileMutation) ResetUpdatedAt() {
	m.updatedAt = nil
}

// SetDeletedAt sets the "deletedAt" field.
func (m *FileMutation) SetDeletedAt(t time.Time) {
	m.deletedAt = &t
}

// DeletedAt returns the value of the "deletedAt" field in the mutation.
func (m *FileMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deletedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deletedAt" field's value of the File entity.
// If the File object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deletedAt" field.
func (m *FileMutation) ClearDeletedAt() {
	m.deletedAt = nil
	m.clearedFields[file.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deletedAt" field was cleared in this mutation.
func (m *FileMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[file.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deletedAt" field.
func (m *FileMutation) ResetDeletedAt() {
	m.deletedAt = nil
	delete(m.clearedFields, file.FieldDeletedAt)
}

// SetCategory sets the "category" field.
func (m *FileMutation) SetCategory(f file.Category) {
	m.category = &f
}

// Category returns the value of the "category" field in the mutation.
func (m *FileMutation) Category() (r file.Category, exists bool) {
	v := m.category
	if v == nil {
		return
	}
	return *v, true
}

// OldCategory returns the old "category" field's value of the File entity.
// If the File object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileMutation) OldCategory(ctx context.Context) (v file.Category, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCategory is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCategory requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCategory: %w", err)
	}
	return oldValue.Category, nil
}

// ResetCategory resets all changes to the "category" field.
func (m *FileMutation) ResetCategory() {
	m.category = nil
}

// SetExtension sets the "extension" field.
func (m *FileMutation) SetExtension(s string) {
	m.extension = &s
}

// Extension returns the value of the "extension" field in the mutation.
func (m *FileMutation) Extension() (r string, exists bool) {
	v := m.extension
	if v == nil {
		return
	}
	return *v, true
}

// OldExtension returns the old "extension" field's value of the File entity.
// If the File object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileMutation) OldExtension(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExtension is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExtension requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExtension: %w", err)
	}
	return oldValue.Extension, nil
}

// ResetExtension resets all changes to the "extension" field.
func (m *FileMutation) ResetExtension() {
	m.extension = nil
}

// SetSize sets the "size" field.
func (m *FileMutation) SetSize(s string) {
	m.size = &s
}

// Size returns the value of the "size" field in the mutation.
func (m *FileMutation) Size() (r string, exists bool) {
	v := m.size
	if v == nil {
		return
	}
	return *v, true
}

// OldSize returns the old "size" field's value of the File entity.
// If the File object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileMutation) OldSize(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSize is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSize requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSize: %w", err)
	}
	return oldValue.Size, nil
}

// ResetSize resets all changes to the "size" field.
func (m *FileMutation) ResetSize() {
	m.size = nil
}

// SetURI sets the "uri" field.
func (m *FileMutation) SetURI(s string) {
	m.uri = &s
}

// URI returns the value of the "uri" field in the mutation.
func (m *FileMutation) URI() (r string, exists bool) {
	v := m.uri
	if v == nil {
		return
	}
	return *v, true
}

// OldURI returns the old "uri" field's value of the File entity.
// If the File object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileMutation) OldURI(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldURI is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldURI requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldURI: %w", err)
	}
	return oldValue.URI, nil
}

// ResetURI resets all changes to the "uri" field.
func (m *FileMutation) ResetURI() {
	m.uri = nil
}

// SetURL sets the "url" field.
func (m *FileMutation) SetURL(s string) {
	m.url = &s
}

// URL returns the value of the "url" field in the mutation.
func (m *FileMutation) URL() (r string, exists bool) {
	v := m.url
	if v == nil {
		return
	}
	return *v, true
}

// OldURL returns the old "url" field's value of the File entity.
// If the File object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileMutation) OldURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldURL: %w", err)
	}
	return oldValue.URL, nil
}

// ResetURL resets all changes to the "url" field.
func (m *FileMutation) ResetURL() {
	m.url = nil
}

// SetDescription sets the "description" field.
func (m *FileMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *FileMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the File entity.
// If the File object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *FileMutation) ResetDescription() {
	m.description = nil
}

// SetCompanyID sets the "company" edge to the Company entity by id.
func (m *FileMutation) SetCompanyID(id int) {
	m.company = &id
}

// ClearCompany clears the "company" edge to the Company entity.
func (m *FileMutation) ClearCompany() {
	m.clearedcompany = true
}

// CompanyCleared reports if the "company" edge to the Company entity was cleared.
func (m *FileMutation) CompanyCleared() bool {
	return m.clearedcompany
}

// CompanyID returns the "company" edge ID in the mutation.
func (m *FileMutation) CompanyID() (id int, exists bool) {
	if m.company != nil {
		return *m.company, true
	}
	return
}

// CompanyIDs returns the "company" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CompanyID instead. It exists only for internal usage by the builders.
func (m *FileMutation) CompanyIDs() (ids []int) {
	if id := m.company; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCompany resets all changes to the "company" edge.
func (m *FileMutation) ResetCompany() {
	m.company = nil
	m.clearedcompany = false
}

// Where appends a list predicates to the FileMutation builder.
func (m *FileMutation) Where(ps ...predicate.File) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the FileMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *FileMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.File, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *FileMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *FileMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (File).
func (m *FileMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *FileMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.createdAt != nil {
		fields = append(fields, file.FieldCreatedAt)
	}
	if m.updatedAt != nil {
		fields = append(fields, file.FieldUpdatedAt)
	}
	if m.deletedAt != nil {
		fields = append(fields, file.FieldDeletedAt)
	}
	if m.category != nil {
		fields = append(fields, file.FieldCategory)
	}
	if m.extension != nil {
		fields = append(fields, file.FieldExtension)
	}
	if m.size != nil {
		fields = append(fields, file.FieldSize)
	}
	if m.uri != nil {
		fields = append(fields, file.FieldURI)
	}
	if m.url != nil {
		fields = append(fields, file.FieldURL)
	}
	if m.description != nil {
		fields = append(fields, file.FieldDescription)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *FileMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case file.FieldCreatedAt:
		return m.CreatedAt()
	case file.FieldUpdatedAt:
		return m.UpdatedAt()
	case file.FieldDeletedAt:
		return m.DeletedAt()
	case file.FieldCategory:
		return m.Category()
	case file.FieldExtension:
		return m.Extension()
	case file.FieldSize:
		return m.Size()
	case file.FieldURI:
		return m.URI()
	case file.FieldURL:
		return m.URL()
	case file.FieldDescription:
		return m.Description()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *FileMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case file.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case file.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case file.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case file.FieldCategory:
		return m.OldCategory(ctx)
	case file.FieldExtension:
		return m.OldExtension(ctx)
	case file.FieldSize:
		return m.OldSize(ctx)
	case file.FieldURI:
		return m.OldURI(ctx)
	case file.FieldURL:
		return m.OldURL(ctx)
	case file.FieldDescription:
		return m.OldDescription(ctx)
	}
	return nil, fmt.Errorf("unknown File field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FileMutation) SetField(name string, value ent.Value) error {
	switch name {
	case file.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case file.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case file.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case file.FieldCategory:
		v, ok := value.(file.Category)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCategory(v)
		return nil
	case file.FieldExtension:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExtension(v)
		return nil
	case file.FieldSize:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSize(v)
		return nil
	case file.FieldURI:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetURI(v)
		return nil
	case file.FieldURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetURL(v)
		return nil
	case file.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	}
	return fmt.Errorf("unknown File field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *FileMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *FileMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FileMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown File numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *FileMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(file.FieldDeletedAt) {
		fields = append(fields, file.FieldDeletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *FileMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *FileMutation) ClearField(name string) error {
	switch name {
	case file.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown File nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *FileMutation) ResetField(name string) error {
	switch name {
	case file.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case file.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case file.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case file.FieldCategory:
		m.ResetCategory()
		return nil
	case file.FieldExtension:
		m.ResetExtension()
		return nil
	case file.FieldSize:
		m.ResetSize()
		return nil
	case file.FieldURI:
		m.ResetURI()
		return nil
	case file.FieldURL:
		m.ResetURL()
		return nil
	case file.FieldDescription:
		m.ResetDescription()
		return nil
	}
	return fmt.Errorf("unknown File field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *FileMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.company != nil {
		edges = append(edges, file.EdgeCompany)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *FileMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case file.EdgeCompany:
		if id := m.company; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *FileMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *FileMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *FileMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedcompany {
		edges = append(edges, file.EdgeCompany)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *FileMutation) EdgeCleared(name string) bool {
	switch name {
	case file.EdgeCompany:
		return m.clearedcompany
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *FileMutation) ClearEdge(name string) error {
	switch name {
	case file.EdgeCompany:
		m.ClearCompany()
		return nil
	}
	return fmt.Errorf("unknown File unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *FileMutation) ResetEdge(name string) error {
	switch name {
	case file.EdgeCompany:
		m.ResetCompany()
		return nil
	}
	return fmt.Errorf("unknown File edge %s", name)
}

// PayableMutation represents an operation that mutates the Payable nodes in the graph.
type PayableMutation struct {
	config
	op                    Op
	typ                   string
	id                    *int
	createdAt             *time.Time
	updatedAt             *time.Time
	deletedAt             *time.Time
	entryGroup            *int
	addentryGroup         *int
	date                  *time.Time
	name                  *string
	outstandingBalance    *float64
	addoutstandingBalance *float64
	totalTransaction      *float64
	addtotalTransaction   *float64
	dueDate               *time.Time
	status                *payable.Status
	clearedFields         map[string]struct{}
	company               *int
	clearedcompany        bool
	done                  bool
	oldValue              func(context.Context) (*Payable, error)
	predicates            []predicate.Payable
}

var _ ent.Mutation = (*PayableMutation)(nil)

// payableOption allows management of the mutation configuration using functional options.
type payableOption func(*PayableMutation)

// newPayableMutation creates new mutation for the Payable entity.
func newPayableMutation(c config, op Op, opts ...payableOption) *PayableMutation {
	m := &PayableMutation{
		config:        c,
		op:            op,
		typ:           TypePayable,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPayableID sets the ID field of the mutation.
func withPayableID(id int) payableOption {
	return func(m *PayableMutation) {
		var (
			err   error
			once  sync.Once
			value *Payable
		)
		m.oldValue = func(ctx context.Context) (*Payable, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Payable.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPayable sets the old Payable of the mutation.
func withPayable(node *Payable) payableOption {
	return func(m *PayableMutation) {
		m.oldValue = func(context.Context) (*Payable, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PayableMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PayableMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("generated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PayableMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PayableMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Payable.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "createdAt" field.
func (m *PayableMutation) SetCreatedAt(t time.Time) {
	m.createdAt = &t
}

// CreatedAt returns the value of the "createdAt" field in the mutation.
func (m *PayableMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.createdAt
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "createdAt" field's value of the Payable entity.
// If the Payable object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PayableMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "createdAt" field.
func (m *PayableMutation) ResetCreatedAt() {
	m.createdAt = nil
}

// SetUpdatedAt sets the "updatedAt" field.
func (m *PayableMutation) SetUpdatedAt(t time.Time) {
	m.updatedAt = &t
}

// UpdatedAt returns the value of the "updatedAt" field in the mutation.
func (m *PayableMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updatedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updatedAt" field's value of the Payable entity.
// If the Payable object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PayableMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updatedAt" field.
func (m *PayableMutation) ResetUpdatedAt() {
	m.updatedAt = nil
}

// SetDeletedAt sets the "deletedAt" field.
func (m *PayableMutation) SetDeletedAt(t time.Time) {
	m.deletedAt = &t
}

// DeletedAt returns the value of the "deletedAt" field in the mutation.
func (m *PayableMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deletedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deletedAt" field's value of the Payable entity.
// If the Payable object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PayableMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deletedAt" field.
func (m *PayableMutation) ClearDeletedAt() {
	m.deletedAt = nil
	m.clearedFields[payable.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deletedAt" field was cleared in this mutation.
func (m *PayableMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[payable.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deletedAt" field.
func (m *PayableMutation) ResetDeletedAt() {
	m.deletedAt = nil
	delete(m.clearedFields, payable.FieldDeletedAt)
}

// SetEntryGroup sets the "entryGroup" field.
func (m *PayableMutation) SetEntryGroup(i int) {
	m.entryGroup = &i
	m.addentryGroup = nil
}

// EntryGroup returns the value of the "entryGroup" field in the mutation.
func (m *PayableMutation) EntryGroup() (r int, exists bool) {
	v := m.entryGroup
	if v == nil {
		return
	}
	return *v, true
}

// OldEntryGroup returns the old "entryGroup" field's value of the Payable entity.
// If the Payable object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PayableMutation) OldEntryGroup(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEntryGroup is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEntryGroup requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEntryGroup: %w", err)
	}
	return oldValue.EntryGroup, nil
}

// AddEntryGroup adds i to the "entryGroup" field.
func (m *PayableMutation) AddEntryGroup(i int) {
	if m.addentryGroup != nil {
		*m.addentryGroup += i
	} else {
		m.addentryGroup = &i
	}
}

// AddedEntryGroup returns the value that was added to the "entryGroup" field in this mutation.
func (m *PayableMutation) AddedEntryGroup() (r int, exists bool) {
	v := m.addentryGroup
	if v == nil {
		return
	}
	return *v, true
}

// ResetEntryGroup resets all changes to the "entryGroup" field.
func (m *PayableMutation) ResetEntryGroup() {
	m.entryGroup = nil
	m.addentryGroup = nil
}

// SetDate sets the "date" field.
func (m *PayableMutation) SetDate(t time.Time) {
	m.date = &t
}

// Date returns the value of the "date" field in the mutation.
func (m *PayableMutation) Date() (r time.Time, exists bool) {
	v := m.date
	if v == nil {
		return
	}
	return *v, true
}

// OldDate returns the old "date" field's value of the Payable entity.
// If the Payable object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PayableMutation) OldDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDate: %w", err)
	}
	return oldValue.Date, nil
}

// ResetDate resets all changes to the "date" field.
func (m *PayableMutation) ResetDate() {
	m.date = nil
}

// SetName sets the "name" field.
func (m *PayableMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *PayableMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Payable entity.
// If the Payable object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PayableMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *PayableMutation) ResetName() {
	m.name = nil
}

// SetOutstandingBalance sets the "outstandingBalance" field.
func (m *PayableMutation) SetOutstandingBalance(f float64) {
	m.outstandingBalance = &f
	m.addoutstandingBalance = nil
}

// OutstandingBalance returns the value of the "outstandingBalance" field in the mutation.
func (m *PayableMutation) OutstandingBalance() (r float64, exists bool) {
	v := m.outstandingBalance
	if v == nil {
		return
	}
	return *v, true
}

// OldOutstandingBalance returns the old "outstandingBalance" field's value of the Payable entity.
// If the Payable object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PayableMutation) OldOutstandingBalance(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOutstandingBalance is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOutstandingBalance requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOutstandingBalance: %w", err)
	}
	return oldValue.OutstandingBalance, nil
}

// AddOutstandingBalance adds f to the "outstandingBalance" field.
func (m *PayableMutation) AddOutstandingBalance(f float64) {
	if m.addoutstandingBalance != nil {
		*m.addoutstandingBalance += f
	} else {
		m.addoutstandingBalance = &f
	}
}

// AddedOutstandingBalance returns the value that was added to the "outstandingBalance" field in this mutation.
func (m *PayableMutation) AddedOutstandingBalance() (r float64, exists bool) {
	v := m.addoutstandingBalance
	if v == nil {
		return
	}
	return *v, true
}

// ResetOutstandingBalance resets all changes to the "outstandingBalance" field.
func (m *PayableMutation) ResetOutstandingBalance() {
	m.outstandingBalance = nil
	m.addoutstandingBalance = nil
}

// SetTotalTransaction sets the "totalTransaction" field.
func (m *PayableMutation) SetTotalTransaction(f float64) {
	m.totalTransaction = &f
	m.addtotalTransaction = nil
}

// TotalTransaction returns the value of the "totalTransaction" field in the mutation.
func (m *PayableMutation) TotalTransaction() (r float64, exists bool) {
	v := m.totalTransaction
	if v == nil {
		return
	}
	return *v, true
}

// OldTotalTransaction returns the old "totalTransaction" field's value of the Payable entity.
// If the Payable object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PayableMutation) OldTotalTransaction(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTotalTransaction is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTotalTransaction requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTotalTransaction: %w", err)
	}
	return oldValue.TotalTransaction, nil
}

// AddTotalTransaction adds f to the "totalTransaction" field.
func (m *PayableMutation) AddTotalTransaction(f float64) {
	if m.addtotalTransaction != nil {
		*m.addtotalTransaction += f
	} else {
		m.addtotalTransaction = &f
	}
}

// AddedTotalTransaction returns the value that was added to the "totalTransaction" field in this mutation.
func (m *PayableMutation) AddedTotalTransaction() (r float64, exists bool) {
	v := m.addtotalTransaction
	if v == nil {
		return
	}
	return *v, true
}

// ResetTotalTransaction resets all changes to the "totalTransaction" field.
func (m *PayableMutation) ResetTotalTransaction() {
	m.totalTransaction = nil
	m.addtotalTransaction = nil
}

// SetDueDate sets the "dueDate" field.
func (m *PayableMutation) SetDueDate(t time.Time) {
	m.dueDate = &t
}

// DueDate returns the value of the "dueDate" field in the mutation.
func (m *PayableMutation) DueDate() (r time.Time, exists bool) {
	v := m.dueDate
	if v == nil {
		return
	}
	return *v, true
}

// OldDueDate returns the old "dueDate" field's value of the Payable entity.
// If the Payable object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PayableMutation) OldDueDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDueDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDueDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDueDate: %w", err)
	}
	return oldValue.DueDate, nil
}

// ResetDueDate resets all changes to the "dueDate" field.
func (m *PayableMutation) ResetDueDate() {
	m.dueDate = nil
}

// SetStatus sets the "status" field.
func (m *PayableMutation) SetStatus(pa payable.Status) {
	m.status = &pa
}

// Status returns the value of the "status" field in the mutation.
func (m *PayableMutation) Status() (r payable.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Payable entity.
// If the Payable object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PayableMutation) OldStatus(ctx context.Context) (v payable.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *PayableMutation) ResetStatus() {
	m.status = nil
}

// SetCompanyID sets the "company" edge to the Company entity by id.
func (m *PayableMutation) SetCompanyID(id int) {
	m.company = &id
}

// ClearCompany clears the "company" edge to the Company entity.
func (m *PayableMutation) ClearCompany() {
	m.clearedcompany = true
}

// CompanyCleared reports if the "company" edge to the Company entity was cleared.
func (m *PayableMutation) CompanyCleared() bool {
	return m.clearedcompany
}

// CompanyID returns the "company" edge ID in the mutation.
func (m *PayableMutation) CompanyID() (id int, exists bool) {
	if m.company != nil {
		return *m.company, true
	}
	return
}

// CompanyIDs returns the "company" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CompanyID instead. It exists only for internal usage by the builders.
func (m *PayableMutation) CompanyIDs() (ids []int) {
	if id := m.company; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCompany resets all changes to the "company" edge.
func (m *PayableMutation) ResetCompany() {
	m.company = nil
	m.clearedcompany = false
}

// Where appends a list predicates to the PayableMutation builder.
func (m *PayableMutation) Where(ps ...predicate.Payable) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PayableMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PayableMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Payable, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PayableMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PayableMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Payable).
func (m *PayableMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PayableMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.createdAt != nil {
		fields = append(fields, payable.FieldCreatedAt)
	}
	if m.updatedAt != nil {
		fields = append(fields, payable.FieldUpdatedAt)
	}
	if m.deletedAt != nil {
		fields = append(fields, payable.FieldDeletedAt)
	}
	if m.entryGroup != nil {
		fields = append(fields, payable.FieldEntryGroup)
	}
	if m.date != nil {
		fields = append(fields, payable.FieldDate)
	}
	if m.name != nil {
		fields = append(fields, payable.FieldName)
	}
	if m.outstandingBalance != nil {
		fields = append(fields, payable.FieldOutstandingBalance)
	}
	if m.totalTransaction != nil {
		fields = append(fields, payable.FieldTotalTransaction)
	}
	if m.dueDate != nil {
		fields = append(fields, payable.FieldDueDate)
	}
	if m.status != nil {
		fields = append(fields, payable.FieldStatus)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PayableMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case payable.FieldCreatedAt:
		return m.CreatedAt()
	case payable.FieldUpdatedAt:
		return m.UpdatedAt()
	case payable.FieldDeletedAt:
		return m.DeletedAt()
	case payable.FieldEntryGroup:
		return m.EntryGroup()
	case payable.FieldDate:
		return m.Date()
	case payable.FieldName:
		return m.Name()
	case payable.FieldOutstandingBalance:
		return m.OutstandingBalance()
	case payable.FieldTotalTransaction:
		return m.TotalTransaction()
	case payable.FieldDueDate:
		return m.DueDate()
	case payable.FieldStatus:
		return m.Status()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PayableMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case payable.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case payable.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case payable.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case payable.FieldEntryGroup:
		return m.OldEntryGroup(ctx)
	case payable.FieldDate:
		return m.OldDate(ctx)
	case payable.FieldName:
		return m.OldName(ctx)
	case payable.FieldOutstandingBalance:
		return m.OldOutstandingBalance(ctx)
	case payable.FieldTotalTransaction:
		return m.OldTotalTransaction(ctx)
	case payable.FieldDueDate:
		return m.OldDueDate(ctx)
	case payable.FieldStatus:
		return m.OldStatus(ctx)
	}
	return nil, fmt.Errorf("unknown Payable field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PayableMutation) SetField(name string, value ent.Value) error {
	switch name {
	case payable.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case payable.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case payable.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case payable.FieldEntryGroup:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEntryGroup(v)
		return nil
	case payable.FieldDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDate(v)
		return nil
	case payable.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case payable.FieldOutstandingBalance:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOutstandingBalance(v)
		return nil
	case payable.FieldTotalTransaction:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTotalTransaction(v)
		return nil
	case payable.FieldDueDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDueDate(v)
		return nil
	case payable.FieldStatus:
		v, ok := value.(payable.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	}
	return fmt.Errorf("unknown Payable field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PayableMutation) AddedFields() []string {
	var fields []string
	if m.addentryGroup != nil {
		fields = append(fields, payable.FieldEntryGroup)
	}
	if m.addoutstandingBalance != nil {
		fields = append(fields, payable.FieldOutstandingBalance)
	}
	if m.addtotalTransaction != nil {
		fields = append(fields, payable.FieldTotalTransaction)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PayableMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case payable.FieldEntryGroup:
		return m.AddedEntryGroup()
	case payable.FieldOutstandingBalance:
		return m.AddedOutstandingBalance()
	case payable.FieldTotalTransaction:
		return m.AddedTotalTransaction()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PayableMutation) AddField(name string, value ent.Value) error {
	switch name {
	case payable.FieldEntryGroup:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddEntryGroup(v)
		return nil
	case payable.FieldOutstandingBalance:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOutstandingBalance(v)
		return nil
	case payable.FieldTotalTransaction:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTotalTransaction(v)
		return nil
	}
	return fmt.Errorf("unknown Payable numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PayableMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(payable.FieldDeletedAt) {
		fields = append(fields, payable.FieldDeletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PayableMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PayableMutation) ClearField(name string) error {
	switch name {
	case payable.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown Payable nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PayableMutation) ResetField(name string) error {
	switch name {
	case payable.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case payable.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case payable.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case payable.FieldEntryGroup:
		m.ResetEntryGroup()
		return nil
	case payable.FieldDate:
		m.ResetDate()
		return nil
	case payable.FieldName:
		m.ResetName()
		return nil
	case payable.FieldOutstandingBalance:
		m.ResetOutstandingBalance()
		return nil
	case payable.FieldTotalTransaction:
		m.ResetTotalTransaction()
		return nil
	case payable.FieldDueDate:
		m.ResetDueDate()
		return nil
	case payable.FieldStatus:
		m.ResetStatus()
		return nil
	}
	return fmt.Errorf("unknown Payable field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PayableMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.company != nil {
		edges = append(edges, payable.EdgeCompany)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PayableMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case payable.EdgeCompany:
		if id := m.company; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PayableMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PayableMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PayableMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedcompany {
		edges = append(edges, payable.EdgeCompany)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PayableMutation) EdgeCleared(name string) bool {
	switch name {
	case payable.EdgeCompany:
		return m.clearedcompany
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PayableMutation) ClearEdge(name string) error {
	switch name {
	case payable.EdgeCompany:
		m.ClearCompany()
		return nil
	}
	return fmt.Errorf("unknown Payable unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PayableMutation) ResetEdge(name string) error {
	switch name {
	case payable.EdgeCompany:
		m.ResetCompany()
		return nil
	}
	return fmt.Errorf("unknown Payable edge %s", name)
}

// ProductMutation represents an operation that mutates the Product nodes in the graph.
type ProductMutation struct {
	config
	op             Op
	typ            string
	id             *int
	createdAt      *time.Time
	updatedAt      *time.Time
	deletedAt      *time.Time
	stock          *int
	addstock       *int
	clearedFields  map[string]struct{}
	company        *int
	clearedcompany bool
	done           bool
	oldValue       func(context.Context) (*Product, error)
	predicates     []predicate.Product
}

var _ ent.Mutation = (*ProductMutation)(nil)

// productOption allows management of the mutation configuration using functional options.
type productOption func(*ProductMutation)

// newProductMutation creates new mutation for the Product entity.
func newProductMutation(c config, op Op, opts ...productOption) *ProductMutation {
	m := &ProductMutation{
		config:        c,
		op:            op,
		typ:           TypeProduct,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withProductID sets the ID field of the mutation.
func withProductID(id int) productOption {
	return func(m *ProductMutation) {
		var (
			err   error
			once  sync.Once
			value *Product
		)
		m.oldValue = func(ctx context.Context) (*Product, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Product.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withProduct sets the old Product of the mutation.
func withProduct(node *Product) productOption {
	return func(m *ProductMutation) {
		m.oldValue = func(context.Context) (*Product, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ProductMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ProductMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("generated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ProductMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ProductMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Product.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "createdAt" field.
func (m *ProductMutation) SetCreatedAt(t time.Time) {
	m.createdAt = &t
}

// CreatedAt returns the value of the "createdAt" field in the mutation.
func (m *ProductMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.createdAt
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "createdAt" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "createdAt" field.
func (m *ProductMutation) ResetCreatedAt() {
	m.createdAt = nil
}

// SetUpdatedAt sets the "updatedAt" field.
func (m *ProductMutation) SetUpdatedAt(t time.Time) {
	m.updatedAt = &t
}

// UpdatedAt returns the value of the "updatedAt" field in the mutation.
func (m *ProductMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updatedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updatedAt" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updatedAt" field.
func (m *ProductMutation) ResetUpdatedAt() {
	m.updatedAt = nil
}

// SetDeletedAt sets the "deletedAt" field.
func (m *ProductMutation) SetDeletedAt(t time.Time) {
	m.deletedAt = &t
}

// DeletedAt returns the value of the "deletedAt" field in the mutation.
func (m *ProductMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deletedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deletedAt" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deletedAt" field.
func (m *ProductMutation) ClearDeletedAt() {
	m.deletedAt = nil
	m.clearedFields[product.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deletedAt" field was cleared in this mutation.
func (m *ProductMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[product.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deletedAt" field.
func (m *ProductMutation) ResetDeletedAt() {
	m.deletedAt = nil
	delete(m.clearedFields, product.FieldDeletedAt)
}

// SetStock sets the "stock" field.
func (m *ProductMutation) SetStock(i int) {
	m.stock = &i
	m.addstock = nil
}

// Stock returns the value of the "stock" field in the mutation.
func (m *ProductMutation) Stock() (r int, exists bool) {
	v := m.stock
	if v == nil {
		return
	}
	return *v, true
}

// OldStock returns the old "stock" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldStock(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStock is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStock requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStock: %w", err)
	}
	return oldValue.Stock, nil
}

// AddStock adds i to the "stock" field.
func (m *ProductMutation) AddStock(i int) {
	if m.addstock != nil {
		*m.addstock += i
	} else {
		m.addstock = &i
	}
}

// AddedStock returns the value that was added to the "stock" field in this mutation.
func (m *ProductMutation) AddedStock() (r int, exists bool) {
	v := m.addstock
	if v == nil {
		return
	}
	return *v, true
}

// ResetStock resets all changes to the "stock" field.
func (m *ProductMutation) ResetStock() {
	m.stock = nil
	m.addstock = nil
}

// SetCompanyID sets the "company" edge to the Company entity by id.
func (m *ProductMutation) SetCompanyID(id int) {
	m.company = &id
}

// ClearCompany clears the "company" edge to the Company entity.
func (m *ProductMutation) ClearCompany() {
	m.clearedcompany = true
}

// CompanyCleared reports if the "company" edge to the Company entity was cleared.
func (m *ProductMutation) CompanyCleared() bool {
	return m.clearedcompany
}

// CompanyID returns the "company" edge ID in the mutation.
func (m *ProductMutation) CompanyID() (id int, exists bool) {
	if m.company != nil {
		return *m.company, true
	}
	return
}

// CompanyIDs returns the "company" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CompanyID instead. It exists only for internal usage by the builders.
func (m *ProductMutation) CompanyIDs() (ids []int) {
	if id := m.company; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCompany resets all changes to the "company" edge.
func (m *ProductMutation) ResetCompany() {
	m.company = nil
	m.clearedcompany = false
}

// Where appends a list predicates to the ProductMutation builder.
func (m *ProductMutation) Where(ps ...predicate.Product) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ProductMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ProductMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Product, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ProductMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ProductMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Product).
func (m *ProductMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ProductMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.createdAt != nil {
		fields = append(fields, product.FieldCreatedAt)
	}
	if m.updatedAt != nil {
		fields = append(fields, product.FieldUpdatedAt)
	}
	if m.deletedAt != nil {
		fields = append(fields, product.FieldDeletedAt)
	}
	if m.stock != nil {
		fields = append(fields, product.FieldStock)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ProductMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case product.FieldCreatedAt:
		return m.CreatedAt()
	case product.FieldUpdatedAt:
		return m.UpdatedAt()
	case product.FieldDeletedAt:
		return m.DeletedAt()
	case product.FieldStock:
		return m.Stock()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ProductMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case product.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case product.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case product.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case product.FieldStock:
		return m.OldStock(ctx)
	}
	return nil, fmt.Errorf("unknown Product field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProductMutation) SetField(name string, value ent.Value) error {
	switch name {
	case product.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case product.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case product.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case product.FieldStock:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStock(v)
		return nil
	}
	return fmt.Errorf("unknown Product field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ProductMutation) AddedFields() []string {
	var fields []string
	if m.addstock != nil {
		fields = append(fields, product.FieldStock)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ProductMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case product.FieldStock:
		return m.AddedStock()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProductMutation) AddField(name string, value ent.Value) error {
	switch name {
	case product.FieldStock:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStock(v)
		return nil
	}
	return fmt.Errorf("unknown Product numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ProductMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(product.FieldDeletedAt) {
		fields = append(fields, product.FieldDeletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ProductMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ProductMutation) ClearField(name string) error {
	switch name {
	case product.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown Product nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ProductMutation) ResetField(name string) error {
	switch name {
	case product.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case product.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case product.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case product.FieldStock:
		m.ResetStock()
		return nil
	}
	return fmt.Errorf("unknown Product field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ProductMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.company != nil {
		edges = append(edges, product.EdgeCompany)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ProductMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case product.EdgeCompany:
		if id := m.company; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ProductMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ProductMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ProductMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedcompany {
		edges = append(edges, product.EdgeCompany)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ProductMutation) EdgeCleared(name string) bool {
	switch name {
	case product.EdgeCompany:
		return m.clearedcompany
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ProductMutation) ClearEdge(name string) error {
	switch name {
	case product.EdgeCompany:
		m.ClearCompany()
		return nil
	}
	return fmt.Errorf("unknown Product unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ProductMutation) ResetEdge(name string) error {
	switch name {
	case product.EdgeCompany:
		m.ResetCompany()
		return nil
	}
	return fmt.Errorf("unknown Product edge %s", name)
}

// ProjectMutation represents an operation that mutates the Project nodes in the graph.
type ProjectMutation struct {
	config
	op                Op
	typ               string
	id                *int
	createdAt         *time.Time
	updatedAt         *time.Time
	deletedAt         *time.Time
	name              *string
	description       *string
	startDate         *time.Time
	endDate           *time.Time
	progress          *float64
	addprogress       *float64
	status            *project.Status
	clearedFields     map[string]struct{}
	company           *int
	clearedcompany    bool
	createdBy         *int
	clearedcreatedBy  bool
	leader            *int
	clearedleader     bool
	tasks             map[int]struct{}
	removedtasks      map[int]struct{}
	clearedtasks      bool
	milestones        map[int]struct{}
	removedmilestones map[int]struct{}
	clearedmilestones bool
	done              bool
	oldValue          func(context.Context) (*Project, error)
	predicates        []predicate.Project
}

var _ ent.Mutation = (*ProjectMutation)(nil)

// projectOption allows management of the mutation configuration using functional options.
type projectOption func(*ProjectMutation)

// newProjectMutation creates new mutation for the Project entity.
func newProjectMutation(c config, op Op, opts ...projectOption) *ProjectMutation {
	m := &ProjectMutation{
		config:        c,
		op:            op,
		typ:           TypeProject,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withProjectID sets the ID field of the mutation.
func withProjectID(id int) projectOption {
	return func(m *ProjectMutation) {
		var (
			err   error
			once  sync.Once
			value *Project
		)
		m.oldValue = func(ctx context.Context) (*Project, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Project.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withProject sets the old Project of the mutation.
func withProject(node *Project) projectOption {
	return func(m *ProjectMutation) {
		m.oldValue = func(context.Context) (*Project, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ProjectMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ProjectMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("generated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ProjectMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ProjectMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Project.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "createdAt" field.
func (m *ProjectMutation) SetCreatedAt(t time.Time) {
	m.createdAt = &t
}

// CreatedAt returns the value of the "createdAt" field in the mutation.
func (m *ProjectMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.createdAt
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "createdAt" field's value of the Project entity.
// If the Project object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "createdAt" field.
func (m *ProjectMutation) ResetCreatedAt() {
	m.createdAt = nil
}

// SetUpdatedAt sets the "updatedAt" field.
func (m *ProjectMutation) SetUpdatedAt(t time.Time) {
	m.updatedAt = &t
}

// UpdatedAt returns the value of the "updatedAt" field in the mutation.
func (m *ProjectMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updatedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updatedAt" field's value of the Project entity.
// If the Project object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updatedAt" field.
func (m *ProjectMutation) ResetUpdatedAt() {
	m.updatedAt = nil
}

// SetDeletedAt sets the "deletedAt" field.
func (m *ProjectMutation) SetDeletedAt(t time.Time) {
	m.deletedAt = &t
}

// DeletedAt returns the value of the "deletedAt" field in the mutation.
func (m *ProjectMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deletedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deletedAt" field's value of the Project entity.
// If the Project object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deletedAt" field.
func (m *ProjectMutation) ClearDeletedAt() {
	m.deletedAt = nil
	m.clearedFields[project.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deletedAt" field was cleared in this mutation.
func (m *ProjectMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[project.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deletedAt" field.
func (m *ProjectMutation) ResetDeletedAt() {
	m.deletedAt = nil
	delete(m.clearedFields, project.FieldDeletedAt)
}

// SetName sets the "name" field.
func (m *ProjectMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ProjectMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Project entity.
// If the Project object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ProjectMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *ProjectMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *ProjectMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Project entity.
// If the Project object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *ProjectMutation) ResetDescription() {
	m.description = nil
}

// SetStartDate sets the "startDate" field.
func (m *ProjectMutation) SetStartDate(t time.Time) {
	m.startDate = &t
}

// StartDate returns the value of the "startDate" field in the mutation.
func (m *ProjectMutation) StartDate() (r time.Time, exists bool) {
	v := m.startDate
	if v == nil {
		return
	}
	return *v, true
}

// OldStartDate returns the old "startDate" field's value of the Project entity.
// If the Project object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectMutation) OldStartDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartDate: %w", err)
	}
	return oldValue.StartDate, nil
}

// ResetStartDate resets all changes to the "startDate" field.
func (m *ProjectMutation) ResetStartDate() {
	m.startDate = nil
}

// SetEndDate sets the "endDate" field.
func (m *ProjectMutation) SetEndDate(t time.Time) {
	m.endDate = &t
}

// EndDate returns the value of the "endDate" field in the mutation.
func (m *ProjectMutation) EndDate() (r time.Time, exists bool) {
	v := m.endDate
	if v == nil {
		return
	}
	return *v, true
}

// OldEndDate returns the old "endDate" field's value of the Project entity.
// If the Project object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectMutation) OldEndDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEndDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEndDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEndDate: %w", err)
	}
	return oldValue.EndDate, nil
}

// ResetEndDate resets all changes to the "endDate" field.
func (m *ProjectMutation) ResetEndDate() {
	m.endDate = nil
}

// SetProgress sets the "progress" field.
func (m *ProjectMutation) SetProgress(f float64) {
	m.progress = &f
	m.addprogress = nil
}

// Progress returns the value of the "progress" field in the mutation.
func (m *ProjectMutation) Progress() (r float64, exists bool) {
	v := m.progress
	if v == nil {
		return
	}
	return *v, true
}

// OldProgress returns the old "progress" field's value of the Project entity.
// If the Project object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectMutation) OldProgress(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProgress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProgress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProgress: %w", err)
	}
	return oldValue.Progress, nil
}

// AddProgress adds f to the "progress" field.
func (m *ProjectMutation) AddProgress(f float64) {
	if m.addprogress != nil {
		*m.addprogress += f
	} else {
		m.addprogress = &f
	}
}

// AddedProgress returns the value that was added to the "progress" field in this mutation.
func (m *ProjectMutation) AddedProgress() (r float64, exists bool) {
	v := m.addprogress
	if v == nil {
		return
	}
	return *v, true
}

// ResetProgress resets all changes to the "progress" field.
func (m *ProjectMutation) ResetProgress() {
	m.progress = nil
	m.addprogress = nil
}

// SetStatus sets the "status" field.
func (m *ProjectMutation) SetStatus(pr project.Status) {
	m.status = &pr
}

// Status returns the value of the "status" field in the mutation.
func (m *ProjectMutation) Status() (r project.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Project entity.
// If the Project object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectMutation) OldStatus(ctx context.Context) (v project.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *ProjectMutation) ResetStatus() {
	m.status = nil
}

// SetCompanyID sets the "company" edge to the Company entity by id.
func (m *ProjectMutation) SetCompanyID(id int) {
	m.company = &id
}

// ClearCompany clears the "company" edge to the Company entity.
func (m *ProjectMutation) ClearCompany() {
	m.clearedcompany = true
}

// CompanyCleared reports if the "company" edge to the Company entity was cleared.
func (m *ProjectMutation) CompanyCleared() bool {
	return m.clearedcompany
}

// CompanyID returns the "company" edge ID in the mutation.
func (m *ProjectMutation) CompanyID() (id int, exists bool) {
	if m.company != nil {
		return *m.company, true
	}
	return
}

// CompanyIDs returns the "company" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CompanyID instead. It exists only for internal usage by the builders.
func (m *ProjectMutation) CompanyIDs() (ids []int) {
	if id := m.company; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCompany resets all changes to the "company" edge.
func (m *ProjectMutation) ResetCompany() {
	m.company = nil
	m.clearedcompany = false
}

// SetCreatedByID sets the "createdBy" edge to the User entity by id.
func (m *ProjectMutation) SetCreatedByID(id int) {
	m.createdBy = &id
}

// ClearCreatedBy clears the "createdBy" edge to the User entity.
func (m *ProjectMutation) ClearCreatedBy() {
	m.clearedcreatedBy = true
}

// CreatedByCleared reports if the "createdBy" edge to the User entity was cleared.
func (m *ProjectMutation) CreatedByCleared() bool {
	return m.clearedcreatedBy
}

// CreatedByID returns the "createdBy" edge ID in the mutation.
func (m *ProjectMutation) CreatedByID() (id int, exists bool) {
	if m.createdBy != nil {
		return *m.createdBy, true
	}
	return
}

// CreatedByIDs returns the "createdBy" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CreatedByID instead. It exists only for internal usage by the builders.
func (m *ProjectMutation) CreatedByIDs() (ids []int) {
	if id := m.createdBy; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCreatedBy resets all changes to the "createdBy" edge.
func (m *ProjectMutation) ResetCreatedBy() {
	m.createdBy = nil
	m.clearedcreatedBy = false
}

// SetLeaderID sets the "leader" edge to the User entity by id.
func (m *ProjectMutation) SetLeaderID(id int) {
	m.leader = &id
}

// ClearLeader clears the "leader" edge to the User entity.
func (m *ProjectMutation) ClearLeader() {
	m.clearedleader = true
}

// LeaderCleared reports if the "leader" edge to the User entity was cleared.
func (m *ProjectMutation) LeaderCleared() bool {
	return m.clearedleader
}

// LeaderID returns the "leader" edge ID in the mutation.
func (m *ProjectMutation) LeaderID() (id int, exists bool) {
	if m.leader != nil {
		return *m.leader, true
	}
	return
}

// LeaderIDs returns the "leader" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// LeaderID instead. It exists only for internal usage by the builders.
func (m *ProjectMutation) LeaderIDs() (ids []int) {
	if id := m.leader; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetLeader resets all changes to the "leader" edge.
func (m *ProjectMutation) ResetLeader() {
	m.leader = nil
	m.clearedleader = false
}

// AddTaskIDs adds the "tasks" edge to the ProjectTask entity by ids.
func (m *ProjectMutation) AddTaskIDs(ids ...int) {
	if m.tasks == nil {
		m.tasks = make(map[int]struct{})
	}
	for i := range ids {
		m.tasks[ids[i]] = struct{}{}
	}
}

// ClearTasks clears the "tasks" edge to the ProjectTask entity.
func (m *ProjectMutation) ClearTasks() {
	m.clearedtasks = true
}

// TasksCleared reports if the "tasks" edge to the ProjectTask entity was cleared.
func (m *ProjectMutation) TasksCleared() bool {
	return m.clearedtasks
}

// RemoveTaskIDs removes the "tasks" edge to the ProjectTask entity by IDs.
func (m *ProjectMutation) RemoveTaskIDs(ids ...int) {
	if m.removedtasks == nil {
		m.removedtasks = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.tasks, ids[i])
		m.removedtasks[ids[i]] = struct{}{}
	}
}

// RemovedTasks returns the removed IDs of the "tasks" edge to the ProjectTask entity.
func (m *ProjectMutation) RemovedTasksIDs() (ids []int) {
	for id := range m.removedtasks {
		ids = append(ids, id)
	}
	return
}

// TasksIDs returns the "tasks" edge IDs in the mutation.
func (m *ProjectMutation) TasksIDs() (ids []int) {
	for id := range m.tasks {
		ids = append(ids, id)
	}
	return
}

// ResetTasks resets all changes to the "tasks" edge.
func (m *ProjectMutation) ResetTasks() {
	m.tasks = nil
	m.clearedtasks = false
	m.removedtasks = nil
}

// AddMilestoneIDs adds the "milestones" edge to the ProjectMilestone entity by ids.
func (m *ProjectMutation) AddMilestoneIDs(ids ...int) {
	if m.milestones == nil {
		m.milestones = make(map[int]struct{})
	}
	for i := range ids {
		m.milestones[ids[i]] = struct{}{}
	}
}

// ClearMilestones clears the "milestones" edge to the ProjectMilestone entity.
func (m *ProjectMutation) ClearMilestones() {
	m.clearedmilestones = true
}

// MilestonesCleared reports if the "milestones" edge to the ProjectMilestone entity was cleared.
func (m *ProjectMutation) MilestonesCleared() bool {
	return m.clearedmilestones
}

// RemoveMilestoneIDs removes the "milestones" edge to the ProjectMilestone entity by IDs.
func (m *ProjectMutation) RemoveMilestoneIDs(ids ...int) {
	if m.removedmilestones == nil {
		m.removedmilestones = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.milestones, ids[i])
		m.removedmilestones[ids[i]] = struct{}{}
	}
}

// RemovedMilestones returns the removed IDs of the "milestones" edge to the ProjectMilestone entity.
func (m *ProjectMutation) RemovedMilestonesIDs() (ids []int) {
	for id := range m.removedmilestones {
		ids = append(ids, id)
	}
	return
}

// MilestonesIDs returns the "milestones" edge IDs in the mutation.
func (m *ProjectMutation) MilestonesIDs() (ids []int) {
	for id := range m.milestones {
		ids = append(ids, id)
	}
	return
}

// ResetMilestones resets all changes to the "milestones" edge.
func (m *ProjectMutation) ResetMilestones() {
	m.milestones = nil
	m.clearedmilestones = false
	m.removedmilestones = nil
}

// Where appends a list predicates to the ProjectMutation builder.
func (m *ProjectMutation) Where(ps ...predicate.Project) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ProjectMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ProjectMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Project, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ProjectMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ProjectMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Project).
func (m *ProjectMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ProjectMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.createdAt != nil {
		fields = append(fields, project.FieldCreatedAt)
	}
	if m.updatedAt != nil {
		fields = append(fields, project.FieldUpdatedAt)
	}
	if m.deletedAt != nil {
		fields = append(fields, project.FieldDeletedAt)
	}
	if m.name != nil {
		fields = append(fields, project.FieldName)
	}
	if m.description != nil {
		fields = append(fields, project.FieldDescription)
	}
	if m.startDate != nil {
		fields = append(fields, project.FieldStartDate)
	}
	if m.endDate != nil {
		fields = append(fields, project.FieldEndDate)
	}
	if m.progress != nil {
		fields = append(fields, project.FieldProgress)
	}
	if m.status != nil {
		fields = append(fields, project.FieldStatus)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ProjectMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case project.FieldCreatedAt:
		return m.CreatedAt()
	case project.FieldUpdatedAt:
		return m.UpdatedAt()
	case project.FieldDeletedAt:
		return m.DeletedAt()
	case project.FieldName:
		return m.Name()
	case project.FieldDescription:
		return m.Description()
	case project.FieldStartDate:
		return m.StartDate()
	case project.FieldEndDate:
		return m.EndDate()
	case project.FieldProgress:
		return m.Progress()
	case project.FieldStatus:
		return m.Status()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ProjectMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case project.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case project.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case project.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case project.FieldName:
		return m.OldName(ctx)
	case project.FieldDescription:
		return m.OldDescription(ctx)
	case project.FieldStartDate:
		return m.OldStartDate(ctx)
	case project.FieldEndDate:
		return m.OldEndDate(ctx)
	case project.FieldProgress:
		return m.OldProgress(ctx)
	case project.FieldStatus:
		return m.OldStatus(ctx)
	}
	return nil, fmt.Errorf("unknown Project field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProjectMutation) SetField(name string, value ent.Value) error {
	switch name {
	case project.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case project.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case project.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case project.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case project.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case project.FieldStartDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartDate(v)
		return nil
	case project.FieldEndDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEndDate(v)
		return nil
	case project.FieldProgress:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProgress(v)
		return nil
	case project.FieldStatus:
		v, ok := value.(project.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	}
	return fmt.Errorf("unknown Project field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ProjectMutation) AddedFields() []string {
	var fields []string
	if m.addprogress != nil {
		fields = append(fields, project.FieldProgress)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ProjectMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case project.FieldProgress:
		return m.AddedProgress()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProjectMutation) AddField(name string, value ent.Value) error {
	switch name {
	case project.FieldProgress:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddProgress(v)
		return nil
	}
	return fmt.Errorf("unknown Project numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ProjectMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(project.FieldDeletedAt) {
		fields = append(fields, project.FieldDeletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ProjectMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ProjectMutation) ClearField(name string) error {
	switch name {
	case project.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown Project nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ProjectMutation) ResetField(name string) error {
	switch name {
	case project.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case project.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case project.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case project.FieldName:
		m.ResetName()
		return nil
	case project.FieldDescription:
		m.ResetDescription()
		return nil
	case project.FieldStartDate:
		m.ResetStartDate()
		return nil
	case project.FieldEndDate:
		m.ResetEndDate()
		return nil
	case project.FieldProgress:
		m.ResetProgress()
		return nil
	case project.FieldStatus:
		m.ResetStatus()
		return nil
	}
	return fmt.Errorf("unknown Project field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ProjectMutation) AddedEdges() []string {
	edges := make([]string, 0, 5)
	if m.company != nil {
		edges = append(edges, project.EdgeCompany)
	}
	if m.createdBy != nil {
		edges = append(edges, project.EdgeCreatedBy)
	}
	if m.leader != nil {
		edges = append(edges, project.EdgeLeader)
	}
	if m.tasks != nil {
		edges = append(edges, project.EdgeTasks)
	}
	if m.milestones != nil {
		edges = append(edges, project.EdgeMilestones)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ProjectMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case project.EdgeCompany:
		if id := m.company; id != nil {
			return []ent.Value{*id}
		}
	case project.EdgeCreatedBy:
		if id := m.createdBy; id != nil {
			return []ent.Value{*id}
		}
	case project.EdgeLeader:
		if id := m.leader; id != nil {
			return []ent.Value{*id}
		}
	case project.EdgeTasks:
		ids := make([]ent.Value, 0, len(m.tasks))
		for id := range m.tasks {
			ids = append(ids, id)
		}
		return ids
	case project.EdgeMilestones:
		ids := make([]ent.Value, 0, len(m.milestones))
		for id := range m.milestones {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ProjectMutation) RemovedEdges() []string {
	edges := make([]string, 0, 5)
	if m.removedtasks != nil {
		edges = append(edges, project.EdgeTasks)
	}
	if m.removedmilestones != nil {
		edges = append(edges, project.EdgeMilestones)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ProjectMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case project.EdgeTasks:
		ids := make([]ent.Value, 0, len(m.removedtasks))
		for id := range m.removedtasks {
			ids = append(ids, id)
		}
		return ids
	case project.EdgeMilestones:
		ids := make([]ent.Value, 0, len(m.removedmilestones))
		for id := range m.removedmilestones {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ProjectMutation) ClearedEdges() []string {
	edges := make([]string, 0, 5)
	if m.clearedcompany {
		edges = append(edges, project.EdgeCompany)
	}
	if m.clearedcreatedBy {
		edges = append(edges, project.EdgeCreatedBy)
	}
	if m.clearedleader {
		edges = append(edges, project.EdgeLeader)
	}
	if m.clearedtasks {
		edges = append(edges, project.EdgeTasks)
	}
	if m.clearedmilestones {
		edges = append(edges, project.EdgeMilestones)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ProjectMutation) EdgeCleared(name string) bool {
	switch name {
	case project.EdgeCompany:
		return m.clearedcompany
	case project.EdgeCreatedBy:
		return m.clearedcreatedBy
	case project.EdgeLeader:
		return m.clearedleader
	case project.EdgeTasks:
		return m.clearedtasks
	case project.EdgeMilestones:
		return m.clearedmilestones
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ProjectMutation) ClearEdge(name string) error {
	switch name {
	case project.EdgeCompany:
		m.ClearCompany()
		return nil
	case project.EdgeCreatedBy:
		m.ClearCreatedBy()
		return nil
	case project.EdgeLeader:
		m.ClearLeader()
		return nil
	}
	return fmt.Errorf("unknown Project unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ProjectMutation) ResetEdge(name string) error {
	switch name {
	case project.EdgeCompany:
		m.ResetCompany()
		return nil
	case project.EdgeCreatedBy:
		m.ResetCreatedBy()
		return nil
	case project.EdgeLeader:
		m.ResetLeader()
		return nil
	case project.EdgeTasks:
		m.ResetTasks()
		return nil
	case project.EdgeMilestones:
		m.ResetMilestones()
		return nil
	}
	return fmt.Errorf("unknown Project edge %s", name)
}

// ProjectMilestoneMutation represents an operation that mutates the ProjectMilestone nodes in the graph.
type ProjectMilestoneMutation struct {
	config
	op             Op
	typ            string
	id             *int
	name           *string
	dueDate        *time.Time
	clearedFields  map[string]struct{}
	project        *int
	clearedproject bool
	done           bool
	oldValue       func(context.Context) (*ProjectMilestone, error)
	predicates     []predicate.ProjectMilestone
}

var _ ent.Mutation = (*ProjectMilestoneMutation)(nil)

// projectmilestoneOption allows management of the mutation configuration using functional options.
type projectmilestoneOption func(*ProjectMilestoneMutation)

// newProjectMilestoneMutation creates new mutation for the ProjectMilestone entity.
func newProjectMilestoneMutation(c config, op Op, opts ...projectmilestoneOption) *ProjectMilestoneMutation {
	m := &ProjectMilestoneMutation{
		config:        c,
		op:            op,
		typ:           TypeProjectMilestone,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withProjectMilestoneID sets the ID field of the mutation.
func withProjectMilestoneID(id int) projectmilestoneOption {
	return func(m *ProjectMilestoneMutation) {
		var (
			err   error
			once  sync.Once
			value *ProjectMilestone
		)
		m.oldValue = func(ctx context.Context) (*ProjectMilestone, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ProjectMilestone.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withProjectMilestone sets the old ProjectMilestone of the mutation.
func withProjectMilestone(node *ProjectMilestone) projectmilestoneOption {
	return func(m *ProjectMilestoneMutation) {
		m.oldValue = func(context.Context) (*ProjectMilestone, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ProjectMilestoneMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ProjectMilestoneMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("generated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ProjectMilestoneMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ProjectMilestoneMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ProjectMilestone.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *ProjectMilestoneMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ProjectMilestoneMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the ProjectMilestone entity.
// If the ProjectMilestone object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectMilestoneMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ProjectMilestoneMutation) ResetName() {
	m.name = nil
}

// SetDueDate sets the "dueDate" field.
func (m *ProjectMilestoneMutation) SetDueDate(t time.Time) {
	m.dueDate = &t
}

// DueDate returns the value of the "dueDate" field in the mutation.
func (m *ProjectMilestoneMutation) DueDate() (r time.Time, exists bool) {
	v := m.dueDate
	if v == nil {
		return
	}
	return *v, true
}

// OldDueDate returns the old "dueDate" field's value of the ProjectMilestone entity.
// If the ProjectMilestone object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectMilestoneMutation) OldDueDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDueDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDueDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDueDate: %w", err)
	}
	return oldValue.DueDate, nil
}

// ResetDueDate resets all changes to the "dueDate" field.
func (m *ProjectMilestoneMutation) ResetDueDate() {
	m.dueDate = nil
}

// SetProjectID sets the "project" edge to the Project entity by id.
func (m *ProjectMilestoneMutation) SetProjectID(id int) {
	m.project = &id
}

// ClearProject clears the "project" edge to the Project entity.
func (m *ProjectMilestoneMutation) ClearProject() {
	m.clearedproject = true
}

// ProjectCleared reports if the "project" edge to the Project entity was cleared.
func (m *ProjectMilestoneMutation) ProjectCleared() bool {
	return m.clearedproject
}

// ProjectID returns the "project" edge ID in the mutation.
func (m *ProjectMilestoneMutation) ProjectID() (id int, exists bool) {
	if m.project != nil {
		return *m.project, true
	}
	return
}

// ProjectIDs returns the "project" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProjectID instead. It exists only for internal usage by the builders.
func (m *ProjectMilestoneMutation) ProjectIDs() (ids []int) {
	if id := m.project; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProject resets all changes to the "project" edge.
func (m *ProjectMilestoneMutation) ResetProject() {
	m.project = nil
	m.clearedproject = false
}

// Where appends a list predicates to the ProjectMilestoneMutation builder.
func (m *ProjectMilestoneMutation) Where(ps ...predicate.ProjectMilestone) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ProjectMilestoneMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ProjectMilestoneMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ProjectMilestone, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ProjectMilestoneMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ProjectMilestoneMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ProjectMilestone).
func (m *ProjectMilestoneMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ProjectMilestoneMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.name != nil {
		fields = append(fields, projectmilestone.FieldName)
	}
	if m.dueDate != nil {
		fields = append(fields, projectmilestone.FieldDueDate)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ProjectMilestoneMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case projectmilestone.FieldName:
		return m.Name()
	case projectmilestone.FieldDueDate:
		return m.DueDate()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ProjectMilestoneMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case projectmilestone.FieldName:
		return m.OldName(ctx)
	case projectmilestone.FieldDueDate:
		return m.OldDueDate(ctx)
	}
	return nil, fmt.Errorf("unknown ProjectMilestone field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProjectMilestoneMutation) SetField(name string, value ent.Value) error {
	switch name {
	case projectmilestone.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case projectmilestone.FieldDueDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDueDate(v)
		return nil
	}
	return fmt.Errorf("unknown ProjectMilestone field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ProjectMilestoneMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ProjectMilestoneMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProjectMilestoneMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ProjectMilestone numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ProjectMilestoneMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ProjectMilestoneMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ProjectMilestoneMutation) ClearField(name string) error {
	return fmt.Errorf("unknown ProjectMilestone nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ProjectMilestoneMutation) ResetField(name string) error {
	switch name {
	case projectmilestone.FieldName:
		m.ResetName()
		return nil
	case projectmilestone.FieldDueDate:
		m.ResetDueDate()
		return nil
	}
	return fmt.Errorf("unknown ProjectMilestone field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ProjectMilestoneMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.project != nil {
		edges = append(edges, projectmilestone.EdgeProject)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ProjectMilestoneMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case projectmilestone.EdgeProject:
		if id := m.project; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ProjectMilestoneMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ProjectMilestoneMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ProjectMilestoneMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedproject {
		edges = append(edges, projectmilestone.EdgeProject)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ProjectMilestoneMutation) EdgeCleared(name string) bool {
	switch name {
	case projectmilestone.EdgeProject:
		return m.clearedproject
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ProjectMilestoneMutation) ClearEdge(name string) error {
	switch name {
	case projectmilestone.EdgeProject:
		m.ClearProject()
		return nil
	}
	return fmt.Errorf("unknown ProjectMilestone unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ProjectMilestoneMutation) ResetEdge(name string) error {
	switch name {
	case projectmilestone.EdgeProject:
		m.ResetProject()
		return nil
	}
	return fmt.Errorf("unknown ProjectMilestone edge %s", name)
}

// ProjectTaskMutation represents an operation that mutates the ProjectTask nodes in the graph.
type ProjectTaskMutation struct {
	config
	op                  Op
	typ                 string
	id                  *int
	createdAt           *time.Time
	name                *string
	assigneeName        *string
	location            *string
	dueDate             *time.Time
	startDate           *time.Time
	endDate             *time.Time
	description         *string
	status              *projecttask.Status
	clearedFields       map[string]struct{}
	project             *int
	clearedproject      bool
	assignee            *int
	clearedassignee     bool
	participants        map[int]struct{}
	removedparticipants map[int]struct{}
	clearedparticipants bool
	createdBy           *int
	clearedcreatedBy    bool
	workShifts          map[int]struct{}
	removedworkShifts   map[int]struct{}
	clearedworkShifts   bool
	done                bool
	oldValue            func(context.Context) (*ProjectTask, error)
	predicates          []predicate.ProjectTask
}

var _ ent.Mutation = (*ProjectTaskMutation)(nil)

// projecttaskOption allows management of the mutation configuration using functional options.
type projecttaskOption func(*ProjectTaskMutation)

// newProjectTaskMutation creates new mutation for the ProjectTask entity.
func newProjectTaskMutation(c config, op Op, opts ...projecttaskOption) *ProjectTaskMutation {
	m := &ProjectTaskMutation{
		config:        c,
		op:            op,
		typ:           TypeProjectTask,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withProjectTaskID sets the ID field of the mutation.
func withProjectTaskID(id int) projecttaskOption {
	return func(m *ProjectTaskMutation) {
		var (
			err   error
			once  sync.Once
			value *ProjectTask
		)
		m.oldValue = func(ctx context.Context) (*ProjectTask, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ProjectTask.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withProjectTask sets the old ProjectTask of the mutation.
func withProjectTask(node *ProjectTask) projecttaskOption {
	return func(m *ProjectTaskMutation) {
		m.oldValue = func(context.Context) (*ProjectTask, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ProjectTaskMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ProjectTaskMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("generated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ProjectTaskMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ProjectTaskMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ProjectTask.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "createdAt" field.
func (m *ProjectTaskMutation) SetCreatedAt(t time.Time) {
	m.createdAt = &t
}

// CreatedAt returns the value of the "createdAt" field in the mutation.
func (m *ProjectTaskMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.createdAt
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "createdAt" field's value of the ProjectTask entity.
// If the ProjectTask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectTaskMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "createdAt" field.
func (m *ProjectTaskMutation) ClearCreatedAt() {
	m.createdAt = nil
	m.clearedFields[projecttask.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "createdAt" field was cleared in this mutation.
func (m *ProjectTaskMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[projecttask.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "createdAt" field.
func (m *ProjectTaskMutation) ResetCreatedAt() {
	m.createdAt = nil
	delete(m.clearedFields, projecttask.FieldCreatedAt)
}

// SetName sets the "name" field.
func (m *ProjectTaskMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ProjectTaskMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the ProjectTask entity.
// If the ProjectTask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectTaskMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ProjectTaskMutation) ResetName() {
	m.name = nil
}

// SetAssigneeName sets the "assigneeName" field.
func (m *ProjectTaskMutation) SetAssigneeName(s string) {
	m.assigneeName = &s
}

// AssigneeName returns the value of the "assigneeName" field in the mutation.
func (m *ProjectTaskMutation) AssigneeName() (r string, exists bool) {
	v := m.assigneeName
	if v == nil {
		return
	}
	return *v, true
}

// OldAssigneeName returns the old "assigneeName" field's value of the ProjectTask entity.
// If the ProjectTask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectTaskMutation) OldAssigneeName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAssigneeName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAssigneeName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAssigneeName: %w", err)
	}
	return oldValue.AssigneeName, nil
}

// ResetAssigneeName resets all changes to the "assigneeName" field.
func (m *ProjectTaskMutation) ResetAssigneeName() {
	m.assigneeName = nil
}

// SetLocation sets the "location" field.
func (m *ProjectTaskMutation) SetLocation(s string) {
	m.location = &s
}

// Location returns the value of the "location" field in the mutation.
func (m *ProjectTaskMutation) Location() (r string, exists bool) {
	v := m.location
	if v == nil {
		return
	}
	return *v, true
}

// OldLocation returns the old "location" field's value of the ProjectTask entity.
// If the ProjectTask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectTaskMutation) OldLocation(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLocation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLocation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLocation: %w", err)
	}
	return oldValue.Location, nil
}

// ClearLocation clears the value of the "location" field.
func (m *ProjectTaskMutation) ClearLocation() {
	m.location = nil
	m.clearedFields[projecttask.FieldLocation] = struct{}{}
}

// LocationCleared returns if the "location" field was cleared in this mutation.
func (m *ProjectTaskMutation) LocationCleared() bool {
	_, ok := m.clearedFields[projecttask.FieldLocation]
	return ok
}

// ResetLocation resets all changes to the "location" field.
func (m *ProjectTaskMutation) ResetLocation() {
	m.location = nil
	delete(m.clearedFields, projecttask.FieldLocation)
}

// SetDueDate sets the "dueDate" field.
func (m *ProjectTaskMutation) SetDueDate(t time.Time) {
	m.dueDate = &t
}

// DueDate returns the value of the "dueDate" field in the mutation.
func (m *ProjectTaskMutation) DueDate() (r time.Time, exists bool) {
	v := m.dueDate
	if v == nil {
		return
	}
	return *v, true
}

// OldDueDate returns the old "dueDate" field's value of the ProjectTask entity.
// If the ProjectTask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectTaskMutation) OldDueDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDueDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDueDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDueDate: %w", err)
	}
	return oldValue.DueDate, nil
}

// ResetDueDate resets all changes to the "dueDate" field.
func (m *ProjectTaskMutation) ResetDueDate() {
	m.dueDate = nil
}

// SetStartDate sets the "startDate" field.
func (m *ProjectTaskMutation) SetStartDate(t time.Time) {
	m.startDate = &t
}

// StartDate returns the value of the "startDate" field in the mutation.
func (m *ProjectTaskMutation) StartDate() (r time.Time, exists bool) {
	v := m.startDate
	if v == nil {
		return
	}
	return *v, true
}

// OldStartDate returns the old "startDate" field's value of the ProjectTask entity.
// If the ProjectTask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectTaskMutation) OldStartDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartDate: %w", err)
	}
	return oldValue.StartDate, nil
}

// ResetStartDate resets all changes to the "startDate" field.
func (m *ProjectTaskMutation) ResetStartDate() {
	m.startDate = nil
}

// SetEndDate sets the "endDate" field.
func (m *ProjectTaskMutation) SetEndDate(t time.Time) {
	m.endDate = &t
}

// EndDate returns the value of the "endDate" field in the mutation.
func (m *ProjectTaskMutation) EndDate() (r time.Time, exists bool) {
	v := m.endDate
	if v == nil {
		return
	}
	return *v, true
}

// OldEndDate returns the old "endDate" field's value of the ProjectTask entity.
// If the ProjectTask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectTaskMutation) OldEndDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEndDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEndDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEndDate: %w", err)
	}
	return oldValue.EndDate, nil
}

// ResetEndDate resets all changes to the "endDate" field.
func (m *ProjectTaskMutation) ResetEndDate() {
	m.endDate = nil
}

// SetDescription sets the "description" field.
func (m *ProjectTaskMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *ProjectTaskMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the ProjectTask entity.
// If the ProjectTask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectTaskMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *ProjectTaskMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[projecttask.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *ProjectTaskMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[projecttask.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *ProjectTaskMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, projecttask.FieldDescription)
}

// SetStatus sets the "status" field.
func (m *ProjectTaskMutation) SetStatus(pr projecttask.Status) {
	m.status = &pr
}

// Status returns the value of the "status" field in the mutation.
func (m *ProjectTaskMutation) Status() (r projecttask.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the ProjectTask entity.
// If the ProjectTask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectTaskMutation) OldStatus(ctx context.Context) (v projecttask.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *ProjectTaskMutation) ResetStatus() {
	m.status = nil
}

// SetProjectID sets the "project" edge to the Project entity by id.
func (m *ProjectTaskMutation) SetProjectID(id int) {
	m.project = &id
}

// ClearProject clears the "project" edge to the Project entity.
func (m *ProjectTaskMutation) ClearProject() {
	m.clearedproject = true
}

// ProjectCleared reports if the "project" edge to the Project entity was cleared.
func (m *ProjectTaskMutation) ProjectCleared() bool {
	return m.clearedproject
}

// ProjectID returns the "project" edge ID in the mutation.
func (m *ProjectTaskMutation) ProjectID() (id int, exists bool) {
	if m.project != nil {
		return *m.project, true
	}
	return
}

// ProjectIDs returns the "project" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProjectID instead. It exists only for internal usage by the builders.
func (m *ProjectTaskMutation) ProjectIDs() (ids []int) {
	if id := m.project; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProject resets all changes to the "project" edge.
func (m *ProjectTaskMutation) ResetProject() {
	m.project = nil
	m.clearedproject = false
}

// SetAssigneeID sets the "assignee" edge to the User entity by id.
func (m *ProjectTaskMutation) SetAssigneeID(id int) {
	m.assignee = &id
}

// ClearAssignee clears the "assignee" edge to the User entity.
func (m *ProjectTaskMutation) ClearAssignee() {
	m.clearedassignee = true
}

// AssigneeCleared reports if the "assignee" edge to the User entity was cleared.
func (m *ProjectTaskMutation) AssigneeCleared() bool {
	return m.clearedassignee
}

// AssigneeID returns the "assignee" edge ID in the mutation.
func (m *ProjectTaskMutation) AssigneeID() (id int, exists bool) {
	if m.assignee != nil {
		return *m.assignee, true
	}
	return
}

// AssigneeIDs returns the "assignee" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AssigneeID instead. It exists only for internal usage by the builders.
func (m *ProjectTaskMutation) AssigneeIDs() (ids []int) {
	if id := m.assignee; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAssignee resets all changes to the "assignee" edge.
func (m *ProjectTaskMutation) ResetAssignee() {
	m.assignee = nil
	m.clearedassignee = false
}

// AddParticipantIDs adds the "participants" edge to the User entity by ids.
func (m *ProjectTaskMutation) AddParticipantIDs(ids ...int) {
	if m.participants == nil {
		m.participants = make(map[int]struct{})
	}
	for i := range ids {
		m.participants[ids[i]] = struct{}{}
	}
}

// ClearParticipants clears the "participants" edge to the User entity.
func (m *ProjectTaskMutation) ClearParticipants() {
	m.clearedparticipants = true
}

// ParticipantsCleared reports if the "participants" edge to the User entity was cleared.
func (m *ProjectTaskMutation) ParticipantsCleared() bool {
	return m.clearedparticipants
}

// RemoveParticipantIDs removes the "participants" edge to the User entity by IDs.
func (m *ProjectTaskMutation) RemoveParticipantIDs(ids ...int) {
	if m.removedparticipants == nil {
		m.removedparticipants = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.participants, ids[i])
		m.removedparticipants[ids[i]] = struct{}{}
	}
}

// RemovedParticipants returns the removed IDs of the "participants" edge to the User entity.
func (m *ProjectTaskMutation) RemovedParticipantsIDs() (ids []int) {
	for id := range m.removedparticipants {
		ids = append(ids, id)
	}
	return
}

// ParticipantsIDs returns the "participants" edge IDs in the mutation.
func (m *ProjectTaskMutation) ParticipantsIDs() (ids []int) {
	for id := range m.participants {
		ids = append(ids, id)
	}
	return
}

// ResetParticipants resets all changes to the "participants" edge.
func (m *ProjectTaskMutation) ResetParticipants() {
	m.participants = nil
	m.clearedparticipants = false
	m.removedparticipants = nil
}

// SetCreatedByID sets the "createdBy" edge to the User entity by id.
func (m *ProjectTaskMutation) SetCreatedByID(id int) {
	m.createdBy = &id
}

// ClearCreatedBy clears the "createdBy" edge to the User entity.
func (m *ProjectTaskMutation) ClearCreatedBy() {
	m.clearedcreatedBy = true
}

// CreatedByCleared reports if the "createdBy" edge to the User entity was cleared.
func (m *ProjectTaskMutation) CreatedByCleared() bool {
	return m.clearedcreatedBy
}

// CreatedByID returns the "createdBy" edge ID in the mutation.
func (m *ProjectTaskMutation) CreatedByID() (id int, exists bool) {
	if m.createdBy != nil {
		return *m.createdBy, true
	}
	return
}

// CreatedByIDs returns the "createdBy" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CreatedByID instead. It exists only for internal usage by the builders.
func (m *ProjectTaskMutation) CreatedByIDs() (ids []int) {
	if id := m.createdBy; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCreatedBy resets all changes to the "createdBy" edge.
func (m *ProjectTaskMutation) ResetCreatedBy() {
	m.createdBy = nil
	m.clearedcreatedBy = false
}

// AddWorkShiftIDs adds the "workShifts" edge to the Workshift entity by ids.
func (m *ProjectTaskMutation) AddWorkShiftIDs(ids ...int) {
	if m.workShifts == nil {
		m.workShifts = make(map[int]struct{})
	}
	for i := range ids {
		m.workShifts[ids[i]] = struct{}{}
	}
}

// ClearWorkShifts clears the "workShifts" edge to the Workshift entity.
func (m *ProjectTaskMutation) ClearWorkShifts() {
	m.clearedworkShifts = true
}

// WorkShiftsCleared reports if the "workShifts" edge to the Workshift entity was cleared.
func (m *ProjectTaskMutation) WorkShiftsCleared() bool {
	return m.clearedworkShifts
}

// RemoveWorkShiftIDs removes the "workShifts" edge to the Workshift entity by IDs.
func (m *ProjectTaskMutation) RemoveWorkShiftIDs(ids ...int) {
	if m.removedworkShifts == nil {
		m.removedworkShifts = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.workShifts, ids[i])
		m.removedworkShifts[ids[i]] = struct{}{}
	}
}

// RemovedWorkShifts returns the removed IDs of the "workShifts" edge to the Workshift entity.
func (m *ProjectTaskMutation) RemovedWorkShiftsIDs() (ids []int) {
	for id := range m.removedworkShifts {
		ids = append(ids, id)
	}
	return
}

// WorkShiftsIDs returns the "workShifts" edge IDs in the mutation.
func (m *ProjectTaskMutation) WorkShiftsIDs() (ids []int) {
	for id := range m.workShifts {
		ids = append(ids, id)
	}
	return
}

// ResetWorkShifts resets all changes to the "workShifts" edge.
func (m *ProjectTaskMutation) ResetWorkShifts() {
	m.workShifts = nil
	m.clearedworkShifts = false
	m.removedworkShifts = nil
}

// Where appends a list predicates to the ProjectTaskMutation builder.
func (m *ProjectTaskMutation) Where(ps ...predicate.ProjectTask) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ProjectTaskMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ProjectTaskMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ProjectTask, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ProjectTaskMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ProjectTaskMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ProjectTask).
func (m *ProjectTaskMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ProjectTaskMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.createdAt != nil {
		fields = append(fields, projecttask.FieldCreatedAt)
	}
	if m.name != nil {
		fields = append(fields, projecttask.FieldName)
	}
	if m.assigneeName != nil {
		fields = append(fields, projecttask.FieldAssigneeName)
	}
	if m.location != nil {
		fields = append(fields, projecttask.FieldLocation)
	}
	if m.dueDate != nil {
		fields = append(fields, projecttask.FieldDueDate)
	}
	if m.startDate != nil {
		fields = append(fields, projecttask.FieldStartDate)
	}
	if m.endDate != nil {
		fields = append(fields, projecttask.FieldEndDate)
	}
	if m.description != nil {
		fields = append(fields, projecttask.FieldDescription)
	}
	if m.status != nil {
		fields = append(fields, projecttask.FieldStatus)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ProjectTaskMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case projecttask.FieldCreatedAt:
		return m.CreatedAt()
	case projecttask.FieldName:
		return m.Name()
	case projecttask.FieldAssigneeName:
		return m.AssigneeName()
	case projecttask.FieldLocation:
		return m.Location()
	case projecttask.FieldDueDate:
		return m.DueDate()
	case projecttask.FieldStartDate:
		return m.StartDate()
	case projecttask.FieldEndDate:
		return m.EndDate()
	case projecttask.FieldDescription:
		return m.Description()
	case projecttask.FieldStatus:
		return m.Status()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ProjectTaskMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case projecttask.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case projecttask.FieldName:
		return m.OldName(ctx)
	case projecttask.FieldAssigneeName:
		return m.OldAssigneeName(ctx)
	case projecttask.FieldLocation:
		return m.OldLocation(ctx)
	case projecttask.FieldDueDate:
		return m.OldDueDate(ctx)
	case projecttask.FieldStartDate:
		return m.OldStartDate(ctx)
	case projecttask.FieldEndDate:
		return m.OldEndDate(ctx)
	case projecttask.FieldDescription:
		return m.OldDescription(ctx)
	case projecttask.FieldStatus:
		return m.OldStatus(ctx)
	}
	return nil, fmt.Errorf("unknown ProjectTask field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProjectTaskMutation) SetField(name string, value ent.Value) error {
	switch name {
	case projecttask.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case projecttask.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case projecttask.FieldAssigneeName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAssigneeName(v)
		return nil
	case projecttask.FieldLocation:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLocation(v)
		return nil
	case projecttask.FieldDueDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDueDate(v)
		return nil
	case projecttask.FieldStartDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartDate(v)
		return nil
	case projecttask.FieldEndDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEndDate(v)
		return nil
	case projecttask.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case projecttask.FieldStatus:
		v, ok := value.(projecttask.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	}
	return fmt.Errorf("unknown ProjectTask field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ProjectTaskMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ProjectTaskMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProjectTaskMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ProjectTask numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ProjectTaskMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(projecttask.FieldCreatedAt) {
		fields = append(fields, projecttask.FieldCreatedAt)
	}
	if m.FieldCleared(projecttask.FieldLocation) {
		fields = append(fields, projecttask.FieldLocation)
	}
	if m.FieldCleared(projecttask.FieldDescription) {
		fields = append(fields, projecttask.FieldDescription)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ProjectTaskMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ProjectTaskMutation) ClearField(name string) error {
	switch name {
	case projecttask.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case projecttask.FieldLocation:
		m.ClearLocation()
		return nil
	case projecttask.FieldDescription:
		m.ClearDescription()
		return nil
	}
	return fmt.Errorf("unknown ProjectTask nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ProjectTaskMutation) ResetField(name string) error {
	switch name {
	case projecttask.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case projecttask.FieldName:
		m.ResetName()
		return nil
	case projecttask.FieldAssigneeName:
		m.ResetAssigneeName()
		return nil
	case projecttask.FieldLocation:
		m.ResetLocation()
		return nil
	case projecttask.FieldDueDate:
		m.ResetDueDate()
		return nil
	case projecttask.FieldStartDate:
		m.ResetStartDate()
		return nil
	case projecttask.FieldEndDate:
		m.ResetEndDate()
		return nil
	case projecttask.FieldDescription:
		m.ResetDescription()
		return nil
	case projecttask.FieldStatus:
		m.ResetStatus()
		return nil
	}
	return fmt.Errorf("unknown ProjectTask field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ProjectTaskMutation) AddedEdges() []string {
	edges := make([]string, 0, 5)
	if m.project != nil {
		edges = append(edges, projecttask.EdgeProject)
	}
	if m.assignee != nil {
		edges = append(edges, projecttask.EdgeAssignee)
	}
	if m.participants != nil {
		edges = append(edges, projecttask.EdgeParticipants)
	}
	if m.createdBy != nil {
		edges = append(edges, projecttask.EdgeCreatedBy)
	}
	if m.workShifts != nil {
		edges = append(edges, projecttask.EdgeWorkShifts)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ProjectTaskMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case projecttask.EdgeProject:
		if id := m.project; id != nil {
			return []ent.Value{*id}
		}
	case projecttask.EdgeAssignee:
		if id := m.assignee; id != nil {
			return []ent.Value{*id}
		}
	case projecttask.EdgeParticipants:
		ids := make([]ent.Value, 0, len(m.participants))
		for id := range m.participants {
			ids = append(ids, id)
		}
		return ids
	case projecttask.EdgeCreatedBy:
		if id := m.createdBy; id != nil {
			return []ent.Value{*id}
		}
	case projecttask.EdgeWorkShifts:
		ids := make([]ent.Value, 0, len(m.workShifts))
		for id := range m.workShifts {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ProjectTaskMutation) RemovedEdges() []string {
	edges := make([]string, 0, 5)
	if m.removedparticipants != nil {
		edges = append(edges, projecttask.EdgeParticipants)
	}
	if m.removedworkShifts != nil {
		edges = append(edges, projecttask.EdgeWorkShifts)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ProjectTaskMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case projecttask.EdgeParticipants:
		ids := make([]ent.Value, 0, len(m.removedparticipants))
		for id := range m.removedparticipants {
			ids = append(ids, id)
		}
		return ids
	case projecttask.EdgeWorkShifts:
		ids := make([]ent.Value, 0, len(m.removedworkShifts))
		for id := range m.removedworkShifts {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ProjectTaskMutation) ClearedEdges() []string {
	edges := make([]string, 0, 5)
	if m.clearedproject {
		edges = append(edges, projecttask.EdgeProject)
	}
	if m.clearedassignee {
		edges = append(edges, projecttask.EdgeAssignee)
	}
	if m.clearedparticipants {
		edges = append(edges, projecttask.EdgeParticipants)
	}
	if m.clearedcreatedBy {
		edges = append(edges, projecttask.EdgeCreatedBy)
	}
	if m.clearedworkShifts {
		edges = append(edges, projecttask.EdgeWorkShifts)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ProjectTaskMutation) EdgeCleared(name string) bool {
	switch name {
	case projecttask.EdgeProject:
		return m.clearedproject
	case projecttask.EdgeAssignee:
		return m.clearedassignee
	case projecttask.EdgeParticipants:
		return m.clearedparticipants
	case projecttask.EdgeCreatedBy:
		return m.clearedcreatedBy
	case projecttask.EdgeWorkShifts:
		return m.clearedworkShifts
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ProjectTaskMutation) ClearEdge(name string) error {
	switch name {
	case projecttask.EdgeProject:
		m.ClearProject()
		return nil
	case projecttask.EdgeAssignee:
		m.ClearAssignee()
		return nil
	case projecttask.EdgeCreatedBy:
		m.ClearCreatedBy()
		return nil
	}
	return fmt.Errorf("unknown ProjectTask unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ProjectTaskMutation) ResetEdge(name string) error {
	switch name {
	case projecttask.EdgeProject:
		m.ResetProject()
		return nil
	case projecttask.EdgeAssignee:
		m.ResetAssignee()
		return nil
	case projecttask.EdgeParticipants:
		m.ResetParticipants()
		return nil
	case projecttask.EdgeCreatedBy:
		m.ResetCreatedBy()
		return nil
	case projecttask.EdgeWorkShifts:
		m.ResetWorkShifts()
		return nil
	}
	return fmt.Errorf("unknown ProjectTask edge %s", name)
}

// ReceivableMutation represents an operation that mutates the Receivable nodes in the graph.
type ReceivableMutation struct {
	config
	op                    Op
	typ                   string
	id                    *int
	createdAt             *time.Time
	updatedAt             *time.Time
	deletedAt             *time.Time
	entryGroup            *int
	addentryGroup         *int
	date                  *time.Time
	name                  *string
	outstandingBalance    *float64
	addoutstandingBalance *float64
	totalTransaction      *float64
	addtotalTransaction   *float64
	dueDate               *time.Time
	status                *receivable.Status
	clearedFields         map[string]struct{}
	company               *int
	clearedcompany        bool
	done                  bool
	oldValue              func(context.Context) (*Receivable, error)
	predicates            []predicate.Receivable
}

var _ ent.Mutation = (*ReceivableMutation)(nil)

// receivableOption allows management of the mutation configuration using functional options.
type receivableOption func(*ReceivableMutation)

// newReceivableMutation creates new mutation for the Receivable entity.
func newReceivableMutation(c config, op Op, opts ...receivableOption) *ReceivableMutation {
	m := &ReceivableMutation{
		config:        c,
		op:            op,
		typ:           TypeReceivable,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withReceivableID sets the ID field of the mutation.
func withReceivableID(id int) receivableOption {
	return func(m *ReceivableMutation) {
		var (
			err   error
			once  sync.Once
			value *Receivable
		)
		m.oldValue = func(ctx context.Context) (*Receivable, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Receivable.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withReceivable sets the old Receivable of the mutation.
func withReceivable(node *Receivable) receivableOption {
	return func(m *ReceivableMutation) {
		m.oldValue = func(context.Context) (*Receivable, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ReceivableMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ReceivableMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("generated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ReceivableMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ReceivableMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Receivable.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "createdAt" field.
func (m *ReceivableMutation) SetCreatedAt(t time.Time) {
	m.createdAt = &t
}

// CreatedAt returns the value of the "createdAt" field in the mutation.
func (m *ReceivableMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.createdAt
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "createdAt" field's value of the Receivable entity.
// If the Receivable object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReceivableMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "createdAt" field.
func (m *ReceivableMutation) ResetCreatedAt() {
	m.createdAt = nil
}

// SetUpdatedAt sets the "updatedAt" field.
func (m *ReceivableMutation) SetUpdatedAt(t time.Time) {
	m.updatedAt = &t
}

// UpdatedAt returns the value of the "updatedAt" field in the mutation.
func (m *ReceivableMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updatedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updatedAt" field's value of the Receivable entity.
// If the Receivable object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReceivableMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updatedAt" field.
func (m *ReceivableMutation) ResetUpdatedAt() {
	m.updatedAt = nil
}

// SetDeletedAt sets the "deletedAt" field.
func (m *ReceivableMutation) SetDeletedAt(t time.Time) {
	m.deletedAt = &t
}

// DeletedAt returns the value of the "deletedAt" field in the mutation.
func (m *ReceivableMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deletedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deletedAt" field's value of the Receivable entity.
// If the Receivable object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReceivableMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deletedAt" field.
func (m *ReceivableMutation) ClearDeletedAt() {
	m.deletedAt = nil
	m.clearedFields[receivable.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deletedAt" field was cleared in this mutation.
func (m *ReceivableMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[receivable.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deletedAt" field.
func (m *ReceivableMutation) ResetDeletedAt() {
	m.deletedAt = nil
	delete(m.clearedFields, receivable.FieldDeletedAt)
}

// SetEntryGroup sets the "entryGroup" field.
func (m *ReceivableMutation) SetEntryGroup(i int) {
	m.entryGroup = &i
	m.addentryGroup = nil
}

// EntryGroup returns the value of the "entryGroup" field in the mutation.
func (m *ReceivableMutation) EntryGroup() (r int, exists bool) {
	v := m.entryGroup
	if v == nil {
		return
	}
	return *v, true
}

// OldEntryGroup returns the old "entryGroup" field's value of the Receivable entity.
// If the Receivable object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReceivableMutation) OldEntryGroup(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEntryGroup is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEntryGroup requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEntryGroup: %w", err)
	}
	return oldValue.EntryGroup, nil
}

// AddEntryGroup adds i to the "entryGroup" field.
func (m *ReceivableMutation) AddEntryGroup(i int) {
	if m.addentryGroup != nil {
		*m.addentryGroup += i
	} else {
		m.addentryGroup = &i
	}
}

// AddedEntryGroup returns the value that was added to the "entryGroup" field in this mutation.
func (m *ReceivableMutation) AddedEntryGroup() (r int, exists bool) {
	v := m.addentryGroup
	if v == nil {
		return
	}
	return *v, true
}

// ResetEntryGroup resets all changes to the "entryGroup" field.
func (m *ReceivableMutation) ResetEntryGroup() {
	m.entryGroup = nil
	m.addentryGroup = nil
}

// SetDate sets the "date" field.
func (m *ReceivableMutation) SetDate(t time.Time) {
	m.date = &t
}

// Date returns the value of the "date" field in the mutation.
func (m *ReceivableMutation) Date() (r time.Time, exists bool) {
	v := m.date
	if v == nil {
		return
	}
	return *v, true
}

// OldDate returns the old "date" field's value of the Receivable entity.
// If the Receivable object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReceivableMutation) OldDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDate: %w", err)
	}
	return oldValue.Date, nil
}

// ResetDate resets all changes to the "date" field.
func (m *ReceivableMutation) ResetDate() {
	m.date = nil
}

// SetName sets the "name" field.
func (m *ReceivableMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ReceivableMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Receivable entity.
// If the Receivable object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReceivableMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ReceivableMutation) ResetName() {
	m.name = nil
}

// SetOutstandingBalance sets the "outstandingBalance" field.
func (m *ReceivableMutation) SetOutstandingBalance(f float64) {
	m.outstandingBalance = &f
	m.addoutstandingBalance = nil
}

// OutstandingBalance returns the value of the "outstandingBalance" field in the mutation.
func (m *ReceivableMutation) OutstandingBalance() (r float64, exists bool) {
	v := m.outstandingBalance
	if v == nil {
		return
	}
	return *v, true
}

// OldOutstandingBalance returns the old "outstandingBalance" field's value of the Receivable entity.
// If the Receivable object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReceivableMutation) OldOutstandingBalance(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOutstandingBalance is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOutstandingBalance requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOutstandingBalance: %w", err)
	}
	return oldValue.OutstandingBalance, nil
}

// AddOutstandingBalance adds f to the "outstandingBalance" field.
func (m *ReceivableMutation) AddOutstandingBalance(f float64) {
	if m.addoutstandingBalance != nil {
		*m.addoutstandingBalance += f
	} else {
		m.addoutstandingBalance = &f
	}
}

// AddedOutstandingBalance returns the value that was added to the "outstandingBalance" field in this mutation.
func (m *ReceivableMutation) AddedOutstandingBalance() (r float64, exists bool) {
	v := m.addoutstandingBalance
	if v == nil {
		return
	}
	return *v, true
}

// ResetOutstandingBalance resets all changes to the "outstandingBalance" field.
func (m *ReceivableMutation) ResetOutstandingBalance() {
	m.outstandingBalance = nil
	m.addoutstandingBalance = nil
}

// SetTotalTransaction sets the "totalTransaction" field.
func (m *ReceivableMutation) SetTotalTransaction(f float64) {
	m.totalTransaction = &f
	m.addtotalTransaction = nil
}

// TotalTransaction returns the value of the "totalTransaction" field in the mutation.
func (m *ReceivableMutation) TotalTransaction() (r float64, exists bool) {
	v := m.totalTransaction
	if v == nil {
		return
	}
	return *v, true
}

// OldTotalTransaction returns the old "totalTransaction" field's value of the Receivable entity.
// If the Receivable object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReceivableMutation) OldTotalTransaction(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTotalTransaction is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTotalTransaction requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTotalTransaction: %w", err)
	}
	return oldValue.TotalTransaction, nil
}

// AddTotalTransaction adds f to the "totalTransaction" field.
func (m *ReceivableMutation) AddTotalTransaction(f float64) {
	if m.addtotalTransaction != nil {
		*m.addtotalTransaction += f
	} else {
		m.addtotalTransaction = &f
	}
}

// AddedTotalTransaction returns the value that was added to the "totalTransaction" field in this mutation.
func (m *ReceivableMutation) AddedTotalTransaction() (r float64, exists bool) {
	v := m.addtotalTransaction
	if v == nil {
		return
	}
	return *v, true
}

// ResetTotalTransaction resets all changes to the "totalTransaction" field.
func (m *ReceivableMutation) ResetTotalTransaction() {
	m.totalTransaction = nil
	m.addtotalTransaction = nil
}

// SetDueDate sets the "dueDate" field.
func (m *ReceivableMutation) SetDueDate(t time.Time) {
	m.dueDate = &t
}

// DueDate returns the value of the "dueDate" field in the mutation.
func (m *ReceivableMutation) DueDate() (r time.Time, exists bool) {
	v := m.dueDate
	if v == nil {
		return
	}
	return *v, true
}

// OldDueDate returns the old "dueDate" field's value of the Receivable entity.
// If the Receivable object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReceivableMutation) OldDueDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDueDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDueDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDueDate: %w", err)
	}
	return oldValue.DueDate, nil
}

// ResetDueDate resets all changes to the "dueDate" field.
func (m *ReceivableMutation) ResetDueDate() {
	m.dueDate = nil
}

// SetStatus sets the "status" field.
func (m *ReceivableMutation) SetStatus(r receivable.Status) {
	m.status = &r
}

// Status returns the value of the "status" field in the mutation.
func (m *ReceivableMutation) Status() (r receivable.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Receivable entity.
// If the Receivable object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReceivableMutation) OldStatus(ctx context.Context) (v receivable.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *ReceivableMutation) ResetStatus() {
	m.status = nil
}

// SetCompanyID sets the "company" edge to the Company entity by id.
func (m *ReceivableMutation) SetCompanyID(id int) {
	m.company = &id
}

// ClearCompany clears the "company" edge to the Company entity.
func (m *ReceivableMutation) ClearCompany() {
	m.clearedcompany = true
}

// CompanyCleared reports if the "company" edge to the Company entity was cleared.
func (m *ReceivableMutation) CompanyCleared() bool {
	return m.clearedcompany
}

// CompanyID returns the "company" edge ID in the mutation.
func (m *ReceivableMutation) CompanyID() (id int, exists bool) {
	if m.company != nil {
		return *m.company, true
	}
	return
}

// CompanyIDs returns the "company" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CompanyID instead. It exists only for internal usage by the builders.
func (m *ReceivableMutation) CompanyIDs() (ids []int) {
	if id := m.company; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCompany resets all changes to the "company" edge.
func (m *ReceivableMutation) ResetCompany() {
	m.company = nil
	m.clearedcompany = false
}

// Where appends a list predicates to the ReceivableMutation builder.
func (m *ReceivableMutation) Where(ps ...predicate.Receivable) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ReceivableMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ReceivableMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Receivable, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ReceivableMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ReceivableMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Receivable).
func (m *ReceivableMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ReceivableMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.createdAt != nil {
		fields = append(fields, receivable.FieldCreatedAt)
	}
	if m.updatedAt != nil {
		fields = append(fields, receivable.FieldUpdatedAt)
	}
	if m.deletedAt != nil {
		fields = append(fields, receivable.FieldDeletedAt)
	}
	if m.entryGroup != nil {
		fields = append(fields, receivable.FieldEntryGroup)
	}
	if m.date != nil {
		fields = append(fields, receivable.FieldDate)
	}
	if m.name != nil {
		fields = append(fields, receivable.FieldName)
	}
	if m.outstandingBalance != nil {
		fields = append(fields, receivable.FieldOutstandingBalance)
	}
	if m.totalTransaction != nil {
		fields = append(fields, receivable.FieldTotalTransaction)
	}
	if m.dueDate != nil {
		fields = append(fields, receivable.FieldDueDate)
	}
	if m.status != nil {
		fields = append(fields, receivable.FieldStatus)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ReceivableMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case receivable.FieldCreatedAt:
		return m.CreatedAt()
	case receivable.FieldUpdatedAt:
		return m.UpdatedAt()
	case receivable.FieldDeletedAt:
		return m.DeletedAt()
	case receivable.FieldEntryGroup:
		return m.EntryGroup()
	case receivable.FieldDate:
		return m.Date()
	case receivable.FieldName:
		return m.Name()
	case receivable.FieldOutstandingBalance:
		return m.OutstandingBalance()
	case receivable.FieldTotalTransaction:
		return m.TotalTransaction()
	case receivable.FieldDueDate:
		return m.DueDate()
	case receivable.FieldStatus:
		return m.Status()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ReceivableMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case receivable.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case receivable.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case receivable.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case receivable.FieldEntryGroup:
		return m.OldEntryGroup(ctx)
	case receivable.FieldDate:
		return m.OldDate(ctx)
	case receivable.FieldName:
		return m.OldName(ctx)
	case receivable.FieldOutstandingBalance:
		return m.OldOutstandingBalance(ctx)
	case receivable.FieldTotalTransaction:
		return m.OldTotalTransaction(ctx)
	case receivable.FieldDueDate:
		return m.OldDueDate(ctx)
	case receivable.FieldStatus:
		return m.OldStatus(ctx)
	}
	return nil, fmt.Errorf("unknown Receivable field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ReceivableMutation) SetField(name string, value ent.Value) error {
	switch name {
	case receivable.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case receivable.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case receivable.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case receivable.FieldEntryGroup:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEntryGroup(v)
		return nil
	case receivable.FieldDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDate(v)
		return nil
	case receivable.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case receivable.FieldOutstandingBalance:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOutstandingBalance(v)
		return nil
	case receivable.FieldTotalTransaction:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTotalTransaction(v)
		return nil
	case receivable.FieldDueDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDueDate(v)
		return nil
	case receivable.FieldStatus:
		v, ok := value.(receivable.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	}
	return fmt.Errorf("unknown Receivable field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ReceivableMutation) AddedFields() []string {
	var fields []string
	if m.addentryGroup != nil {
		fields = append(fields, receivable.FieldEntryGroup)
	}
	if m.addoutstandingBalance != nil {
		fields = append(fields, receivable.FieldOutstandingBalance)
	}
	if m.addtotalTransaction != nil {
		fields = append(fields, receivable.FieldTotalTransaction)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ReceivableMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case receivable.FieldEntryGroup:
		return m.AddedEntryGroup()
	case receivable.FieldOutstandingBalance:
		return m.AddedOutstandingBalance()
	case receivable.FieldTotalTransaction:
		return m.AddedTotalTransaction()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ReceivableMutation) AddField(name string, value ent.Value) error {
	switch name {
	case receivable.FieldEntryGroup:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddEntryGroup(v)
		return nil
	case receivable.FieldOutstandingBalance:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOutstandingBalance(v)
		return nil
	case receivable.FieldTotalTransaction:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTotalTransaction(v)
		return nil
	}
	return fmt.Errorf("unknown Receivable numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ReceivableMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(receivable.FieldDeletedAt) {
		fields = append(fields, receivable.FieldDeletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ReceivableMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ReceivableMutation) ClearField(name string) error {
	switch name {
	case receivable.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown Receivable nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ReceivableMutation) ResetField(name string) error {
	switch name {
	case receivable.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case receivable.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case receivable.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case receivable.FieldEntryGroup:
		m.ResetEntryGroup()
		return nil
	case receivable.FieldDate:
		m.ResetDate()
		return nil
	case receivable.FieldName:
		m.ResetName()
		return nil
	case receivable.FieldOutstandingBalance:
		m.ResetOutstandingBalance()
		return nil
	case receivable.FieldTotalTransaction:
		m.ResetTotalTransaction()
		return nil
	case receivable.FieldDueDate:
		m.ResetDueDate()
		return nil
	case receivable.FieldStatus:
		m.ResetStatus()
		return nil
	}
	return fmt.Errorf("unknown Receivable field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ReceivableMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.company != nil {
		edges = append(edges, receivable.EdgeCompany)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ReceivableMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case receivable.EdgeCompany:
		if id := m.company; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ReceivableMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ReceivableMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ReceivableMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedcompany {
		edges = append(edges, receivable.EdgeCompany)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ReceivableMutation) EdgeCleared(name string) bool {
	switch name {
	case receivable.EdgeCompany:
		return m.clearedcompany
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ReceivableMutation) ClearEdge(name string) error {
	switch name {
	case receivable.EdgeCompany:
		m.ClearCompany()
		return nil
	}
	return fmt.Errorf("unknown Receivable unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ReceivableMutation) ResetEdge(name string) error {
	switch name {
	case receivable.EdgeCompany:
		m.ResetCompany()
		return nil
	}
	return fmt.Errorf("unknown Receivable edge %s", name)
}

// SupplierMutation represents an operation that mutates the Supplier nodes in the graph.
type SupplierMutation struct {
	config
	op              Op
	typ             string
	id              *int
	createdAt       *time.Time
	updatedAt       *time.Time
	deletedAt       *time.Time
	address         *string
	city            *string
	country         *string
	description     *string
	email           *string
	isDefault       *bool
	name            *string
	phone           *string
	taxId           *string
	clearedFields   map[string]struct{}
	company         *int
	clearedcompany  bool
	payables        map[int]struct{}
	removedpayables map[int]struct{}
	clearedpayables bool
	done            bool
	oldValue        func(context.Context) (*Supplier, error)
	predicates      []predicate.Supplier
}

var _ ent.Mutation = (*SupplierMutation)(nil)

// supplierOption allows management of the mutation configuration using functional options.
type supplierOption func(*SupplierMutation)

// newSupplierMutation creates new mutation for the Supplier entity.
func newSupplierMutation(c config, op Op, opts ...supplierOption) *SupplierMutation {
	m := &SupplierMutation{
		config:        c,
		op:            op,
		typ:           TypeSupplier,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSupplierID sets the ID field of the mutation.
func withSupplierID(id int) supplierOption {
	return func(m *SupplierMutation) {
		var (
			err   error
			once  sync.Once
			value *Supplier
		)
		m.oldValue = func(ctx context.Context) (*Supplier, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Supplier.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSupplier sets the old Supplier of the mutation.
func withSupplier(node *Supplier) supplierOption {
	return func(m *SupplierMutation) {
		m.oldValue = func(context.Context) (*Supplier, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SupplierMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SupplierMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("generated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SupplierMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SupplierMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Supplier.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "createdAt" field.
func (m *SupplierMutation) SetCreatedAt(t time.Time) {
	m.createdAt = &t
}

// CreatedAt returns the value of the "createdAt" field in the mutation.
func (m *SupplierMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.createdAt
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "createdAt" field's value of the Supplier entity.
// If the Supplier object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SupplierMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "createdAt" field.
func (m *SupplierMutation) ResetCreatedAt() {
	m.createdAt = nil
}

// SetUpdatedAt sets the "updatedAt" field.
func (m *SupplierMutation) SetUpdatedAt(t time.Time) {
	m.updatedAt = &t
}

// UpdatedAt returns the value of the "updatedAt" field in the mutation.
func (m *SupplierMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updatedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updatedAt" field's value of the Supplier entity.
// If the Supplier object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SupplierMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updatedAt" field.
func (m *SupplierMutation) ResetUpdatedAt() {
	m.updatedAt = nil
}

// SetDeletedAt sets the "deletedAt" field.
func (m *SupplierMutation) SetDeletedAt(t time.Time) {
	m.deletedAt = &t
}

// DeletedAt returns the value of the "deletedAt" field in the mutation.
func (m *SupplierMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deletedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deletedAt" field's value of the Supplier entity.
// If the Supplier object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SupplierMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deletedAt" field.
func (m *SupplierMutation) ClearDeletedAt() {
	m.deletedAt = nil
	m.clearedFields[supplier.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deletedAt" field was cleared in this mutation.
func (m *SupplierMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[supplier.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deletedAt" field.
func (m *SupplierMutation) ResetDeletedAt() {
	m.deletedAt = nil
	delete(m.clearedFields, supplier.FieldDeletedAt)
}

// SetAddress sets the "address" field.
func (m *SupplierMutation) SetAddress(s string) {
	m.address = &s
}

// Address returns the value of the "address" field in the mutation.
func (m *SupplierMutation) Address() (r string, exists bool) {
	v := m.address
	if v == nil {
		return
	}
	return *v, true
}

// OldAddress returns the old "address" field's value of the Supplier entity.
// If the Supplier object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SupplierMutation) OldAddress(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAddress: %w", err)
	}
	return oldValue.Address, nil
}

// ResetAddress resets all changes to the "address" field.
func (m *SupplierMutation) ResetAddress() {
	m.address = nil
}

// SetCity sets the "city" field.
func (m *SupplierMutation) SetCity(s string) {
	m.city = &s
}

// City returns the value of the "city" field in the mutation.
func (m *SupplierMutation) City() (r string, exists bool) {
	v := m.city
	if v == nil {
		return
	}
	return *v, true
}

// OldCity returns the old "city" field's value of the Supplier entity.
// If the Supplier object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SupplierMutation) OldCity(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCity: %w", err)
	}
	return oldValue.City, nil
}

// ResetCity resets all changes to the "city" field.
func (m *SupplierMutation) ResetCity() {
	m.city = nil
}

// SetCountry sets the "country" field.
func (m *SupplierMutation) SetCountry(s string) {
	m.country = &s
}

// Country returns the value of the "country" field in the mutation.
func (m *SupplierMutation) Country() (r string, exists bool) {
	v := m.country
	if v == nil {
		return
	}
	return *v, true
}

// OldCountry returns the old "country" field's value of the Supplier entity.
// If the Supplier object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SupplierMutation) OldCountry(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCountry is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCountry requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCountry: %w", err)
	}
	return oldValue.Country, nil
}

// ResetCountry resets all changes to the "country" field.
func (m *SupplierMutation) ResetCountry() {
	m.country = nil
}

// SetDescription sets the "description" field.
func (m *SupplierMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *SupplierMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Supplier entity.
// If the Supplier object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SupplierMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *SupplierMutation) ResetDescription() {
	m.description = nil
}

// SetEmail sets the "email" field.
func (m *SupplierMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *SupplierMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the Supplier entity.
// If the Supplier object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SupplierMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ResetEmail resets all changes to the "email" field.
func (m *SupplierMutation) ResetEmail() {
	m.email = nil
}

// SetIsDefault sets the "isDefault" field.
func (m *SupplierMutation) SetIsDefault(b bool) {
	m.isDefault = &b
}

// IsDefault returns the value of the "isDefault" field in the mutation.
func (m *SupplierMutation) IsDefault() (r bool, exists bool) {
	v := m.isDefault
	if v == nil {
		return
	}
	return *v, true
}

// OldIsDefault returns the old "isDefault" field's value of the Supplier entity.
// If the Supplier object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SupplierMutation) OldIsDefault(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsDefault is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsDefault requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsDefault: %w", err)
	}
	return oldValue.IsDefault, nil
}

// ClearIsDefault clears the value of the "isDefault" field.
func (m *SupplierMutation) ClearIsDefault() {
	m.isDefault = nil
	m.clearedFields[supplier.FieldIsDefault] = struct{}{}
}

// IsDefaultCleared returns if the "isDefault" field was cleared in this mutation.
func (m *SupplierMutation) IsDefaultCleared() bool {
	_, ok := m.clearedFields[supplier.FieldIsDefault]
	return ok
}

// ResetIsDefault resets all changes to the "isDefault" field.
func (m *SupplierMutation) ResetIsDefault() {
	m.isDefault = nil
	delete(m.clearedFields, supplier.FieldIsDefault)
}

// SetName sets the "name" field.
func (m *SupplierMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *SupplierMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Supplier entity.
// If the Supplier object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SupplierMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *SupplierMutation) ResetName() {
	m.name = nil
}

// SetPhone sets the "phone" field.
func (m *SupplierMutation) SetPhone(s string) {
	m.phone = &s
}

// Phone returns the value of the "phone" field in the mutation.
func (m *SupplierMutation) Phone() (r string, exists bool) {
	v := m.phone
	if v == nil {
		return
	}
	return *v, true
}

// OldPhone returns the old "phone" field's value of the Supplier entity.
// If the Supplier object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SupplierMutation) OldPhone(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPhone is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPhone requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPhone: %w", err)
	}
	return oldValue.Phone, nil
}

// ResetPhone resets all changes to the "phone" field.
func (m *SupplierMutation) ResetPhone() {
	m.phone = nil
}

// SetTaxId sets the "taxId" field.
func (m *SupplierMutation) SetTaxId(s string) {
	m.taxId = &s
}

// TaxId returns the value of the "taxId" field in the mutation.
func (m *SupplierMutation) TaxId() (r string, exists bool) {
	v := m.taxId
	if v == nil {
		return
	}
	return *v, true
}

// OldTaxId returns the old "taxId" field's value of the Supplier entity.
// If the Supplier object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SupplierMutation) OldTaxId(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTaxId is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTaxId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTaxId: %w", err)
	}
	return oldValue.TaxId, nil
}

// ResetTaxId resets all changes to the "taxId" field.
func (m *SupplierMutation) ResetTaxId() {
	m.taxId = nil
}

// SetCompanyID sets the "company" edge to the Company entity by id.
func (m *SupplierMutation) SetCompanyID(id int) {
	m.company = &id
}

// ClearCompany clears the "company" edge to the Company entity.
func (m *SupplierMutation) ClearCompany() {
	m.clearedcompany = true
}

// CompanyCleared reports if the "company" edge to the Company entity was cleared.
func (m *SupplierMutation) CompanyCleared() bool {
	return m.clearedcompany
}

// CompanyID returns the "company" edge ID in the mutation.
func (m *SupplierMutation) CompanyID() (id int, exists bool) {
	if m.company != nil {
		return *m.company, true
	}
	return
}

// CompanyIDs returns the "company" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CompanyID instead. It exists only for internal usage by the builders.
func (m *SupplierMutation) CompanyIDs() (ids []int) {
	if id := m.company; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCompany resets all changes to the "company" edge.
func (m *SupplierMutation) ResetCompany() {
	m.company = nil
	m.clearedcompany = false
}

// AddPayableIDs adds the "payables" edge to the Payable entity by ids.
func (m *SupplierMutation) AddPayableIDs(ids ...int) {
	if m.payables == nil {
		m.payables = make(map[int]struct{})
	}
	for i := range ids {
		m.payables[ids[i]] = struct{}{}
	}
}

// ClearPayables clears the "payables" edge to the Payable entity.
func (m *SupplierMutation) ClearPayables() {
	m.clearedpayables = true
}

// PayablesCleared reports if the "payables" edge to the Payable entity was cleared.
func (m *SupplierMutation) PayablesCleared() bool {
	return m.clearedpayables
}

// RemovePayableIDs removes the "payables" edge to the Payable entity by IDs.
func (m *SupplierMutation) RemovePayableIDs(ids ...int) {
	if m.removedpayables == nil {
		m.removedpayables = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.payables, ids[i])
		m.removedpayables[ids[i]] = struct{}{}
	}
}

// RemovedPayables returns the removed IDs of the "payables" edge to the Payable entity.
func (m *SupplierMutation) RemovedPayablesIDs() (ids []int) {
	for id := range m.removedpayables {
		ids = append(ids, id)
	}
	return
}

// PayablesIDs returns the "payables" edge IDs in the mutation.
func (m *SupplierMutation) PayablesIDs() (ids []int) {
	for id := range m.payables {
		ids = append(ids, id)
	}
	return
}

// ResetPayables resets all changes to the "payables" edge.
func (m *SupplierMutation) ResetPayables() {
	m.payables = nil
	m.clearedpayables = false
	m.removedpayables = nil
}

// Where appends a list predicates to the SupplierMutation builder.
func (m *SupplierMutation) Where(ps ...predicate.Supplier) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SupplierMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SupplierMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Supplier, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SupplierMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SupplierMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Supplier).
func (m *SupplierMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SupplierMutation) Fields() []string {
	fields := make([]string, 0, 12)
	if m.createdAt != nil {
		fields = append(fields, supplier.FieldCreatedAt)
	}
	if m.updatedAt != nil {
		fields = append(fields, supplier.FieldUpdatedAt)
	}
	if m.deletedAt != nil {
		fields = append(fields, supplier.FieldDeletedAt)
	}
	if m.address != nil {
		fields = append(fields, supplier.FieldAddress)
	}
	if m.city != nil {
		fields = append(fields, supplier.FieldCity)
	}
	if m.country != nil {
		fields = append(fields, supplier.FieldCountry)
	}
	if m.description != nil {
		fields = append(fields, supplier.FieldDescription)
	}
	if m.email != nil {
		fields = append(fields, supplier.FieldEmail)
	}
	if m.isDefault != nil {
		fields = append(fields, supplier.FieldIsDefault)
	}
	if m.name != nil {
		fields = append(fields, supplier.FieldName)
	}
	if m.phone != nil {
		fields = append(fields, supplier.FieldPhone)
	}
	if m.taxId != nil {
		fields = append(fields, supplier.FieldTaxId)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SupplierMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case supplier.FieldCreatedAt:
		return m.CreatedAt()
	case supplier.FieldUpdatedAt:
		return m.UpdatedAt()
	case supplier.FieldDeletedAt:
		return m.DeletedAt()
	case supplier.FieldAddress:
		return m.Address()
	case supplier.FieldCity:
		return m.City()
	case supplier.FieldCountry:
		return m.Country()
	case supplier.FieldDescription:
		return m.Description()
	case supplier.FieldEmail:
		return m.Email()
	case supplier.FieldIsDefault:
		return m.IsDefault()
	case supplier.FieldName:
		return m.Name()
	case supplier.FieldPhone:
		return m.Phone()
	case supplier.FieldTaxId:
		return m.TaxId()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SupplierMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case supplier.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case supplier.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case supplier.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case supplier.FieldAddress:
		return m.OldAddress(ctx)
	case supplier.FieldCity:
		return m.OldCity(ctx)
	case supplier.FieldCountry:
		return m.OldCountry(ctx)
	case supplier.FieldDescription:
		return m.OldDescription(ctx)
	case supplier.FieldEmail:
		return m.OldEmail(ctx)
	case supplier.FieldIsDefault:
		return m.OldIsDefault(ctx)
	case supplier.FieldName:
		return m.OldName(ctx)
	case supplier.FieldPhone:
		return m.OldPhone(ctx)
	case supplier.FieldTaxId:
		return m.OldTaxId(ctx)
	}
	return nil, fmt.Errorf("unknown Supplier field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SupplierMutation) SetField(name string, value ent.Value) error {
	switch name {
	case supplier.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case supplier.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case supplier.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case supplier.FieldAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAddress(v)
		return nil
	case supplier.FieldCity:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCity(v)
		return nil
	case supplier.FieldCountry:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCountry(v)
		return nil
	case supplier.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case supplier.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case supplier.FieldIsDefault:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsDefault(v)
		return nil
	case supplier.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case supplier.FieldPhone:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPhone(v)
		return nil
	case supplier.FieldTaxId:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTaxId(v)
		return nil
	}
	return fmt.Errorf("unknown Supplier field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SupplierMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SupplierMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SupplierMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Supplier numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SupplierMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(supplier.FieldDeletedAt) {
		fields = append(fields, supplier.FieldDeletedAt)
	}
	if m.FieldCleared(supplier.FieldIsDefault) {
		fields = append(fields, supplier.FieldIsDefault)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SupplierMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SupplierMutation) ClearField(name string) error {
	switch name {
	case supplier.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case supplier.FieldIsDefault:
		m.ClearIsDefault()
		return nil
	}
	return fmt.Errorf("unknown Supplier nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SupplierMutation) ResetField(name string) error {
	switch name {
	case supplier.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case supplier.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case supplier.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case supplier.FieldAddress:
		m.ResetAddress()
		return nil
	case supplier.FieldCity:
		m.ResetCity()
		return nil
	case supplier.FieldCountry:
		m.ResetCountry()
		return nil
	case supplier.FieldDescription:
		m.ResetDescription()
		return nil
	case supplier.FieldEmail:
		m.ResetEmail()
		return nil
	case supplier.FieldIsDefault:
		m.ResetIsDefault()
		return nil
	case supplier.FieldName:
		m.ResetName()
		return nil
	case supplier.FieldPhone:
		m.ResetPhone()
		return nil
	case supplier.FieldTaxId:
		m.ResetTaxId()
		return nil
	}
	return fmt.Errorf("unknown Supplier field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SupplierMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.company != nil {
		edges = append(edges, supplier.EdgeCompany)
	}
	if m.payables != nil {
		edges = append(edges, supplier.EdgePayables)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SupplierMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case supplier.EdgeCompany:
		if id := m.company; id != nil {
			return []ent.Value{*id}
		}
	case supplier.EdgePayables:
		ids := make([]ent.Value, 0, len(m.payables))
		for id := range m.payables {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SupplierMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedpayables != nil {
		edges = append(edges, supplier.EdgePayables)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SupplierMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case supplier.EdgePayables:
		ids := make([]ent.Value, 0, len(m.removedpayables))
		for id := range m.removedpayables {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SupplierMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedcompany {
		edges = append(edges, supplier.EdgeCompany)
	}
	if m.clearedpayables {
		edges = append(edges, supplier.EdgePayables)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SupplierMutation) EdgeCleared(name string) bool {
	switch name {
	case supplier.EdgeCompany:
		return m.clearedcompany
	case supplier.EdgePayables:
		return m.clearedpayables
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SupplierMutation) ClearEdge(name string) error {
	switch name {
	case supplier.EdgeCompany:
		m.ClearCompany()
		return nil
	}
	return fmt.Errorf("unknown Supplier unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SupplierMutation) ResetEdge(name string) error {
	switch name {
	case supplier.EdgeCompany:
		m.ResetCompany()
		return nil
	case supplier.EdgePayables:
		m.ResetPayables()
		return nil
	}
	return fmt.Errorf("unknown Supplier edge %s", name)
}

// TokenMutation represents an operation that mutates the Token nodes in the graph.
type TokenMutation struct {
	config
	op             Op
	typ            string
	id             *int
	expiry         *time.Time
	category       *token.Category
	token          *string
	clearedFields  map[string]struct{}
	company        *int
	clearedcompany bool
	user           *int
	cleareduser    bool
	done           bool
	oldValue       func(context.Context) (*Token, error)
	predicates     []predicate.Token
}

var _ ent.Mutation = (*TokenMutation)(nil)

// tokenOption allows management of the mutation configuration using functional options.
type tokenOption func(*TokenMutation)

// newTokenMutation creates new mutation for the Token entity.
func newTokenMutation(c config, op Op, opts ...tokenOption) *TokenMutation {
	m := &TokenMutation{
		config:        c,
		op:            op,
		typ:           TypeToken,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTokenID sets the ID field of the mutation.
func withTokenID(id int) tokenOption {
	return func(m *TokenMutation) {
		var (
			err   error
			once  sync.Once
			value *Token
		)
		m.oldValue = func(ctx context.Context) (*Token, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Token.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withToken sets the old Token of the mutation.
func withToken(node *Token) tokenOption {
	return func(m *TokenMutation) {
		m.oldValue = func(context.Context) (*Token, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TokenMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TokenMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("generated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TokenMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TokenMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Token.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetExpiry sets the "expiry" field.
func (m *TokenMutation) SetExpiry(t time.Time) {
	m.expiry = &t
}

// Expiry returns the value of the "expiry" field in the mutation.
func (m *TokenMutation) Expiry() (r time.Time, exists bool) {
	v := m.expiry
	if v == nil {
		return
	}
	return *v, true
}

// OldExpiry returns the old "expiry" field's value of the Token entity.
// If the Token object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TokenMutation) OldExpiry(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExpiry is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExpiry requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpiry: %w", err)
	}
	return oldValue.Expiry, nil
}

// ResetExpiry resets all changes to the "expiry" field.
func (m *TokenMutation) ResetExpiry() {
	m.expiry = nil
}

// SetCategory sets the "category" field.
func (m *TokenMutation) SetCategory(t token.Category) {
	m.category = &t
}

// Category returns the value of the "category" field in the mutation.
func (m *TokenMutation) Category() (r token.Category, exists bool) {
	v := m.category
	if v == nil {
		return
	}
	return *v, true
}

// OldCategory returns the old "category" field's value of the Token entity.
// If the Token object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TokenMutation) OldCategory(ctx context.Context) (v token.Category, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCategory is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCategory requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCategory: %w", err)
	}
	return oldValue.Category, nil
}

// ResetCategory resets all changes to the "category" field.
func (m *TokenMutation) ResetCategory() {
	m.category = nil
}

// SetToken sets the "token" field.
func (m *TokenMutation) SetToken(s string) {
	m.token = &s
}

// Token returns the value of the "token" field in the mutation.
func (m *TokenMutation) Token() (r string, exists bool) {
	v := m.token
	if v == nil {
		return
	}
	return *v, true
}

// OldToken returns the old "token" field's value of the Token entity.
// If the Token object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TokenMutation) OldToken(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldToken is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldToken requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldToken: %w", err)
	}
	return oldValue.Token, nil
}

// ResetToken resets all changes to the "token" field.
func (m *TokenMutation) ResetToken() {
	m.token = nil
}

// SetCompanyID sets the "company" edge to the Company entity by id.
func (m *TokenMutation) SetCompanyID(id int) {
	m.company = &id
}

// ClearCompany clears the "company" edge to the Company entity.
func (m *TokenMutation) ClearCompany() {
	m.clearedcompany = true
}

// CompanyCleared reports if the "company" edge to the Company entity was cleared.
func (m *TokenMutation) CompanyCleared() bool {
	return m.clearedcompany
}

// CompanyID returns the "company" edge ID in the mutation.
func (m *TokenMutation) CompanyID() (id int, exists bool) {
	if m.company != nil {
		return *m.company, true
	}
	return
}

// CompanyIDs returns the "company" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CompanyID instead. It exists only for internal usage by the builders.
func (m *TokenMutation) CompanyIDs() (ids []int) {
	if id := m.company; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCompany resets all changes to the "company" edge.
func (m *TokenMutation) ResetCompany() {
	m.company = nil
	m.clearedcompany = false
}

// SetUserID sets the "user" edge to the User entity by id.
func (m *TokenMutation) SetUserID(id int) {
	m.user = &id
}

// ClearUser clears the "user" edge to the User entity.
func (m *TokenMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *TokenMutation) UserCleared() bool {
	return m.cleareduser
}

// UserID returns the "user" edge ID in the mutation.
func (m *TokenMutation) UserID() (id int, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *TokenMutation) UserIDs() (ids []int) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *TokenMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the TokenMutation builder.
func (m *TokenMutation) Where(ps ...predicate.Token) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TokenMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TokenMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Token, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TokenMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TokenMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Token).
func (m *TokenMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TokenMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.expiry != nil {
		fields = append(fields, token.FieldExpiry)
	}
	if m.category != nil {
		fields = append(fields, token.FieldCategory)
	}
	if m.token != nil {
		fields = append(fields, token.FieldToken)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TokenMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case token.FieldExpiry:
		return m.Expiry()
	case token.FieldCategory:
		return m.Category()
	case token.FieldToken:
		return m.Token()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TokenMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case token.FieldExpiry:
		return m.OldExpiry(ctx)
	case token.FieldCategory:
		return m.OldCategory(ctx)
	case token.FieldToken:
		return m.OldToken(ctx)
	}
	return nil, fmt.Errorf("unknown Token field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TokenMutation) SetField(name string, value ent.Value) error {
	switch name {
	case token.FieldExpiry:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpiry(v)
		return nil
	case token.FieldCategory:
		v, ok := value.(token.Category)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCategory(v)
		return nil
	case token.FieldToken:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetToken(v)
		return nil
	}
	return fmt.Errorf("unknown Token field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TokenMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TokenMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TokenMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Token numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TokenMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TokenMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TokenMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Token nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TokenMutation) ResetField(name string) error {
	switch name {
	case token.FieldExpiry:
		m.ResetExpiry()
		return nil
	case token.FieldCategory:
		m.ResetCategory()
		return nil
	case token.FieldToken:
		m.ResetToken()
		return nil
	}
	return fmt.Errorf("unknown Token field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TokenMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.company != nil {
		edges = append(edges, token.EdgeCompany)
	}
	if m.user != nil {
		edges = append(edges, token.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TokenMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case token.EdgeCompany:
		if id := m.company; id != nil {
			return []ent.Value{*id}
		}
	case token.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TokenMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TokenMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TokenMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedcompany {
		edges = append(edges, token.EdgeCompany)
	}
	if m.cleareduser {
		edges = append(edges, token.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TokenMutation) EdgeCleared(name string) bool {
	switch name {
	case token.EdgeCompany:
		return m.clearedcompany
	case token.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TokenMutation) ClearEdge(name string) error {
	switch name {
	case token.EdgeCompany:
		m.ClearCompany()
		return nil
	case token.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown Token unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TokenMutation) ResetEdge(name string) error {
	switch name {
	case token.EdgeCompany:
		m.ResetCompany()
		return nil
	case token.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown Token edge %s", name)
}

// TreasuryMutation represents an operation that mutates the Treasury nodes in the graph.
type TreasuryMutation struct {
	config
	op             Op
	typ            string
	id             *int
	createdAt      *time.Time
	updatedAt      *time.Time
	deletedAt      *time.Time
	balance        *float64
	addbalance     *float64
	clearedFields  map[string]struct{}
	company        *int
	clearedcompany bool
	done           bool
	oldValue       func(context.Context) (*Treasury, error)
	predicates     []predicate.Treasury
}

var _ ent.Mutation = (*TreasuryMutation)(nil)

// treasuryOption allows management of the mutation configuration using functional options.
type treasuryOption func(*TreasuryMutation)

// newTreasuryMutation creates new mutation for the Treasury entity.
func newTreasuryMutation(c config, op Op, opts ...treasuryOption) *TreasuryMutation {
	m := &TreasuryMutation{
		config:        c,
		op:            op,
		typ:           TypeTreasury,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTreasuryID sets the ID field of the mutation.
func withTreasuryID(id int) treasuryOption {
	return func(m *TreasuryMutation) {
		var (
			err   error
			once  sync.Once
			value *Treasury
		)
		m.oldValue = func(ctx context.Context) (*Treasury, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Treasury.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTreasury sets the old Treasury of the mutation.
func withTreasury(node *Treasury) treasuryOption {
	return func(m *TreasuryMutation) {
		m.oldValue = func(context.Context) (*Treasury, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TreasuryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TreasuryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("generated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TreasuryMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TreasuryMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Treasury.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "createdAt" field.
func (m *TreasuryMutation) SetCreatedAt(t time.Time) {
	m.createdAt = &t
}

// CreatedAt returns the value of the "createdAt" field in the mutation.
func (m *TreasuryMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.createdAt
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "createdAt" field's value of the Treasury entity.
// If the Treasury object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TreasuryMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "createdAt" field.
func (m *TreasuryMutation) ResetCreatedAt() {
	m.createdAt = nil
}

// SetUpdatedAt sets the "updatedAt" field.
func (m *TreasuryMutation) SetUpdatedAt(t time.Time) {
	m.updatedAt = &t
}

// UpdatedAt returns the value of the "updatedAt" field in the mutation.
func (m *TreasuryMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updatedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updatedAt" field's value of the Treasury entity.
// If the Treasury object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TreasuryMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updatedAt" field.
func (m *TreasuryMutation) ResetUpdatedAt() {
	m.updatedAt = nil
}

// SetDeletedAt sets the "deletedAt" field.
func (m *TreasuryMutation) SetDeletedAt(t time.Time) {
	m.deletedAt = &t
}

// DeletedAt returns the value of the "deletedAt" field in the mutation.
func (m *TreasuryMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deletedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deletedAt" field's value of the Treasury entity.
// If the Treasury object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TreasuryMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deletedAt" field.
func (m *TreasuryMutation) ClearDeletedAt() {
	m.deletedAt = nil
	m.clearedFields[treasury.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deletedAt" field was cleared in this mutation.
func (m *TreasuryMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[treasury.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deletedAt" field.
func (m *TreasuryMutation) ResetDeletedAt() {
	m.deletedAt = nil
	delete(m.clearedFields, treasury.FieldDeletedAt)
}

// SetBalance sets the "balance" field.
func (m *TreasuryMutation) SetBalance(f float64) {
	m.balance = &f
	m.addbalance = nil
}

// Balance returns the value of the "balance" field in the mutation.
func (m *TreasuryMutation) Balance() (r float64, exists bool) {
	v := m.balance
	if v == nil {
		return
	}
	return *v, true
}

// OldBalance returns the old "balance" field's value of the Treasury entity.
// If the Treasury object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TreasuryMutation) OldBalance(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBalance is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBalance requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBalance: %w", err)
	}
	return oldValue.Balance, nil
}

// AddBalance adds f to the "balance" field.
func (m *TreasuryMutation) AddBalance(f float64) {
	if m.addbalance != nil {
		*m.addbalance += f
	} else {
		m.addbalance = &f
	}
}

// AddedBalance returns the value that was added to the "balance" field in this mutation.
func (m *TreasuryMutation) AddedBalance() (r float64, exists bool) {
	v := m.addbalance
	if v == nil {
		return
	}
	return *v, true
}

// ResetBalance resets all changes to the "balance" field.
func (m *TreasuryMutation) ResetBalance() {
	m.balance = nil
	m.addbalance = nil
}

// SetCompanyID sets the "company" edge to the Company entity by id.
func (m *TreasuryMutation) SetCompanyID(id int) {
	m.company = &id
}

// ClearCompany clears the "company" edge to the Company entity.
func (m *TreasuryMutation) ClearCompany() {
	m.clearedcompany = true
}

// CompanyCleared reports if the "company" edge to the Company entity was cleared.
func (m *TreasuryMutation) CompanyCleared() bool {
	return m.clearedcompany
}

// CompanyID returns the "company" edge ID in the mutation.
func (m *TreasuryMutation) CompanyID() (id int, exists bool) {
	if m.company != nil {
		return *m.company, true
	}
	return
}

// CompanyIDs returns the "company" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CompanyID instead. It exists only for internal usage by the builders.
func (m *TreasuryMutation) CompanyIDs() (ids []int) {
	if id := m.company; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCompany resets all changes to the "company" edge.
func (m *TreasuryMutation) ResetCompany() {
	m.company = nil
	m.clearedcompany = false
}

// Where appends a list predicates to the TreasuryMutation builder.
func (m *TreasuryMutation) Where(ps ...predicate.Treasury) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TreasuryMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TreasuryMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Treasury, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TreasuryMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TreasuryMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Treasury).
func (m *TreasuryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TreasuryMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.createdAt != nil {
		fields = append(fields, treasury.FieldCreatedAt)
	}
	if m.updatedAt != nil {
		fields = append(fields, treasury.FieldUpdatedAt)
	}
	if m.deletedAt != nil {
		fields = append(fields, treasury.FieldDeletedAt)
	}
	if m.balance != nil {
		fields = append(fields, treasury.FieldBalance)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TreasuryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case treasury.FieldCreatedAt:
		return m.CreatedAt()
	case treasury.FieldUpdatedAt:
		return m.UpdatedAt()
	case treasury.FieldDeletedAt:
		return m.DeletedAt()
	case treasury.FieldBalance:
		return m.Balance()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TreasuryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case treasury.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case treasury.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case treasury.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case treasury.FieldBalance:
		return m.OldBalance(ctx)
	}
	return nil, fmt.Errorf("unknown Treasury field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TreasuryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case treasury.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case treasury.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case treasury.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case treasury.FieldBalance:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBalance(v)
		return nil
	}
	return fmt.Errorf("unknown Treasury field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TreasuryMutation) AddedFields() []string {
	var fields []string
	if m.addbalance != nil {
		fields = append(fields, treasury.FieldBalance)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TreasuryMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case treasury.FieldBalance:
		return m.AddedBalance()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TreasuryMutation) AddField(name string, value ent.Value) error {
	switch name {
	case treasury.FieldBalance:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddBalance(v)
		return nil
	}
	return fmt.Errorf("unknown Treasury numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TreasuryMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(treasury.FieldDeletedAt) {
		fields = append(fields, treasury.FieldDeletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TreasuryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TreasuryMutation) ClearField(name string) error {
	switch name {
	case treasury.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown Treasury nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TreasuryMutation) ResetField(name string) error {
	switch name {
	case treasury.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case treasury.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case treasury.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case treasury.FieldBalance:
		m.ResetBalance()
		return nil
	}
	return fmt.Errorf("unknown Treasury field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TreasuryMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.company != nil {
		edges = append(edges, treasury.EdgeCompany)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TreasuryMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case treasury.EdgeCompany:
		if id := m.company; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TreasuryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TreasuryMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TreasuryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedcompany {
		edges = append(edges, treasury.EdgeCompany)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TreasuryMutation) EdgeCleared(name string) bool {
	switch name {
	case treasury.EdgeCompany:
		return m.clearedcompany
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TreasuryMutation) ClearEdge(name string) error {
	switch name {
	case treasury.EdgeCompany:
		m.ClearCompany()
		return nil
	}
	return fmt.Errorf("unknown Treasury unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TreasuryMutation) ResetEdge(name string) error {
	switch name {
	case treasury.EdgeCompany:
		m.ResetCompany()
		return nil
	}
	return fmt.Errorf("unknown Treasury edge %s", name)
}

// UserMutation represents an operation that mutates the User nodes in the graph.
type UserMutation struct {
	config
	op                              Op
	typ                             string
	id                              *int
	createdAt                       *time.Time
	updatedAt                       *time.Time
	deletedAt                       *time.Time
	firebaseUID                     *string
	fcmToken                        *string
	email                           *string
	name                            *string
	phone                           *string
	birthdate                       *time.Time
	gender                          *user.Gender
	disabled                        *bool
	notVerified                     *bool
	clearedFields                   map[string]struct{}
	accountingEntries               map[int]struct{}
	removedaccountingEntries        map[int]struct{}
	clearedaccountingEntries        bool
	company                         map[int]struct{}
	removedcompany                  map[int]struct{}
	clearedcompany                  bool
	assignedRoles                   map[int]struct{}
	removedassignedRoles            map[int]struct{}
	clearedassignedRoles            bool
	subordinates                    map[int]struct{}
	removedsubordinates             map[int]struct{}
	clearedsubordinates             bool
	leader                          *int
	clearedleader                   bool
	employee                        *int
	clearedemployee                 bool
	createdProjects                 map[int]struct{}
	removedcreatedProjects          map[int]struct{}
	clearedcreatedProjects          bool
	leaderedProjects                map[int]struct{}
	removedleaderedProjects         map[int]struct{}
	clearedleaderedProjects         bool
	assignedProjectTasks            map[int]struct{}
	removedassignedProjectTasks     map[int]struct{}
	clearedassignedProjectTasks     bool
	participatedProjectTasks        map[int]struct{}
	removedparticipatedProjectTasks map[int]struct{}
	clearedparticipatedProjectTasks bool
	createdTasks                    map[int]struct{}
	removedcreatedTasks             map[int]struct{}
	clearedcreatedTasks             bool
	tokens                          map[int]struct{}
	removedtokens                   map[int]struct{}
	clearedtokens                   bool
	approvedWorkShifts              map[int]struct{}
	removedapprovedWorkShifts       map[int]struct{}
	clearedapprovedWorkShifts       bool
	workShifts                      map[int]struct{}
	removedworkShifts               map[int]struct{}
	clearedworkShifts               bool
	uploadedDocuments               map[int]struct{}
	removeduploadedDocuments        map[int]struct{}
	cleareduploadedDocuments        bool
	approvedDocuments               map[int]struct{}
	removedapprovedDocuments        map[int]struct{}
	clearedapprovedDocuments        bool
	done                            bool
	oldValue                        func(context.Context) (*User, error)
	predicates                      []predicate.User
}

var _ ent.Mutation = (*UserMutation)(nil)

// userOption allows management of the mutation configuration using functional options.
type userOption func(*UserMutation)

// newUserMutation creates new mutation for the User entity.
func newUserMutation(c config, op Op, opts ...userOption) *UserMutation {
	m := &UserMutation{
		config:        c,
		op:            op,
		typ:           TypeUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserID sets the ID field of the mutation.
func withUserID(id int) userOption {
	return func(m *UserMutation) {
		var (
			err   error
			once  sync.Once
			value *User
		)
		m.oldValue = func(ctx context.Context) (*User, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().User.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUser sets the old User of the mutation.
func withUser(node *User) userOption {
	return func(m *UserMutation) {
		m.oldValue = func(context.Context) (*User, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("generated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().User.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "createdAt" field.
func (m *UserMutation) SetCreatedAt(t time.Time) {
	m.createdAt = &t
}

// CreatedAt returns the value of the "createdAt" field in the mutation.
func (m *UserMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.createdAt
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "createdAt" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "createdAt" field.
func (m *UserMutation) ResetCreatedAt() {
	m.createdAt = nil
}

// SetUpdatedAt sets the "updatedAt" field.
func (m *UserMutation) SetUpdatedAt(t time.Time) {
	m.updatedAt = &t
}

// UpdatedAt returns the value of the "updatedAt" field in the mutation.
func (m *UserMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updatedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updatedAt" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updatedAt" field.
func (m *UserMutation) ResetUpdatedAt() {
	m.updatedAt = nil
}

// SetDeletedAt sets the "deletedAt" field.
func (m *UserMutation) SetDeletedAt(t time.Time) {
	m.deletedAt = &t
}

// DeletedAt returns the value of the "deletedAt" field in the mutation.
func (m *UserMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deletedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deletedAt" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deletedAt" field.
func (m *UserMutation) ClearDeletedAt() {
	m.deletedAt = nil
	m.clearedFields[user.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deletedAt" field was cleared in this mutation.
func (m *UserMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[user.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deletedAt" field.
func (m *UserMutation) ResetDeletedAt() {
	m.deletedAt = nil
	delete(m.clearedFields, user.FieldDeletedAt)
}

// SetFirebaseUID sets the "firebaseUID" field.
func (m *UserMutation) SetFirebaseUID(s string) {
	m.firebaseUID = &s
}

// FirebaseUID returns the value of the "firebaseUID" field in the mutation.
func (m *UserMutation) FirebaseUID() (r string, exists bool) {
	v := m.firebaseUID
	if v == nil {
		return
	}
	return *v, true
}

// OldFirebaseUID returns the old "firebaseUID" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldFirebaseUID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFirebaseUID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFirebaseUID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFirebaseUID: %w", err)
	}
	return oldValue.FirebaseUID, nil
}

// ResetFirebaseUID resets all changes to the "firebaseUID" field.
func (m *UserMutation) ResetFirebaseUID() {
	m.firebaseUID = nil
}

// SetFcmToken sets the "fcmToken" field.
func (m *UserMutation) SetFcmToken(s string) {
	m.fcmToken = &s
}

// FcmToken returns the value of the "fcmToken" field in the mutation.
func (m *UserMutation) FcmToken() (r string, exists bool) {
	v := m.fcmToken
	if v == nil {
		return
	}
	return *v, true
}

// OldFcmToken returns the old "fcmToken" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldFcmToken(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFcmToken is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFcmToken requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFcmToken: %w", err)
	}
	return oldValue.FcmToken, nil
}

// ClearFcmToken clears the value of the "fcmToken" field.
func (m *UserMutation) ClearFcmToken() {
	m.fcmToken = nil
	m.clearedFields[user.FieldFcmToken] = struct{}{}
}

// FcmTokenCleared returns if the "fcmToken" field was cleared in this mutation.
func (m *UserMutation) FcmTokenCleared() bool {
	_, ok := m.clearedFields[user.FieldFcmToken]
	return ok
}

// ResetFcmToken resets all changes to the "fcmToken" field.
func (m *UserMutation) ResetFcmToken() {
	m.fcmToken = nil
	delete(m.clearedFields, user.FieldFcmToken)
}

// SetEmail sets the "email" field.
func (m *UserMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *UserMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldEmail(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ClearEmail clears the value of the "email" field.
func (m *UserMutation) ClearEmail() {
	m.email = nil
	m.clearedFields[user.FieldEmail] = struct{}{}
}

// EmailCleared returns if the "email" field was cleared in this mutation.
func (m *UserMutation) EmailCleared() bool {
	_, ok := m.clearedFields[user.FieldEmail]
	return ok
}

// ResetEmail resets all changes to the "email" field.
func (m *UserMutation) ResetEmail() {
	m.email = nil
	delete(m.clearedFields, user.FieldEmail)
}

// SetName sets the "name" field.
func (m *UserMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *UserMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *UserMutation) ResetName() {
	m.name = nil
}

// SetPhone sets the "phone" field.
func (m *UserMutation) SetPhone(s string) {
	m.phone = &s
}

// Phone returns the value of the "phone" field in the mutation.
func (m *UserMutation) Phone() (r string, exists bool) {
	v := m.phone
	if v == nil {
		return
	}
	return *v, true
}

// OldPhone returns the old "phone" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldPhone(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPhone is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPhone requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPhone: %w", err)
	}
	return oldValue.Phone, nil
}

// ClearPhone clears the value of the "phone" field.
func (m *UserMutation) ClearPhone() {
	m.phone = nil
	m.clearedFields[user.FieldPhone] = struct{}{}
}

// PhoneCleared returns if the "phone" field was cleared in this mutation.
func (m *UserMutation) PhoneCleared() bool {
	_, ok := m.clearedFields[user.FieldPhone]
	return ok
}

// ResetPhone resets all changes to the "phone" field.
func (m *UserMutation) ResetPhone() {
	m.phone = nil
	delete(m.clearedFields, user.FieldPhone)
}

// SetBirthdate sets the "birthdate" field.
func (m *UserMutation) SetBirthdate(t time.Time) {
	m.birthdate = &t
}

// Birthdate returns the value of the "birthdate" field in the mutation.
func (m *UserMutation) Birthdate() (r time.Time, exists bool) {
	v := m.birthdate
	if v == nil {
		return
	}
	return *v, true
}

// OldBirthdate returns the old "birthdate" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldBirthdate(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBirthdate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBirthdate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBirthdate: %w", err)
	}
	return oldValue.Birthdate, nil
}

// ClearBirthdate clears the value of the "birthdate" field.
func (m *UserMutation) ClearBirthdate() {
	m.birthdate = nil
	m.clearedFields[user.FieldBirthdate] = struct{}{}
}

// BirthdateCleared returns if the "birthdate" field was cleared in this mutation.
func (m *UserMutation) BirthdateCleared() bool {
	_, ok := m.clearedFields[user.FieldBirthdate]
	return ok
}

// ResetBirthdate resets all changes to the "birthdate" field.
func (m *UserMutation) ResetBirthdate() {
	m.birthdate = nil
	delete(m.clearedFields, user.FieldBirthdate)
}

// SetGender sets the "gender" field.
func (m *UserMutation) SetGender(u user.Gender) {
	m.gender = &u
}

// Gender returns the value of the "gender" field in the mutation.
func (m *UserMutation) Gender() (r user.Gender, exists bool) {
	v := m.gender
	if v == nil {
		return
	}
	return *v, true
}

// OldGender returns the old "gender" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldGender(ctx context.Context) (v user.Gender, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGender is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGender requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGender: %w", err)
	}
	return oldValue.Gender, nil
}

// ResetGender resets all changes to the "gender" field.
func (m *UserMutation) ResetGender() {
	m.gender = nil
}

// SetDisabled sets the "disabled" field.
func (m *UserMutation) SetDisabled(b bool) {
	m.disabled = &b
}

// Disabled returns the value of the "disabled" field in the mutation.
func (m *UserMutation) Disabled() (r bool, exists bool) {
	v := m.disabled
	if v == nil {
		return
	}
	return *v, true
}

// OldDisabled returns the old "disabled" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldDisabled(ctx context.Context) (v *bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDisabled is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDisabled requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisabled: %w", err)
	}
	return oldValue.Disabled, nil
}

// ClearDisabled clears the value of the "disabled" field.
func (m *UserMutation) ClearDisabled() {
	m.disabled = nil
	m.clearedFields[user.FieldDisabled] = struct{}{}
}

// DisabledCleared returns if the "disabled" field was cleared in this mutation.
func (m *UserMutation) DisabledCleared() bool {
	_, ok := m.clearedFields[user.FieldDisabled]
	return ok
}

// ResetDisabled resets all changes to the "disabled" field.
func (m *UserMutation) ResetDisabled() {
	m.disabled = nil
	delete(m.clearedFields, user.FieldDisabled)
}

// SetNotVerified sets the "notVerified" field.
func (m *UserMutation) SetNotVerified(b bool) {
	m.notVerified = &b
}

// NotVerified returns the value of the "notVerified" field in the mutation.
func (m *UserMutation) NotVerified() (r bool, exists bool) {
	v := m.notVerified
	if v == nil {
		return
	}
	return *v, true
}

// OldNotVerified returns the old "notVerified" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldNotVerified(ctx context.Context) (v *bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNotVerified is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNotVerified requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNotVerified: %w", err)
	}
	return oldValue.NotVerified, nil
}

// ClearNotVerified clears the value of the "notVerified" field.
func (m *UserMutation) ClearNotVerified() {
	m.notVerified = nil
	m.clearedFields[user.FieldNotVerified] = struct{}{}
}

// NotVerifiedCleared returns if the "notVerified" field was cleared in this mutation.
func (m *UserMutation) NotVerifiedCleared() bool {
	_, ok := m.clearedFields[user.FieldNotVerified]
	return ok
}

// ResetNotVerified resets all changes to the "notVerified" field.
func (m *UserMutation) ResetNotVerified() {
	m.notVerified = nil
	delete(m.clearedFields, user.FieldNotVerified)
}

// AddAccountingEntryIDs adds the "accountingEntries" edge to the AccountingEntry entity by ids.
func (m *UserMutation) AddAccountingEntryIDs(ids ...int) {
	if m.accountingEntries == nil {
		m.accountingEntries = make(map[int]struct{})
	}
	for i := range ids {
		m.accountingEntries[ids[i]] = struct{}{}
	}
}

// ClearAccountingEntries clears the "accountingEntries" edge to the AccountingEntry entity.
func (m *UserMutation) ClearAccountingEntries() {
	m.clearedaccountingEntries = true
}

// AccountingEntriesCleared reports if the "accountingEntries" edge to the AccountingEntry entity was cleared.
func (m *UserMutation) AccountingEntriesCleared() bool {
	return m.clearedaccountingEntries
}

// RemoveAccountingEntryIDs removes the "accountingEntries" edge to the AccountingEntry entity by IDs.
func (m *UserMutation) RemoveAccountingEntryIDs(ids ...int) {
	if m.removedaccountingEntries == nil {
		m.removedaccountingEntries = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.accountingEntries, ids[i])
		m.removedaccountingEntries[ids[i]] = struct{}{}
	}
}

// RemovedAccountingEntries returns the removed IDs of the "accountingEntries" edge to the AccountingEntry entity.
func (m *UserMutation) RemovedAccountingEntriesIDs() (ids []int) {
	for id := range m.removedaccountingEntries {
		ids = append(ids, id)
	}
	return
}

// AccountingEntriesIDs returns the "accountingEntries" edge IDs in the mutation.
func (m *UserMutation) AccountingEntriesIDs() (ids []int) {
	for id := range m.accountingEntries {
		ids = append(ids, id)
	}
	return
}

// ResetAccountingEntries resets all changes to the "accountingEntries" edge.
func (m *UserMutation) ResetAccountingEntries() {
	m.accountingEntries = nil
	m.clearedaccountingEntries = false
	m.removedaccountingEntries = nil
}

// AddCompanyIDs adds the "company" edge to the Company entity by ids.
func (m *UserMutation) AddCompanyIDs(ids ...int) {
	if m.company == nil {
		m.company = make(map[int]struct{})
	}
	for i := range ids {
		m.company[ids[i]] = struct{}{}
	}
}

// ClearCompany clears the "company" edge to the Company entity.
func (m *UserMutation) ClearCompany() {
	m.clearedcompany = true
}

// CompanyCleared reports if the "company" edge to the Company entity was cleared.
func (m *UserMutation) CompanyCleared() bool {
	return m.clearedcompany
}

// RemoveCompanyIDs removes the "company" edge to the Company entity by IDs.
func (m *UserMutation) RemoveCompanyIDs(ids ...int) {
	if m.removedcompany == nil {
		m.removedcompany = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.company, ids[i])
		m.removedcompany[ids[i]] = struct{}{}
	}
}

// RemovedCompany returns the removed IDs of the "company" edge to the Company entity.
func (m *UserMutation) RemovedCompanyIDs() (ids []int) {
	for id := range m.removedcompany {
		ids = append(ids, id)
	}
	return
}

// CompanyIDs returns the "company" edge IDs in the mutation.
func (m *UserMutation) CompanyIDs() (ids []int) {
	for id := range m.company {
		ids = append(ids, id)
	}
	return
}

// ResetCompany resets all changes to the "company" edge.
func (m *UserMutation) ResetCompany() {
	m.company = nil
	m.clearedcompany = false
	m.removedcompany = nil
}

// AddAssignedRoleIDs adds the "assignedRoles" edge to the UserRole entity by ids.
func (m *UserMutation) AddAssignedRoleIDs(ids ...int) {
	if m.assignedRoles == nil {
		m.assignedRoles = make(map[int]struct{})
	}
	for i := range ids {
		m.assignedRoles[ids[i]] = struct{}{}
	}
}

// ClearAssignedRoles clears the "assignedRoles" edge to the UserRole entity.
func (m *UserMutation) ClearAssignedRoles() {
	m.clearedassignedRoles = true
}

// AssignedRolesCleared reports if the "assignedRoles" edge to the UserRole entity was cleared.
func (m *UserMutation) AssignedRolesCleared() bool {
	return m.clearedassignedRoles
}

// RemoveAssignedRoleIDs removes the "assignedRoles" edge to the UserRole entity by IDs.
func (m *UserMutation) RemoveAssignedRoleIDs(ids ...int) {
	if m.removedassignedRoles == nil {
		m.removedassignedRoles = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.assignedRoles, ids[i])
		m.removedassignedRoles[ids[i]] = struct{}{}
	}
}

// RemovedAssignedRoles returns the removed IDs of the "assignedRoles" edge to the UserRole entity.
func (m *UserMutation) RemovedAssignedRolesIDs() (ids []int) {
	for id := range m.removedassignedRoles {
		ids = append(ids, id)
	}
	return
}

// AssignedRolesIDs returns the "assignedRoles" edge IDs in the mutation.
func (m *UserMutation) AssignedRolesIDs() (ids []int) {
	for id := range m.assignedRoles {
		ids = append(ids, id)
	}
	return
}

// ResetAssignedRoles resets all changes to the "assignedRoles" edge.
func (m *UserMutation) ResetAssignedRoles() {
	m.assignedRoles = nil
	m.clearedassignedRoles = false
	m.removedassignedRoles = nil
}

// AddSubordinateIDs adds the "subordinates" edge to the User entity by ids.
func (m *UserMutation) AddSubordinateIDs(ids ...int) {
	if m.subordinates == nil {
		m.subordinates = make(map[int]struct{})
	}
	for i := range ids {
		m.subordinates[ids[i]] = struct{}{}
	}
}

// ClearSubordinates clears the "subordinates" edge to the User entity.
func (m *UserMutation) ClearSubordinates() {
	m.clearedsubordinates = true
}

// SubordinatesCleared reports if the "subordinates" edge to the User entity was cleared.
func (m *UserMutation) SubordinatesCleared() bool {
	return m.clearedsubordinates
}

// RemoveSubordinateIDs removes the "subordinates" edge to the User entity by IDs.
func (m *UserMutation) RemoveSubordinateIDs(ids ...int) {
	if m.removedsubordinates == nil {
		m.removedsubordinates = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.subordinates, ids[i])
		m.removedsubordinates[ids[i]] = struct{}{}
	}
}

// RemovedSubordinates returns the removed IDs of the "subordinates" edge to the User entity.
func (m *UserMutation) RemovedSubordinatesIDs() (ids []int) {
	for id := range m.removedsubordinates {
		ids = append(ids, id)
	}
	return
}

// SubordinatesIDs returns the "subordinates" edge IDs in the mutation.
func (m *UserMutation) SubordinatesIDs() (ids []int) {
	for id := range m.subordinates {
		ids = append(ids, id)
	}
	return
}

// ResetSubordinates resets all changes to the "subordinates" edge.
func (m *UserMutation) ResetSubordinates() {
	m.subordinates = nil
	m.clearedsubordinates = false
	m.removedsubordinates = nil
}

// SetLeaderID sets the "leader" edge to the User entity by id.
func (m *UserMutation) SetLeaderID(id int) {
	m.leader = &id
}

// ClearLeader clears the "leader" edge to the User entity.
func (m *UserMutation) ClearLeader() {
	m.clearedleader = true
}

// LeaderCleared reports if the "leader" edge to the User entity was cleared.
func (m *UserMutation) LeaderCleared() bool {
	return m.clearedleader
}

// LeaderID returns the "leader" edge ID in the mutation.
func (m *UserMutation) LeaderID() (id int, exists bool) {
	if m.leader != nil {
		return *m.leader, true
	}
	return
}

// LeaderIDs returns the "leader" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// LeaderID instead. It exists only for internal usage by the builders.
func (m *UserMutation) LeaderIDs() (ids []int) {
	if id := m.leader; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetLeader resets all changes to the "leader" edge.
func (m *UserMutation) ResetLeader() {
	m.leader = nil
	m.clearedleader = false
}

// SetEmployeeID sets the "employee" edge to the Employee entity by id.
func (m *UserMutation) SetEmployeeID(id int) {
	m.employee = &id
}

// ClearEmployee clears the "employee" edge to the Employee entity.
func (m *UserMutation) ClearEmployee() {
	m.clearedemployee = true
}

// EmployeeCleared reports if the "employee" edge to the Employee entity was cleared.
func (m *UserMutation) EmployeeCleared() bool {
	return m.clearedemployee
}

// EmployeeID returns the "employee" edge ID in the mutation.
func (m *UserMutation) EmployeeID() (id int, exists bool) {
	if m.employee != nil {
		return *m.employee, true
	}
	return
}

// EmployeeIDs returns the "employee" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// EmployeeID instead. It exists only for internal usage by the builders.
func (m *UserMutation) EmployeeIDs() (ids []int) {
	if id := m.employee; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEmployee resets all changes to the "employee" edge.
func (m *UserMutation) ResetEmployee() {
	m.employee = nil
	m.clearedemployee = false
}

// AddCreatedProjectIDs adds the "createdProjects" edge to the Project entity by ids.
func (m *UserMutation) AddCreatedProjectIDs(ids ...int) {
	if m.createdProjects == nil {
		m.createdProjects = make(map[int]struct{})
	}
	for i := range ids {
		m.createdProjects[ids[i]] = struct{}{}
	}
}

// ClearCreatedProjects clears the "createdProjects" edge to the Project entity.
func (m *UserMutation) ClearCreatedProjects() {
	m.clearedcreatedProjects = true
}

// CreatedProjectsCleared reports if the "createdProjects" edge to the Project entity was cleared.
func (m *UserMutation) CreatedProjectsCleared() bool {
	return m.clearedcreatedProjects
}

// RemoveCreatedProjectIDs removes the "createdProjects" edge to the Project entity by IDs.
func (m *UserMutation) RemoveCreatedProjectIDs(ids ...int) {
	if m.removedcreatedProjects == nil {
		m.removedcreatedProjects = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.createdProjects, ids[i])
		m.removedcreatedProjects[ids[i]] = struct{}{}
	}
}

// RemovedCreatedProjects returns the removed IDs of the "createdProjects" edge to the Project entity.
func (m *UserMutation) RemovedCreatedProjectsIDs() (ids []int) {
	for id := range m.removedcreatedProjects {
		ids = append(ids, id)
	}
	return
}

// CreatedProjectsIDs returns the "createdProjects" edge IDs in the mutation.
func (m *UserMutation) CreatedProjectsIDs() (ids []int) {
	for id := range m.createdProjects {
		ids = append(ids, id)
	}
	return
}

// ResetCreatedProjects resets all changes to the "createdProjects" edge.
func (m *UserMutation) ResetCreatedProjects() {
	m.createdProjects = nil
	m.clearedcreatedProjects = false
	m.removedcreatedProjects = nil
}

// AddLeaderedProjectIDs adds the "leaderedProjects" edge to the Project entity by ids.
func (m *UserMutation) AddLeaderedProjectIDs(ids ...int) {
	if m.leaderedProjects == nil {
		m.leaderedProjects = make(map[int]struct{})
	}
	for i := range ids {
		m.leaderedProjects[ids[i]] = struct{}{}
	}
}

// ClearLeaderedProjects clears the "leaderedProjects" edge to the Project entity.
func (m *UserMutation) ClearLeaderedProjects() {
	m.clearedleaderedProjects = true
}

// LeaderedProjectsCleared reports if the "leaderedProjects" edge to the Project entity was cleared.
func (m *UserMutation) LeaderedProjectsCleared() bool {
	return m.clearedleaderedProjects
}

// RemoveLeaderedProjectIDs removes the "leaderedProjects" edge to the Project entity by IDs.
func (m *UserMutation) RemoveLeaderedProjectIDs(ids ...int) {
	if m.removedleaderedProjects == nil {
		m.removedleaderedProjects = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.leaderedProjects, ids[i])
		m.removedleaderedProjects[ids[i]] = struct{}{}
	}
}

// RemovedLeaderedProjects returns the removed IDs of the "leaderedProjects" edge to the Project entity.
func (m *UserMutation) RemovedLeaderedProjectsIDs() (ids []int) {
	for id := range m.removedleaderedProjects {
		ids = append(ids, id)
	}
	return
}

// LeaderedProjectsIDs returns the "leaderedProjects" edge IDs in the mutation.
func (m *UserMutation) LeaderedProjectsIDs() (ids []int) {
	for id := range m.leaderedProjects {
		ids = append(ids, id)
	}
	return
}

// ResetLeaderedProjects resets all changes to the "leaderedProjects" edge.
func (m *UserMutation) ResetLeaderedProjects() {
	m.leaderedProjects = nil
	m.clearedleaderedProjects = false
	m.removedleaderedProjects = nil
}

// AddAssignedProjectTaskIDs adds the "assignedProjectTasks" edge to the ProjectTask entity by ids.
func (m *UserMutation) AddAssignedProjectTaskIDs(ids ...int) {
	if m.assignedProjectTasks == nil {
		m.assignedProjectTasks = make(map[int]struct{})
	}
	for i := range ids {
		m.assignedProjectTasks[ids[i]] = struct{}{}
	}
}

// ClearAssignedProjectTasks clears the "assignedProjectTasks" edge to the ProjectTask entity.
func (m *UserMutation) ClearAssignedProjectTasks() {
	m.clearedassignedProjectTasks = true
}

// AssignedProjectTasksCleared reports if the "assignedProjectTasks" edge to the ProjectTask entity was cleared.
func (m *UserMutation) AssignedProjectTasksCleared() bool {
	return m.clearedassignedProjectTasks
}

// RemoveAssignedProjectTaskIDs removes the "assignedProjectTasks" edge to the ProjectTask entity by IDs.
func (m *UserMutation) RemoveAssignedProjectTaskIDs(ids ...int) {
	if m.removedassignedProjectTasks == nil {
		m.removedassignedProjectTasks = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.assignedProjectTasks, ids[i])
		m.removedassignedProjectTasks[ids[i]] = struct{}{}
	}
}

// RemovedAssignedProjectTasks returns the removed IDs of the "assignedProjectTasks" edge to the ProjectTask entity.
func (m *UserMutation) RemovedAssignedProjectTasksIDs() (ids []int) {
	for id := range m.removedassignedProjectTasks {
		ids = append(ids, id)
	}
	return
}

// AssignedProjectTasksIDs returns the "assignedProjectTasks" edge IDs in the mutation.
func (m *UserMutation) AssignedProjectTasksIDs() (ids []int) {
	for id := range m.assignedProjectTasks {
		ids = append(ids, id)
	}
	return
}

// ResetAssignedProjectTasks resets all changes to the "assignedProjectTasks" edge.
func (m *UserMutation) ResetAssignedProjectTasks() {
	m.assignedProjectTasks = nil
	m.clearedassignedProjectTasks = false
	m.removedassignedProjectTasks = nil
}

// AddParticipatedProjectTaskIDs adds the "participatedProjectTasks" edge to the ProjectTask entity by ids.
func (m *UserMutation) AddParticipatedProjectTaskIDs(ids ...int) {
	if m.participatedProjectTasks == nil {
		m.participatedProjectTasks = make(map[int]struct{})
	}
	for i := range ids {
		m.participatedProjectTasks[ids[i]] = struct{}{}
	}
}

// ClearParticipatedProjectTasks clears the "participatedProjectTasks" edge to the ProjectTask entity.
func (m *UserMutation) ClearParticipatedProjectTasks() {
	m.clearedparticipatedProjectTasks = true
}

// ParticipatedProjectTasksCleared reports if the "participatedProjectTasks" edge to the ProjectTask entity was cleared.
func (m *UserMutation) ParticipatedProjectTasksCleared() bool {
	return m.clearedparticipatedProjectTasks
}

// RemoveParticipatedProjectTaskIDs removes the "participatedProjectTasks" edge to the ProjectTask entity by IDs.
func (m *UserMutation) RemoveParticipatedProjectTaskIDs(ids ...int) {
	if m.removedparticipatedProjectTasks == nil {
		m.removedparticipatedProjectTasks = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.participatedProjectTasks, ids[i])
		m.removedparticipatedProjectTasks[ids[i]] = struct{}{}
	}
}

// RemovedParticipatedProjectTasks returns the removed IDs of the "participatedProjectTasks" edge to the ProjectTask entity.
func (m *UserMutation) RemovedParticipatedProjectTasksIDs() (ids []int) {
	for id := range m.removedparticipatedProjectTasks {
		ids = append(ids, id)
	}
	return
}

// ParticipatedProjectTasksIDs returns the "participatedProjectTasks" edge IDs in the mutation.
func (m *UserMutation) ParticipatedProjectTasksIDs() (ids []int) {
	for id := range m.participatedProjectTasks {
		ids = append(ids, id)
	}
	return
}

// ResetParticipatedProjectTasks resets all changes to the "participatedProjectTasks" edge.
func (m *UserMutation) ResetParticipatedProjectTasks() {
	m.participatedProjectTasks = nil
	m.clearedparticipatedProjectTasks = false
	m.removedparticipatedProjectTasks = nil
}

// AddCreatedTaskIDs adds the "createdTasks" edge to the ProjectTask entity by ids.
func (m *UserMutation) AddCreatedTaskIDs(ids ...int) {
	if m.createdTasks == nil {
		m.createdTasks = make(map[int]struct{})
	}
	for i := range ids {
		m.createdTasks[ids[i]] = struct{}{}
	}
}

// ClearCreatedTasks clears the "createdTasks" edge to the ProjectTask entity.
func (m *UserMutation) ClearCreatedTasks() {
	m.clearedcreatedTasks = true
}

// CreatedTasksCleared reports if the "createdTasks" edge to the ProjectTask entity was cleared.
func (m *UserMutation) CreatedTasksCleared() bool {
	return m.clearedcreatedTasks
}

// RemoveCreatedTaskIDs removes the "createdTasks" edge to the ProjectTask entity by IDs.
func (m *UserMutation) RemoveCreatedTaskIDs(ids ...int) {
	if m.removedcreatedTasks == nil {
		m.removedcreatedTasks = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.createdTasks, ids[i])
		m.removedcreatedTasks[ids[i]] = struct{}{}
	}
}

// RemovedCreatedTasks returns the removed IDs of the "createdTasks" edge to the ProjectTask entity.
func (m *UserMutation) RemovedCreatedTasksIDs() (ids []int) {
	for id := range m.removedcreatedTasks {
		ids = append(ids, id)
	}
	return
}

// CreatedTasksIDs returns the "createdTasks" edge IDs in the mutation.
func (m *UserMutation) CreatedTasksIDs() (ids []int) {
	for id := range m.createdTasks {
		ids = append(ids, id)
	}
	return
}

// ResetCreatedTasks resets all changes to the "createdTasks" edge.
func (m *UserMutation) ResetCreatedTasks() {
	m.createdTasks = nil
	m.clearedcreatedTasks = false
	m.removedcreatedTasks = nil
}

// AddTokenIDs adds the "tokens" edge to the Token entity by ids.
func (m *UserMutation) AddTokenIDs(ids ...int) {
	if m.tokens == nil {
		m.tokens = make(map[int]struct{})
	}
	for i := range ids {
		m.tokens[ids[i]] = struct{}{}
	}
}

// ClearTokens clears the "tokens" edge to the Token entity.
func (m *UserMutation) ClearTokens() {
	m.clearedtokens = true
}

// TokensCleared reports if the "tokens" edge to the Token entity was cleared.
func (m *UserMutation) TokensCleared() bool {
	return m.clearedtokens
}

// RemoveTokenIDs removes the "tokens" edge to the Token entity by IDs.
func (m *UserMutation) RemoveTokenIDs(ids ...int) {
	if m.removedtokens == nil {
		m.removedtokens = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.tokens, ids[i])
		m.removedtokens[ids[i]] = struct{}{}
	}
}

// RemovedTokens returns the removed IDs of the "tokens" edge to the Token entity.
func (m *UserMutation) RemovedTokensIDs() (ids []int) {
	for id := range m.removedtokens {
		ids = append(ids, id)
	}
	return
}

// TokensIDs returns the "tokens" edge IDs in the mutation.
func (m *UserMutation) TokensIDs() (ids []int) {
	for id := range m.tokens {
		ids = append(ids, id)
	}
	return
}

// ResetTokens resets all changes to the "tokens" edge.
func (m *UserMutation) ResetTokens() {
	m.tokens = nil
	m.clearedtokens = false
	m.removedtokens = nil
}

// AddApprovedWorkShiftIDs adds the "approvedWorkShifts" edge to the Workshift entity by ids.
func (m *UserMutation) AddApprovedWorkShiftIDs(ids ...int) {
	if m.approvedWorkShifts == nil {
		m.approvedWorkShifts = make(map[int]struct{})
	}
	for i := range ids {
		m.approvedWorkShifts[ids[i]] = struct{}{}
	}
}

// ClearApprovedWorkShifts clears the "approvedWorkShifts" edge to the Workshift entity.
func (m *UserMutation) ClearApprovedWorkShifts() {
	m.clearedapprovedWorkShifts = true
}

// ApprovedWorkShiftsCleared reports if the "approvedWorkShifts" edge to the Workshift entity was cleared.
func (m *UserMutation) ApprovedWorkShiftsCleared() bool {
	return m.clearedapprovedWorkShifts
}

// RemoveApprovedWorkShiftIDs removes the "approvedWorkShifts" edge to the Workshift entity by IDs.
func (m *UserMutation) RemoveApprovedWorkShiftIDs(ids ...int) {
	if m.removedapprovedWorkShifts == nil {
		m.removedapprovedWorkShifts = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.approvedWorkShifts, ids[i])
		m.removedapprovedWorkShifts[ids[i]] = struct{}{}
	}
}

// RemovedApprovedWorkShifts returns the removed IDs of the "approvedWorkShifts" edge to the Workshift entity.
func (m *UserMutation) RemovedApprovedWorkShiftsIDs() (ids []int) {
	for id := range m.removedapprovedWorkShifts {
		ids = append(ids, id)
	}
	return
}

// ApprovedWorkShiftsIDs returns the "approvedWorkShifts" edge IDs in the mutation.
func (m *UserMutation) ApprovedWorkShiftsIDs() (ids []int) {
	for id := range m.approvedWorkShifts {
		ids = append(ids, id)
	}
	return
}

// ResetApprovedWorkShifts resets all changes to the "approvedWorkShifts" edge.
func (m *UserMutation) ResetApprovedWorkShifts() {
	m.approvedWorkShifts = nil
	m.clearedapprovedWorkShifts = false
	m.removedapprovedWorkShifts = nil
}

// AddWorkShiftIDs adds the "workShifts" edge to the Workshift entity by ids.
func (m *UserMutation) AddWorkShiftIDs(ids ...int) {
	if m.workShifts == nil {
		m.workShifts = make(map[int]struct{})
	}
	for i := range ids {
		m.workShifts[ids[i]] = struct{}{}
	}
}

// ClearWorkShifts clears the "workShifts" edge to the Workshift entity.
func (m *UserMutation) ClearWorkShifts() {
	m.clearedworkShifts = true
}

// WorkShiftsCleared reports if the "workShifts" edge to the Workshift entity was cleared.
func (m *UserMutation) WorkShiftsCleared() bool {
	return m.clearedworkShifts
}

// RemoveWorkShiftIDs removes the "workShifts" edge to the Workshift entity by IDs.
func (m *UserMutation) RemoveWorkShiftIDs(ids ...int) {
	if m.removedworkShifts == nil {
		m.removedworkShifts = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.workShifts, ids[i])
		m.removedworkShifts[ids[i]] = struct{}{}
	}
}

// RemovedWorkShifts returns the removed IDs of the "workShifts" edge to the Workshift entity.
func (m *UserMutation) RemovedWorkShiftsIDs() (ids []int) {
	for id := range m.removedworkShifts {
		ids = append(ids, id)
	}
	return
}

// WorkShiftsIDs returns the "workShifts" edge IDs in the mutation.
func (m *UserMutation) WorkShiftsIDs() (ids []int) {
	for id := range m.workShifts {
		ids = append(ids, id)
	}
	return
}

// ResetWorkShifts resets all changes to the "workShifts" edge.
func (m *UserMutation) ResetWorkShifts() {
	m.workShifts = nil
	m.clearedworkShifts = false
	m.removedworkShifts = nil
}

// AddUploadedDocumentIDs adds the "uploadedDocuments" edge to the CompanyDocument entity by ids.
func (m *UserMutation) AddUploadedDocumentIDs(ids ...int) {
	if m.uploadedDocuments == nil {
		m.uploadedDocuments = make(map[int]struct{})
	}
	for i := range ids {
		m.uploadedDocuments[ids[i]] = struct{}{}
	}
}

// ClearUploadedDocuments clears the "uploadedDocuments" edge to the CompanyDocument entity.
func (m *UserMutation) ClearUploadedDocuments() {
	m.cleareduploadedDocuments = true
}

// UploadedDocumentsCleared reports if the "uploadedDocuments" edge to the CompanyDocument entity was cleared.
func (m *UserMutation) UploadedDocumentsCleared() bool {
	return m.cleareduploadedDocuments
}

// RemoveUploadedDocumentIDs removes the "uploadedDocuments" edge to the CompanyDocument entity by IDs.
func (m *UserMutation) RemoveUploadedDocumentIDs(ids ...int) {
	if m.removeduploadedDocuments == nil {
		m.removeduploadedDocuments = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.uploadedDocuments, ids[i])
		m.removeduploadedDocuments[ids[i]] = struct{}{}
	}
}

// RemovedUploadedDocuments returns the removed IDs of the "uploadedDocuments" edge to the CompanyDocument entity.
func (m *UserMutation) RemovedUploadedDocumentsIDs() (ids []int) {
	for id := range m.removeduploadedDocuments {
		ids = append(ids, id)
	}
	return
}

// UploadedDocumentsIDs returns the "uploadedDocuments" edge IDs in the mutation.
func (m *UserMutation) UploadedDocumentsIDs() (ids []int) {
	for id := range m.uploadedDocuments {
		ids = append(ids, id)
	}
	return
}

// ResetUploadedDocuments resets all changes to the "uploadedDocuments" edge.
func (m *UserMutation) ResetUploadedDocuments() {
	m.uploadedDocuments = nil
	m.cleareduploadedDocuments = false
	m.removeduploadedDocuments = nil
}

// AddApprovedDocumentIDs adds the "approvedDocuments" edge to the CompanyDocument entity by ids.
func (m *UserMutation) AddApprovedDocumentIDs(ids ...int) {
	if m.approvedDocuments == nil {
		m.approvedDocuments = make(map[int]struct{})
	}
	for i := range ids {
		m.approvedDocuments[ids[i]] = struct{}{}
	}
}

// ClearApprovedDocuments clears the "approvedDocuments" edge to the CompanyDocument entity.
func (m *UserMutation) ClearApprovedDocuments() {
	m.clearedapprovedDocuments = true
}

// ApprovedDocumentsCleared reports if the "approvedDocuments" edge to the CompanyDocument entity was cleared.
func (m *UserMutation) ApprovedDocumentsCleared() bool {
	return m.clearedapprovedDocuments
}

// RemoveApprovedDocumentIDs removes the "approvedDocuments" edge to the CompanyDocument entity by IDs.
func (m *UserMutation) RemoveApprovedDocumentIDs(ids ...int) {
	if m.removedapprovedDocuments == nil {
		m.removedapprovedDocuments = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.approvedDocuments, ids[i])
		m.removedapprovedDocuments[ids[i]] = struct{}{}
	}
}

// RemovedApprovedDocuments returns the removed IDs of the "approvedDocuments" edge to the CompanyDocument entity.
func (m *UserMutation) RemovedApprovedDocumentsIDs() (ids []int) {
	for id := range m.removedapprovedDocuments {
		ids = append(ids, id)
	}
	return
}

// ApprovedDocumentsIDs returns the "approvedDocuments" edge IDs in the mutation.
func (m *UserMutation) ApprovedDocumentsIDs() (ids []int) {
	for id := range m.approvedDocuments {
		ids = append(ids, id)
	}
	return
}

// ResetApprovedDocuments resets all changes to the "approvedDocuments" edge.
func (m *UserMutation) ResetApprovedDocuments() {
	m.approvedDocuments = nil
	m.clearedapprovedDocuments = false
	m.removedapprovedDocuments = nil
}

// Where appends a list predicates to the UserMutation builder.
func (m *UserMutation) Where(ps ...predicate.User) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.User, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (User).
func (m *UserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserMutation) Fields() []string {
	fields := make([]string, 0, 12)
	if m.createdAt != nil {
		fields = append(fields, user.FieldCreatedAt)
	}
	if m.updatedAt != nil {
		fields = append(fields, user.FieldUpdatedAt)
	}
	if m.deletedAt != nil {
		fields = append(fields, user.FieldDeletedAt)
	}
	if m.firebaseUID != nil {
		fields = append(fields, user.FieldFirebaseUID)
	}
	if m.fcmToken != nil {
		fields = append(fields, user.FieldFcmToken)
	}
	if m.email != nil {
		fields = append(fields, user.FieldEmail)
	}
	if m.name != nil {
		fields = append(fields, user.FieldName)
	}
	if m.phone != nil {
		fields = append(fields, user.FieldPhone)
	}
	if m.birthdate != nil {
		fields = append(fields, user.FieldBirthdate)
	}
	if m.gender != nil {
		fields = append(fields, user.FieldGender)
	}
	if m.disabled != nil {
		fields = append(fields, user.FieldDisabled)
	}
	if m.notVerified != nil {
		fields = append(fields, user.FieldNotVerified)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case user.FieldCreatedAt:
		return m.CreatedAt()
	case user.FieldUpdatedAt:
		return m.UpdatedAt()
	case user.FieldDeletedAt:
		return m.DeletedAt()
	case user.FieldFirebaseUID:
		return m.FirebaseUID()
	case user.FieldFcmToken:
		return m.FcmToken()
	case user.FieldEmail:
		return m.Email()
	case user.FieldName:
		return m.Name()
	case user.FieldPhone:
		return m.Phone()
	case user.FieldBirthdate:
		return m.Birthdate()
	case user.FieldGender:
		return m.Gender()
	case user.FieldDisabled:
		return m.Disabled()
	case user.FieldNotVerified:
		return m.NotVerified()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case user.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case user.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case user.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case user.FieldFirebaseUID:
		return m.OldFirebaseUID(ctx)
	case user.FieldFcmToken:
		return m.OldFcmToken(ctx)
	case user.FieldEmail:
		return m.OldEmail(ctx)
	case user.FieldName:
		return m.OldName(ctx)
	case user.FieldPhone:
		return m.OldPhone(ctx)
	case user.FieldBirthdate:
		return m.OldBirthdate(ctx)
	case user.FieldGender:
		return m.OldGender(ctx)
	case user.FieldDisabled:
		return m.OldDisabled(ctx)
	case user.FieldNotVerified:
		return m.OldNotVerified(ctx)
	}
	return nil, fmt.Errorf("unknown User field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case user.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case user.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case user.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case user.FieldFirebaseUID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFirebaseUID(v)
		return nil
	case user.FieldFcmToken:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFcmToken(v)
		return nil
	case user.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case user.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case user.FieldPhone:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPhone(v)
		return nil
	case user.FieldBirthdate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBirthdate(v)
		return nil
	case user.FieldGender:
		v, ok := value.(user.Gender)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGender(v)
		return nil
	case user.FieldDisabled:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisabled(v)
		return nil
	case user.FieldNotVerified:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNotVerified(v)
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown User numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(user.FieldDeletedAt) {
		fields = append(fields, user.FieldDeletedAt)
	}
	if m.FieldCleared(user.FieldFcmToken) {
		fields = append(fields, user.FieldFcmToken)
	}
	if m.FieldCleared(user.FieldEmail) {
		fields = append(fields, user.FieldEmail)
	}
	if m.FieldCleared(user.FieldPhone) {
		fields = append(fields, user.FieldPhone)
	}
	if m.FieldCleared(user.FieldBirthdate) {
		fields = append(fields, user.FieldBirthdate)
	}
	if m.FieldCleared(user.FieldDisabled) {
		fields = append(fields, user.FieldDisabled)
	}
	if m.FieldCleared(user.FieldNotVerified) {
		fields = append(fields, user.FieldNotVerified)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserMutation) ClearField(name string) error {
	switch name {
	case user.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case user.FieldFcmToken:
		m.ClearFcmToken()
		return nil
	case user.FieldEmail:
		m.ClearEmail()
		return nil
	case user.FieldPhone:
		m.ClearPhone()
		return nil
	case user.FieldBirthdate:
		m.ClearBirthdate()
		return nil
	case user.FieldDisabled:
		m.ClearDisabled()
		return nil
	case user.FieldNotVerified:
		m.ClearNotVerified()
		return nil
	}
	return fmt.Errorf("unknown User nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserMutation) ResetField(name string) error {
	switch name {
	case user.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case user.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case user.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case user.FieldFirebaseUID:
		m.ResetFirebaseUID()
		return nil
	case user.FieldFcmToken:
		m.ResetFcmToken()
		return nil
	case user.FieldEmail:
		m.ResetEmail()
		return nil
	case user.FieldName:
		m.ResetName()
		return nil
	case user.FieldPhone:
		m.ResetPhone()
		return nil
	case user.FieldBirthdate:
		m.ResetBirthdate()
		return nil
	case user.FieldGender:
		m.ResetGender()
		return nil
	case user.FieldDisabled:
		m.ResetDisabled()
		return nil
	case user.FieldNotVerified:
		m.ResetNotVerified()
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserMutation) AddedEdges() []string {
	edges := make([]string, 0, 16)
	if m.accountingEntries != nil {
		edges = append(edges, user.EdgeAccountingEntries)
	}
	if m.company != nil {
		edges = append(edges, user.EdgeCompany)
	}
	if m.assignedRoles != nil {
		edges = append(edges, user.EdgeAssignedRoles)
	}
	if m.subordinates != nil {
		edges = append(edges, user.EdgeSubordinates)
	}
	if m.leader != nil {
		edges = append(edges, user.EdgeLeader)
	}
	if m.employee != nil {
		edges = append(edges, user.EdgeEmployee)
	}
	if m.createdProjects != nil {
		edges = append(edges, user.EdgeCreatedProjects)
	}
	if m.leaderedProjects != nil {
		edges = append(edges, user.EdgeLeaderedProjects)
	}
	if m.assignedProjectTasks != nil {
		edges = append(edges, user.EdgeAssignedProjectTasks)
	}
	if m.participatedProjectTasks != nil {
		edges = append(edges, user.EdgeParticipatedProjectTasks)
	}
	if m.createdTasks != nil {
		edges = append(edges, user.EdgeCreatedTasks)
	}
	if m.tokens != nil {
		edges = append(edges, user.EdgeTokens)
	}
	if m.approvedWorkShifts != nil {
		edges = append(edges, user.EdgeApprovedWorkShifts)
	}
	if m.workShifts != nil {
		edges = append(edges, user.EdgeWorkShifts)
	}
	if m.uploadedDocuments != nil {
		edges = append(edges, user.EdgeUploadedDocuments)
	}
	if m.approvedDocuments != nil {
		edges = append(edges, user.EdgeApprovedDocuments)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeAccountingEntries:
		ids := make([]ent.Value, 0, len(m.accountingEntries))
		for id := range m.accountingEntries {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeCompany:
		ids := make([]ent.Value, 0, len(m.company))
		for id := range m.company {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeAssignedRoles:
		ids := make([]ent.Value, 0, len(m.assignedRoles))
		for id := range m.assignedRoles {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeSubordinates:
		ids := make([]ent.Value, 0, len(m.subordinates))
		for id := range m.subordinates {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeLeader:
		if id := m.leader; id != nil {
			return []ent.Value{*id}
		}
	case user.EdgeEmployee:
		if id := m.employee; id != nil {
			return []ent.Value{*id}
		}
	case user.EdgeCreatedProjects:
		ids := make([]ent.Value, 0, len(m.createdProjects))
		for id := range m.createdProjects {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeLeaderedProjects:
		ids := make([]ent.Value, 0, len(m.leaderedProjects))
		for id := range m.leaderedProjects {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeAssignedProjectTasks:
		ids := make([]ent.Value, 0, len(m.assignedProjectTasks))
		for id := range m.assignedProjectTasks {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeParticipatedProjectTasks:
		ids := make([]ent.Value, 0, len(m.participatedProjectTasks))
		for id := range m.participatedProjectTasks {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeCreatedTasks:
		ids := make([]ent.Value, 0, len(m.createdTasks))
		for id := range m.createdTasks {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeTokens:
		ids := make([]ent.Value, 0, len(m.tokens))
		for id := range m.tokens {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeApprovedWorkShifts:
		ids := make([]ent.Value, 0, len(m.approvedWorkShifts))
		for id := range m.approvedWorkShifts {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeWorkShifts:
		ids := make([]ent.Value, 0, len(m.workShifts))
		for id := range m.workShifts {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeUploadedDocuments:
		ids := make([]ent.Value, 0, len(m.uploadedDocuments))
		for id := range m.uploadedDocuments {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeApprovedDocuments:
		ids := make([]ent.Value, 0, len(m.approvedDocuments))
		for id := range m.approvedDocuments {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 16)
	if m.removedaccountingEntries != nil {
		edges = append(edges, user.EdgeAccountingEntries)
	}
	if m.removedcompany != nil {
		edges = append(edges, user.EdgeCompany)
	}
	if m.removedassignedRoles != nil {
		edges = append(edges, user.EdgeAssignedRoles)
	}
	if m.removedsubordinates != nil {
		edges = append(edges, user.EdgeSubordinates)
	}
	if m.removedcreatedProjects != nil {
		edges = append(edges, user.EdgeCreatedProjects)
	}
	if m.removedleaderedProjects != nil {
		edges = append(edges, user.EdgeLeaderedProjects)
	}
	if m.removedassignedProjectTasks != nil {
		edges = append(edges, user.EdgeAssignedProjectTasks)
	}
	if m.removedparticipatedProjectTasks != nil {
		edges = append(edges, user.EdgeParticipatedProjectTasks)
	}
	if m.removedcreatedTasks != nil {
		edges = append(edges, user.EdgeCreatedTasks)
	}
	if m.removedtokens != nil {
		edges = append(edges, user.EdgeTokens)
	}
	if m.removedapprovedWorkShifts != nil {
		edges = append(edges, user.EdgeApprovedWorkShifts)
	}
	if m.removedworkShifts != nil {
		edges = append(edges, user.EdgeWorkShifts)
	}
	if m.removeduploadedDocuments != nil {
		edges = append(edges, user.EdgeUploadedDocuments)
	}
	if m.removedapprovedDocuments != nil {
		edges = append(edges, user.EdgeApprovedDocuments)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeAccountingEntries:
		ids := make([]ent.Value, 0, len(m.removedaccountingEntries))
		for id := range m.removedaccountingEntries {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeCompany:
		ids := make([]ent.Value, 0, len(m.removedcompany))
		for id := range m.removedcompany {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeAssignedRoles:
		ids := make([]ent.Value, 0, len(m.removedassignedRoles))
		for id := range m.removedassignedRoles {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeSubordinates:
		ids := make([]ent.Value, 0, len(m.removedsubordinates))
		for id := range m.removedsubordinates {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeCreatedProjects:
		ids := make([]ent.Value, 0, len(m.removedcreatedProjects))
		for id := range m.removedcreatedProjects {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeLeaderedProjects:
		ids := make([]ent.Value, 0, len(m.removedleaderedProjects))
		for id := range m.removedleaderedProjects {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeAssignedProjectTasks:
		ids := make([]ent.Value, 0, len(m.removedassignedProjectTasks))
		for id := range m.removedassignedProjectTasks {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeParticipatedProjectTasks:
		ids := make([]ent.Value, 0, len(m.removedparticipatedProjectTasks))
		for id := range m.removedparticipatedProjectTasks {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeCreatedTasks:
		ids := make([]ent.Value, 0, len(m.removedcreatedTasks))
		for id := range m.removedcreatedTasks {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeTokens:
		ids := make([]ent.Value, 0, len(m.removedtokens))
		for id := range m.removedtokens {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeApprovedWorkShifts:
		ids := make([]ent.Value, 0, len(m.removedapprovedWorkShifts))
		for id := range m.removedapprovedWorkShifts {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeWorkShifts:
		ids := make([]ent.Value, 0, len(m.removedworkShifts))
		for id := range m.removedworkShifts {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeUploadedDocuments:
		ids := make([]ent.Value, 0, len(m.removeduploadedDocuments))
		for id := range m.removeduploadedDocuments {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeApprovedDocuments:
		ids := make([]ent.Value, 0, len(m.removedapprovedDocuments))
		for id := range m.removedapprovedDocuments {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 16)
	if m.clearedaccountingEntries {
		edges = append(edges, user.EdgeAccountingEntries)
	}
	if m.clearedcompany {
		edges = append(edges, user.EdgeCompany)
	}
	if m.clearedassignedRoles {
		edges = append(edges, user.EdgeAssignedRoles)
	}
	if m.clearedsubordinates {
		edges = append(edges, user.EdgeSubordinates)
	}
	if m.clearedleader {
		edges = append(edges, user.EdgeLeader)
	}
	if m.clearedemployee {
		edges = append(edges, user.EdgeEmployee)
	}
	if m.clearedcreatedProjects {
		edges = append(edges, user.EdgeCreatedProjects)
	}
	if m.clearedleaderedProjects {
		edges = append(edges, user.EdgeLeaderedProjects)
	}
	if m.clearedassignedProjectTasks {
		edges = append(edges, user.EdgeAssignedProjectTasks)
	}
	if m.clearedparticipatedProjectTasks {
		edges = append(edges, user.EdgeParticipatedProjectTasks)
	}
	if m.clearedcreatedTasks {
		edges = append(edges, user.EdgeCreatedTasks)
	}
	if m.clearedtokens {
		edges = append(edges, user.EdgeTokens)
	}
	if m.clearedapprovedWorkShifts {
		edges = append(edges, user.EdgeApprovedWorkShifts)
	}
	if m.clearedworkShifts {
		edges = append(edges, user.EdgeWorkShifts)
	}
	if m.cleareduploadedDocuments {
		edges = append(edges, user.EdgeUploadedDocuments)
	}
	if m.clearedapprovedDocuments {
		edges = append(edges, user.EdgeApprovedDocuments)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserMutation) EdgeCleared(name string) bool {
	switch name {
	case user.EdgeAccountingEntries:
		return m.clearedaccountingEntries
	case user.EdgeCompany:
		return m.clearedcompany
	case user.EdgeAssignedRoles:
		return m.clearedassignedRoles
	case user.EdgeSubordinates:
		return m.clearedsubordinates
	case user.EdgeLeader:
		return m.clearedleader
	case user.EdgeEmployee:
		return m.clearedemployee
	case user.EdgeCreatedProjects:
		return m.clearedcreatedProjects
	case user.EdgeLeaderedProjects:
		return m.clearedleaderedProjects
	case user.EdgeAssignedProjectTasks:
		return m.clearedassignedProjectTasks
	case user.EdgeParticipatedProjectTasks:
		return m.clearedparticipatedProjectTasks
	case user.EdgeCreatedTasks:
		return m.clearedcreatedTasks
	case user.EdgeTokens:
		return m.clearedtokens
	case user.EdgeApprovedWorkShifts:
		return m.clearedapprovedWorkShifts
	case user.EdgeWorkShifts:
		return m.clearedworkShifts
	case user.EdgeUploadedDocuments:
		return m.cleareduploadedDocuments
	case user.EdgeApprovedDocuments:
		return m.clearedapprovedDocuments
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserMutation) ClearEdge(name string) error {
	switch name {
	case user.EdgeLeader:
		m.ClearLeader()
		return nil
	case user.EdgeEmployee:
		m.ClearEmployee()
		return nil
	}
	return fmt.Errorf("unknown User unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserMutation) ResetEdge(name string) error {
	switch name {
	case user.EdgeAccountingEntries:
		m.ResetAccountingEntries()
		return nil
	case user.EdgeCompany:
		m.ResetCompany()
		return nil
	case user.EdgeAssignedRoles:
		m.ResetAssignedRoles()
		return nil
	case user.EdgeSubordinates:
		m.ResetSubordinates()
		return nil
	case user.EdgeLeader:
		m.ResetLeader()
		return nil
	case user.EdgeEmployee:
		m.ResetEmployee()
		return nil
	case user.EdgeCreatedProjects:
		m.ResetCreatedProjects()
		return nil
	case user.EdgeLeaderedProjects:
		m.ResetLeaderedProjects()
		return nil
	case user.EdgeAssignedProjectTasks:
		m.ResetAssignedProjectTasks()
		return nil
	case user.EdgeParticipatedProjectTasks:
		m.ResetParticipatedProjectTasks()
		return nil
	case user.EdgeCreatedTasks:
		m.ResetCreatedTasks()
		return nil
	case user.EdgeTokens:
		m.ResetTokens()
		return nil
	case user.EdgeApprovedWorkShifts:
		m.ResetApprovedWorkShifts()
		return nil
	case user.EdgeWorkShifts:
		m.ResetWorkShifts()
		return nil
	case user.EdgeUploadedDocuments:
		m.ResetUploadedDocuments()
		return nil
	case user.EdgeApprovedDocuments:
		m.ResetApprovedDocuments()
		return nil
	}
	return fmt.Errorf("unknown User edge %s", name)
}

// UserRoleMutation represents an operation that mutates the UserRole nodes in the graph.
type UserRoleMutation struct {
	config
	op             Op
	typ            string
	id             *int
	role           *userrole.Role
	clearedFields  map[string]struct{}
	company        *int
	clearedcompany bool
	user           map[int]struct{}
	removeduser    map[int]struct{}
	cleareduser    bool
	done           bool
	oldValue       func(context.Context) (*UserRole, error)
	predicates     []predicate.UserRole
}

var _ ent.Mutation = (*UserRoleMutation)(nil)

// userroleOption allows management of the mutation configuration using functional options.
type userroleOption func(*UserRoleMutation)

// newUserRoleMutation creates new mutation for the UserRole entity.
func newUserRoleMutation(c config, op Op, opts ...userroleOption) *UserRoleMutation {
	m := &UserRoleMutation{
		config:        c,
		op:            op,
		typ:           TypeUserRole,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserRoleID sets the ID field of the mutation.
func withUserRoleID(id int) userroleOption {
	return func(m *UserRoleMutation) {
		var (
			err   error
			once  sync.Once
			value *UserRole
		)
		m.oldValue = func(ctx context.Context) (*UserRole, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().UserRole.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUserRole sets the old UserRole of the mutation.
func withUserRole(node *UserRole) userroleOption {
	return func(m *UserRoleMutation) {
		m.oldValue = func(context.Context) (*UserRole, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserRoleMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserRoleMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("generated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserRoleMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserRoleMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().UserRole.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetRole sets the "role" field.
func (m *UserRoleMutation) SetRole(u userrole.Role) {
	m.role = &u
}

// Role returns the value of the "role" field in the mutation.
func (m *UserRoleMutation) Role() (r userrole.Role, exists bool) {
	v := m.role
	if v == nil {
		return
	}
	return *v, true
}

// OldRole returns the old "role" field's value of the UserRole entity.
// If the UserRole object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserRoleMutation) OldRole(ctx context.Context) (v userrole.Role, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRole is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRole requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRole: %w", err)
	}
	return oldValue.Role, nil
}

// ResetRole resets all changes to the "role" field.
func (m *UserRoleMutation) ResetRole() {
	m.role = nil
}

// SetCompanyID sets the "company" edge to the Company entity by id.
func (m *UserRoleMutation) SetCompanyID(id int) {
	m.company = &id
}

// ClearCompany clears the "company" edge to the Company entity.
func (m *UserRoleMutation) ClearCompany() {
	m.clearedcompany = true
}

// CompanyCleared reports if the "company" edge to the Company entity was cleared.
func (m *UserRoleMutation) CompanyCleared() bool {
	return m.clearedcompany
}

// CompanyID returns the "company" edge ID in the mutation.
func (m *UserRoleMutation) CompanyID() (id int, exists bool) {
	if m.company != nil {
		return *m.company, true
	}
	return
}

// CompanyIDs returns the "company" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CompanyID instead. It exists only for internal usage by the builders.
func (m *UserRoleMutation) CompanyIDs() (ids []int) {
	if id := m.company; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCompany resets all changes to the "company" edge.
func (m *UserRoleMutation) ResetCompany() {
	m.company = nil
	m.clearedcompany = false
}

// AddUserIDs adds the "user" edge to the User entity by ids.
func (m *UserRoleMutation) AddUserIDs(ids ...int) {
	if m.user == nil {
		m.user = make(map[int]struct{})
	}
	for i := range ids {
		m.user[ids[i]] = struct{}{}
	}
}

// ClearUser clears the "user" edge to the User entity.
func (m *UserRoleMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *UserRoleMutation) UserCleared() bool {
	return m.cleareduser
}

// RemoveUserIDs removes the "user" edge to the User entity by IDs.
func (m *UserRoleMutation) RemoveUserIDs(ids ...int) {
	if m.removeduser == nil {
		m.removeduser = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.user, ids[i])
		m.removeduser[ids[i]] = struct{}{}
	}
}

// RemovedUser returns the removed IDs of the "user" edge to the User entity.
func (m *UserRoleMutation) RemovedUserIDs() (ids []int) {
	for id := range m.removeduser {
		ids = append(ids, id)
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
func (m *UserRoleMutation) UserIDs() (ids []int) {
	for id := range m.user {
		ids = append(ids, id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *UserRoleMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
	m.removeduser = nil
}

// Where appends a list predicates to the UserRoleMutation builder.
func (m *UserRoleMutation) Where(ps ...predicate.UserRole) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserRoleMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserRoleMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.UserRole, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserRoleMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserRoleMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (UserRole).
func (m *UserRoleMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserRoleMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.role != nil {
		fields = append(fields, userrole.FieldRole)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserRoleMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case userrole.FieldRole:
		return m.Role()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserRoleMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case userrole.FieldRole:
		return m.OldRole(ctx)
	}
	return nil, fmt.Errorf("unknown UserRole field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserRoleMutation) SetField(name string, value ent.Value) error {
	switch name {
	case userrole.FieldRole:
		v, ok := value.(userrole.Role)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRole(v)
		return nil
	}
	return fmt.Errorf("unknown UserRole field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserRoleMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserRoleMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserRoleMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown UserRole numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserRoleMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserRoleMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserRoleMutation) ClearField(name string) error {
	return fmt.Errorf("unknown UserRole nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserRoleMutation) ResetField(name string) error {
	switch name {
	case userrole.FieldRole:
		m.ResetRole()
		return nil
	}
	return fmt.Errorf("unknown UserRole field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserRoleMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.company != nil {
		edges = append(edges, userrole.EdgeCompany)
	}
	if m.user != nil {
		edges = append(edges, userrole.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserRoleMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case userrole.EdgeCompany:
		if id := m.company; id != nil {
			return []ent.Value{*id}
		}
	case userrole.EdgeUser:
		ids := make([]ent.Value, 0, len(m.user))
		for id := range m.user {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserRoleMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removeduser != nil {
		edges = append(edges, userrole.EdgeUser)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserRoleMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case userrole.EdgeUser:
		ids := make([]ent.Value, 0, len(m.removeduser))
		for id := range m.removeduser {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserRoleMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedcompany {
		edges = append(edges, userrole.EdgeCompany)
	}
	if m.cleareduser {
		edges = append(edges, userrole.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserRoleMutation) EdgeCleared(name string) bool {
	switch name {
	case userrole.EdgeCompany:
		return m.clearedcompany
	case userrole.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserRoleMutation) ClearEdge(name string) error {
	switch name {
	case userrole.EdgeCompany:
		m.ClearCompany()
		return nil
	}
	return fmt.Errorf("unknown UserRole unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserRoleMutation) ResetEdge(name string) error {
	switch name {
	case userrole.EdgeCompany:
		m.ResetCompany()
		return nil
	case userrole.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown UserRole edge %s", name)
}

// WorkshiftMutation represents an operation that mutates the Workshift nodes in the graph.
type WorkshiftMutation struct {
	config
	op                 Op
	typ                string
	id                 *int
	createdAt          *time.Time
	updatedAt          *time.Time
	deletedAt          *time.Time
	approvedAt         *time.Time
	clockIn            *time.Time
	clockOut           *time.Time
	clockInLocation    *string
	clockOutLocation   *string
	description        *string
	note               *string
	status             *workshift.Status
	clearedFields      map[string]struct{}
	company            *int
	clearedcompany     bool
	user               *int
	cleareduser        bool
	approvedBy         *int
	clearedapprovedBy  bool
	task               *int
	clearedtask        bool
	editRequest        *int
	clearededitRequest bool
	workShift          *int
	clearedworkShift   bool
	done               bool
	oldValue           func(context.Context) (*Workshift, error)
	predicates         []predicate.Workshift
}

var _ ent.Mutation = (*WorkshiftMutation)(nil)

// workshiftOption allows management of the mutation configuration using functional options.
type workshiftOption func(*WorkshiftMutation)

// newWorkshiftMutation creates new mutation for the Workshift entity.
func newWorkshiftMutation(c config, op Op, opts ...workshiftOption) *WorkshiftMutation {
	m := &WorkshiftMutation{
		config:        c,
		op:            op,
		typ:           TypeWorkshift,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withWorkshiftID sets the ID field of the mutation.
func withWorkshiftID(id int) workshiftOption {
	return func(m *WorkshiftMutation) {
		var (
			err   error
			once  sync.Once
			value *Workshift
		)
		m.oldValue = func(ctx context.Context) (*Workshift, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Workshift.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withWorkshift sets the old Workshift of the mutation.
func withWorkshift(node *Workshift) workshiftOption {
	return func(m *WorkshiftMutation) {
		m.oldValue = func(context.Context) (*Workshift, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m WorkshiftMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m WorkshiftMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("generated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *WorkshiftMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *WorkshiftMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Workshift.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "createdAt" field.
func (m *WorkshiftMutation) SetCreatedAt(t time.Time) {
	m.createdAt = &t
}

// CreatedAt returns the value of the "createdAt" field in the mutation.
func (m *WorkshiftMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.createdAt
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "createdAt" field's value of the Workshift entity.
// If the Workshift object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkshiftMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "createdAt" field.
func (m *WorkshiftMutation) ResetCreatedAt() {
	m.createdAt = nil
}

// SetUpdatedAt sets the "updatedAt" field.
func (m *WorkshiftMutation) SetUpdatedAt(t time.Time) {
	m.updatedAt = &t
}

// UpdatedAt returns the value of the "updatedAt" field in the mutation.
func (m *WorkshiftMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updatedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updatedAt" field's value of the Workshift entity.
// If the Workshift object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkshiftMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updatedAt" field.
func (m *WorkshiftMutation) ResetUpdatedAt() {
	m.updatedAt = nil
}

// SetDeletedAt sets the "deletedAt" field.
func (m *WorkshiftMutation) SetDeletedAt(t time.Time) {
	m.deletedAt = &t
}

// DeletedAt returns the value of the "deletedAt" field in the mutation.
func (m *WorkshiftMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deletedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deletedAt" field's value of the Workshift entity.
// If the Workshift object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkshiftMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deletedAt" field.
func (m *WorkshiftMutation) ClearDeletedAt() {
	m.deletedAt = nil
	m.clearedFields[workshift.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deletedAt" field was cleared in this mutation.
func (m *WorkshiftMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[workshift.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deletedAt" field.
func (m *WorkshiftMutation) ResetDeletedAt() {
	m.deletedAt = nil
	delete(m.clearedFields, workshift.FieldDeletedAt)
}

// SetApprovedAt sets the "approvedAt" field.
func (m *WorkshiftMutation) SetApprovedAt(t time.Time) {
	m.approvedAt = &t
}

// ApprovedAt returns the value of the "approvedAt" field in the mutation.
func (m *WorkshiftMutation) ApprovedAt() (r time.Time, exists bool) {
	v := m.approvedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldApprovedAt returns the old "approvedAt" field's value of the Workshift entity.
// If the Workshift object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkshiftMutation) OldApprovedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldApprovedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldApprovedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldApprovedAt: %w", err)
	}
	return oldValue.ApprovedAt, nil
}

// ClearApprovedAt clears the value of the "approvedAt" field.
func (m *WorkshiftMutation) ClearApprovedAt() {
	m.approvedAt = nil
	m.clearedFields[workshift.FieldApprovedAt] = struct{}{}
}

// ApprovedAtCleared returns if the "approvedAt" field was cleared in this mutation.
func (m *WorkshiftMutation) ApprovedAtCleared() bool {
	_, ok := m.clearedFields[workshift.FieldApprovedAt]
	return ok
}

// ResetApprovedAt resets all changes to the "approvedAt" field.
func (m *WorkshiftMutation) ResetApprovedAt() {
	m.approvedAt = nil
	delete(m.clearedFields, workshift.FieldApprovedAt)
}

// SetClockIn sets the "clockIn" field.
func (m *WorkshiftMutation) SetClockIn(t time.Time) {
	m.clockIn = &t
}

// ClockIn returns the value of the "clockIn" field in the mutation.
func (m *WorkshiftMutation) ClockIn() (r time.Time, exists bool) {
	v := m.clockIn
	if v == nil {
		return
	}
	return *v, true
}

// OldClockIn returns the old "clockIn" field's value of the Workshift entity.
// If the Workshift object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkshiftMutation) OldClockIn(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClockIn is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClockIn requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClockIn: %w", err)
	}
	return oldValue.ClockIn, nil
}

// ResetClockIn resets all changes to the "clockIn" field.
func (m *WorkshiftMutation) ResetClockIn() {
	m.clockIn = nil
}

// SetClockOut sets the "clockOut" field.
func (m *WorkshiftMutation) SetClockOut(t time.Time) {
	m.clockOut = &t
}

// ClockOut returns the value of the "clockOut" field in the mutation.
func (m *WorkshiftMutation) ClockOut() (r time.Time, exists bool) {
	v := m.clockOut
	if v == nil {
		return
	}
	return *v, true
}

// OldClockOut returns the old "clockOut" field's value of the Workshift entity.
// If the Workshift object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkshiftMutation) OldClockOut(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClockOut is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClockOut requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClockOut: %w", err)
	}
	return oldValue.ClockOut, nil
}

// ClearClockOut clears the value of the "clockOut" field.
func (m *WorkshiftMutation) ClearClockOut() {
	m.clockOut = nil
	m.clearedFields[workshift.FieldClockOut] = struct{}{}
}

// ClockOutCleared returns if the "clockOut" field was cleared in this mutation.
func (m *WorkshiftMutation) ClockOutCleared() bool {
	_, ok := m.clearedFields[workshift.FieldClockOut]
	return ok
}

// ResetClockOut resets all changes to the "clockOut" field.
func (m *WorkshiftMutation) ResetClockOut() {
	m.clockOut = nil
	delete(m.clearedFields, workshift.FieldClockOut)
}

// SetClockInLocation sets the "clockInLocation" field.
func (m *WorkshiftMutation) SetClockInLocation(s string) {
	m.clockInLocation = &s
}

// ClockInLocation returns the value of the "clockInLocation" field in the mutation.
func (m *WorkshiftMutation) ClockInLocation() (r string, exists bool) {
	v := m.clockInLocation
	if v == nil {
		return
	}
	return *v, true
}

// OldClockInLocation returns the old "clockInLocation" field's value of the Workshift entity.
// If the Workshift object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkshiftMutation) OldClockInLocation(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClockInLocation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClockInLocation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClockInLocation: %w", err)
	}
	return oldValue.ClockInLocation, nil
}

// ResetClockInLocation resets all changes to the "clockInLocation" field.
func (m *WorkshiftMutation) ResetClockInLocation() {
	m.clockInLocation = nil
}

// SetClockOutLocation sets the "clockOutLocation" field.
func (m *WorkshiftMutation) SetClockOutLocation(s string) {
	m.clockOutLocation = &s
}

// ClockOutLocation returns the value of the "clockOutLocation" field in the mutation.
func (m *WorkshiftMutation) ClockOutLocation() (r string, exists bool) {
	v := m.clockOutLocation
	if v == nil {
		return
	}
	return *v, true
}

// OldClockOutLocation returns the old "clockOutLocation" field's value of the Workshift entity.
// If the Workshift object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkshiftMutation) OldClockOutLocation(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClockOutLocation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClockOutLocation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClockOutLocation: %w", err)
	}
	return oldValue.ClockOutLocation, nil
}

// ClearClockOutLocation clears the value of the "clockOutLocation" field.
func (m *WorkshiftMutation) ClearClockOutLocation() {
	m.clockOutLocation = nil
	m.clearedFields[workshift.FieldClockOutLocation] = struct{}{}
}

// ClockOutLocationCleared returns if the "clockOutLocation" field was cleared in this mutation.
func (m *WorkshiftMutation) ClockOutLocationCleared() bool {
	_, ok := m.clearedFields[workshift.FieldClockOutLocation]
	return ok
}

// ResetClockOutLocation resets all changes to the "clockOutLocation" field.
func (m *WorkshiftMutation) ResetClockOutLocation() {
	m.clockOutLocation = nil
	delete(m.clearedFields, workshift.FieldClockOutLocation)
}

// SetDescription sets the "description" field.
func (m *WorkshiftMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *WorkshiftMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Workshift entity.
// If the Workshift object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkshiftMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *WorkshiftMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[workshift.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *WorkshiftMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[workshift.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *WorkshiftMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, workshift.FieldDescription)
}

// SetNote sets the "note" field.
func (m *WorkshiftMutation) SetNote(s string) {
	m.note = &s
}

// Note returns the value of the "note" field in the mutation.
func (m *WorkshiftMutation) Note() (r string, exists bool) {
	v := m.note
	if v == nil {
		return
	}
	return *v, true
}

// OldNote returns the old "note" field's value of the Workshift entity.
// If the Workshift object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkshiftMutation) OldNote(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNote is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNote requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNote: %w", err)
	}
	return oldValue.Note, nil
}

// ClearNote clears the value of the "note" field.
func (m *WorkshiftMutation) ClearNote() {
	m.note = nil
	m.clearedFields[workshift.FieldNote] = struct{}{}
}

// NoteCleared returns if the "note" field was cleared in this mutation.
func (m *WorkshiftMutation) NoteCleared() bool {
	_, ok := m.clearedFields[workshift.FieldNote]
	return ok
}

// ResetNote resets all changes to the "note" field.
func (m *WorkshiftMutation) ResetNote() {
	m.note = nil
	delete(m.clearedFields, workshift.FieldNote)
}

// SetStatus sets the "status" field.
func (m *WorkshiftMutation) SetStatus(w workshift.Status) {
	m.status = &w
}

// Status returns the value of the "status" field in the mutation.
func (m *WorkshiftMutation) Status() (r workshift.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Workshift entity.
// If the Workshift object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkshiftMutation) OldStatus(ctx context.Context) (v workshift.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *WorkshiftMutation) ResetStatus() {
	m.status = nil
}

// SetCompanyID sets the "company" edge to the Company entity by id.
func (m *WorkshiftMutation) SetCompanyID(id int) {
	m.company = &id
}

// ClearCompany clears the "company" edge to the Company entity.
func (m *WorkshiftMutation) ClearCompany() {
	m.clearedcompany = true
}

// CompanyCleared reports if the "company" edge to the Company entity was cleared.
func (m *WorkshiftMutation) CompanyCleared() bool {
	return m.clearedcompany
}

// CompanyID returns the "company" edge ID in the mutation.
func (m *WorkshiftMutation) CompanyID() (id int, exists bool) {
	if m.company != nil {
		return *m.company, true
	}
	return
}

// CompanyIDs returns the "company" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CompanyID instead. It exists only for internal usage by the builders.
func (m *WorkshiftMutation) CompanyIDs() (ids []int) {
	if id := m.company; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCompany resets all changes to the "company" edge.
func (m *WorkshiftMutation) ResetCompany() {
	m.company = nil
	m.clearedcompany = false
}

// SetUserID sets the "user" edge to the User entity by id.
func (m *WorkshiftMutation) SetUserID(id int) {
	m.user = &id
}

// ClearUser clears the "user" edge to the User entity.
func (m *WorkshiftMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *WorkshiftMutation) UserCleared() bool {
	return m.cleareduser
}

// UserID returns the "user" edge ID in the mutation.
func (m *WorkshiftMutation) UserID() (id int, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *WorkshiftMutation) UserIDs() (ids []int) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *WorkshiftMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// SetApprovedByID sets the "approvedBy" edge to the User entity by id.
func (m *WorkshiftMutation) SetApprovedByID(id int) {
	m.approvedBy = &id
}

// ClearApprovedBy clears the "approvedBy" edge to the User entity.
func (m *WorkshiftMutation) ClearApprovedBy() {
	m.clearedapprovedBy = true
}

// ApprovedByCleared reports if the "approvedBy" edge to the User entity was cleared.
func (m *WorkshiftMutation) ApprovedByCleared() bool {
	return m.clearedapprovedBy
}

// ApprovedByID returns the "approvedBy" edge ID in the mutation.
func (m *WorkshiftMutation) ApprovedByID() (id int, exists bool) {
	if m.approvedBy != nil {
		return *m.approvedBy, true
	}
	return
}

// ApprovedByIDs returns the "approvedBy" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ApprovedByID instead. It exists only for internal usage by the builders.
func (m *WorkshiftMutation) ApprovedByIDs() (ids []int) {
	if id := m.approvedBy; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetApprovedBy resets all changes to the "approvedBy" edge.
func (m *WorkshiftMutation) ResetApprovedBy() {
	m.approvedBy = nil
	m.clearedapprovedBy = false
}

// SetTaskID sets the "task" edge to the ProjectTask entity by id.
func (m *WorkshiftMutation) SetTaskID(id int) {
	m.task = &id
}

// ClearTask clears the "task" edge to the ProjectTask entity.
func (m *WorkshiftMutation) ClearTask() {
	m.clearedtask = true
}

// TaskCleared reports if the "task" edge to the ProjectTask entity was cleared.
func (m *WorkshiftMutation) TaskCleared() bool {
	return m.clearedtask
}

// TaskID returns the "task" edge ID in the mutation.
func (m *WorkshiftMutation) TaskID() (id int, exists bool) {
	if m.task != nil {
		return *m.task, true
	}
	return
}

// TaskIDs returns the "task" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TaskID instead. It exists only for internal usage by the builders.
func (m *WorkshiftMutation) TaskIDs() (ids []int) {
	if id := m.task; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTask resets all changes to the "task" edge.
func (m *WorkshiftMutation) ResetTask() {
	m.task = nil
	m.clearedtask = false
}

// SetEditRequestID sets the "editRequest" edge to the Workshift entity by id.
func (m *WorkshiftMutation) SetEditRequestID(id int) {
	m.editRequest = &id
}

// ClearEditRequest clears the "editRequest" edge to the Workshift entity.
func (m *WorkshiftMutation) ClearEditRequest() {
	m.clearededitRequest = true
}

// EditRequestCleared reports if the "editRequest" edge to the Workshift entity was cleared.
func (m *WorkshiftMutation) EditRequestCleared() bool {
	return m.clearededitRequest
}

// EditRequestID returns the "editRequest" edge ID in the mutation.
func (m *WorkshiftMutation) EditRequestID() (id int, exists bool) {
	if m.editRequest != nil {
		return *m.editRequest, true
	}
	return
}

// EditRequestIDs returns the "editRequest" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// EditRequestID instead. It exists only for internal usage by the builders.
func (m *WorkshiftMutation) EditRequestIDs() (ids []int) {
	if id := m.editRequest; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEditRequest resets all changes to the "editRequest" edge.
func (m *WorkshiftMutation) ResetEditRequest() {
	m.editRequest = nil
	m.clearededitRequest = false
}

// SetWorkShiftID sets the "workShift" edge to the Workshift entity by id.
func (m *WorkshiftMutation) SetWorkShiftID(id int) {
	m.workShift = &id
}

// ClearWorkShift clears the "workShift" edge to the Workshift entity.
func (m *WorkshiftMutation) ClearWorkShift() {
	m.clearedworkShift = true
}

// WorkShiftCleared reports if the "workShift" edge to the Workshift entity was cleared.
func (m *WorkshiftMutation) WorkShiftCleared() bool {
	return m.clearedworkShift
}

// WorkShiftID returns the "workShift" edge ID in the mutation.
func (m *WorkshiftMutation) WorkShiftID() (id int, exists bool) {
	if m.workShift != nil {
		return *m.workShift, true
	}
	return
}

// WorkShiftIDs returns the "workShift" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// WorkShiftID instead. It exists only for internal usage by the builders.
func (m *WorkshiftMutation) WorkShiftIDs() (ids []int) {
	if id := m.workShift; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetWorkShift resets all changes to the "workShift" edge.
func (m *WorkshiftMutation) ResetWorkShift() {
	m.workShift = nil
	m.clearedworkShift = false
}

// Where appends a list predicates to the WorkshiftMutation builder.
func (m *WorkshiftMutation) Where(ps ...predicate.Workshift) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the WorkshiftMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *WorkshiftMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Workshift, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *WorkshiftMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *WorkshiftMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Workshift).
func (m *WorkshiftMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *WorkshiftMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.createdAt != nil {
		fields = append(fields, workshift.FieldCreatedAt)
	}
	if m.updatedAt != nil {
		fields = append(fields, workshift.FieldUpdatedAt)
	}
	if m.deletedAt != nil {
		fields = append(fields, workshift.FieldDeletedAt)
	}
	if m.approvedAt != nil {
		fields = append(fields, workshift.FieldApprovedAt)
	}
	if m.clockIn != nil {
		fields = append(fields, workshift.FieldClockIn)
	}
	if m.clockOut != nil {
		fields = append(fields, workshift.FieldClockOut)
	}
	if m.clockInLocation != nil {
		fields = append(fields, workshift.FieldClockInLocation)
	}
	if m.clockOutLocation != nil {
		fields = append(fields, workshift.FieldClockOutLocation)
	}
	if m.description != nil {
		fields = append(fields, workshift.FieldDescription)
	}
	if m.note != nil {
		fields = append(fields, workshift.FieldNote)
	}
	if m.status != nil {
		fields = append(fields, workshift.FieldStatus)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *WorkshiftMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case workshift.FieldCreatedAt:
		return m.CreatedAt()
	case workshift.FieldUpdatedAt:
		return m.UpdatedAt()
	case workshift.FieldDeletedAt:
		return m.DeletedAt()
	case workshift.FieldApprovedAt:
		return m.ApprovedAt()
	case workshift.FieldClockIn:
		return m.ClockIn()
	case workshift.FieldClockOut:
		return m.ClockOut()
	case workshift.FieldClockInLocation:
		return m.ClockInLocation()
	case workshift.FieldClockOutLocation:
		return m.ClockOutLocation()
	case workshift.FieldDescription:
		return m.Description()
	case workshift.FieldNote:
		return m.Note()
	case workshift.FieldStatus:
		return m.Status()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *WorkshiftMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case workshift.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case workshift.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case workshift.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case workshift.FieldApprovedAt:
		return m.OldApprovedAt(ctx)
	case workshift.FieldClockIn:
		return m.OldClockIn(ctx)
	case workshift.FieldClockOut:
		return m.OldClockOut(ctx)
	case workshift.FieldClockInLocation:
		return m.OldClockInLocation(ctx)
	case workshift.FieldClockOutLocation:
		return m.OldClockOutLocation(ctx)
	case workshift.FieldDescription:
		return m.OldDescription(ctx)
	case workshift.FieldNote:
		return m.OldNote(ctx)
	case workshift.FieldStatus:
		return m.OldStatus(ctx)
	}
	return nil, fmt.Errorf("unknown Workshift field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WorkshiftMutation) SetField(name string, value ent.Value) error {
	switch name {
	case workshift.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case workshift.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case workshift.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case workshift.FieldApprovedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetApprovedAt(v)
		return nil
	case workshift.FieldClockIn:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClockIn(v)
		return nil
	case workshift.FieldClockOut:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClockOut(v)
		return nil
	case workshift.FieldClockInLocation:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClockInLocation(v)
		return nil
	case workshift.FieldClockOutLocation:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClockOutLocation(v)
		return nil
	case workshift.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case workshift.FieldNote:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNote(v)
		return nil
	case workshift.FieldStatus:
		v, ok := value.(workshift.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	}
	return fmt.Errorf("unknown Workshift field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *WorkshiftMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *WorkshiftMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WorkshiftMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Workshift numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *WorkshiftMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(workshift.FieldDeletedAt) {
		fields = append(fields, workshift.FieldDeletedAt)
	}
	if m.FieldCleared(workshift.FieldApprovedAt) {
		fields = append(fields, workshift.FieldApprovedAt)
	}
	if m.FieldCleared(workshift.FieldClockOut) {
		fields = append(fields, workshift.FieldClockOut)
	}
	if m.FieldCleared(workshift.FieldClockOutLocation) {
		fields = append(fields, workshift.FieldClockOutLocation)
	}
	if m.FieldCleared(workshift.FieldDescription) {
		fields = append(fields, workshift.FieldDescription)
	}
	if m.FieldCleared(workshift.FieldNote) {
		fields = append(fields, workshift.FieldNote)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *WorkshiftMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *WorkshiftMutation) ClearField(name string) error {
	switch name {
	case workshift.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case workshift.FieldApprovedAt:
		m.ClearApprovedAt()
		return nil
	case workshift.FieldClockOut:
		m.ClearClockOut()
		return nil
	case workshift.FieldClockOutLocation:
		m.ClearClockOutLocation()
		return nil
	case workshift.FieldDescription:
		m.ClearDescription()
		return nil
	case workshift.FieldNote:
		m.ClearNote()
		return nil
	}
	return fmt.Errorf("unknown Workshift nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *WorkshiftMutation) ResetField(name string) error {
	switch name {
	case workshift.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case workshift.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case workshift.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case workshift.FieldApprovedAt:
		m.ResetApprovedAt()
		return nil
	case workshift.FieldClockIn:
		m.ResetClockIn()
		return nil
	case workshift.FieldClockOut:
		m.ResetClockOut()
		return nil
	case workshift.FieldClockInLocation:
		m.ResetClockInLocation()
		return nil
	case workshift.FieldClockOutLocation:
		m.ResetClockOutLocation()
		return nil
	case workshift.FieldDescription:
		m.ResetDescription()
		return nil
	case workshift.FieldNote:
		m.ResetNote()
		return nil
	case workshift.FieldStatus:
		m.ResetStatus()
		return nil
	}
	return fmt.Errorf("unknown Workshift field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *WorkshiftMutation) AddedEdges() []string {
	edges := make([]string, 0, 6)
	if m.company != nil {
		edges = append(edges, workshift.EdgeCompany)
	}
	if m.user != nil {
		edges = append(edges, workshift.EdgeUser)
	}
	if m.approvedBy != nil {
		edges = append(edges, workshift.EdgeApprovedBy)
	}
	if m.task != nil {
		edges = append(edges, workshift.EdgeTask)
	}
	if m.editRequest != nil {
		edges = append(edges, workshift.EdgeEditRequest)
	}
	if m.workShift != nil {
		edges = append(edges, workshift.EdgeWorkShift)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *WorkshiftMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case workshift.EdgeCompany:
		if id := m.company; id != nil {
			return []ent.Value{*id}
		}
	case workshift.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case workshift.EdgeApprovedBy:
		if id := m.approvedBy; id != nil {
			return []ent.Value{*id}
		}
	case workshift.EdgeTask:
		if id := m.task; id != nil {
			return []ent.Value{*id}
		}
	case workshift.EdgeEditRequest:
		if id := m.editRequest; id != nil {
			return []ent.Value{*id}
		}
	case workshift.EdgeWorkShift:
		if id := m.workShift; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *WorkshiftMutation) RemovedEdges() []string {
	edges := make([]string, 0, 6)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *WorkshiftMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *WorkshiftMutation) ClearedEdges() []string {
	edges := make([]string, 0, 6)
	if m.clearedcompany {
		edges = append(edges, workshift.EdgeCompany)
	}
	if m.cleareduser {
		edges = append(edges, workshift.EdgeUser)
	}
	if m.clearedapprovedBy {
		edges = append(edges, workshift.EdgeApprovedBy)
	}
	if m.clearedtask {
		edges = append(edges, workshift.EdgeTask)
	}
	if m.clearededitRequest {
		edges = append(edges, workshift.EdgeEditRequest)
	}
	if m.clearedworkShift {
		edges = append(edges, workshift.EdgeWorkShift)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *WorkshiftMutation) EdgeCleared(name string) bool {
	switch name {
	case workshift.EdgeCompany:
		return m.clearedcompany
	case workshift.EdgeUser:
		return m.cleareduser
	case workshift.EdgeApprovedBy:
		return m.clearedapprovedBy
	case workshift.EdgeTask:
		return m.clearedtask
	case workshift.EdgeEditRequest:
		return m.clearededitRequest
	case workshift.EdgeWorkShift:
		return m.clearedworkShift
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *WorkshiftMutation) ClearEdge(name string) error {
	switch name {
	case workshift.EdgeCompany:
		m.ClearCompany()
		return nil
	case workshift.EdgeUser:
		m.ClearUser()
		return nil
	case workshift.EdgeApprovedBy:
		m.ClearApprovedBy()
		return nil
	case workshift.EdgeTask:
		m.ClearTask()
		return nil
	case workshift.EdgeEditRequest:
		m.ClearEditRequest()
		return nil
	case workshift.EdgeWorkShift:
		m.ClearWorkShift()
		return nil
	}
	return fmt.Errorf("unknown Workshift unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *WorkshiftMutation) ResetEdge(name string) error {
	switch name {
	case workshift.EdgeCompany:
		m.ResetCompany()
		return nil
	case workshift.EdgeUser:
		m.ResetUser()
		return nil
	case workshift.EdgeApprovedBy:
		m.ResetApprovedBy()
		return nil
	case workshift.EdgeTask:
		m.ResetTask()
		return nil
	case workshift.EdgeEditRequest:
		m.ResetEditRequest()
		return nil
	case workshift.EdgeWorkShift:
		m.ResetWorkShift()
		return nil
	}
	return fmt.Errorf("unknown Workshift edge %s", name)
}
