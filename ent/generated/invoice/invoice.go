// Code generated by ent, DO NOT EDIT.

package invoice

import (
	"fmt"
	"io"
	"strconv"
	"time"

	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
)

const (
	// Label holds the string label denoting the invoice type in the database.
	Label = "invoice"
	// FieldID holds the string denoting the id field in the database.
	FieldID = "id"
	// FieldCreatedAt holds the string denoting the created_at field in the database.
	FieldCreatedAt = "created_at"
	// FieldUpdatedAt holds the string denoting the updated_at field in the database.
	FieldUpdatedAt = "updated_at"
	// FieldDeletedAt holds the string denoting the deleted_at field in the database.
	FieldDeletedAt = "deleted_at"
	// FieldCompanyLogo holds the string denoting the company_logo field in the database.
	FieldCompanyLogo = "company_logo"
	// FieldCompanyName holds the string denoting the company_name field in the database.
	FieldCompanyName = "company_name"
	// FieldCompanyTaxID holds the string denoting the company_tax_id field in the database.
	FieldCompanyTaxID = "company_tax_id"
	// FieldCompanyAddress holds the string denoting the company_address field in the database.
	FieldCompanyAddress = "company_address"
	// FieldCompanyCity holds the string denoting the company_city field in the database.
	FieldCompanyCity = "company_city"
	// FieldCompanyEmail holds the string denoting the company_email field in the database.
	FieldCompanyEmail = "company_email"
	// FieldCompanyPhone holds the string denoting the company_phone field in the database.
	FieldCompanyPhone = "company_phone"
	// FieldNumber holds the string denoting the number field in the database.
	FieldNumber = "number"
	// FieldIssueDate holds the string denoting the issue_date field in the database.
	FieldIssueDate = "issue_date"
	// FieldDueDate holds the string denoting the due_date field in the database.
	FieldDueDate = "due_date"
	// FieldPaidAt holds the string denoting the paid_at field in the database.
	FieldPaidAt = "paid_at"
	// FieldStatus holds the string denoting the status field in the database.
	FieldStatus = "status"
	// FieldCustomerName holds the string denoting the customer_name field in the database.
	FieldCustomerName = "customer_name"
	// FieldCustomerTaxID holds the string denoting the customer_tax_id field in the database.
	FieldCustomerTaxID = "customer_tax_id"
	// FieldCustomerAddress holds the string denoting the customer_address field in the database.
	FieldCustomerAddress = "customer_address"
	// FieldCustomerCity holds the string denoting the customer_city field in the database.
	FieldCustomerCity = "customer_city"
	// FieldCustomerEmail holds the string denoting the customer_email field in the database.
	FieldCustomerEmail = "customer_email"
	// FieldCustomerPhone holds the string denoting the customer_phone field in the database.
	FieldCustomerPhone = "customer_phone"
	// FieldItems holds the string denoting the items field in the database.
	FieldItems = "items"
	// FieldSubtotal holds the string denoting the subtotal field in the database.
	FieldSubtotal = "subtotal"
	// FieldTax holds the string denoting the tax field in the database.
	FieldTax = "tax"
	// FieldTotal holds the string denoting the total field in the database.
	FieldTotal = "total"
	// FieldNotes holds the string denoting the notes field in the database.
	FieldNotes = "notes"
	// FieldPaymentMethod holds the string denoting the payment_method field in the database.
	FieldPaymentMethod = "payment_method"
	// FieldBankName holds the string denoting the bank_name field in the database.
	FieldBankName = "bank_name"
	// FieldBankAgency holds the string denoting the bank_agency field in the database.
	FieldBankAgency = "bank_agency"
	// FieldBankAccountNumber holds the string denoting the bank_account_number field in the database.
	FieldBankAccountNumber = "bank_account_number"
	// FieldBankAccountName holds the string denoting the bank_account_name field in the database.
	FieldBankAccountName = "bank_account_name"
	// FieldStorageURI holds the string denoting the storage_uri field in the database.
	FieldStorageURI = "storage_uri"
	// FieldURL holds the string denoting the url field in the database.
	FieldURL = "url"
	// FieldFilename holds the string denoting the filename field in the database.
	FieldFilename = "filename"
	// FieldSize holds the string denoting the size field in the database.
	FieldSize = "size"
	// FieldKeywords holds the string denoting the keywords field in the database.
	FieldKeywords = "keywords"
	// EdgeCompany holds the string denoting the company edge name in mutations.
	EdgeCompany = "company"
	// EdgeIssuedBy holds the string denoting the issued_by edge name in mutations.
	EdgeIssuedBy = "issued_by"
	// EdgeClient holds the string denoting the client edge name in mutations.
	EdgeClient = "client"
	// EdgeReceivable holds the string denoting the receivable edge name in mutations.
	EdgeReceivable = "receivable"
	// Table holds the table name of the invoice in the database.
	Table = "invoices"
	// CompanyTable is the table that holds the company relation/edge.
	CompanyTable = "invoices"
	// CompanyInverseTable is the table name for the Company entity.
	// It exists in this package in order to avoid circular dependency with the "company" package.
	CompanyInverseTable = "companies"
	// CompanyColumn is the table column denoting the company relation/edge.
	CompanyColumn = "company_invoices"
	// IssuedByTable is the table that holds the issued_by relation/edge.
	IssuedByTable = "invoices"
	// IssuedByInverseTable is the table name for the User entity.
	// It exists in this package in order to avoid circular dependency with the "user" package.
	IssuedByInverseTable = "users"
	// IssuedByColumn is the table column denoting the issued_by relation/edge.
	IssuedByColumn = "user_issued_invoices"
	// ClientTable is the table that holds the client relation/edge.
	ClientTable = "invoices"
	// ClientInverseTable is the table name for the Customer entity.
	// It exists in this package in order to avoid circular dependency with the "customer" package.
	ClientInverseTable = "customers"
	// ClientColumn is the table column denoting the client relation/edge.
	ClientColumn = "customer_invoices"
	// ReceivableTable is the table that holds the receivable relation/edge.
	ReceivableTable = "receivables"
	// ReceivableInverseTable is the table name for the Receivable entity.
	// It exists in this package in order to avoid circular dependency with the "receivable" package.
	ReceivableInverseTable = "receivables"
	// ReceivableColumn is the table column denoting the receivable relation/edge.
	ReceivableColumn = "invoice_receivable"
)

// Columns holds all SQL columns for invoice fields.
var Columns = []string{
	FieldID,
	FieldCreatedAt,
	FieldUpdatedAt,
	FieldDeletedAt,
	FieldCompanyLogo,
	FieldCompanyName,
	FieldCompanyTaxID,
	FieldCompanyAddress,
	FieldCompanyCity,
	FieldCompanyEmail,
	FieldCompanyPhone,
	FieldNumber,
	FieldIssueDate,
	FieldDueDate,
	FieldPaidAt,
	FieldStatus,
	FieldCustomerName,
	FieldCustomerTaxID,
	FieldCustomerAddress,
	FieldCustomerCity,
	FieldCustomerEmail,
	FieldCustomerPhone,
	FieldItems,
	FieldSubtotal,
	FieldTax,
	FieldTotal,
	FieldNotes,
	FieldPaymentMethod,
	FieldBankName,
	FieldBankAgency,
	FieldBankAccountNumber,
	FieldBankAccountName,
	FieldStorageURI,
	FieldURL,
	FieldFilename,
	FieldSize,
	FieldKeywords,
}

// ForeignKeys holds the SQL foreign-keys that are owned by the "invoices"
// table and are not defined as standalone fields in the schema.
var ForeignKeys = []string{
	"company_invoices",
	"customer_invoices",
	"user_issued_invoices",
}

// ValidColumn reports if the column name is valid (part of the table columns).
func ValidColumn(column string) bool {
	for i := range Columns {
		if column == Columns[i] {
			return true
		}
	}
	for i := range ForeignKeys {
		if column == ForeignKeys[i] {
			return true
		}
	}
	return false
}

var (
	// DefaultCreatedAt holds the default value on creation for the "created_at" field.
	DefaultCreatedAt func() time.Time
	// DefaultUpdatedAt holds the default value on creation for the "updated_at" field.
	DefaultUpdatedAt func() time.Time
	// UpdateDefaultUpdatedAt holds the default value on update for the "updated_at" field.
	UpdateDefaultUpdatedAt func() time.Time
	// DefaultCustomerName holds the default value on creation for the "customer_name" field.
	DefaultCustomerName string
	// ItemsValidator is a validator for the "items" field. It is called by the builders before save.
	ItemsValidator func(string) error
	// SubtotalValidator is a validator for the "subtotal" field. It is called by the builders before save.
	SubtotalValidator func(float64) error
	// TaxValidator is a validator for the "tax" field. It is called by the builders before save.
	TaxValidator func(float64) error
	// TotalValidator is a validator for the "total" field. It is called by the builders before save.
	TotalValidator func(float64) error
	// SizeValidator is a validator for the "size" field. It is called by the builders before save.
	SizeValidator func(float64) error
	// KeywordsValidator is a validator for the "keywords" field. It is called by the builders before save.
	KeywordsValidator func(string) error
)

// Status defines the type for the "status" enum field.
type Status string

// StatusPAID is the default value of the Status enum.
const DefaultStatus = StatusPAID

// Status values.
const (
	StatusDRAFT     Status = "DRAFT"
	StatusCANCELED  Status = "CANCELED"
	StatusPENDING   Status = "PENDING"
	StatusPAID      Status = "PAID"
	StatusOVERDUE   Status = "OVERDUE"
	StatusDEFAULTED Status = "DEFAULTED"
)

func (s Status) String() string {
	return string(s)
}

// StatusValidator is a validator for the "status" field enum values. It is called by the builders before save.
func StatusValidator(s Status) error {
	switch s {
	case StatusDRAFT, StatusCANCELED, StatusPENDING, StatusPAID, StatusOVERDUE, StatusDEFAULTED:
		return nil
	default:
		return fmt.Errorf("invoice: invalid enum value for status field: %q", s)
	}
}

// OrderOption defines the ordering options for the Invoice queries.
type OrderOption func(*sql.Selector)

// ByID orders the results by the id field.
func ByID(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldID, opts...).ToFunc()
}

// ByCreatedAt orders the results by the created_at field.
func ByCreatedAt(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldCreatedAt, opts...).ToFunc()
}

// ByUpdatedAt orders the results by the updated_at field.
func ByUpdatedAt(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldUpdatedAt, opts...).ToFunc()
}

// ByDeletedAt orders the results by the deleted_at field.
func ByDeletedAt(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldDeletedAt, opts...).ToFunc()
}

// ByCompanyLogo orders the results by the company_logo field.
func ByCompanyLogo(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldCompanyLogo, opts...).ToFunc()
}

// ByCompanyName orders the results by the company_name field.
func ByCompanyName(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldCompanyName, opts...).ToFunc()
}

// ByCompanyTaxID orders the results by the company_tax_id field.
func ByCompanyTaxID(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldCompanyTaxID, opts...).ToFunc()
}

// ByCompanyAddress orders the results by the company_address field.
func ByCompanyAddress(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldCompanyAddress, opts...).ToFunc()
}

// ByCompanyCity orders the results by the company_city field.
func ByCompanyCity(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldCompanyCity, opts...).ToFunc()
}

// ByCompanyEmail orders the results by the company_email field.
func ByCompanyEmail(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldCompanyEmail, opts...).ToFunc()
}

// ByCompanyPhone orders the results by the company_phone field.
func ByCompanyPhone(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldCompanyPhone, opts...).ToFunc()
}

// ByNumber orders the results by the number field.
func ByNumber(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldNumber, opts...).ToFunc()
}

// ByIssueDate orders the results by the issue_date field.
func ByIssueDate(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldIssueDate, opts...).ToFunc()
}

// ByDueDate orders the results by the due_date field.
func ByDueDate(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldDueDate, opts...).ToFunc()
}

// ByPaidAt orders the results by the paid_at field.
func ByPaidAt(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldPaidAt, opts...).ToFunc()
}

// ByStatus orders the results by the status field.
func ByStatus(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldStatus, opts...).ToFunc()
}

// ByCustomerName orders the results by the customer_name field.
func ByCustomerName(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldCustomerName, opts...).ToFunc()
}

// ByCustomerTaxID orders the results by the customer_tax_id field.
func ByCustomerTaxID(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldCustomerTaxID, opts...).ToFunc()
}

// ByCustomerAddress orders the results by the customer_address field.
func ByCustomerAddress(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldCustomerAddress, opts...).ToFunc()
}

// ByCustomerCity orders the results by the customer_city field.
func ByCustomerCity(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldCustomerCity, opts...).ToFunc()
}

// ByCustomerEmail orders the results by the customer_email field.
func ByCustomerEmail(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldCustomerEmail, opts...).ToFunc()
}

// ByCustomerPhone orders the results by the customer_phone field.
func ByCustomerPhone(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldCustomerPhone, opts...).ToFunc()
}

// ByItems orders the results by the items field.
func ByItems(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldItems, opts...).ToFunc()
}

// BySubtotal orders the results by the subtotal field.
func BySubtotal(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldSubtotal, opts...).ToFunc()
}

// ByTax orders the results by the tax field.
func ByTax(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldTax, opts...).ToFunc()
}

// ByTotal orders the results by the total field.
func ByTotal(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldTotal, opts...).ToFunc()
}

// ByNotes orders the results by the notes field.
func ByNotes(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldNotes, opts...).ToFunc()
}

// ByPaymentMethod orders the results by the payment_method field.
func ByPaymentMethod(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldPaymentMethod, opts...).ToFunc()
}

// ByBankName orders the results by the bank_name field.
func ByBankName(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldBankName, opts...).ToFunc()
}

// ByBankAgency orders the results by the bank_agency field.
func ByBankAgency(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldBankAgency, opts...).ToFunc()
}

// ByBankAccountNumber orders the results by the bank_account_number field.
func ByBankAccountNumber(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldBankAccountNumber, opts...).ToFunc()
}

// ByBankAccountName orders the results by the bank_account_name field.
func ByBankAccountName(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldBankAccountName, opts...).ToFunc()
}

// ByStorageURI orders the results by the storage_URI field.
func ByStorageURI(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldStorageURI, opts...).ToFunc()
}

// ByURL orders the results by the URL field.
func ByURL(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldURL, opts...).ToFunc()
}

// ByFilename orders the results by the filename field.
func ByFilename(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldFilename, opts...).ToFunc()
}

// BySize orders the results by the size field.
func BySize(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldSize, opts...).ToFunc()
}

// ByKeywords orders the results by the keywords field.
func ByKeywords(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldKeywords, opts...).ToFunc()
}

// ByCompanyField orders the results by company field.
func ByCompanyField(field string, opts ...sql.OrderTermOption) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborTerms(s, newCompanyStep(), sql.OrderByField(field, opts...))
	}
}

// ByIssuedByField orders the results by issued_by field.
func ByIssuedByField(field string, opts ...sql.OrderTermOption) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborTerms(s, newIssuedByStep(), sql.OrderByField(field, opts...))
	}
}

// ByClientField orders the results by client field.
func ByClientField(field string, opts ...sql.OrderTermOption) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborTerms(s, newClientStep(), sql.OrderByField(field, opts...))
	}
}

// ByReceivableField orders the results by receivable field.
func ByReceivableField(field string, opts ...sql.OrderTermOption) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborTerms(s, newReceivableStep(), sql.OrderByField(field, opts...))
	}
}
func newCompanyStep() *sqlgraph.Step {
	return sqlgraph.NewStep(
		sqlgraph.From(Table, FieldID),
		sqlgraph.To(CompanyInverseTable, FieldID),
		sqlgraph.Edge(sqlgraph.M2O, true, CompanyTable, CompanyColumn),
	)
}
func newIssuedByStep() *sqlgraph.Step {
	return sqlgraph.NewStep(
		sqlgraph.From(Table, FieldID),
		sqlgraph.To(IssuedByInverseTable, FieldID),
		sqlgraph.Edge(sqlgraph.M2O, true, IssuedByTable, IssuedByColumn),
	)
}
func newClientStep() *sqlgraph.Step {
	return sqlgraph.NewStep(
		sqlgraph.From(Table, FieldID),
		sqlgraph.To(ClientInverseTable, FieldID),
		sqlgraph.Edge(sqlgraph.M2O, true, ClientTable, ClientColumn),
	)
}
func newReceivableStep() *sqlgraph.Step {
	return sqlgraph.NewStep(
		sqlgraph.From(Table, FieldID),
		sqlgraph.To(ReceivableInverseTable, FieldID),
		sqlgraph.Edge(sqlgraph.O2O, false, ReceivableTable, ReceivableColumn),
	)
}

// MarshalGQL implements graphql.Marshaler interface.
func (e Status) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(e.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (e *Status) UnmarshalGQL(val interface{}) error {
	str, ok := val.(string)
	if !ok {
		return fmt.Errorf("enum %T must be a string", val)
	}
	*e = Status(str)
	if err := StatusValidator(*e); err != nil {
		return fmt.Errorf("%s is not a valid Status", str)
	}
	return nil
}
