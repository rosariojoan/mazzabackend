// Code generated by ent, DO NOT EDIT.

package invoice

import (
	"fmt"
	"io"
	"strconv"
	"time"

	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
)

const (
	// Label holds the string label denoting the invoice type in the database.
	Label = "invoice"
	// FieldID holds the string denoting the id field in the database.
	FieldID = "id"
	// FieldCreatedAt holds the string denoting the created_at field in the database.
	FieldCreatedAt = "created_at"
	// FieldUpdatedAt holds the string denoting the updated_at field in the database.
	FieldUpdatedAt = "updated_at"
	// FieldDeletedAt holds the string denoting the deleted_at field in the database.
	FieldDeletedAt = "deleted_at"
	// FieldIsInvoice holds the string denoting the is_invoice field in the database.
	FieldIsInvoice = "is_invoice"
	// FieldCompanyName holds the string denoting the company_name field in the database.
	FieldCompanyName = "company_name"
	// FieldCompanyTaxID holds the string denoting the company_tax_id field in the database.
	FieldCompanyTaxID = "company_tax_id"
	// FieldCompanyAddress holds the string denoting the company_address field in the database.
	FieldCompanyAddress = "company_address"
	// FieldCompanyCity holds the string denoting the company_city field in the database.
	FieldCompanyCity = "company_city"
	// FieldCompanyEmail holds the string denoting the company_email field in the database.
	FieldCompanyEmail = "company_email"
	// FieldCompanyPhone holds the string denoting the company_phone field in the database.
	FieldCompanyPhone = "company_phone"
	// FieldCurrency holds the string denoting the currency field in the database.
	FieldCurrency = "currency"
	// FieldNumber holds the string denoting the number field in the database.
	FieldNumber = "number"
	// FieldIssueDate holds the string denoting the issue_date field in the database.
	FieldIssueDate = "issue_date"
	// FieldDueDate holds the string denoting the due_date field in the database.
	FieldDueDate = "due_date"
	// FieldPaidAt holds the string denoting the paid_at field in the database.
	FieldPaidAt = "paid_at"
	// FieldStatus holds the string denoting the status field in the database.
	FieldStatus = "status"
	// FieldCustomerName holds the string denoting the customer_name field in the database.
	FieldCustomerName = "customer_name"
	// FieldCustomerTaxID holds the string denoting the customer_tax_id field in the database.
	FieldCustomerTaxID = "customer_tax_id"
	// FieldCustomerAddress holds the string denoting the customer_address field in the database.
	FieldCustomerAddress = "customer_address"
	// FieldCustomerCity holds the string denoting the customer_city field in the database.
	FieldCustomerCity = "customer_city"
	// FieldCustomerEmail holds the string denoting the customer_email field in the database.
	FieldCustomerEmail = "customer_email"
	// FieldCustomerPhone holds the string denoting the customer_phone field in the database.
	FieldCustomerPhone = "customer_phone"
	// FieldItems holds the string denoting the items field in the database.
	FieldItems = "items"
	// FieldSubtotal holds the string denoting the subtotal field in the database.
	FieldSubtotal = "subtotal"
	// FieldTax holds the string denoting the tax field in the database.
	FieldTax = "tax"
	// FieldTotal holds the string denoting the total field in the database.
	FieldTotal = "total"
	// FieldTerms holds the string denoting the terms field in the database.
	FieldTerms = "terms"
	// FieldKeywords holds the string denoting the keywords field in the database.
	FieldKeywords = "keywords"
	// EdgeCompany holds the string denoting the company edge name in mutations.
	EdgeCompany = "company"
	// EdgeIssuedBy holds the string denoting the issued_by edge name in mutations.
	EdgeIssuedBy = "issued_by"
	// EdgeClient holds the string denoting the client edge name in mutations.
	EdgeClient = "client"
	// EdgeReceivable holds the string denoting the receivable edge name in mutations.
	EdgeReceivable = "receivable"
	// Table holds the table name of the invoice in the database.
	Table = "invoices"
	// CompanyTable is the table that holds the company relation/edge.
	CompanyTable = "invoices"
	// CompanyInverseTable is the table name for the Company entity.
	// It exists in this package in order to avoid circular dependency with the "company" package.
	CompanyInverseTable = "companies"
	// CompanyColumn is the table column denoting the company relation/edge.
	CompanyColumn = "company_invoices"
	// IssuedByTable is the table that holds the issued_by relation/edge.
	IssuedByTable = "invoices"
	// IssuedByInverseTable is the table name for the User entity.
	// It exists in this package in order to avoid circular dependency with the "user" package.
	IssuedByInverseTable = "users"
	// IssuedByColumn is the table column denoting the issued_by relation/edge.
	IssuedByColumn = "user_issued_invoices"
	// ClientTable is the table that holds the client relation/edge.
	ClientTable = "invoices"
	// ClientInverseTable is the table name for the Customer entity.
	// It exists in this package in order to avoid circular dependency with the "customer" package.
	ClientInverseTable = "customers"
	// ClientColumn is the table column denoting the client relation/edge.
	ClientColumn = "customer_invoices"
	// ReceivableTable is the table that holds the receivable relation/edge.
	ReceivableTable = "receivables"
	// ReceivableInverseTable is the table name for the Receivable entity.
	// It exists in this package in order to avoid circular dependency with the "receivable" package.
	ReceivableInverseTable = "receivables"
	// ReceivableColumn is the table column denoting the receivable relation/edge.
	ReceivableColumn = "invoice_receivable"
)

// Columns holds all SQL columns for invoice fields.
var Columns = []string{
	FieldID,
	FieldCreatedAt,
	FieldUpdatedAt,
	FieldDeletedAt,
	FieldIsInvoice,
	FieldCompanyName,
	FieldCompanyTaxID,
	FieldCompanyAddress,
	FieldCompanyCity,
	FieldCompanyEmail,
	FieldCompanyPhone,
	FieldCurrency,
	FieldNumber,
	FieldIssueDate,
	FieldDueDate,
	FieldPaidAt,
	FieldStatus,
	FieldCustomerName,
	FieldCustomerTaxID,
	FieldCustomerAddress,
	FieldCustomerCity,
	FieldCustomerEmail,
	FieldCustomerPhone,
	FieldItems,
	FieldSubtotal,
	FieldTax,
	FieldTotal,
	FieldTerms,
	FieldKeywords,
}

// ForeignKeys holds the SQL foreign-keys that are owned by the "invoices"
// table and are not defined as standalone fields in the schema.
var ForeignKeys = []string{
	"company_invoices",
	"customer_invoices",
	"user_issued_invoices",
}

// ValidColumn reports if the column name is valid (part of the table columns).
func ValidColumn(column string) bool {
	for i := range Columns {
		if column == Columns[i] {
			return true
		}
	}
	for i := range ForeignKeys {
		if column == ForeignKeys[i] {
			return true
		}
	}
	return false
}

var (
	// DefaultCreatedAt holds the default value on creation for the "created_at" field.
	DefaultCreatedAt func() time.Time
	// DefaultUpdatedAt holds the default value on creation for the "updated_at" field.
	DefaultUpdatedAt func() time.Time
	// UpdateDefaultUpdatedAt holds the default value on update for the "updated_at" field.
	UpdateDefaultUpdatedAt func() time.Time
	// DefaultIsInvoice holds the default value on creation for the "is_invoice" field.
	DefaultIsInvoice bool
	// DefaultCustomerName holds the default value on creation for the "customer_name" field.
	DefaultCustomerName string
	// ItemsValidator is a validator for the "items" field. It is called by the builders before save.
	ItemsValidator func(string) error
	// SubtotalValidator is a validator for the "subtotal" field. It is called by the builders before save.
	SubtotalValidator func(float64) error
	// TaxValidator is a validator for the "tax" field. It is called by the builders before save.
	TaxValidator func(float64) error
	// TotalValidator is a validator for the "total" field. It is called by the builders before save.
	TotalValidator func(float64) error
	// KeywordsValidator is a validator for the "keywords" field. It is called by the builders before save.
	KeywordsValidator func(string) error
)

// Status defines the type for the "status" enum field.
type Status string

// StatusPaid is the default value of the Status enum.
const DefaultStatus = StatusPaid

// Status values.
const (
	StatusDraft     Status = "draft"
	StatusCancelled Status = "cancelled"
	StatusPending   Status = "pending"
	StatusPaid      Status = "paid"
	StatusOverdue   Status = "overdue"
	StatusDefaulted Status = "defaulted"
)

func (s Status) String() string {
	return string(s)
}

// StatusValidator is a validator for the "status" field enum values. It is called by the builders before save.
func StatusValidator(s Status) error {
	switch s {
	case StatusDraft, StatusCancelled, StatusPending, StatusPaid, StatusOverdue, StatusDefaulted:
		return nil
	default:
		return fmt.Errorf("invoice: invalid enum value for status field: %q", s)
	}
}

// OrderOption defines the ordering options for the Invoice queries.
type OrderOption func(*sql.Selector)

// ByID orders the results by the id field.
func ByID(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldID, opts...).ToFunc()
}

// ByCreatedAt orders the results by the created_at field.
func ByCreatedAt(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldCreatedAt, opts...).ToFunc()
}

// ByUpdatedAt orders the results by the updated_at field.
func ByUpdatedAt(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldUpdatedAt, opts...).ToFunc()
}

// ByDeletedAt orders the results by the deleted_at field.
func ByDeletedAt(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldDeletedAt, opts...).ToFunc()
}

// ByIsInvoice orders the results by the is_invoice field.
func ByIsInvoice(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldIsInvoice, opts...).ToFunc()
}

// ByCompanyName orders the results by the company_name field.
func ByCompanyName(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldCompanyName, opts...).ToFunc()
}

// ByCompanyTaxID orders the results by the company_tax_id field.
func ByCompanyTaxID(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldCompanyTaxID, opts...).ToFunc()
}

// ByCompanyAddress orders the results by the company_address field.
func ByCompanyAddress(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldCompanyAddress, opts...).ToFunc()
}

// ByCompanyCity orders the results by the company_city field.
func ByCompanyCity(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldCompanyCity, opts...).ToFunc()
}

// ByCompanyEmail orders the results by the company_email field.
func ByCompanyEmail(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldCompanyEmail, opts...).ToFunc()
}

// ByCompanyPhone orders the results by the company_phone field.
func ByCompanyPhone(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldCompanyPhone, opts...).ToFunc()
}

// ByCurrency orders the results by the currency field.
func ByCurrency(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldCurrency, opts...).ToFunc()
}

// ByNumber orders the results by the number field.
func ByNumber(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldNumber, opts...).ToFunc()
}

// ByIssueDate orders the results by the issue_date field.
func ByIssueDate(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldIssueDate, opts...).ToFunc()
}

// ByDueDate orders the results by the due_date field.
func ByDueDate(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldDueDate, opts...).ToFunc()
}

// ByPaidAt orders the results by the paid_at field.
func ByPaidAt(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldPaidAt, opts...).ToFunc()
}

// ByStatus orders the results by the status field.
func ByStatus(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldStatus, opts...).ToFunc()
}

// ByCustomerName orders the results by the customer_name field.
func ByCustomerName(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldCustomerName, opts...).ToFunc()
}

// ByCustomerTaxID orders the results by the customer_tax_id field.
func ByCustomerTaxID(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldCustomerTaxID, opts...).ToFunc()
}

// ByCustomerAddress orders the results by the customer_address field.
func ByCustomerAddress(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldCustomerAddress, opts...).ToFunc()
}

// ByCustomerCity orders the results by the customer_city field.
func ByCustomerCity(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldCustomerCity, opts...).ToFunc()
}

// ByCustomerEmail orders the results by the customer_email field.
func ByCustomerEmail(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldCustomerEmail, opts...).ToFunc()
}

// ByCustomerPhone orders the results by the customer_phone field.
func ByCustomerPhone(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldCustomerPhone, opts...).ToFunc()
}

// ByItems orders the results by the items field.
func ByItems(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldItems, opts...).ToFunc()
}

// BySubtotal orders the results by the subtotal field.
func BySubtotal(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldSubtotal, opts...).ToFunc()
}

// ByTax orders the results by the tax field.
func ByTax(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldTax, opts...).ToFunc()
}

// ByTotal orders the results by the total field.
func ByTotal(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldTotal, opts...).ToFunc()
}

// ByTerms orders the results by the terms field.
func ByTerms(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldTerms, opts...).ToFunc()
}

// ByKeywords orders the results by the keywords field.
func ByKeywords(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldKeywords, opts...).ToFunc()
}

// ByCompanyField orders the results by company field.
func ByCompanyField(field string, opts ...sql.OrderTermOption) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborTerms(s, newCompanyStep(), sql.OrderByField(field, opts...))
	}
}

// ByIssuedByField orders the results by issued_by field.
func ByIssuedByField(field string, opts ...sql.OrderTermOption) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborTerms(s, newIssuedByStep(), sql.OrderByField(field, opts...))
	}
}

// ByClientField orders the results by client field.
func ByClientField(field string, opts ...sql.OrderTermOption) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborTerms(s, newClientStep(), sql.OrderByField(field, opts...))
	}
}

// ByReceivableField orders the results by receivable field.
func ByReceivableField(field string, opts ...sql.OrderTermOption) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborTerms(s, newReceivableStep(), sql.OrderByField(field, opts...))
	}
}
func newCompanyStep() *sqlgraph.Step {
	return sqlgraph.NewStep(
		sqlgraph.From(Table, FieldID),
		sqlgraph.To(CompanyInverseTable, FieldID),
		sqlgraph.Edge(sqlgraph.M2O, true, CompanyTable, CompanyColumn),
	)
}
func newIssuedByStep() *sqlgraph.Step {
	return sqlgraph.NewStep(
		sqlgraph.From(Table, FieldID),
		sqlgraph.To(IssuedByInverseTable, FieldID),
		sqlgraph.Edge(sqlgraph.M2O, true, IssuedByTable, IssuedByColumn),
	)
}
func newClientStep() *sqlgraph.Step {
	return sqlgraph.NewStep(
		sqlgraph.From(Table, FieldID),
		sqlgraph.To(ClientInverseTable, FieldID),
		sqlgraph.Edge(sqlgraph.M2O, true, ClientTable, ClientColumn),
	)
}
func newReceivableStep() *sqlgraph.Step {
	return sqlgraph.NewStep(
		sqlgraph.From(Table, FieldID),
		sqlgraph.To(ReceivableInverseTable, FieldID),
		sqlgraph.Edge(sqlgraph.O2O, false, ReceivableTable, ReceivableColumn),
	)
}

// MarshalGQL implements graphql.Marshaler interface.
func (e Status) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(e.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (e *Status) UnmarshalGQL(val interface{}) error {
	str, ok := val.(string)
	if !ok {
		return fmt.Errorf("enum %T must be a string", val)
	}
	*e = Status(str)
	if err := StatusValidator(*e); err != nil {
		return fmt.Errorf("%s is not a valid Status", str)
	}
	return nil
}
