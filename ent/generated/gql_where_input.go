// Code generated by ent, DO NOT EDIT.

package generated

import (
	"errors"
	"fmt"
	"mazza/ent/generated/accountingentry"
	"mazza/ent/generated/cashmovement"
	"mazza/ent/generated/company"
	"mazza/ent/generated/customer"
	"mazza/ent/generated/employee"
	"mazza/ent/generated/file"
	"mazza/ent/generated/payable"
	"mazza/ent/generated/predicate"
	"mazza/ent/generated/product"
	"mazza/ent/generated/productmovement"
	"mazza/ent/generated/receivable"
	"mazza/ent/generated/supplier"
	"mazza/ent/generated/token"
	"mazza/ent/generated/treasury"
	"mazza/ent/generated/user"
	"mazza/ent/generated/userrole"
	"mazza/ent/generated/workshift"
	"mazza/ent/generated/worktag"
	"mazza/ent/generated/worktask"
	"time"
)

// AccountingEntryWhereInput represents a where input for filtering AccountingEntry queries.
type AccountingEntryWhereInput struct {
	Predicates []predicate.AccountingEntry  `json:"-"`
	Not        *AccountingEntryWhereInput   `json:"not,omitempty"`
	Or         []*AccountingEntryWhereInput `json:"or,omitempty"`
	And        []*AccountingEntryWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "createdAt" field predicates.
	CreatedAt      *time.Time  `json:"createdat,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdatNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdatIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdatNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdatGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdatGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdatLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdatLTE,omitempty"`

	// "updatedAt" field predicates.
	UpdatedAt      *time.Time  `json:"updatedat,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedatNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedatIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedatNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedatGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedatGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedatLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedatLTE,omitempty"`

	// "deletedAt" field predicates.
	DeletedAt       *time.Time  `json:"deletedat,omitempty"`
	DeletedAtNEQ    *time.Time  `json:"deletedatNEQ,omitempty"`
	DeletedAtIn     []time.Time `json:"deletedatIn,omitempty"`
	DeletedAtNotIn  []time.Time `json:"deletedatNotIn,omitempty"`
	DeletedAtGT     *time.Time  `json:"deletedatGT,omitempty"`
	DeletedAtGTE    *time.Time  `json:"deletedatGTE,omitempty"`
	DeletedAtLT     *time.Time  `json:"deletedatLT,omitempty"`
	DeletedAtLTE    *time.Time  `json:"deletedatLTE,omitempty"`
	DeletedAtIsNil  bool        `json:"deletedatIsNil,omitempty"`
	DeletedAtNotNil bool        `json:"deletedatNotNil,omitempty"`

	// "number" field predicates.
	Number      *int  `json:"number,omitempty"`
	NumberNEQ   *int  `json:"numberNEQ,omitempty"`
	NumberIn    []int `json:"numberIn,omitempty"`
	NumberNotIn []int `json:"numberNotIn,omitempty"`
	NumberGT    *int  `json:"numberGT,omitempty"`
	NumberGTE   *int  `json:"numberGTE,omitempty"`
	NumberLT    *int  `json:"numberLT,omitempty"`
	NumberLTE   *int  `json:"numberLTE,omitempty"`

	// "group" field predicates.
	Group      *int  `json:"group,omitempty"`
	GroupNEQ   *int  `json:"groupNEQ,omitempty"`
	GroupIn    []int `json:"groupIn,omitempty"`
	GroupNotIn []int `json:"groupNotIn,omitempty"`
	GroupGT    *int  `json:"groupGT,omitempty"`
	GroupGTE   *int  `json:"groupGTE,omitempty"`
	GroupLT    *int  `json:"groupLT,omitempty"`
	GroupLTE   *int  `json:"groupLTE,omitempty"`

	// "date" field predicates.
	Date      *time.Time  `json:"date,omitempty"`
	DateNEQ   *time.Time  `json:"dateNEQ,omitempty"`
	DateIn    []time.Time `json:"dateIn,omitempty"`
	DateNotIn []time.Time `json:"dateNotIn,omitempty"`
	DateGT    *time.Time  `json:"dateGT,omitempty"`
	DateGTE   *time.Time  `json:"dateGTE,omitempty"`
	DateLT    *time.Time  `json:"dateLT,omitempty"`
	DateLTE   *time.Time  `json:"dateLTE,omitempty"`

	// "account" field predicates.
	Account             *string  `json:"account,omitempty"`
	AccountNEQ          *string  `json:"accountNEQ,omitempty"`
	AccountIn           []string `json:"accountIn,omitempty"`
	AccountNotIn        []string `json:"accountNotIn,omitempty"`
	AccountGT           *string  `json:"accountGT,omitempty"`
	AccountGTE          *string  `json:"accountGTE,omitempty"`
	AccountLT           *string  `json:"accountLT,omitempty"`
	AccountLTE          *string  `json:"accountLTE,omitempty"`
	AccountContains     *string  `json:"accountContains,omitempty"`
	AccountHasPrefix    *string  `json:"accountHasPrefix,omitempty"`
	AccountHasSuffix    *string  `json:"accountHasSuffix,omitempty"`
	AccountEqualFold    *string  `json:"accountEqualFold,omitempty"`
	AccountContainsFold *string  `json:"accountContainsFold,omitempty"`

	// "label" field predicates.
	Label             *string  `json:"label,omitempty"`
	LabelNEQ          *string  `json:"labelNEQ,omitempty"`
	LabelIn           []string `json:"labelIn,omitempty"`
	LabelNotIn        []string `json:"labelNotIn,omitempty"`
	LabelGT           *string  `json:"labelGT,omitempty"`
	LabelGTE          *string  `json:"labelGTE,omitempty"`
	LabelLT           *string  `json:"labelLT,omitempty"`
	LabelLTE          *string  `json:"labelLTE,omitempty"`
	LabelContains     *string  `json:"labelContains,omitempty"`
	LabelHasPrefix    *string  `json:"labelHasPrefix,omitempty"`
	LabelHasSuffix    *string  `json:"labelHasSuffix,omitempty"`
	LabelEqualFold    *string  `json:"labelEqualFold,omitempty"`
	LabelContainsFold *string  `json:"labelContainsFold,omitempty"`

	// "amount" field predicates.
	Amount      *float64  `json:"amount,omitempty"`
	AmountNEQ   *float64  `json:"amountNEQ,omitempty"`
	AmountIn    []float64 `json:"amountIn,omitempty"`
	AmountNotIn []float64 `json:"amountNotIn,omitempty"`
	AmountGT    *float64  `json:"amountGT,omitempty"`
	AmountGTE   *float64  `json:"amountGTE,omitempty"`
	AmountLT    *float64  `json:"amountLT,omitempty"`
	AmountLTE   *float64  `json:"amountLTE,omitempty"`

	// "description" field predicates.
	Description             *string  `json:"description,omitempty"`
	DescriptionNEQ          *string  `json:"descriptionNEQ,omitempty"`
	DescriptionIn           []string `json:"descriptionIn,omitempty"`
	DescriptionNotIn        []string `json:"descriptionNotIn,omitempty"`
	DescriptionGT           *string  `json:"descriptionGT,omitempty"`
	DescriptionGTE          *string  `json:"descriptionGTE,omitempty"`
	DescriptionLT           *string  `json:"descriptionLT,omitempty"`
	DescriptionLTE          *string  `json:"descriptionLTE,omitempty"`
	DescriptionContains     *string  `json:"descriptionContains,omitempty"`
	DescriptionHasPrefix    *string  `json:"descriptionHasPrefix,omitempty"`
	DescriptionHasSuffix    *string  `json:"descriptionHasSuffix,omitempty"`
	DescriptionEqualFold    *string  `json:"descriptionEqualFold,omitempty"`
	DescriptionContainsFold *string  `json:"descriptionContainsFold,omitempty"`

	// "accountType" field predicates.
	AccountType      *accountingentry.AccountType  `json:"accounttype,omitempty"`
	AccountTypeNEQ   *accountingentry.AccountType  `json:"accounttypeNEQ,omitempty"`
	AccountTypeIn    []accountingentry.AccountType `json:"accounttypeIn,omitempty"`
	AccountTypeNotIn []accountingentry.AccountType `json:"accounttypeNotIn,omitempty"`

	// "isDebit" field predicates.
	IsDebit    *bool `json:"isdebit,omitempty"`
	IsDebitNEQ *bool `json:"isdebitNEQ,omitempty"`

	// "isReversal" field predicates.
	IsReversal    *bool `json:"isreversal,omitempty"`
	IsReversalNEQ *bool `json:"isreversalNEQ,omitempty"`

	// "reversed" field predicates.
	Reversed    *bool `json:"reversed,omitempty"`
	ReversedNEQ *bool `json:"reversedNEQ,omitempty"`

	// "company" edge predicates.
	HasCompany     *bool                `json:"hasCompany,omitempty"`
	HasCompanyWith []*CompanyWhereInput `json:"hasCompanyWith,omitempty"`

	// "user" edge predicates.
	HasUser     *bool             `json:"hasUser,omitempty"`
	HasUserWith []*UserWhereInput `json:"hasUserWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *AccountingEntryWhereInput) AddPredicates(predicates ...predicate.AccountingEntry) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the AccountingEntryWhereInput filter on the AccountingEntryQuery builder.
func (i *AccountingEntryWhereInput) Filter(q *AccountingEntryQuery) (*AccountingEntryQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyAccountingEntryWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyAccountingEntryWhereInput is returned in case the AccountingEntryWhereInput is empty.
var ErrEmptyAccountingEntryWhereInput = errors.New("generated: empty predicate AccountingEntryWhereInput")

// P returns a predicate for filtering accountingentries.
// An error is returned if the input is empty or invalid.
func (i *AccountingEntryWhereInput) P() (predicate.AccountingEntry, error) {
	var predicates []predicate.AccountingEntry
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, accountingentry.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.AccountingEntry, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, accountingentry.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.AccountingEntry, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, accountingentry.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, accountingentry.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, accountingentry.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, accountingentry.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, accountingentry.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, accountingentry.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, accountingentry.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, accountingentry.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, accountingentry.IDLTE(*i.IDLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, accountingentry.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, accountingentry.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, accountingentry.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, accountingentry.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, accountingentry.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, accountingentry.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, accountingentry.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, accountingentry.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, accountingentry.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, accountingentry.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, accountingentry.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, accountingentry.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, accountingentry.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, accountingentry.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, accountingentry.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, accountingentry.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.DeletedAt != nil {
		predicates = append(predicates, accountingentry.DeletedAtEQ(*i.DeletedAt))
	}
	if i.DeletedAtNEQ != nil {
		predicates = append(predicates, accountingentry.DeletedAtNEQ(*i.DeletedAtNEQ))
	}
	if len(i.DeletedAtIn) > 0 {
		predicates = append(predicates, accountingentry.DeletedAtIn(i.DeletedAtIn...))
	}
	if len(i.DeletedAtNotIn) > 0 {
		predicates = append(predicates, accountingentry.DeletedAtNotIn(i.DeletedAtNotIn...))
	}
	if i.DeletedAtGT != nil {
		predicates = append(predicates, accountingentry.DeletedAtGT(*i.DeletedAtGT))
	}
	if i.DeletedAtGTE != nil {
		predicates = append(predicates, accountingentry.DeletedAtGTE(*i.DeletedAtGTE))
	}
	if i.DeletedAtLT != nil {
		predicates = append(predicates, accountingentry.DeletedAtLT(*i.DeletedAtLT))
	}
	if i.DeletedAtLTE != nil {
		predicates = append(predicates, accountingentry.DeletedAtLTE(*i.DeletedAtLTE))
	}
	if i.DeletedAtIsNil {
		predicates = append(predicates, accountingentry.DeletedAtIsNil())
	}
	if i.DeletedAtNotNil {
		predicates = append(predicates, accountingentry.DeletedAtNotNil())
	}
	if i.Number != nil {
		predicates = append(predicates, accountingentry.NumberEQ(*i.Number))
	}
	if i.NumberNEQ != nil {
		predicates = append(predicates, accountingentry.NumberNEQ(*i.NumberNEQ))
	}
	if len(i.NumberIn) > 0 {
		predicates = append(predicates, accountingentry.NumberIn(i.NumberIn...))
	}
	if len(i.NumberNotIn) > 0 {
		predicates = append(predicates, accountingentry.NumberNotIn(i.NumberNotIn...))
	}
	if i.NumberGT != nil {
		predicates = append(predicates, accountingentry.NumberGT(*i.NumberGT))
	}
	if i.NumberGTE != nil {
		predicates = append(predicates, accountingentry.NumberGTE(*i.NumberGTE))
	}
	if i.NumberLT != nil {
		predicates = append(predicates, accountingentry.NumberLT(*i.NumberLT))
	}
	if i.NumberLTE != nil {
		predicates = append(predicates, accountingentry.NumberLTE(*i.NumberLTE))
	}
	if i.Group != nil {
		predicates = append(predicates, accountingentry.GroupEQ(*i.Group))
	}
	if i.GroupNEQ != nil {
		predicates = append(predicates, accountingentry.GroupNEQ(*i.GroupNEQ))
	}
	if len(i.GroupIn) > 0 {
		predicates = append(predicates, accountingentry.GroupIn(i.GroupIn...))
	}
	if len(i.GroupNotIn) > 0 {
		predicates = append(predicates, accountingentry.GroupNotIn(i.GroupNotIn...))
	}
	if i.GroupGT != nil {
		predicates = append(predicates, accountingentry.GroupGT(*i.GroupGT))
	}
	if i.GroupGTE != nil {
		predicates = append(predicates, accountingentry.GroupGTE(*i.GroupGTE))
	}
	if i.GroupLT != nil {
		predicates = append(predicates, accountingentry.GroupLT(*i.GroupLT))
	}
	if i.GroupLTE != nil {
		predicates = append(predicates, accountingentry.GroupLTE(*i.GroupLTE))
	}
	if i.Date != nil {
		predicates = append(predicates, accountingentry.DateEQ(*i.Date))
	}
	if i.DateNEQ != nil {
		predicates = append(predicates, accountingentry.DateNEQ(*i.DateNEQ))
	}
	if len(i.DateIn) > 0 {
		predicates = append(predicates, accountingentry.DateIn(i.DateIn...))
	}
	if len(i.DateNotIn) > 0 {
		predicates = append(predicates, accountingentry.DateNotIn(i.DateNotIn...))
	}
	if i.DateGT != nil {
		predicates = append(predicates, accountingentry.DateGT(*i.DateGT))
	}
	if i.DateGTE != nil {
		predicates = append(predicates, accountingentry.DateGTE(*i.DateGTE))
	}
	if i.DateLT != nil {
		predicates = append(predicates, accountingentry.DateLT(*i.DateLT))
	}
	if i.DateLTE != nil {
		predicates = append(predicates, accountingentry.DateLTE(*i.DateLTE))
	}
	if i.Account != nil {
		predicates = append(predicates, accountingentry.AccountEQ(*i.Account))
	}
	if i.AccountNEQ != nil {
		predicates = append(predicates, accountingentry.AccountNEQ(*i.AccountNEQ))
	}
	if len(i.AccountIn) > 0 {
		predicates = append(predicates, accountingentry.AccountIn(i.AccountIn...))
	}
	if len(i.AccountNotIn) > 0 {
		predicates = append(predicates, accountingentry.AccountNotIn(i.AccountNotIn...))
	}
	if i.AccountGT != nil {
		predicates = append(predicates, accountingentry.AccountGT(*i.AccountGT))
	}
	if i.AccountGTE != nil {
		predicates = append(predicates, accountingentry.AccountGTE(*i.AccountGTE))
	}
	if i.AccountLT != nil {
		predicates = append(predicates, accountingentry.AccountLT(*i.AccountLT))
	}
	if i.AccountLTE != nil {
		predicates = append(predicates, accountingentry.AccountLTE(*i.AccountLTE))
	}
	if i.AccountContains != nil {
		predicates = append(predicates, accountingentry.AccountContains(*i.AccountContains))
	}
	if i.AccountHasPrefix != nil {
		predicates = append(predicates, accountingentry.AccountHasPrefix(*i.AccountHasPrefix))
	}
	if i.AccountHasSuffix != nil {
		predicates = append(predicates, accountingentry.AccountHasSuffix(*i.AccountHasSuffix))
	}
	if i.AccountEqualFold != nil {
		predicates = append(predicates, accountingentry.AccountEqualFold(*i.AccountEqualFold))
	}
	if i.AccountContainsFold != nil {
		predicates = append(predicates, accountingentry.AccountContainsFold(*i.AccountContainsFold))
	}
	if i.Label != nil {
		predicates = append(predicates, accountingentry.LabelEQ(*i.Label))
	}
	if i.LabelNEQ != nil {
		predicates = append(predicates, accountingentry.LabelNEQ(*i.LabelNEQ))
	}
	if len(i.LabelIn) > 0 {
		predicates = append(predicates, accountingentry.LabelIn(i.LabelIn...))
	}
	if len(i.LabelNotIn) > 0 {
		predicates = append(predicates, accountingentry.LabelNotIn(i.LabelNotIn...))
	}
	if i.LabelGT != nil {
		predicates = append(predicates, accountingentry.LabelGT(*i.LabelGT))
	}
	if i.LabelGTE != nil {
		predicates = append(predicates, accountingentry.LabelGTE(*i.LabelGTE))
	}
	if i.LabelLT != nil {
		predicates = append(predicates, accountingentry.LabelLT(*i.LabelLT))
	}
	if i.LabelLTE != nil {
		predicates = append(predicates, accountingentry.LabelLTE(*i.LabelLTE))
	}
	if i.LabelContains != nil {
		predicates = append(predicates, accountingentry.LabelContains(*i.LabelContains))
	}
	if i.LabelHasPrefix != nil {
		predicates = append(predicates, accountingentry.LabelHasPrefix(*i.LabelHasPrefix))
	}
	if i.LabelHasSuffix != nil {
		predicates = append(predicates, accountingentry.LabelHasSuffix(*i.LabelHasSuffix))
	}
	if i.LabelEqualFold != nil {
		predicates = append(predicates, accountingentry.LabelEqualFold(*i.LabelEqualFold))
	}
	if i.LabelContainsFold != nil {
		predicates = append(predicates, accountingentry.LabelContainsFold(*i.LabelContainsFold))
	}
	if i.Amount != nil {
		predicates = append(predicates, accountingentry.AmountEQ(*i.Amount))
	}
	if i.AmountNEQ != nil {
		predicates = append(predicates, accountingentry.AmountNEQ(*i.AmountNEQ))
	}
	if len(i.AmountIn) > 0 {
		predicates = append(predicates, accountingentry.AmountIn(i.AmountIn...))
	}
	if len(i.AmountNotIn) > 0 {
		predicates = append(predicates, accountingentry.AmountNotIn(i.AmountNotIn...))
	}
	if i.AmountGT != nil {
		predicates = append(predicates, accountingentry.AmountGT(*i.AmountGT))
	}
	if i.AmountGTE != nil {
		predicates = append(predicates, accountingentry.AmountGTE(*i.AmountGTE))
	}
	if i.AmountLT != nil {
		predicates = append(predicates, accountingentry.AmountLT(*i.AmountLT))
	}
	if i.AmountLTE != nil {
		predicates = append(predicates, accountingentry.AmountLTE(*i.AmountLTE))
	}
	if i.Description != nil {
		predicates = append(predicates, accountingentry.DescriptionEQ(*i.Description))
	}
	if i.DescriptionNEQ != nil {
		predicates = append(predicates, accountingentry.DescriptionNEQ(*i.DescriptionNEQ))
	}
	if len(i.DescriptionIn) > 0 {
		predicates = append(predicates, accountingentry.DescriptionIn(i.DescriptionIn...))
	}
	if len(i.DescriptionNotIn) > 0 {
		predicates = append(predicates, accountingentry.DescriptionNotIn(i.DescriptionNotIn...))
	}
	if i.DescriptionGT != nil {
		predicates = append(predicates, accountingentry.DescriptionGT(*i.DescriptionGT))
	}
	if i.DescriptionGTE != nil {
		predicates = append(predicates, accountingentry.DescriptionGTE(*i.DescriptionGTE))
	}
	if i.DescriptionLT != nil {
		predicates = append(predicates, accountingentry.DescriptionLT(*i.DescriptionLT))
	}
	if i.DescriptionLTE != nil {
		predicates = append(predicates, accountingentry.DescriptionLTE(*i.DescriptionLTE))
	}
	if i.DescriptionContains != nil {
		predicates = append(predicates, accountingentry.DescriptionContains(*i.DescriptionContains))
	}
	if i.DescriptionHasPrefix != nil {
		predicates = append(predicates, accountingentry.DescriptionHasPrefix(*i.DescriptionHasPrefix))
	}
	if i.DescriptionHasSuffix != nil {
		predicates = append(predicates, accountingentry.DescriptionHasSuffix(*i.DescriptionHasSuffix))
	}
	if i.DescriptionEqualFold != nil {
		predicates = append(predicates, accountingentry.DescriptionEqualFold(*i.DescriptionEqualFold))
	}
	if i.DescriptionContainsFold != nil {
		predicates = append(predicates, accountingentry.DescriptionContainsFold(*i.DescriptionContainsFold))
	}
	if i.AccountType != nil {
		predicates = append(predicates, accountingentry.AccountTypeEQ(*i.AccountType))
	}
	if i.AccountTypeNEQ != nil {
		predicates = append(predicates, accountingentry.AccountTypeNEQ(*i.AccountTypeNEQ))
	}
	if len(i.AccountTypeIn) > 0 {
		predicates = append(predicates, accountingentry.AccountTypeIn(i.AccountTypeIn...))
	}
	if len(i.AccountTypeNotIn) > 0 {
		predicates = append(predicates, accountingentry.AccountTypeNotIn(i.AccountTypeNotIn...))
	}
	if i.IsDebit != nil {
		predicates = append(predicates, accountingentry.IsDebitEQ(*i.IsDebit))
	}
	if i.IsDebitNEQ != nil {
		predicates = append(predicates, accountingentry.IsDebitNEQ(*i.IsDebitNEQ))
	}
	if i.IsReversal != nil {
		predicates = append(predicates, accountingentry.IsReversalEQ(*i.IsReversal))
	}
	if i.IsReversalNEQ != nil {
		predicates = append(predicates, accountingentry.IsReversalNEQ(*i.IsReversalNEQ))
	}
	if i.Reversed != nil {
		predicates = append(predicates, accountingentry.ReversedEQ(*i.Reversed))
	}
	if i.ReversedNEQ != nil {
		predicates = append(predicates, accountingentry.ReversedNEQ(*i.ReversedNEQ))
	}

	if i.HasCompany != nil {
		p := accountingentry.HasCompany()
		if !*i.HasCompany {
			p = accountingentry.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasCompanyWith) > 0 {
		with := make([]predicate.Company, 0, len(i.HasCompanyWith))
		for _, w := range i.HasCompanyWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasCompanyWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, accountingentry.HasCompanyWith(with...))
	}
	if i.HasUser != nil {
		p := accountingentry.HasUser()
		if !*i.HasUser {
			p = accountingentry.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasUserWith) > 0 {
		with := make([]predicate.User, 0, len(i.HasUserWith))
		for _, w := range i.HasUserWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasUserWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, accountingentry.HasUserWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyAccountingEntryWhereInput
	case 1:
		return predicates[0], nil
	default:
		return accountingentry.And(predicates...), nil
	}
}

// CashMovementWhereInput represents a where input for filtering CashMovement queries.
type CashMovementWhereInput struct {
	Predicates []predicate.CashMovement  `json:"-"`
	Not        *CashMovementWhereInput   `json:"not,omitempty"`
	Or         []*CashMovementWhereInput `json:"or,omitempty"`
	And        []*CashMovementWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "createdAt" field predicates.
	CreatedAt      *time.Time  `json:"createdat,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdatNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdatIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdatNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdatGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdatGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdatLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdatLTE,omitempty"`

	// "updatedAt" field predicates.
	UpdatedAt      *time.Time  `json:"updatedat,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedatNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedatIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedatNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedatGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedatGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedatLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedatLTE,omitempty"`

	// "deletedAt" field predicates.
	DeletedAt       *time.Time  `json:"deletedat,omitempty"`
	DeletedAtNEQ    *time.Time  `json:"deletedatNEQ,omitempty"`
	DeletedAtIn     []time.Time `json:"deletedatIn,omitempty"`
	DeletedAtNotIn  []time.Time `json:"deletedatNotIn,omitempty"`
	DeletedAtGT     *time.Time  `json:"deletedatGT,omitempty"`
	DeletedAtGTE    *time.Time  `json:"deletedatGTE,omitempty"`
	DeletedAtLT     *time.Time  `json:"deletedatLT,omitempty"`
	DeletedAtLTE    *time.Time  `json:"deletedatLTE,omitempty"`
	DeletedAtIsNil  bool        `json:"deletedatIsNil,omitempty"`
	DeletedAtNotNil bool        `json:"deletedatNotNil,omitempty"`

	// "amount" field predicates.
	Amount      *float64  `json:"amount,omitempty"`
	AmountNEQ   *float64  `json:"amountNEQ,omitempty"`
	AmountIn    []float64 `json:"amountIn,omitempty"`
	AmountNotIn []float64 `json:"amountNotIn,omitempty"`
	AmountGT    *float64  `json:"amountGT,omitempty"`
	AmountGTE   *float64  `json:"amountGTE,omitempty"`
	AmountLT    *float64  `json:"amountLT,omitempty"`
	AmountLTE   *float64  `json:"amountLTE,omitempty"`

	// "date" field predicates.
	Date      *time.Time  `json:"date,omitempty"`
	DateNEQ   *time.Time  `json:"dateNEQ,omitempty"`
	DateIn    []time.Time `json:"dateIn,omitempty"`
	DateNotIn []time.Time `json:"dateNotIn,omitempty"`
	DateGT    *time.Time  `json:"dateGT,omitempty"`
	DateGTE   *time.Time  `json:"dateGTE,omitempty"`
	DateLT    *time.Time  `json:"dateLT,omitempty"`
	DateLTE   *time.Time  `json:"dateLTE,omitempty"`

	// "entryGroup" field predicates.
	EntryGroup      *int  `json:"entrygroup,omitempty"`
	EntryGroupNEQ   *int  `json:"entrygroupNEQ,omitempty"`
	EntryGroupIn    []int `json:"entrygroupIn,omitempty"`
	EntryGroupNotIn []int `json:"entrygroupNotIn,omitempty"`
	EntryGroupGT    *int  `json:"entrygroupGT,omitempty"`
	EntryGroupGTE   *int  `json:"entrygroupGTE,omitempty"`
	EntryGroupLT    *int  `json:"entrygroupLT,omitempty"`
	EntryGroupLTE   *int  `json:"entrygroupLTE,omitempty"`

	// "treasury" edge predicates.
	HasTreasury     *bool                 `json:"hasTreasury,omitempty"`
	HasTreasuryWith []*TreasuryWhereInput `json:"hasTreasuryWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *CashMovementWhereInput) AddPredicates(predicates ...predicate.CashMovement) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the CashMovementWhereInput filter on the CashMovementQuery builder.
func (i *CashMovementWhereInput) Filter(q *CashMovementQuery) (*CashMovementQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyCashMovementWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyCashMovementWhereInput is returned in case the CashMovementWhereInput is empty.
var ErrEmptyCashMovementWhereInput = errors.New("generated: empty predicate CashMovementWhereInput")

// P returns a predicate for filtering cashmovements.
// An error is returned if the input is empty or invalid.
func (i *CashMovementWhereInput) P() (predicate.CashMovement, error) {
	var predicates []predicate.CashMovement
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, cashmovement.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.CashMovement, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, cashmovement.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.CashMovement, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, cashmovement.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, cashmovement.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, cashmovement.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, cashmovement.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, cashmovement.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, cashmovement.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, cashmovement.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, cashmovement.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, cashmovement.IDLTE(*i.IDLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, cashmovement.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, cashmovement.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, cashmovement.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, cashmovement.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, cashmovement.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, cashmovement.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, cashmovement.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, cashmovement.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, cashmovement.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, cashmovement.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, cashmovement.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, cashmovement.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, cashmovement.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, cashmovement.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, cashmovement.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, cashmovement.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.DeletedAt != nil {
		predicates = append(predicates, cashmovement.DeletedAtEQ(*i.DeletedAt))
	}
	if i.DeletedAtNEQ != nil {
		predicates = append(predicates, cashmovement.DeletedAtNEQ(*i.DeletedAtNEQ))
	}
	if len(i.DeletedAtIn) > 0 {
		predicates = append(predicates, cashmovement.DeletedAtIn(i.DeletedAtIn...))
	}
	if len(i.DeletedAtNotIn) > 0 {
		predicates = append(predicates, cashmovement.DeletedAtNotIn(i.DeletedAtNotIn...))
	}
	if i.DeletedAtGT != nil {
		predicates = append(predicates, cashmovement.DeletedAtGT(*i.DeletedAtGT))
	}
	if i.DeletedAtGTE != nil {
		predicates = append(predicates, cashmovement.DeletedAtGTE(*i.DeletedAtGTE))
	}
	if i.DeletedAtLT != nil {
		predicates = append(predicates, cashmovement.DeletedAtLT(*i.DeletedAtLT))
	}
	if i.DeletedAtLTE != nil {
		predicates = append(predicates, cashmovement.DeletedAtLTE(*i.DeletedAtLTE))
	}
	if i.DeletedAtIsNil {
		predicates = append(predicates, cashmovement.DeletedAtIsNil())
	}
	if i.DeletedAtNotNil {
		predicates = append(predicates, cashmovement.DeletedAtNotNil())
	}
	if i.Amount != nil {
		predicates = append(predicates, cashmovement.AmountEQ(*i.Amount))
	}
	if i.AmountNEQ != nil {
		predicates = append(predicates, cashmovement.AmountNEQ(*i.AmountNEQ))
	}
	if len(i.AmountIn) > 0 {
		predicates = append(predicates, cashmovement.AmountIn(i.AmountIn...))
	}
	if len(i.AmountNotIn) > 0 {
		predicates = append(predicates, cashmovement.AmountNotIn(i.AmountNotIn...))
	}
	if i.AmountGT != nil {
		predicates = append(predicates, cashmovement.AmountGT(*i.AmountGT))
	}
	if i.AmountGTE != nil {
		predicates = append(predicates, cashmovement.AmountGTE(*i.AmountGTE))
	}
	if i.AmountLT != nil {
		predicates = append(predicates, cashmovement.AmountLT(*i.AmountLT))
	}
	if i.AmountLTE != nil {
		predicates = append(predicates, cashmovement.AmountLTE(*i.AmountLTE))
	}
	if i.Date != nil {
		predicates = append(predicates, cashmovement.DateEQ(*i.Date))
	}
	if i.DateNEQ != nil {
		predicates = append(predicates, cashmovement.DateNEQ(*i.DateNEQ))
	}
	if len(i.DateIn) > 0 {
		predicates = append(predicates, cashmovement.DateIn(i.DateIn...))
	}
	if len(i.DateNotIn) > 0 {
		predicates = append(predicates, cashmovement.DateNotIn(i.DateNotIn...))
	}
	if i.DateGT != nil {
		predicates = append(predicates, cashmovement.DateGT(*i.DateGT))
	}
	if i.DateGTE != nil {
		predicates = append(predicates, cashmovement.DateGTE(*i.DateGTE))
	}
	if i.DateLT != nil {
		predicates = append(predicates, cashmovement.DateLT(*i.DateLT))
	}
	if i.DateLTE != nil {
		predicates = append(predicates, cashmovement.DateLTE(*i.DateLTE))
	}
	if i.EntryGroup != nil {
		predicates = append(predicates, cashmovement.EntryGroupEQ(*i.EntryGroup))
	}
	if i.EntryGroupNEQ != nil {
		predicates = append(predicates, cashmovement.EntryGroupNEQ(*i.EntryGroupNEQ))
	}
	if len(i.EntryGroupIn) > 0 {
		predicates = append(predicates, cashmovement.EntryGroupIn(i.EntryGroupIn...))
	}
	if len(i.EntryGroupNotIn) > 0 {
		predicates = append(predicates, cashmovement.EntryGroupNotIn(i.EntryGroupNotIn...))
	}
	if i.EntryGroupGT != nil {
		predicates = append(predicates, cashmovement.EntryGroupGT(*i.EntryGroupGT))
	}
	if i.EntryGroupGTE != nil {
		predicates = append(predicates, cashmovement.EntryGroupGTE(*i.EntryGroupGTE))
	}
	if i.EntryGroupLT != nil {
		predicates = append(predicates, cashmovement.EntryGroupLT(*i.EntryGroupLT))
	}
	if i.EntryGroupLTE != nil {
		predicates = append(predicates, cashmovement.EntryGroupLTE(*i.EntryGroupLTE))
	}

	if i.HasTreasury != nil {
		p := cashmovement.HasTreasury()
		if !*i.HasTreasury {
			p = cashmovement.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasTreasuryWith) > 0 {
		with := make([]predicate.Treasury, 0, len(i.HasTreasuryWith))
		for _, w := range i.HasTreasuryWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasTreasuryWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, cashmovement.HasTreasuryWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyCashMovementWhereInput
	case 1:
		return predicates[0], nil
	default:
		return cashmovement.And(predicates...), nil
	}
}

// CompanyWhereInput represents a where input for filtering Company queries.
type CompanyWhereInput struct {
	Predicates []predicate.Company  `json:"-"`
	Not        *CompanyWhereInput   `json:"not,omitempty"`
	Or         []*CompanyWhereInput `json:"or,omitempty"`
	And        []*CompanyWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "createdAt" field predicates.
	CreatedAt      *time.Time  `json:"createdat,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdatNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdatIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdatNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdatGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdatGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdatLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdatLTE,omitempty"`

	// "updatedAt" field predicates.
	UpdatedAt      *time.Time  `json:"updatedat,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedatNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedatIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedatNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedatGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedatGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedatLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedatLTE,omitempty"`

	// "deletedAt" field predicates.
	DeletedAt       *time.Time  `json:"deletedat,omitempty"`
	DeletedAtNEQ    *time.Time  `json:"deletedatNEQ,omitempty"`
	DeletedAtIn     []time.Time `json:"deletedatIn,omitempty"`
	DeletedAtNotIn  []time.Time `json:"deletedatNotIn,omitempty"`
	DeletedAtGT     *time.Time  `json:"deletedatGT,omitempty"`
	DeletedAtGTE    *time.Time  `json:"deletedatGTE,omitempty"`
	DeletedAtLT     *time.Time  `json:"deletedatLT,omitempty"`
	DeletedAtLTE    *time.Time  `json:"deletedatLTE,omitempty"`
	DeletedAtIsNil  bool        `json:"deletedatIsNil,omitempty"`
	DeletedAtNotNil bool        `json:"deletedatNotNil,omitempty"`

	// "address" field predicates.
	Address             *string  `json:"address,omitempty"`
	AddressNEQ          *string  `json:"addressNEQ,omitempty"`
	AddressIn           []string `json:"addressIn,omitempty"`
	AddressNotIn        []string `json:"addressNotIn,omitempty"`
	AddressGT           *string  `json:"addressGT,omitempty"`
	AddressGTE          *string  `json:"addressGTE,omitempty"`
	AddressLT           *string  `json:"addressLT,omitempty"`
	AddressLTE          *string  `json:"addressLTE,omitempty"`
	AddressContains     *string  `json:"addressContains,omitempty"`
	AddressHasPrefix    *string  `json:"addressHasPrefix,omitempty"`
	AddressHasSuffix    *string  `json:"addressHasSuffix,omitempty"`
	AddressIsNil        bool     `json:"addressIsNil,omitempty"`
	AddressNotNil       bool     `json:"addressNotNil,omitempty"`
	AddressEqualFold    *string  `json:"addressEqualFold,omitempty"`
	AddressContainsFold *string  `json:"addressContainsFold,omitempty"`

	// "baseCurrency" field predicates.
	BaseCurrency             *string  `json:"basecurrency,omitempty"`
	BaseCurrencyNEQ          *string  `json:"basecurrencyNEQ,omitempty"`
	BaseCurrencyIn           []string `json:"basecurrencyIn,omitempty"`
	BaseCurrencyNotIn        []string `json:"basecurrencyNotIn,omitempty"`
	BaseCurrencyGT           *string  `json:"basecurrencyGT,omitempty"`
	BaseCurrencyGTE          *string  `json:"basecurrencyGTE,omitempty"`
	BaseCurrencyLT           *string  `json:"basecurrencyLT,omitempty"`
	BaseCurrencyLTE          *string  `json:"basecurrencyLTE,omitempty"`
	BaseCurrencyContains     *string  `json:"basecurrencyContains,omitempty"`
	BaseCurrencyHasPrefix    *string  `json:"basecurrencyHasPrefix,omitempty"`
	BaseCurrencyHasSuffix    *string  `json:"basecurrencyHasSuffix,omitempty"`
	BaseCurrencyEqualFold    *string  `json:"basecurrencyEqualFold,omitempty"`
	BaseCurrencyContainsFold *string  `json:"basecurrencyContainsFold,omitempty"`

	// "ceoName" field predicates.
	CeoName             *string  `json:"ceoname,omitempty"`
	CeoNameNEQ          *string  `json:"ceonameNEQ,omitempty"`
	CeoNameIn           []string `json:"ceonameIn,omitempty"`
	CeoNameNotIn        []string `json:"ceonameNotIn,omitempty"`
	CeoNameGT           *string  `json:"ceonameGT,omitempty"`
	CeoNameGTE          *string  `json:"ceonameGTE,omitempty"`
	CeoNameLT           *string  `json:"ceonameLT,omitempty"`
	CeoNameLTE          *string  `json:"ceonameLTE,omitempty"`
	CeoNameContains     *string  `json:"ceonameContains,omitempty"`
	CeoNameHasPrefix    *string  `json:"ceonameHasPrefix,omitempty"`
	CeoNameHasSuffix    *string  `json:"ceonameHasSuffix,omitempty"`
	CeoNameIsNil        bool     `json:"ceonameIsNil,omitempty"`
	CeoNameNotNil       bool     `json:"ceonameNotNil,omitempty"`
	CeoNameEqualFold    *string  `json:"ceonameEqualFold,omitempty"`
	CeoNameContainsFold *string  `json:"ceonameContainsFold,omitempty"`

	// "city" field predicates.
	City             *string  `json:"city,omitempty"`
	CityNEQ          *string  `json:"cityNEQ,omitempty"`
	CityIn           []string `json:"cityIn,omitempty"`
	CityNotIn        []string `json:"cityNotIn,omitempty"`
	CityGT           *string  `json:"cityGT,omitempty"`
	CityGTE          *string  `json:"cityGTE,omitempty"`
	CityLT           *string  `json:"cityLT,omitempty"`
	CityLTE          *string  `json:"cityLTE,omitempty"`
	CityContains     *string  `json:"cityContains,omitempty"`
	CityHasPrefix    *string  `json:"cityHasPrefix,omitempty"`
	CityHasSuffix    *string  `json:"cityHasSuffix,omitempty"`
	CityEqualFold    *string  `json:"cityEqualFold,omitempty"`
	CityContainsFold *string  `json:"cityContainsFold,omitempty"`

	// "country" field predicates.
	Country             *string  `json:"country,omitempty"`
	CountryNEQ          *string  `json:"countryNEQ,omitempty"`
	CountryIn           []string `json:"countryIn,omitempty"`
	CountryNotIn        []string `json:"countryNotIn,omitempty"`
	CountryGT           *string  `json:"countryGT,omitempty"`
	CountryGTE          *string  `json:"countryGTE,omitempty"`
	CountryLT           *string  `json:"countryLT,omitempty"`
	CountryLTE          *string  `json:"countryLTE,omitempty"`
	CountryContains     *string  `json:"countryContains,omitempty"`
	CountryHasPrefix    *string  `json:"countryHasPrefix,omitempty"`
	CountryHasSuffix    *string  `json:"countryHasSuffix,omitempty"`
	CountryEqualFold    *string  `json:"countryEqualFold,omitempty"`
	CountryContainsFold *string  `json:"countryContainsFold,omitempty"`

	// "establishedAt" field predicates.
	EstablishedAt      *time.Time  `json:"establishedat,omitempty"`
	EstablishedAtNEQ   *time.Time  `json:"establishedatNEQ,omitempty"`
	EstablishedAtIn    []time.Time `json:"establishedatIn,omitempty"`
	EstablishedAtNotIn []time.Time `json:"establishedatNotIn,omitempty"`
	EstablishedAtGT    *time.Time  `json:"establishedatGT,omitempty"`
	EstablishedAtGTE   *time.Time  `json:"establishedatGTE,omitempty"`
	EstablishedAtLT    *time.Time  `json:"establishedatLT,omitempty"`
	EstablishedAtLTE   *time.Time  `json:"establishedatLTE,omitempty"`

	// "description" field predicates.
	Description             *string  `json:"description,omitempty"`
	DescriptionNEQ          *string  `json:"descriptionNEQ,omitempty"`
	DescriptionIn           []string `json:"descriptionIn,omitempty"`
	DescriptionNotIn        []string `json:"descriptionNotIn,omitempty"`
	DescriptionGT           *string  `json:"descriptionGT,omitempty"`
	DescriptionGTE          *string  `json:"descriptionGTE,omitempty"`
	DescriptionLT           *string  `json:"descriptionLT,omitempty"`
	DescriptionLTE          *string  `json:"descriptionLTE,omitempty"`
	DescriptionContains     *string  `json:"descriptionContains,omitempty"`
	DescriptionHasPrefix    *string  `json:"descriptionHasPrefix,omitempty"`
	DescriptionHasSuffix    *string  `json:"descriptionHasSuffix,omitempty"`
	DescriptionIsNil        bool     `json:"descriptionIsNil,omitempty"`
	DescriptionNotNil       bool     `json:"descriptionNotNil,omitempty"`
	DescriptionEqualFold    *string  `json:"descriptionEqualFold,omitempty"`
	DescriptionContainsFold *string  `json:"descriptionContainsFold,omitempty"`

	// "email" field predicates.
	Email             *string  `json:"email,omitempty"`
	EmailNEQ          *string  `json:"emailNEQ,omitempty"`
	EmailIn           []string `json:"emailIn,omitempty"`
	EmailNotIn        []string `json:"emailNotIn,omitempty"`
	EmailGT           *string  `json:"emailGT,omitempty"`
	EmailGTE          *string  `json:"emailGTE,omitempty"`
	EmailLT           *string  `json:"emailLT,omitempty"`
	EmailLTE          *string  `json:"emailLTE,omitempty"`
	EmailContains     *string  `json:"emailContains,omitempty"`
	EmailHasPrefix    *string  `json:"emailHasPrefix,omitempty"`
	EmailHasSuffix    *string  `json:"emailHasSuffix,omitempty"`
	EmailIsNil        bool     `json:"emailIsNil,omitempty"`
	EmailNotNil       bool     `json:"emailNotNil,omitempty"`
	EmailEqualFold    *string  `json:"emailEqualFold,omitempty"`
	EmailContainsFold *string  `json:"emailContainsFold,omitempty"`

	// "lastEntryDate" field predicates.
	LastEntryDate      *time.Time  `json:"lastentrydate,omitempty"`
	LastEntryDateNEQ   *time.Time  `json:"lastentrydateNEQ,omitempty"`
	LastEntryDateIn    []time.Time `json:"lastentrydateIn,omitempty"`
	LastEntryDateNotIn []time.Time `json:"lastentrydateNotIn,omitempty"`
	LastEntryDateGT    *time.Time  `json:"lastentrydateGT,omitempty"`
	LastEntryDateGTE   *time.Time  `json:"lastentrydateGTE,omitempty"`
	LastEntryDateLT    *time.Time  `json:"lastentrydateLT,omitempty"`
	LastEntryDateLTE   *time.Time  `json:"lastentrydateLTE,omitempty"`

	// "lastInvoiceNumber" field predicates.
	LastInvoiceNumber       *int32  `json:"lastinvoicenumber,omitempty"`
	LastInvoiceNumberNEQ    *int32  `json:"lastinvoicenumberNEQ,omitempty"`
	LastInvoiceNumberIn     []int32 `json:"lastinvoicenumberIn,omitempty"`
	LastInvoiceNumberNotIn  []int32 `json:"lastinvoicenumberNotIn,omitempty"`
	LastInvoiceNumberGT     *int32  `json:"lastinvoicenumberGT,omitempty"`
	LastInvoiceNumberGTE    *int32  `json:"lastinvoicenumberGTE,omitempty"`
	LastInvoiceNumberLT     *int32  `json:"lastinvoicenumberLT,omitempty"`
	LastInvoiceNumberLTE    *int32  `json:"lastinvoicenumberLTE,omitempty"`
	LastInvoiceNumberIsNil  bool    `json:"lastinvoicenumberIsNil,omitempty"`
	LastInvoiceNumberNotNil bool    `json:"lastinvoicenumberNotNil,omitempty"`

	// "logo" field predicates.
	Logo             *string  `json:"logo,omitempty"`
	LogoNEQ          *string  `json:"logoNEQ,omitempty"`
	LogoIn           []string `json:"logoIn,omitempty"`
	LogoNotIn        []string `json:"logoNotIn,omitempty"`
	LogoGT           *string  `json:"logoGT,omitempty"`
	LogoGTE          *string  `json:"logoGTE,omitempty"`
	LogoLT           *string  `json:"logoLT,omitempty"`
	LogoLTE          *string  `json:"logoLTE,omitempty"`
	LogoContains     *string  `json:"logoContains,omitempty"`
	LogoHasPrefix    *string  `json:"logoHasPrefix,omitempty"`
	LogoHasSuffix    *string  `json:"logoHasSuffix,omitempty"`
	LogoIsNil        bool     `json:"logoIsNil,omitempty"`
	LogoNotNil       bool     `json:"logoNotNil,omitempty"`
	LogoEqualFold    *string  `json:"logoEqualFold,omitempty"`
	LogoContainsFold *string  `json:"logoContainsFold,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "numberOfEmployees" field predicates.
	NumberOfEmployees      *int32  `json:"numberofemployees,omitempty"`
	NumberOfEmployeesNEQ   *int32  `json:"numberofemployeesNEQ,omitempty"`
	NumberOfEmployeesIn    []int32 `json:"numberofemployeesIn,omitempty"`
	NumberOfEmployeesNotIn []int32 `json:"numberofemployeesNotIn,omitempty"`
	NumberOfEmployeesGT    *int32  `json:"numberofemployeesGT,omitempty"`
	NumberOfEmployeesGTE   *int32  `json:"numberofemployeesGTE,omitempty"`
	NumberOfEmployeesLT    *int32  `json:"numberofemployeesLT,omitempty"`
	NumberOfEmployeesLTE   *int32  `json:"numberofemployeesLTE,omitempty"`

	// "phone" field predicates.
	Phone             *string  `json:"phone,omitempty"`
	PhoneNEQ          *string  `json:"phoneNEQ,omitempty"`
	PhoneIn           []string `json:"phoneIn,omitempty"`
	PhoneNotIn        []string `json:"phoneNotIn,omitempty"`
	PhoneGT           *string  `json:"phoneGT,omitempty"`
	PhoneGTE          *string  `json:"phoneGTE,omitempty"`
	PhoneLT           *string  `json:"phoneLT,omitempty"`
	PhoneLTE          *string  `json:"phoneLTE,omitempty"`
	PhoneContains     *string  `json:"phoneContains,omitempty"`
	PhoneHasPrefix    *string  `json:"phoneHasPrefix,omitempty"`
	PhoneHasSuffix    *string  `json:"phoneHasSuffix,omitempty"`
	PhoneIsNil        bool     `json:"phoneIsNil,omitempty"`
	PhoneNotNil       bool     `json:"phoneNotNil,omitempty"`
	PhoneEqualFold    *string  `json:"phoneEqualFold,omitempty"`
	PhoneContainsFold *string  `json:"phoneContainsFold,omitempty"`

	// "sector" field predicates.
	Sector             *string  `json:"sector,omitempty"`
	SectorNEQ          *string  `json:"sectorNEQ,omitempty"`
	SectorIn           []string `json:"sectorIn,omitempty"`
	SectorNotIn        []string `json:"sectorNotIn,omitempty"`
	SectorGT           *string  `json:"sectorGT,omitempty"`
	SectorGTE          *string  `json:"sectorGTE,omitempty"`
	SectorLT           *string  `json:"sectorLT,omitempty"`
	SectorLTE          *string  `json:"sectorLTE,omitempty"`
	SectorContains     *string  `json:"sectorContains,omitempty"`
	SectorHasPrefix    *string  `json:"sectorHasPrefix,omitempty"`
	SectorHasSuffix    *string  `json:"sectorHasSuffix,omitempty"`
	SectorIsNil        bool     `json:"sectorIsNil,omitempty"`
	SectorNotNil       bool     `json:"sectorNotNil,omitempty"`
	SectorEqualFold    *string  `json:"sectorEqualFold,omitempty"`
	SectorContainsFold *string  `json:"sectorContainsFold,omitempty"`

	// "taxId" field predicates.
	TaxId             *string  `json:"taxid,omitempty"`
	TaxIdNEQ          *string  `json:"taxidNEQ,omitempty"`
	TaxIdIn           []string `json:"taxidIn,omitempty"`
	TaxIdNotIn        []string `json:"taxidNotIn,omitempty"`
	TaxIdGT           *string  `json:"taxidGT,omitempty"`
	TaxIdGTE          *string  `json:"taxidGTE,omitempty"`
	TaxIdLT           *string  `json:"taxidLT,omitempty"`
	TaxIdLTE          *string  `json:"taxidLTE,omitempty"`
	TaxIdContains     *string  `json:"taxidContains,omitempty"`
	TaxIdHasPrefix    *string  `json:"taxidHasPrefix,omitempty"`
	TaxIdHasSuffix    *string  `json:"taxidHasSuffix,omitempty"`
	TaxIdEqualFold    *string  `json:"taxidEqualFold,omitempty"`
	TaxIdContainsFold *string  `json:"taxidContainsFold,omitempty"`

	// "vatRate" field predicates.
	VatRate      *float64  `json:"vatrate,omitempty"`
	VatRateNEQ   *float64  `json:"vatrateNEQ,omitempty"`
	VatRateIn    []float64 `json:"vatrateIn,omitempty"`
	VatRateNotIn []float64 `json:"vatrateNotIn,omitempty"`
	VatRateGT    *float64  `json:"vatrateGT,omitempty"`
	VatRateGTE   *float64  `json:"vatrateGTE,omitempty"`
	VatRateLT    *float64  `json:"vatrateLT,omitempty"`
	VatRateLTE   *float64  `json:"vatrateLTE,omitempty"`

	// "website" field predicates.
	Website             *string  `json:"website,omitempty"`
	WebsiteNEQ          *string  `json:"websiteNEQ,omitempty"`
	WebsiteIn           []string `json:"websiteIn,omitempty"`
	WebsiteNotIn        []string `json:"websiteNotIn,omitempty"`
	WebsiteGT           *string  `json:"websiteGT,omitempty"`
	WebsiteGTE          *string  `json:"websiteGTE,omitempty"`
	WebsiteLT           *string  `json:"websiteLT,omitempty"`
	WebsiteLTE          *string  `json:"websiteLTE,omitempty"`
	WebsiteContains     *string  `json:"websiteContains,omitempty"`
	WebsiteHasPrefix    *string  `json:"websiteHasPrefix,omitempty"`
	WebsiteHasSuffix    *string  `json:"websiteHasSuffix,omitempty"`
	WebsiteIsNil        bool     `json:"websiteIsNil,omitempty"`
	WebsiteNotNil       bool     `json:"websiteNotNil,omitempty"`
	WebsiteEqualFold    *string  `json:"websiteEqualFold,omitempty"`
	WebsiteContainsFold *string  `json:"websiteContainsFold,omitempty"`

	// "availableRoles" edge predicates.
	HasAvailableRoles     *bool                 `json:"hasAvailableRoles,omitempty"`
	HasAvailableRolesWith []*UserRoleWhereInput `json:"hasAvailableRolesWith,omitempty"`

	// "accountingEntries" edge predicates.
	HasAccountingEntries     *bool                        `json:"hasAccountingEntries,omitempty"`
	HasAccountingEntriesWith []*AccountingEntryWhereInput `json:"hasAccountingEntriesWith,omitempty"`

	// "customers" edge predicates.
	HasCustomers     *bool                 `json:"hasCustomers,omitempty"`
	HasCustomersWith []*CustomerWhereInput `json:"hasCustomersWith,omitempty"`

	// "employees" edge predicates.
	HasEmployees     *bool                 `json:"hasEmployees,omitempty"`
	HasEmployeesWith []*EmployeeWhereInput `json:"hasEmployeesWith,omitempty"`

	// "files" edge predicates.
	HasFiles     *bool             `json:"hasFiles,omitempty"`
	HasFilesWith []*FileWhereInput `json:"hasFilesWith,omitempty"`

	// "products" edge predicates.
	HasProducts     *bool                `json:"hasProducts,omitempty"`
	HasProductsWith []*ProductWhereInput `json:"hasProductsWith,omitempty"`

	// "suppliers" edge predicates.
	HasSuppliers     *bool                 `json:"hasSuppliers,omitempty"`
	HasSuppliersWith []*SupplierWhereInput `json:"hasSuppliersWith,omitempty"`

	// "tokens" edge predicates.
	HasTokens     *bool              `json:"hasTokens,omitempty"`
	HasTokensWith []*TokenWhereInput `json:"hasTokensWith,omitempty"`

	// "treasuries" edge predicates.
	HasTreasuries     *bool                 `json:"hasTreasuries,omitempty"`
	HasTreasuriesWith []*TreasuryWhereInput `json:"hasTreasuriesWith,omitempty"`

	// "workShifts" edge predicates.
	HasWorkShifts     *bool                  `json:"hasWorkShifts,omitempty"`
	HasWorkShiftsWith []*WorkshiftWhereInput `json:"hasWorkShiftsWith,omitempty"`

	// "workTasks" edge predicates.
	HasWorkTasks     *bool                 `json:"hasWorkTasks,omitempty"`
	HasWorkTasksWith []*WorktaskWhereInput `json:"hasWorkTasksWith,omitempty"`

	// "workTags" edge predicates.
	HasWorkTags     *bool                `json:"hasWorkTags,omitempty"`
	HasWorkTagsWith []*WorktagWhereInput `json:"hasWorkTagsWith,omitempty"`

	// "users" edge predicates.
	HasUsers     *bool             `json:"hasUsers,omitempty"`
	HasUsersWith []*UserWhereInput `json:"hasUsersWith,omitempty"`

	// "daughterCompanies" edge predicates.
	HasDaughterCompanies     *bool                `json:"hasDaughterCompanies,omitempty"`
	HasDaughterCompaniesWith []*CompanyWhereInput `json:"hasDaughterCompaniesWith,omitempty"`

	// "parentCompany" edge predicates.
	HasParentCompany     *bool                `json:"hasParentCompany,omitempty"`
	HasParentCompanyWith []*CompanyWhereInput `json:"hasParentCompanyWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *CompanyWhereInput) AddPredicates(predicates ...predicate.Company) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the CompanyWhereInput filter on the CompanyQuery builder.
func (i *CompanyWhereInput) Filter(q *CompanyQuery) (*CompanyQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyCompanyWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyCompanyWhereInput is returned in case the CompanyWhereInput is empty.
var ErrEmptyCompanyWhereInput = errors.New("generated: empty predicate CompanyWhereInput")

// P returns a predicate for filtering companies.
// An error is returned if the input is empty or invalid.
func (i *CompanyWhereInput) P() (predicate.Company, error) {
	var predicates []predicate.Company
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, company.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Company, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, company.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Company, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, company.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, company.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, company.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, company.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, company.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, company.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, company.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, company.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, company.IDLTE(*i.IDLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, company.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, company.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, company.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, company.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, company.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, company.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, company.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, company.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, company.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, company.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, company.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, company.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, company.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, company.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, company.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, company.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.DeletedAt != nil {
		predicates = append(predicates, company.DeletedAtEQ(*i.DeletedAt))
	}
	if i.DeletedAtNEQ != nil {
		predicates = append(predicates, company.DeletedAtNEQ(*i.DeletedAtNEQ))
	}
	if len(i.DeletedAtIn) > 0 {
		predicates = append(predicates, company.DeletedAtIn(i.DeletedAtIn...))
	}
	if len(i.DeletedAtNotIn) > 0 {
		predicates = append(predicates, company.DeletedAtNotIn(i.DeletedAtNotIn...))
	}
	if i.DeletedAtGT != nil {
		predicates = append(predicates, company.DeletedAtGT(*i.DeletedAtGT))
	}
	if i.DeletedAtGTE != nil {
		predicates = append(predicates, company.DeletedAtGTE(*i.DeletedAtGTE))
	}
	if i.DeletedAtLT != nil {
		predicates = append(predicates, company.DeletedAtLT(*i.DeletedAtLT))
	}
	if i.DeletedAtLTE != nil {
		predicates = append(predicates, company.DeletedAtLTE(*i.DeletedAtLTE))
	}
	if i.DeletedAtIsNil {
		predicates = append(predicates, company.DeletedAtIsNil())
	}
	if i.DeletedAtNotNil {
		predicates = append(predicates, company.DeletedAtNotNil())
	}
	if i.Address != nil {
		predicates = append(predicates, company.AddressEQ(*i.Address))
	}
	if i.AddressNEQ != nil {
		predicates = append(predicates, company.AddressNEQ(*i.AddressNEQ))
	}
	if len(i.AddressIn) > 0 {
		predicates = append(predicates, company.AddressIn(i.AddressIn...))
	}
	if len(i.AddressNotIn) > 0 {
		predicates = append(predicates, company.AddressNotIn(i.AddressNotIn...))
	}
	if i.AddressGT != nil {
		predicates = append(predicates, company.AddressGT(*i.AddressGT))
	}
	if i.AddressGTE != nil {
		predicates = append(predicates, company.AddressGTE(*i.AddressGTE))
	}
	if i.AddressLT != nil {
		predicates = append(predicates, company.AddressLT(*i.AddressLT))
	}
	if i.AddressLTE != nil {
		predicates = append(predicates, company.AddressLTE(*i.AddressLTE))
	}
	if i.AddressContains != nil {
		predicates = append(predicates, company.AddressContains(*i.AddressContains))
	}
	if i.AddressHasPrefix != nil {
		predicates = append(predicates, company.AddressHasPrefix(*i.AddressHasPrefix))
	}
	if i.AddressHasSuffix != nil {
		predicates = append(predicates, company.AddressHasSuffix(*i.AddressHasSuffix))
	}
	if i.AddressIsNil {
		predicates = append(predicates, company.AddressIsNil())
	}
	if i.AddressNotNil {
		predicates = append(predicates, company.AddressNotNil())
	}
	if i.AddressEqualFold != nil {
		predicates = append(predicates, company.AddressEqualFold(*i.AddressEqualFold))
	}
	if i.AddressContainsFold != nil {
		predicates = append(predicates, company.AddressContainsFold(*i.AddressContainsFold))
	}
	if i.BaseCurrency != nil {
		predicates = append(predicates, company.BaseCurrencyEQ(*i.BaseCurrency))
	}
	if i.BaseCurrencyNEQ != nil {
		predicates = append(predicates, company.BaseCurrencyNEQ(*i.BaseCurrencyNEQ))
	}
	if len(i.BaseCurrencyIn) > 0 {
		predicates = append(predicates, company.BaseCurrencyIn(i.BaseCurrencyIn...))
	}
	if len(i.BaseCurrencyNotIn) > 0 {
		predicates = append(predicates, company.BaseCurrencyNotIn(i.BaseCurrencyNotIn...))
	}
	if i.BaseCurrencyGT != nil {
		predicates = append(predicates, company.BaseCurrencyGT(*i.BaseCurrencyGT))
	}
	if i.BaseCurrencyGTE != nil {
		predicates = append(predicates, company.BaseCurrencyGTE(*i.BaseCurrencyGTE))
	}
	if i.BaseCurrencyLT != nil {
		predicates = append(predicates, company.BaseCurrencyLT(*i.BaseCurrencyLT))
	}
	if i.BaseCurrencyLTE != nil {
		predicates = append(predicates, company.BaseCurrencyLTE(*i.BaseCurrencyLTE))
	}
	if i.BaseCurrencyContains != nil {
		predicates = append(predicates, company.BaseCurrencyContains(*i.BaseCurrencyContains))
	}
	if i.BaseCurrencyHasPrefix != nil {
		predicates = append(predicates, company.BaseCurrencyHasPrefix(*i.BaseCurrencyHasPrefix))
	}
	if i.BaseCurrencyHasSuffix != nil {
		predicates = append(predicates, company.BaseCurrencyHasSuffix(*i.BaseCurrencyHasSuffix))
	}
	if i.BaseCurrencyEqualFold != nil {
		predicates = append(predicates, company.BaseCurrencyEqualFold(*i.BaseCurrencyEqualFold))
	}
	if i.BaseCurrencyContainsFold != nil {
		predicates = append(predicates, company.BaseCurrencyContainsFold(*i.BaseCurrencyContainsFold))
	}
	if i.CeoName != nil {
		predicates = append(predicates, company.CeoNameEQ(*i.CeoName))
	}
	if i.CeoNameNEQ != nil {
		predicates = append(predicates, company.CeoNameNEQ(*i.CeoNameNEQ))
	}
	if len(i.CeoNameIn) > 0 {
		predicates = append(predicates, company.CeoNameIn(i.CeoNameIn...))
	}
	if len(i.CeoNameNotIn) > 0 {
		predicates = append(predicates, company.CeoNameNotIn(i.CeoNameNotIn...))
	}
	if i.CeoNameGT != nil {
		predicates = append(predicates, company.CeoNameGT(*i.CeoNameGT))
	}
	if i.CeoNameGTE != nil {
		predicates = append(predicates, company.CeoNameGTE(*i.CeoNameGTE))
	}
	if i.CeoNameLT != nil {
		predicates = append(predicates, company.CeoNameLT(*i.CeoNameLT))
	}
	if i.CeoNameLTE != nil {
		predicates = append(predicates, company.CeoNameLTE(*i.CeoNameLTE))
	}
	if i.CeoNameContains != nil {
		predicates = append(predicates, company.CeoNameContains(*i.CeoNameContains))
	}
	if i.CeoNameHasPrefix != nil {
		predicates = append(predicates, company.CeoNameHasPrefix(*i.CeoNameHasPrefix))
	}
	if i.CeoNameHasSuffix != nil {
		predicates = append(predicates, company.CeoNameHasSuffix(*i.CeoNameHasSuffix))
	}
	if i.CeoNameIsNil {
		predicates = append(predicates, company.CeoNameIsNil())
	}
	if i.CeoNameNotNil {
		predicates = append(predicates, company.CeoNameNotNil())
	}
	if i.CeoNameEqualFold != nil {
		predicates = append(predicates, company.CeoNameEqualFold(*i.CeoNameEqualFold))
	}
	if i.CeoNameContainsFold != nil {
		predicates = append(predicates, company.CeoNameContainsFold(*i.CeoNameContainsFold))
	}
	if i.City != nil {
		predicates = append(predicates, company.CityEQ(*i.City))
	}
	if i.CityNEQ != nil {
		predicates = append(predicates, company.CityNEQ(*i.CityNEQ))
	}
	if len(i.CityIn) > 0 {
		predicates = append(predicates, company.CityIn(i.CityIn...))
	}
	if len(i.CityNotIn) > 0 {
		predicates = append(predicates, company.CityNotIn(i.CityNotIn...))
	}
	if i.CityGT != nil {
		predicates = append(predicates, company.CityGT(*i.CityGT))
	}
	if i.CityGTE != nil {
		predicates = append(predicates, company.CityGTE(*i.CityGTE))
	}
	if i.CityLT != nil {
		predicates = append(predicates, company.CityLT(*i.CityLT))
	}
	if i.CityLTE != nil {
		predicates = append(predicates, company.CityLTE(*i.CityLTE))
	}
	if i.CityContains != nil {
		predicates = append(predicates, company.CityContains(*i.CityContains))
	}
	if i.CityHasPrefix != nil {
		predicates = append(predicates, company.CityHasPrefix(*i.CityHasPrefix))
	}
	if i.CityHasSuffix != nil {
		predicates = append(predicates, company.CityHasSuffix(*i.CityHasSuffix))
	}
	if i.CityEqualFold != nil {
		predicates = append(predicates, company.CityEqualFold(*i.CityEqualFold))
	}
	if i.CityContainsFold != nil {
		predicates = append(predicates, company.CityContainsFold(*i.CityContainsFold))
	}
	if i.Country != nil {
		predicates = append(predicates, company.CountryEQ(*i.Country))
	}
	if i.CountryNEQ != nil {
		predicates = append(predicates, company.CountryNEQ(*i.CountryNEQ))
	}
	if len(i.CountryIn) > 0 {
		predicates = append(predicates, company.CountryIn(i.CountryIn...))
	}
	if len(i.CountryNotIn) > 0 {
		predicates = append(predicates, company.CountryNotIn(i.CountryNotIn...))
	}
	if i.CountryGT != nil {
		predicates = append(predicates, company.CountryGT(*i.CountryGT))
	}
	if i.CountryGTE != nil {
		predicates = append(predicates, company.CountryGTE(*i.CountryGTE))
	}
	if i.CountryLT != nil {
		predicates = append(predicates, company.CountryLT(*i.CountryLT))
	}
	if i.CountryLTE != nil {
		predicates = append(predicates, company.CountryLTE(*i.CountryLTE))
	}
	if i.CountryContains != nil {
		predicates = append(predicates, company.CountryContains(*i.CountryContains))
	}
	if i.CountryHasPrefix != nil {
		predicates = append(predicates, company.CountryHasPrefix(*i.CountryHasPrefix))
	}
	if i.CountryHasSuffix != nil {
		predicates = append(predicates, company.CountryHasSuffix(*i.CountryHasSuffix))
	}
	if i.CountryEqualFold != nil {
		predicates = append(predicates, company.CountryEqualFold(*i.CountryEqualFold))
	}
	if i.CountryContainsFold != nil {
		predicates = append(predicates, company.CountryContainsFold(*i.CountryContainsFold))
	}
	if i.EstablishedAt != nil {
		predicates = append(predicates, company.EstablishedAtEQ(*i.EstablishedAt))
	}
	if i.EstablishedAtNEQ != nil {
		predicates = append(predicates, company.EstablishedAtNEQ(*i.EstablishedAtNEQ))
	}
	if len(i.EstablishedAtIn) > 0 {
		predicates = append(predicates, company.EstablishedAtIn(i.EstablishedAtIn...))
	}
	if len(i.EstablishedAtNotIn) > 0 {
		predicates = append(predicates, company.EstablishedAtNotIn(i.EstablishedAtNotIn...))
	}
	if i.EstablishedAtGT != nil {
		predicates = append(predicates, company.EstablishedAtGT(*i.EstablishedAtGT))
	}
	if i.EstablishedAtGTE != nil {
		predicates = append(predicates, company.EstablishedAtGTE(*i.EstablishedAtGTE))
	}
	if i.EstablishedAtLT != nil {
		predicates = append(predicates, company.EstablishedAtLT(*i.EstablishedAtLT))
	}
	if i.EstablishedAtLTE != nil {
		predicates = append(predicates, company.EstablishedAtLTE(*i.EstablishedAtLTE))
	}
	if i.Description != nil {
		predicates = append(predicates, company.DescriptionEQ(*i.Description))
	}
	if i.DescriptionNEQ != nil {
		predicates = append(predicates, company.DescriptionNEQ(*i.DescriptionNEQ))
	}
	if len(i.DescriptionIn) > 0 {
		predicates = append(predicates, company.DescriptionIn(i.DescriptionIn...))
	}
	if len(i.DescriptionNotIn) > 0 {
		predicates = append(predicates, company.DescriptionNotIn(i.DescriptionNotIn...))
	}
	if i.DescriptionGT != nil {
		predicates = append(predicates, company.DescriptionGT(*i.DescriptionGT))
	}
	if i.DescriptionGTE != nil {
		predicates = append(predicates, company.DescriptionGTE(*i.DescriptionGTE))
	}
	if i.DescriptionLT != nil {
		predicates = append(predicates, company.DescriptionLT(*i.DescriptionLT))
	}
	if i.DescriptionLTE != nil {
		predicates = append(predicates, company.DescriptionLTE(*i.DescriptionLTE))
	}
	if i.DescriptionContains != nil {
		predicates = append(predicates, company.DescriptionContains(*i.DescriptionContains))
	}
	if i.DescriptionHasPrefix != nil {
		predicates = append(predicates, company.DescriptionHasPrefix(*i.DescriptionHasPrefix))
	}
	if i.DescriptionHasSuffix != nil {
		predicates = append(predicates, company.DescriptionHasSuffix(*i.DescriptionHasSuffix))
	}
	if i.DescriptionIsNil {
		predicates = append(predicates, company.DescriptionIsNil())
	}
	if i.DescriptionNotNil {
		predicates = append(predicates, company.DescriptionNotNil())
	}
	if i.DescriptionEqualFold != nil {
		predicates = append(predicates, company.DescriptionEqualFold(*i.DescriptionEqualFold))
	}
	if i.DescriptionContainsFold != nil {
		predicates = append(predicates, company.DescriptionContainsFold(*i.DescriptionContainsFold))
	}
	if i.Email != nil {
		predicates = append(predicates, company.EmailEQ(*i.Email))
	}
	if i.EmailNEQ != nil {
		predicates = append(predicates, company.EmailNEQ(*i.EmailNEQ))
	}
	if len(i.EmailIn) > 0 {
		predicates = append(predicates, company.EmailIn(i.EmailIn...))
	}
	if len(i.EmailNotIn) > 0 {
		predicates = append(predicates, company.EmailNotIn(i.EmailNotIn...))
	}
	if i.EmailGT != nil {
		predicates = append(predicates, company.EmailGT(*i.EmailGT))
	}
	if i.EmailGTE != nil {
		predicates = append(predicates, company.EmailGTE(*i.EmailGTE))
	}
	if i.EmailLT != nil {
		predicates = append(predicates, company.EmailLT(*i.EmailLT))
	}
	if i.EmailLTE != nil {
		predicates = append(predicates, company.EmailLTE(*i.EmailLTE))
	}
	if i.EmailContains != nil {
		predicates = append(predicates, company.EmailContains(*i.EmailContains))
	}
	if i.EmailHasPrefix != nil {
		predicates = append(predicates, company.EmailHasPrefix(*i.EmailHasPrefix))
	}
	if i.EmailHasSuffix != nil {
		predicates = append(predicates, company.EmailHasSuffix(*i.EmailHasSuffix))
	}
	if i.EmailIsNil {
		predicates = append(predicates, company.EmailIsNil())
	}
	if i.EmailNotNil {
		predicates = append(predicates, company.EmailNotNil())
	}
	if i.EmailEqualFold != nil {
		predicates = append(predicates, company.EmailEqualFold(*i.EmailEqualFold))
	}
	if i.EmailContainsFold != nil {
		predicates = append(predicates, company.EmailContainsFold(*i.EmailContainsFold))
	}
	if i.LastEntryDate != nil {
		predicates = append(predicates, company.LastEntryDateEQ(*i.LastEntryDate))
	}
	if i.LastEntryDateNEQ != nil {
		predicates = append(predicates, company.LastEntryDateNEQ(*i.LastEntryDateNEQ))
	}
	if len(i.LastEntryDateIn) > 0 {
		predicates = append(predicates, company.LastEntryDateIn(i.LastEntryDateIn...))
	}
	if len(i.LastEntryDateNotIn) > 0 {
		predicates = append(predicates, company.LastEntryDateNotIn(i.LastEntryDateNotIn...))
	}
	if i.LastEntryDateGT != nil {
		predicates = append(predicates, company.LastEntryDateGT(*i.LastEntryDateGT))
	}
	if i.LastEntryDateGTE != nil {
		predicates = append(predicates, company.LastEntryDateGTE(*i.LastEntryDateGTE))
	}
	if i.LastEntryDateLT != nil {
		predicates = append(predicates, company.LastEntryDateLT(*i.LastEntryDateLT))
	}
	if i.LastEntryDateLTE != nil {
		predicates = append(predicates, company.LastEntryDateLTE(*i.LastEntryDateLTE))
	}
	if i.LastInvoiceNumber != nil {
		predicates = append(predicates, company.LastInvoiceNumberEQ(*i.LastInvoiceNumber))
	}
	if i.LastInvoiceNumberNEQ != nil {
		predicates = append(predicates, company.LastInvoiceNumberNEQ(*i.LastInvoiceNumberNEQ))
	}
	if len(i.LastInvoiceNumberIn) > 0 {
		predicates = append(predicates, company.LastInvoiceNumberIn(i.LastInvoiceNumberIn...))
	}
	if len(i.LastInvoiceNumberNotIn) > 0 {
		predicates = append(predicates, company.LastInvoiceNumberNotIn(i.LastInvoiceNumberNotIn...))
	}
	if i.LastInvoiceNumberGT != nil {
		predicates = append(predicates, company.LastInvoiceNumberGT(*i.LastInvoiceNumberGT))
	}
	if i.LastInvoiceNumberGTE != nil {
		predicates = append(predicates, company.LastInvoiceNumberGTE(*i.LastInvoiceNumberGTE))
	}
	if i.LastInvoiceNumberLT != nil {
		predicates = append(predicates, company.LastInvoiceNumberLT(*i.LastInvoiceNumberLT))
	}
	if i.LastInvoiceNumberLTE != nil {
		predicates = append(predicates, company.LastInvoiceNumberLTE(*i.LastInvoiceNumberLTE))
	}
	if i.LastInvoiceNumberIsNil {
		predicates = append(predicates, company.LastInvoiceNumberIsNil())
	}
	if i.LastInvoiceNumberNotNil {
		predicates = append(predicates, company.LastInvoiceNumberNotNil())
	}
	if i.Logo != nil {
		predicates = append(predicates, company.LogoEQ(*i.Logo))
	}
	if i.LogoNEQ != nil {
		predicates = append(predicates, company.LogoNEQ(*i.LogoNEQ))
	}
	if len(i.LogoIn) > 0 {
		predicates = append(predicates, company.LogoIn(i.LogoIn...))
	}
	if len(i.LogoNotIn) > 0 {
		predicates = append(predicates, company.LogoNotIn(i.LogoNotIn...))
	}
	if i.LogoGT != nil {
		predicates = append(predicates, company.LogoGT(*i.LogoGT))
	}
	if i.LogoGTE != nil {
		predicates = append(predicates, company.LogoGTE(*i.LogoGTE))
	}
	if i.LogoLT != nil {
		predicates = append(predicates, company.LogoLT(*i.LogoLT))
	}
	if i.LogoLTE != nil {
		predicates = append(predicates, company.LogoLTE(*i.LogoLTE))
	}
	if i.LogoContains != nil {
		predicates = append(predicates, company.LogoContains(*i.LogoContains))
	}
	if i.LogoHasPrefix != nil {
		predicates = append(predicates, company.LogoHasPrefix(*i.LogoHasPrefix))
	}
	if i.LogoHasSuffix != nil {
		predicates = append(predicates, company.LogoHasSuffix(*i.LogoHasSuffix))
	}
	if i.LogoIsNil {
		predicates = append(predicates, company.LogoIsNil())
	}
	if i.LogoNotNil {
		predicates = append(predicates, company.LogoNotNil())
	}
	if i.LogoEqualFold != nil {
		predicates = append(predicates, company.LogoEqualFold(*i.LogoEqualFold))
	}
	if i.LogoContainsFold != nil {
		predicates = append(predicates, company.LogoContainsFold(*i.LogoContainsFold))
	}
	if i.Name != nil {
		predicates = append(predicates, company.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, company.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, company.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, company.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, company.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, company.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, company.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, company.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, company.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, company.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, company.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, company.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, company.NameContainsFold(*i.NameContainsFold))
	}
	if i.NumberOfEmployees != nil {
		predicates = append(predicates, company.NumberOfEmployeesEQ(*i.NumberOfEmployees))
	}
	if i.NumberOfEmployeesNEQ != nil {
		predicates = append(predicates, company.NumberOfEmployeesNEQ(*i.NumberOfEmployeesNEQ))
	}
	if len(i.NumberOfEmployeesIn) > 0 {
		predicates = append(predicates, company.NumberOfEmployeesIn(i.NumberOfEmployeesIn...))
	}
	if len(i.NumberOfEmployeesNotIn) > 0 {
		predicates = append(predicates, company.NumberOfEmployeesNotIn(i.NumberOfEmployeesNotIn...))
	}
	if i.NumberOfEmployeesGT != nil {
		predicates = append(predicates, company.NumberOfEmployeesGT(*i.NumberOfEmployeesGT))
	}
	if i.NumberOfEmployeesGTE != nil {
		predicates = append(predicates, company.NumberOfEmployeesGTE(*i.NumberOfEmployeesGTE))
	}
	if i.NumberOfEmployeesLT != nil {
		predicates = append(predicates, company.NumberOfEmployeesLT(*i.NumberOfEmployeesLT))
	}
	if i.NumberOfEmployeesLTE != nil {
		predicates = append(predicates, company.NumberOfEmployeesLTE(*i.NumberOfEmployeesLTE))
	}
	if i.Phone != nil {
		predicates = append(predicates, company.PhoneEQ(*i.Phone))
	}
	if i.PhoneNEQ != nil {
		predicates = append(predicates, company.PhoneNEQ(*i.PhoneNEQ))
	}
	if len(i.PhoneIn) > 0 {
		predicates = append(predicates, company.PhoneIn(i.PhoneIn...))
	}
	if len(i.PhoneNotIn) > 0 {
		predicates = append(predicates, company.PhoneNotIn(i.PhoneNotIn...))
	}
	if i.PhoneGT != nil {
		predicates = append(predicates, company.PhoneGT(*i.PhoneGT))
	}
	if i.PhoneGTE != nil {
		predicates = append(predicates, company.PhoneGTE(*i.PhoneGTE))
	}
	if i.PhoneLT != nil {
		predicates = append(predicates, company.PhoneLT(*i.PhoneLT))
	}
	if i.PhoneLTE != nil {
		predicates = append(predicates, company.PhoneLTE(*i.PhoneLTE))
	}
	if i.PhoneContains != nil {
		predicates = append(predicates, company.PhoneContains(*i.PhoneContains))
	}
	if i.PhoneHasPrefix != nil {
		predicates = append(predicates, company.PhoneHasPrefix(*i.PhoneHasPrefix))
	}
	if i.PhoneHasSuffix != nil {
		predicates = append(predicates, company.PhoneHasSuffix(*i.PhoneHasSuffix))
	}
	if i.PhoneIsNil {
		predicates = append(predicates, company.PhoneIsNil())
	}
	if i.PhoneNotNil {
		predicates = append(predicates, company.PhoneNotNil())
	}
	if i.PhoneEqualFold != nil {
		predicates = append(predicates, company.PhoneEqualFold(*i.PhoneEqualFold))
	}
	if i.PhoneContainsFold != nil {
		predicates = append(predicates, company.PhoneContainsFold(*i.PhoneContainsFold))
	}
	if i.Sector != nil {
		predicates = append(predicates, company.SectorEQ(*i.Sector))
	}
	if i.SectorNEQ != nil {
		predicates = append(predicates, company.SectorNEQ(*i.SectorNEQ))
	}
	if len(i.SectorIn) > 0 {
		predicates = append(predicates, company.SectorIn(i.SectorIn...))
	}
	if len(i.SectorNotIn) > 0 {
		predicates = append(predicates, company.SectorNotIn(i.SectorNotIn...))
	}
	if i.SectorGT != nil {
		predicates = append(predicates, company.SectorGT(*i.SectorGT))
	}
	if i.SectorGTE != nil {
		predicates = append(predicates, company.SectorGTE(*i.SectorGTE))
	}
	if i.SectorLT != nil {
		predicates = append(predicates, company.SectorLT(*i.SectorLT))
	}
	if i.SectorLTE != nil {
		predicates = append(predicates, company.SectorLTE(*i.SectorLTE))
	}
	if i.SectorContains != nil {
		predicates = append(predicates, company.SectorContains(*i.SectorContains))
	}
	if i.SectorHasPrefix != nil {
		predicates = append(predicates, company.SectorHasPrefix(*i.SectorHasPrefix))
	}
	if i.SectorHasSuffix != nil {
		predicates = append(predicates, company.SectorHasSuffix(*i.SectorHasSuffix))
	}
	if i.SectorIsNil {
		predicates = append(predicates, company.SectorIsNil())
	}
	if i.SectorNotNil {
		predicates = append(predicates, company.SectorNotNil())
	}
	if i.SectorEqualFold != nil {
		predicates = append(predicates, company.SectorEqualFold(*i.SectorEqualFold))
	}
	if i.SectorContainsFold != nil {
		predicates = append(predicates, company.SectorContainsFold(*i.SectorContainsFold))
	}
	if i.TaxId != nil {
		predicates = append(predicates, company.TaxIdEQ(*i.TaxId))
	}
	if i.TaxIdNEQ != nil {
		predicates = append(predicates, company.TaxIdNEQ(*i.TaxIdNEQ))
	}
	if len(i.TaxIdIn) > 0 {
		predicates = append(predicates, company.TaxIdIn(i.TaxIdIn...))
	}
	if len(i.TaxIdNotIn) > 0 {
		predicates = append(predicates, company.TaxIdNotIn(i.TaxIdNotIn...))
	}
	if i.TaxIdGT != nil {
		predicates = append(predicates, company.TaxIdGT(*i.TaxIdGT))
	}
	if i.TaxIdGTE != nil {
		predicates = append(predicates, company.TaxIdGTE(*i.TaxIdGTE))
	}
	if i.TaxIdLT != nil {
		predicates = append(predicates, company.TaxIdLT(*i.TaxIdLT))
	}
	if i.TaxIdLTE != nil {
		predicates = append(predicates, company.TaxIdLTE(*i.TaxIdLTE))
	}
	if i.TaxIdContains != nil {
		predicates = append(predicates, company.TaxIdContains(*i.TaxIdContains))
	}
	if i.TaxIdHasPrefix != nil {
		predicates = append(predicates, company.TaxIdHasPrefix(*i.TaxIdHasPrefix))
	}
	if i.TaxIdHasSuffix != nil {
		predicates = append(predicates, company.TaxIdHasSuffix(*i.TaxIdHasSuffix))
	}
	if i.TaxIdEqualFold != nil {
		predicates = append(predicates, company.TaxIdEqualFold(*i.TaxIdEqualFold))
	}
	if i.TaxIdContainsFold != nil {
		predicates = append(predicates, company.TaxIdContainsFold(*i.TaxIdContainsFold))
	}
	if i.VatRate != nil {
		predicates = append(predicates, company.VatRateEQ(*i.VatRate))
	}
	if i.VatRateNEQ != nil {
		predicates = append(predicates, company.VatRateNEQ(*i.VatRateNEQ))
	}
	if len(i.VatRateIn) > 0 {
		predicates = append(predicates, company.VatRateIn(i.VatRateIn...))
	}
	if len(i.VatRateNotIn) > 0 {
		predicates = append(predicates, company.VatRateNotIn(i.VatRateNotIn...))
	}
	if i.VatRateGT != nil {
		predicates = append(predicates, company.VatRateGT(*i.VatRateGT))
	}
	if i.VatRateGTE != nil {
		predicates = append(predicates, company.VatRateGTE(*i.VatRateGTE))
	}
	if i.VatRateLT != nil {
		predicates = append(predicates, company.VatRateLT(*i.VatRateLT))
	}
	if i.VatRateLTE != nil {
		predicates = append(predicates, company.VatRateLTE(*i.VatRateLTE))
	}
	if i.Website != nil {
		predicates = append(predicates, company.WebsiteEQ(*i.Website))
	}
	if i.WebsiteNEQ != nil {
		predicates = append(predicates, company.WebsiteNEQ(*i.WebsiteNEQ))
	}
	if len(i.WebsiteIn) > 0 {
		predicates = append(predicates, company.WebsiteIn(i.WebsiteIn...))
	}
	if len(i.WebsiteNotIn) > 0 {
		predicates = append(predicates, company.WebsiteNotIn(i.WebsiteNotIn...))
	}
	if i.WebsiteGT != nil {
		predicates = append(predicates, company.WebsiteGT(*i.WebsiteGT))
	}
	if i.WebsiteGTE != nil {
		predicates = append(predicates, company.WebsiteGTE(*i.WebsiteGTE))
	}
	if i.WebsiteLT != nil {
		predicates = append(predicates, company.WebsiteLT(*i.WebsiteLT))
	}
	if i.WebsiteLTE != nil {
		predicates = append(predicates, company.WebsiteLTE(*i.WebsiteLTE))
	}
	if i.WebsiteContains != nil {
		predicates = append(predicates, company.WebsiteContains(*i.WebsiteContains))
	}
	if i.WebsiteHasPrefix != nil {
		predicates = append(predicates, company.WebsiteHasPrefix(*i.WebsiteHasPrefix))
	}
	if i.WebsiteHasSuffix != nil {
		predicates = append(predicates, company.WebsiteHasSuffix(*i.WebsiteHasSuffix))
	}
	if i.WebsiteIsNil {
		predicates = append(predicates, company.WebsiteIsNil())
	}
	if i.WebsiteNotNil {
		predicates = append(predicates, company.WebsiteNotNil())
	}
	if i.WebsiteEqualFold != nil {
		predicates = append(predicates, company.WebsiteEqualFold(*i.WebsiteEqualFold))
	}
	if i.WebsiteContainsFold != nil {
		predicates = append(predicates, company.WebsiteContainsFold(*i.WebsiteContainsFold))
	}

	if i.HasAvailableRoles != nil {
		p := company.HasAvailableRoles()
		if !*i.HasAvailableRoles {
			p = company.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasAvailableRolesWith) > 0 {
		with := make([]predicate.UserRole, 0, len(i.HasAvailableRolesWith))
		for _, w := range i.HasAvailableRolesWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasAvailableRolesWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, company.HasAvailableRolesWith(with...))
	}
	if i.HasAccountingEntries != nil {
		p := company.HasAccountingEntries()
		if !*i.HasAccountingEntries {
			p = company.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasAccountingEntriesWith) > 0 {
		with := make([]predicate.AccountingEntry, 0, len(i.HasAccountingEntriesWith))
		for _, w := range i.HasAccountingEntriesWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasAccountingEntriesWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, company.HasAccountingEntriesWith(with...))
	}
	if i.HasCustomers != nil {
		p := company.HasCustomers()
		if !*i.HasCustomers {
			p = company.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasCustomersWith) > 0 {
		with := make([]predicate.Customer, 0, len(i.HasCustomersWith))
		for _, w := range i.HasCustomersWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasCustomersWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, company.HasCustomersWith(with...))
	}
	if i.HasEmployees != nil {
		p := company.HasEmployees()
		if !*i.HasEmployees {
			p = company.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasEmployeesWith) > 0 {
		with := make([]predicate.Employee, 0, len(i.HasEmployeesWith))
		for _, w := range i.HasEmployeesWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasEmployeesWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, company.HasEmployeesWith(with...))
	}
	if i.HasFiles != nil {
		p := company.HasFiles()
		if !*i.HasFiles {
			p = company.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasFilesWith) > 0 {
		with := make([]predicate.File, 0, len(i.HasFilesWith))
		for _, w := range i.HasFilesWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasFilesWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, company.HasFilesWith(with...))
	}
	if i.HasProducts != nil {
		p := company.HasProducts()
		if !*i.HasProducts {
			p = company.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasProductsWith) > 0 {
		with := make([]predicate.Product, 0, len(i.HasProductsWith))
		for _, w := range i.HasProductsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasProductsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, company.HasProductsWith(with...))
	}
	if i.HasSuppliers != nil {
		p := company.HasSuppliers()
		if !*i.HasSuppliers {
			p = company.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasSuppliersWith) > 0 {
		with := make([]predicate.Supplier, 0, len(i.HasSuppliersWith))
		for _, w := range i.HasSuppliersWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasSuppliersWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, company.HasSuppliersWith(with...))
	}
	if i.HasTokens != nil {
		p := company.HasTokens()
		if !*i.HasTokens {
			p = company.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasTokensWith) > 0 {
		with := make([]predicate.Token, 0, len(i.HasTokensWith))
		for _, w := range i.HasTokensWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasTokensWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, company.HasTokensWith(with...))
	}
	if i.HasTreasuries != nil {
		p := company.HasTreasuries()
		if !*i.HasTreasuries {
			p = company.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasTreasuriesWith) > 0 {
		with := make([]predicate.Treasury, 0, len(i.HasTreasuriesWith))
		for _, w := range i.HasTreasuriesWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasTreasuriesWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, company.HasTreasuriesWith(with...))
	}
	if i.HasWorkShifts != nil {
		p := company.HasWorkShifts()
		if !*i.HasWorkShifts {
			p = company.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasWorkShiftsWith) > 0 {
		with := make([]predicate.Workshift, 0, len(i.HasWorkShiftsWith))
		for _, w := range i.HasWorkShiftsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasWorkShiftsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, company.HasWorkShiftsWith(with...))
	}
	if i.HasWorkTasks != nil {
		p := company.HasWorkTasks()
		if !*i.HasWorkTasks {
			p = company.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasWorkTasksWith) > 0 {
		with := make([]predicate.Worktask, 0, len(i.HasWorkTasksWith))
		for _, w := range i.HasWorkTasksWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasWorkTasksWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, company.HasWorkTasksWith(with...))
	}
	if i.HasWorkTags != nil {
		p := company.HasWorkTags()
		if !*i.HasWorkTags {
			p = company.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasWorkTagsWith) > 0 {
		with := make([]predicate.Worktag, 0, len(i.HasWorkTagsWith))
		for _, w := range i.HasWorkTagsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasWorkTagsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, company.HasWorkTagsWith(with...))
	}
	if i.HasUsers != nil {
		p := company.HasUsers()
		if !*i.HasUsers {
			p = company.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasUsersWith) > 0 {
		with := make([]predicate.User, 0, len(i.HasUsersWith))
		for _, w := range i.HasUsersWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasUsersWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, company.HasUsersWith(with...))
	}
	if i.HasDaughterCompanies != nil {
		p := company.HasDaughterCompanies()
		if !*i.HasDaughterCompanies {
			p = company.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasDaughterCompaniesWith) > 0 {
		with := make([]predicate.Company, 0, len(i.HasDaughterCompaniesWith))
		for _, w := range i.HasDaughterCompaniesWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasDaughterCompaniesWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, company.HasDaughterCompaniesWith(with...))
	}
	if i.HasParentCompany != nil {
		p := company.HasParentCompany()
		if !*i.HasParentCompany {
			p = company.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasParentCompanyWith) > 0 {
		with := make([]predicate.Company, 0, len(i.HasParentCompanyWith))
		for _, w := range i.HasParentCompanyWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasParentCompanyWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, company.HasParentCompanyWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyCompanyWhereInput
	case 1:
		return predicates[0], nil
	default:
		return company.And(predicates...), nil
	}
}

// CustomerWhereInput represents a where input for filtering Customer queries.
type CustomerWhereInput struct {
	Predicates []predicate.Customer  `json:"-"`
	Not        *CustomerWhereInput   `json:"not,omitempty"`
	Or         []*CustomerWhereInput `json:"or,omitempty"`
	And        []*CustomerWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "createdAt" field predicates.
	CreatedAt      *time.Time  `json:"createdat,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdatNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdatIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdatNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdatGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdatGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdatLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdatLTE,omitempty"`

	// "updatedAt" field predicates.
	UpdatedAt      *time.Time  `json:"updatedat,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedatNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedatIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedatNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedatGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedatGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedatLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedatLTE,omitempty"`

	// "deletedAt" field predicates.
	DeletedAt       *time.Time  `json:"deletedat,omitempty"`
	DeletedAtNEQ    *time.Time  `json:"deletedatNEQ,omitempty"`
	DeletedAtIn     []time.Time `json:"deletedatIn,omitempty"`
	DeletedAtNotIn  []time.Time `json:"deletedatNotIn,omitempty"`
	DeletedAtGT     *time.Time  `json:"deletedatGT,omitempty"`
	DeletedAtGTE    *time.Time  `json:"deletedatGTE,omitempty"`
	DeletedAtLT     *time.Time  `json:"deletedatLT,omitempty"`
	DeletedAtLTE    *time.Time  `json:"deletedatLTE,omitempty"`
	DeletedAtIsNil  bool        `json:"deletedatIsNil,omitempty"`
	DeletedAtNotNil bool        `json:"deletedatNotNil,omitempty"`

	// "address" field predicates.
	Address             *string  `json:"address,omitempty"`
	AddressNEQ          *string  `json:"addressNEQ,omitempty"`
	AddressIn           []string `json:"addressIn,omitempty"`
	AddressNotIn        []string `json:"addressNotIn,omitempty"`
	AddressGT           *string  `json:"addressGT,omitempty"`
	AddressGTE          *string  `json:"addressGTE,omitempty"`
	AddressLT           *string  `json:"addressLT,omitempty"`
	AddressLTE          *string  `json:"addressLTE,omitempty"`
	AddressContains     *string  `json:"addressContains,omitempty"`
	AddressHasPrefix    *string  `json:"addressHasPrefix,omitempty"`
	AddressHasSuffix    *string  `json:"addressHasSuffix,omitempty"`
	AddressEqualFold    *string  `json:"addressEqualFold,omitempty"`
	AddressContainsFold *string  `json:"addressContainsFold,omitempty"`

	// "city" field predicates.
	City             *string  `json:"city,omitempty"`
	CityNEQ          *string  `json:"cityNEQ,omitempty"`
	CityIn           []string `json:"cityIn,omitempty"`
	CityNotIn        []string `json:"cityNotIn,omitempty"`
	CityGT           *string  `json:"cityGT,omitempty"`
	CityGTE          *string  `json:"cityGTE,omitempty"`
	CityLT           *string  `json:"cityLT,omitempty"`
	CityLTE          *string  `json:"cityLTE,omitempty"`
	CityContains     *string  `json:"cityContains,omitempty"`
	CityHasPrefix    *string  `json:"cityHasPrefix,omitempty"`
	CityHasSuffix    *string  `json:"cityHasSuffix,omitempty"`
	CityEqualFold    *string  `json:"cityEqualFold,omitempty"`
	CityContainsFold *string  `json:"cityContainsFold,omitempty"`

	// "country" field predicates.
	Country             *string  `json:"country,omitempty"`
	CountryNEQ          *string  `json:"countryNEQ,omitempty"`
	CountryIn           []string `json:"countryIn,omitempty"`
	CountryNotIn        []string `json:"countryNotIn,omitempty"`
	CountryGT           *string  `json:"countryGT,omitempty"`
	CountryGTE          *string  `json:"countryGTE,omitempty"`
	CountryLT           *string  `json:"countryLT,omitempty"`
	CountryLTE          *string  `json:"countryLTE,omitempty"`
	CountryContains     *string  `json:"countryContains,omitempty"`
	CountryHasPrefix    *string  `json:"countryHasPrefix,omitempty"`
	CountryHasSuffix    *string  `json:"countryHasSuffix,omitempty"`
	CountryEqualFold    *string  `json:"countryEqualFold,omitempty"`
	CountryContainsFold *string  `json:"countryContainsFold,omitempty"`

	// "description" field predicates.
	Description             *string  `json:"description,omitempty"`
	DescriptionNEQ          *string  `json:"descriptionNEQ,omitempty"`
	DescriptionIn           []string `json:"descriptionIn,omitempty"`
	DescriptionNotIn        []string `json:"descriptionNotIn,omitempty"`
	DescriptionGT           *string  `json:"descriptionGT,omitempty"`
	DescriptionGTE          *string  `json:"descriptionGTE,omitempty"`
	DescriptionLT           *string  `json:"descriptionLT,omitempty"`
	DescriptionLTE          *string  `json:"descriptionLTE,omitempty"`
	DescriptionContains     *string  `json:"descriptionContains,omitempty"`
	DescriptionHasPrefix    *string  `json:"descriptionHasPrefix,omitempty"`
	DescriptionHasSuffix    *string  `json:"descriptionHasSuffix,omitempty"`
	DescriptionEqualFold    *string  `json:"descriptionEqualFold,omitempty"`
	DescriptionContainsFold *string  `json:"descriptionContainsFold,omitempty"`

	// "email" field predicates.
	Email             *string  `json:"email,omitempty"`
	EmailNEQ          *string  `json:"emailNEQ,omitempty"`
	EmailIn           []string `json:"emailIn,omitempty"`
	EmailNotIn        []string `json:"emailNotIn,omitempty"`
	EmailGT           *string  `json:"emailGT,omitempty"`
	EmailGTE          *string  `json:"emailGTE,omitempty"`
	EmailLT           *string  `json:"emailLT,omitempty"`
	EmailLTE          *string  `json:"emailLTE,omitempty"`
	EmailContains     *string  `json:"emailContains,omitempty"`
	EmailHasPrefix    *string  `json:"emailHasPrefix,omitempty"`
	EmailHasSuffix    *string  `json:"emailHasSuffix,omitempty"`
	EmailEqualFold    *string  `json:"emailEqualFold,omitempty"`
	EmailContainsFold *string  `json:"emailContainsFold,omitempty"`

	// "isDefault" field predicates.
	IsDefault       *bool `json:"isdefault,omitempty"`
	IsDefaultNEQ    *bool `json:"isdefaultNEQ,omitempty"`
	IsDefaultIsNil  bool  `json:"isdefaultIsNil,omitempty"`
	IsDefaultNotNil bool  `json:"isdefaultNotNil,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "phone" field predicates.
	Phone             *string  `json:"phone,omitempty"`
	PhoneNEQ          *string  `json:"phoneNEQ,omitempty"`
	PhoneIn           []string `json:"phoneIn,omitempty"`
	PhoneNotIn        []string `json:"phoneNotIn,omitempty"`
	PhoneGT           *string  `json:"phoneGT,omitempty"`
	PhoneGTE          *string  `json:"phoneGTE,omitempty"`
	PhoneLT           *string  `json:"phoneLT,omitempty"`
	PhoneLTE          *string  `json:"phoneLTE,omitempty"`
	PhoneContains     *string  `json:"phoneContains,omitempty"`
	PhoneHasPrefix    *string  `json:"phoneHasPrefix,omitempty"`
	PhoneHasSuffix    *string  `json:"phoneHasSuffix,omitempty"`
	PhoneEqualFold    *string  `json:"phoneEqualFold,omitempty"`
	PhoneContainsFold *string  `json:"phoneContainsFold,omitempty"`

	// "taxId" field predicates.
	TaxId             *string  `json:"taxid,omitempty"`
	TaxIdNEQ          *string  `json:"taxidNEQ,omitempty"`
	TaxIdIn           []string `json:"taxidIn,omitempty"`
	TaxIdNotIn        []string `json:"taxidNotIn,omitempty"`
	TaxIdGT           *string  `json:"taxidGT,omitempty"`
	TaxIdGTE          *string  `json:"taxidGTE,omitempty"`
	TaxIdLT           *string  `json:"taxidLT,omitempty"`
	TaxIdLTE          *string  `json:"taxidLTE,omitempty"`
	TaxIdContains     *string  `json:"taxidContains,omitempty"`
	TaxIdHasPrefix    *string  `json:"taxidHasPrefix,omitempty"`
	TaxIdHasSuffix    *string  `json:"taxidHasSuffix,omitempty"`
	TaxIdEqualFold    *string  `json:"taxidEqualFold,omitempty"`
	TaxIdContainsFold *string  `json:"taxidContainsFold,omitempty"`

	// "company" edge predicates.
	HasCompany     *bool                `json:"hasCompany,omitempty"`
	HasCompanyWith []*CompanyWhereInput `json:"hasCompanyWith,omitempty"`

	// "receivables" edge predicates.
	HasReceivables     *bool                   `json:"hasReceivables,omitempty"`
	HasReceivablesWith []*ReceivableWhereInput `json:"hasReceivablesWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *CustomerWhereInput) AddPredicates(predicates ...predicate.Customer) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the CustomerWhereInput filter on the CustomerQuery builder.
func (i *CustomerWhereInput) Filter(q *CustomerQuery) (*CustomerQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyCustomerWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyCustomerWhereInput is returned in case the CustomerWhereInput is empty.
var ErrEmptyCustomerWhereInput = errors.New("generated: empty predicate CustomerWhereInput")

// P returns a predicate for filtering customers.
// An error is returned if the input is empty or invalid.
func (i *CustomerWhereInput) P() (predicate.Customer, error) {
	var predicates []predicate.Customer
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, customer.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Customer, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, customer.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Customer, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, customer.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, customer.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, customer.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, customer.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, customer.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, customer.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, customer.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, customer.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, customer.IDLTE(*i.IDLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, customer.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, customer.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, customer.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, customer.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, customer.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, customer.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, customer.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, customer.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, customer.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, customer.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, customer.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, customer.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, customer.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, customer.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, customer.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, customer.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.DeletedAt != nil {
		predicates = append(predicates, customer.DeletedAtEQ(*i.DeletedAt))
	}
	if i.DeletedAtNEQ != nil {
		predicates = append(predicates, customer.DeletedAtNEQ(*i.DeletedAtNEQ))
	}
	if len(i.DeletedAtIn) > 0 {
		predicates = append(predicates, customer.DeletedAtIn(i.DeletedAtIn...))
	}
	if len(i.DeletedAtNotIn) > 0 {
		predicates = append(predicates, customer.DeletedAtNotIn(i.DeletedAtNotIn...))
	}
	if i.DeletedAtGT != nil {
		predicates = append(predicates, customer.DeletedAtGT(*i.DeletedAtGT))
	}
	if i.DeletedAtGTE != nil {
		predicates = append(predicates, customer.DeletedAtGTE(*i.DeletedAtGTE))
	}
	if i.DeletedAtLT != nil {
		predicates = append(predicates, customer.DeletedAtLT(*i.DeletedAtLT))
	}
	if i.DeletedAtLTE != nil {
		predicates = append(predicates, customer.DeletedAtLTE(*i.DeletedAtLTE))
	}
	if i.DeletedAtIsNil {
		predicates = append(predicates, customer.DeletedAtIsNil())
	}
	if i.DeletedAtNotNil {
		predicates = append(predicates, customer.DeletedAtNotNil())
	}
	if i.Address != nil {
		predicates = append(predicates, customer.AddressEQ(*i.Address))
	}
	if i.AddressNEQ != nil {
		predicates = append(predicates, customer.AddressNEQ(*i.AddressNEQ))
	}
	if len(i.AddressIn) > 0 {
		predicates = append(predicates, customer.AddressIn(i.AddressIn...))
	}
	if len(i.AddressNotIn) > 0 {
		predicates = append(predicates, customer.AddressNotIn(i.AddressNotIn...))
	}
	if i.AddressGT != nil {
		predicates = append(predicates, customer.AddressGT(*i.AddressGT))
	}
	if i.AddressGTE != nil {
		predicates = append(predicates, customer.AddressGTE(*i.AddressGTE))
	}
	if i.AddressLT != nil {
		predicates = append(predicates, customer.AddressLT(*i.AddressLT))
	}
	if i.AddressLTE != nil {
		predicates = append(predicates, customer.AddressLTE(*i.AddressLTE))
	}
	if i.AddressContains != nil {
		predicates = append(predicates, customer.AddressContains(*i.AddressContains))
	}
	if i.AddressHasPrefix != nil {
		predicates = append(predicates, customer.AddressHasPrefix(*i.AddressHasPrefix))
	}
	if i.AddressHasSuffix != nil {
		predicates = append(predicates, customer.AddressHasSuffix(*i.AddressHasSuffix))
	}
	if i.AddressEqualFold != nil {
		predicates = append(predicates, customer.AddressEqualFold(*i.AddressEqualFold))
	}
	if i.AddressContainsFold != nil {
		predicates = append(predicates, customer.AddressContainsFold(*i.AddressContainsFold))
	}
	if i.City != nil {
		predicates = append(predicates, customer.CityEQ(*i.City))
	}
	if i.CityNEQ != nil {
		predicates = append(predicates, customer.CityNEQ(*i.CityNEQ))
	}
	if len(i.CityIn) > 0 {
		predicates = append(predicates, customer.CityIn(i.CityIn...))
	}
	if len(i.CityNotIn) > 0 {
		predicates = append(predicates, customer.CityNotIn(i.CityNotIn...))
	}
	if i.CityGT != nil {
		predicates = append(predicates, customer.CityGT(*i.CityGT))
	}
	if i.CityGTE != nil {
		predicates = append(predicates, customer.CityGTE(*i.CityGTE))
	}
	if i.CityLT != nil {
		predicates = append(predicates, customer.CityLT(*i.CityLT))
	}
	if i.CityLTE != nil {
		predicates = append(predicates, customer.CityLTE(*i.CityLTE))
	}
	if i.CityContains != nil {
		predicates = append(predicates, customer.CityContains(*i.CityContains))
	}
	if i.CityHasPrefix != nil {
		predicates = append(predicates, customer.CityHasPrefix(*i.CityHasPrefix))
	}
	if i.CityHasSuffix != nil {
		predicates = append(predicates, customer.CityHasSuffix(*i.CityHasSuffix))
	}
	if i.CityEqualFold != nil {
		predicates = append(predicates, customer.CityEqualFold(*i.CityEqualFold))
	}
	if i.CityContainsFold != nil {
		predicates = append(predicates, customer.CityContainsFold(*i.CityContainsFold))
	}
	if i.Country != nil {
		predicates = append(predicates, customer.CountryEQ(*i.Country))
	}
	if i.CountryNEQ != nil {
		predicates = append(predicates, customer.CountryNEQ(*i.CountryNEQ))
	}
	if len(i.CountryIn) > 0 {
		predicates = append(predicates, customer.CountryIn(i.CountryIn...))
	}
	if len(i.CountryNotIn) > 0 {
		predicates = append(predicates, customer.CountryNotIn(i.CountryNotIn...))
	}
	if i.CountryGT != nil {
		predicates = append(predicates, customer.CountryGT(*i.CountryGT))
	}
	if i.CountryGTE != nil {
		predicates = append(predicates, customer.CountryGTE(*i.CountryGTE))
	}
	if i.CountryLT != nil {
		predicates = append(predicates, customer.CountryLT(*i.CountryLT))
	}
	if i.CountryLTE != nil {
		predicates = append(predicates, customer.CountryLTE(*i.CountryLTE))
	}
	if i.CountryContains != nil {
		predicates = append(predicates, customer.CountryContains(*i.CountryContains))
	}
	if i.CountryHasPrefix != nil {
		predicates = append(predicates, customer.CountryHasPrefix(*i.CountryHasPrefix))
	}
	if i.CountryHasSuffix != nil {
		predicates = append(predicates, customer.CountryHasSuffix(*i.CountryHasSuffix))
	}
	if i.CountryEqualFold != nil {
		predicates = append(predicates, customer.CountryEqualFold(*i.CountryEqualFold))
	}
	if i.CountryContainsFold != nil {
		predicates = append(predicates, customer.CountryContainsFold(*i.CountryContainsFold))
	}
	if i.Description != nil {
		predicates = append(predicates, customer.DescriptionEQ(*i.Description))
	}
	if i.DescriptionNEQ != nil {
		predicates = append(predicates, customer.DescriptionNEQ(*i.DescriptionNEQ))
	}
	if len(i.DescriptionIn) > 0 {
		predicates = append(predicates, customer.DescriptionIn(i.DescriptionIn...))
	}
	if len(i.DescriptionNotIn) > 0 {
		predicates = append(predicates, customer.DescriptionNotIn(i.DescriptionNotIn...))
	}
	if i.DescriptionGT != nil {
		predicates = append(predicates, customer.DescriptionGT(*i.DescriptionGT))
	}
	if i.DescriptionGTE != nil {
		predicates = append(predicates, customer.DescriptionGTE(*i.DescriptionGTE))
	}
	if i.DescriptionLT != nil {
		predicates = append(predicates, customer.DescriptionLT(*i.DescriptionLT))
	}
	if i.DescriptionLTE != nil {
		predicates = append(predicates, customer.DescriptionLTE(*i.DescriptionLTE))
	}
	if i.DescriptionContains != nil {
		predicates = append(predicates, customer.DescriptionContains(*i.DescriptionContains))
	}
	if i.DescriptionHasPrefix != nil {
		predicates = append(predicates, customer.DescriptionHasPrefix(*i.DescriptionHasPrefix))
	}
	if i.DescriptionHasSuffix != nil {
		predicates = append(predicates, customer.DescriptionHasSuffix(*i.DescriptionHasSuffix))
	}
	if i.DescriptionEqualFold != nil {
		predicates = append(predicates, customer.DescriptionEqualFold(*i.DescriptionEqualFold))
	}
	if i.DescriptionContainsFold != nil {
		predicates = append(predicates, customer.DescriptionContainsFold(*i.DescriptionContainsFold))
	}
	if i.Email != nil {
		predicates = append(predicates, customer.EmailEQ(*i.Email))
	}
	if i.EmailNEQ != nil {
		predicates = append(predicates, customer.EmailNEQ(*i.EmailNEQ))
	}
	if len(i.EmailIn) > 0 {
		predicates = append(predicates, customer.EmailIn(i.EmailIn...))
	}
	if len(i.EmailNotIn) > 0 {
		predicates = append(predicates, customer.EmailNotIn(i.EmailNotIn...))
	}
	if i.EmailGT != nil {
		predicates = append(predicates, customer.EmailGT(*i.EmailGT))
	}
	if i.EmailGTE != nil {
		predicates = append(predicates, customer.EmailGTE(*i.EmailGTE))
	}
	if i.EmailLT != nil {
		predicates = append(predicates, customer.EmailLT(*i.EmailLT))
	}
	if i.EmailLTE != nil {
		predicates = append(predicates, customer.EmailLTE(*i.EmailLTE))
	}
	if i.EmailContains != nil {
		predicates = append(predicates, customer.EmailContains(*i.EmailContains))
	}
	if i.EmailHasPrefix != nil {
		predicates = append(predicates, customer.EmailHasPrefix(*i.EmailHasPrefix))
	}
	if i.EmailHasSuffix != nil {
		predicates = append(predicates, customer.EmailHasSuffix(*i.EmailHasSuffix))
	}
	if i.EmailEqualFold != nil {
		predicates = append(predicates, customer.EmailEqualFold(*i.EmailEqualFold))
	}
	if i.EmailContainsFold != nil {
		predicates = append(predicates, customer.EmailContainsFold(*i.EmailContainsFold))
	}
	if i.IsDefault != nil {
		predicates = append(predicates, customer.IsDefaultEQ(*i.IsDefault))
	}
	if i.IsDefaultNEQ != nil {
		predicates = append(predicates, customer.IsDefaultNEQ(*i.IsDefaultNEQ))
	}
	if i.IsDefaultIsNil {
		predicates = append(predicates, customer.IsDefaultIsNil())
	}
	if i.IsDefaultNotNil {
		predicates = append(predicates, customer.IsDefaultNotNil())
	}
	if i.Name != nil {
		predicates = append(predicates, customer.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, customer.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, customer.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, customer.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, customer.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, customer.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, customer.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, customer.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, customer.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, customer.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, customer.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, customer.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, customer.NameContainsFold(*i.NameContainsFold))
	}
	if i.Phone != nil {
		predicates = append(predicates, customer.PhoneEQ(*i.Phone))
	}
	if i.PhoneNEQ != nil {
		predicates = append(predicates, customer.PhoneNEQ(*i.PhoneNEQ))
	}
	if len(i.PhoneIn) > 0 {
		predicates = append(predicates, customer.PhoneIn(i.PhoneIn...))
	}
	if len(i.PhoneNotIn) > 0 {
		predicates = append(predicates, customer.PhoneNotIn(i.PhoneNotIn...))
	}
	if i.PhoneGT != nil {
		predicates = append(predicates, customer.PhoneGT(*i.PhoneGT))
	}
	if i.PhoneGTE != nil {
		predicates = append(predicates, customer.PhoneGTE(*i.PhoneGTE))
	}
	if i.PhoneLT != nil {
		predicates = append(predicates, customer.PhoneLT(*i.PhoneLT))
	}
	if i.PhoneLTE != nil {
		predicates = append(predicates, customer.PhoneLTE(*i.PhoneLTE))
	}
	if i.PhoneContains != nil {
		predicates = append(predicates, customer.PhoneContains(*i.PhoneContains))
	}
	if i.PhoneHasPrefix != nil {
		predicates = append(predicates, customer.PhoneHasPrefix(*i.PhoneHasPrefix))
	}
	if i.PhoneHasSuffix != nil {
		predicates = append(predicates, customer.PhoneHasSuffix(*i.PhoneHasSuffix))
	}
	if i.PhoneEqualFold != nil {
		predicates = append(predicates, customer.PhoneEqualFold(*i.PhoneEqualFold))
	}
	if i.PhoneContainsFold != nil {
		predicates = append(predicates, customer.PhoneContainsFold(*i.PhoneContainsFold))
	}
	if i.TaxId != nil {
		predicates = append(predicates, customer.TaxIdEQ(*i.TaxId))
	}
	if i.TaxIdNEQ != nil {
		predicates = append(predicates, customer.TaxIdNEQ(*i.TaxIdNEQ))
	}
	if len(i.TaxIdIn) > 0 {
		predicates = append(predicates, customer.TaxIdIn(i.TaxIdIn...))
	}
	if len(i.TaxIdNotIn) > 0 {
		predicates = append(predicates, customer.TaxIdNotIn(i.TaxIdNotIn...))
	}
	if i.TaxIdGT != nil {
		predicates = append(predicates, customer.TaxIdGT(*i.TaxIdGT))
	}
	if i.TaxIdGTE != nil {
		predicates = append(predicates, customer.TaxIdGTE(*i.TaxIdGTE))
	}
	if i.TaxIdLT != nil {
		predicates = append(predicates, customer.TaxIdLT(*i.TaxIdLT))
	}
	if i.TaxIdLTE != nil {
		predicates = append(predicates, customer.TaxIdLTE(*i.TaxIdLTE))
	}
	if i.TaxIdContains != nil {
		predicates = append(predicates, customer.TaxIdContains(*i.TaxIdContains))
	}
	if i.TaxIdHasPrefix != nil {
		predicates = append(predicates, customer.TaxIdHasPrefix(*i.TaxIdHasPrefix))
	}
	if i.TaxIdHasSuffix != nil {
		predicates = append(predicates, customer.TaxIdHasSuffix(*i.TaxIdHasSuffix))
	}
	if i.TaxIdEqualFold != nil {
		predicates = append(predicates, customer.TaxIdEqualFold(*i.TaxIdEqualFold))
	}
	if i.TaxIdContainsFold != nil {
		predicates = append(predicates, customer.TaxIdContainsFold(*i.TaxIdContainsFold))
	}

	if i.HasCompany != nil {
		p := customer.HasCompany()
		if !*i.HasCompany {
			p = customer.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasCompanyWith) > 0 {
		with := make([]predicate.Company, 0, len(i.HasCompanyWith))
		for _, w := range i.HasCompanyWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasCompanyWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, customer.HasCompanyWith(with...))
	}
	if i.HasReceivables != nil {
		p := customer.HasReceivables()
		if !*i.HasReceivables {
			p = customer.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasReceivablesWith) > 0 {
		with := make([]predicate.Receivable, 0, len(i.HasReceivablesWith))
		for _, w := range i.HasReceivablesWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasReceivablesWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, customer.HasReceivablesWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyCustomerWhereInput
	case 1:
		return predicates[0], nil
	default:
		return customer.And(predicates...), nil
	}
}

// EmployeeWhereInput represents a where input for filtering Employee queries.
type EmployeeWhereInput struct {
	Predicates []predicate.Employee  `json:"-"`
	Not        *EmployeeWhereInput   `json:"not,omitempty"`
	Or         []*EmployeeWhereInput `json:"or,omitempty"`
	And        []*EmployeeWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "createdAt" field predicates.
	CreatedAt      *time.Time  `json:"createdat,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdatNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdatIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdatNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdatGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdatGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdatLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdatLTE,omitempty"`

	// "updatedAt" field predicates.
	UpdatedAt      *time.Time  `json:"updatedat,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedatNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedatIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedatNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedatGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedatGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedatLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedatLTE,omitempty"`

	// "deletedAt" field predicates.
	DeletedAt       *time.Time  `json:"deletedat,omitempty"`
	DeletedAtNEQ    *time.Time  `json:"deletedatNEQ,omitempty"`
	DeletedAtIn     []time.Time `json:"deletedatIn,omitempty"`
	DeletedAtNotIn  []time.Time `json:"deletedatNotIn,omitempty"`
	DeletedAtGT     *time.Time  `json:"deletedatGT,omitempty"`
	DeletedAtGTE    *time.Time  `json:"deletedatGTE,omitempty"`
	DeletedAtLT     *time.Time  `json:"deletedatLT,omitempty"`
	DeletedAtLTE    *time.Time  `json:"deletedatLTE,omitempty"`
	DeletedAtIsNil  bool        `json:"deletedatIsNil,omitempty"`
	DeletedAtNotNil bool        `json:"deletedatNotNil,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "gender" field predicates.
	Gender      *employee.Gender  `json:"gender,omitempty"`
	GenderNEQ   *employee.Gender  `json:"genderNEQ,omitempty"`
	GenderIn    []employee.Gender `json:"genderIn,omitempty"`
	GenderNotIn []employee.Gender `json:"genderNotIn,omitempty"`

	// "position" field predicates.
	Position             *string  `json:"position,omitempty"`
	PositionNEQ          *string  `json:"positionNEQ,omitempty"`
	PositionIn           []string `json:"positionIn,omitempty"`
	PositionNotIn        []string `json:"positionNotIn,omitempty"`
	PositionGT           *string  `json:"positionGT,omitempty"`
	PositionGTE          *string  `json:"positionGTE,omitempty"`
	PositionLT           *string  `json:"positionLT,omitempty"`
	PositionLTE          *string  `json:"positionLTE,omitempty"`
	PositionContains     *string  `json:"positionContains,omitempty"`
	PositionHasPrefix    *string  `json:"positionHasPrefix,omitempty"`
	PositionHasSuffix    *string  `json:"positionHasSuffix,omitempty"`
	PositionIsNil        bool     `json:"positionIsNil,omitempty"`
	PositionNotNil       bool     `json:"positionNotNil,omitempty"`
	PositionEqualFold    *string  `json:"positionEqualFold,omitempty"`
	PositionContainsFold *string  `json:"positionContainsFold,omitempty"`

	// "email" field predicates.
	Email             *string  `json:"email,omitempty"`
	EmailNEQ          *string  `json:"emailNEQ,omitempty"`
	EmailIn           []string `json:"emailIn,omitempty"`
	EmailNotIn        []string `json:"emailNotIn,omitempty"`
	EmailGT           *string  `json:"emailGT,omitempty"`
	EmailGTE          *string  `json:"emailGTE,omitempty"`
	EmailLT           *string  `json:"emailLT,omitempty"`
	EmailLTE          *string  `json:"emailLTE,omitempty"`
	EmailContains     *string  `json:"emailContains,omitempty"`
	EmailHasPrefix    *string  `json:"emailHasPrefix,omitempty"`
	EmailHasSuffix    *string  `json:"emailHasSuffix,omitempty"`
	EmailIsNil        bool     `json:"emailIsNil,omitempty"`
	EmailNotNil       bool     `json:"emailNotNil,omitempty"`
	EmailEqualFold    *string  `json:"emailEqualFold,omitempty"`
	EmailContainsFold *string  `json:"emailContainsFold,omitempty"`

	// "phone" field predicates.
	Phone             *string  `json:"phone,omitempty"`
	PhoneNEQ          *string  `json:"phoneNEQ,omitempty"`
	PhoneIn           []string `json:"phoneIn,omitempty"`
	PhoneNotIn        []string `json:"phoneNotIn,omitempty"`
	PhoneGT           *string  `json:"phoneGT,omitempty"`
	PhoneGTE          *string  `json:"phoneGTE,omitempty"`
	PhoneLT           *string  `json:"phoneLT,omitempty"`
	PhoneLTE          *string  `json:"phoneLTE,omitempty"`
	PhoneContains     *string  `json:"phoneContains,omitempty"`
	PhoneHasPrefix    *string  `json:"phoneHasPrefix,omitempty"`
	PhoneHasSuffix    *string  `json:"phoneHasSuffix,omitempty"`
	PhoneEqualFold    *string  `json:"phoneEqualFold,omitempty"`
	PhoneContainsFold *string  `json:"phoneContainsFold,omitempty"`

	// "company" edge predicates.
	HasCompany     *bool                `json:"hasCompany,omitempty"`
	HasCompanyWith []*CompanyWhereInput `json:"hasCompanyWith,omitempty"`

	// "user" edge predicates.
	HasUser     *bool             `json:"hasUser,omitempty"`
	HasUserWith []*UserWhereInput `json:"hasUserWith,omitempty"`

	// "subordinates" edge predicates.
	HasSubordinates     *bool                 `json:"hasSubordinates,omitempty"`
	HasSubordinatesWith []*EmployeeWhereInput `json:"hasSubordinatesWith,omitempty"`

	// "leader" edge predicates.
	HasLeader     *bool                 `json:"hasLeader,omitempty"`
	HasLeaderWith []*EmployeeWhereInput `json:"hasLeaderWith,omitempty"`

	// "workShifts" edge predicates.
	HasWorkShifts     *bool                  `json:"hasWorkShifts,omitempty"`
	HasWorkShiftsWith []*WorkshiftWhereInput `json:"hasWorkShiftsWith,omitempty"`

	// "approvedWorkShifts" edge predicates.
	HasApprovedWorkShifts     *bool                  `json:"hasApprovedWorkShifts,omitempty"`
	HasApprovedWorkShiftsWith []*WorkshiftWhereInput `json:"hasApprovedWorkShiftsWith,omitempty"`

	// "assignedTasks" edge predicates.
	HasAssignedTasks     *bool                 `json:"hasAssignedTasks,omitempty"`
	HasAssignedTasksWith []*WorktaskWhereInput `json:"hasAssignedTasksWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *EmployeeWhereInput) AddPredicates(predicates ...predicate.Employee) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the EmployeeWhereInput filter on the EmployeeQuery builder.
func (i *EmployeeWhereInput) Filter(q *EmployeeQuery) (*EmployeeQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyEmployeeWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyEmployeeWhereInput is returned in case the EmployeeWhereInput is empty.
var ErrEmptyEmployeeWhereInput = errors.New("generated: empty predicate EmployeeWhereInput")

// P returns a predicate for filtering employees.
// An error is returned if the input is empty or invalid.
func (i *EmployeeWhereInput) P() (predicate.Employee, error) {
	var predicates []predicate.Employee
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, employee.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Employee, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, employee.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Employee, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, employee.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, employee.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, employee.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, employee.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, employee.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, employee.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, employee.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, employee.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, employee.IDLTE(*i.IDLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, employee.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, employee.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, employee.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, employee.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, employee.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, employee.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, employee.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, employee.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, employee.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, employee.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, employee.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, employee.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, employee.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, employee.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, employee.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, employee.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.DeletedAt != nil {
		predicates = append(predicates, employee.DeletedAtEQ(*i.DeletedAt))
	}
	if i.DeletedAtNEQ != nil {
		predicates = append(predicates, employee.DeletedAtNEQ(*i.DeletedAtNEQ))
	}
	if len(i.DeletedAtIn) > 0 {
		predicates = append(predicates, employee.DeletedAtIn(i.DeletedAtIn...))
	}
	if len(i.DeletedAtNotIn) > 0 {
		predicates = append(predicates, employee.DeletedAtNotIn(i.DeletedAtNotIn...))
	}
	if i.DeletedAtGT != nil {
		predicates = append(predicates, employee.DeletedAtGT(*i.DeletedAtGT))
	}
	if i.DeletedAtGTE != nil {
		predicates = append(predicates, employee.DeletedAtGTE(*i.DeletedAtGTE))
	}
	if i.DeletedAtLT != nil {
		predicates = append(predicates, employee.DeletedAtLT(*i.DeletedAtLT))
	}
	if i.DeletedAtLTE != nil {
		predicates = append(predicates, employee.DeletedAtLTE(*i.DeletedAtLTE))
	}
	if i.DeletedAtIsNil {
		predicates = append(predicates, employee.DeletedAtIsNil())
	}
	if i.DeletedAtNotNil {
		predicates = append(predicates, employee.DeletedAtNotNil())
	}
	if i.Name != nil {
		predicates = append(predicates, employee.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, employee.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, employee.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, employee.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, employee.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, employee.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, employee.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, employee.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, employee.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, employee.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, employee.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, employee.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, employee.NameContainsFold(*i.NameContainsFold))
	}
	if i.Gender != nil {
		predicates = append(predicates, employee.GenderEQ(*i.Gender))
	}
	if i.GenderNEQ != nil {
		predicates = append(predicates, employee.GenderNEQ(*i.GenderNEQ))
	}
	if len(i.GenderIn) > 0 {
		predicates = append(predicates, employee.GenderIn(i.GenderIn...))
	}
	if len(i.GenderNotIn) > 0 {
		predicates = append(predicates, employee.GenderNotIn(i.GenderNotIn...))
	}
	if i.Position != nil {
		predicates = append(predicates, employee.PositionEQ(*i.Position))
	}
	if i.PositionNEQ != nil {
		predicates = append(predicates, employee.PositionNEQ(*i.PositionNEQ))
	}
	if len(i.PositionIn) > 0 {
		predicates = append(predicates, employee.PositionIn(i.PositionIn...))
	}
	if len(i.PositionNotIn) > 0 {
		predicates = append(predicates, employee.PositionNotIn(i.PositionNotIn...))
	}
	if i.PositionGT != nil {
		predicates = append(predicates, employee.PositionGT(*i.PositionGT))
	}
	if i.PositionGTE != nil {
		predicates = append(predicates, employee.PositionGTE(*i.PositionGTE))
	}
	if i.PositionLT != nil {
		predicates = append(predicates, employee.PositionLT(*i.PositionLT))
	}
	if i.PositionLTE != nil {
		predicates = append(predicates, employee.PositionLTE(*i.PositionLTE))
	}
	if i.PositionContains != nil {
		predicates = append(predicates, employee.PositionContains(*i.PositionContains))
	}
	if i.PositionHasPrefix != nil {
		predicates = append(predicates, employee.PositionHasPrefix(*i.PositionHasPrefix))
	}
	if i.PositionHasSuffix != nil {
		predicates = append(predicates, employee.PositionHasSuffix(*i.PositionHasSuffix))
	}
	if i.PositionIsNil {
		predicates = append(predicates, employee.PositionIsNil())
	}
	if i.PositionNotNil {
		predicates = append(predicates, employee.PositionNotNil())
	}
	if i.PositionEqualFold != nil {
		predicates = append(predicates, employee.PositionEqualFold(*i.PositionEqualFold))
	}
	if i.PositionContainsFold != nil {
		predicates = append(predicates, employee.PositionContainsFold(*i.PositionContainsFold))
	}
	if i.Email != nil {
		predicates = append(predicates, employee.EmailEQ(*i.Email))
	}
	if i.EmailNEQ != nil {
		predicates = append(predicates, employee.EmailNEQ(*i.EmailNEQ))
	}
	if len(i.EmailIn) > 0 {
		predicates = append(predicates, employee.EmailIn(i.EmailIn...))
	}
	if len(i.EmailNotIn) > 0 {
		predicates = append(predicates, employee.EmailNotIn(i.EmailNotIn...))
	}
	if i.EmailGT != nil {
		predicates = append(predicates, employee.EmailGT(*i.EmailGT))
	}
	if i.EmailGTE != nil {
		predicates = append(predicates, employee.EmailGTE(*i.EmailGTE))
	}
	if i.EmailLT != nil {
		predicates = append(predicates, employee.EmailLT(*i.EmailLT))
	}
	if i.EmailLTE != nil {
		predicates = append(predicates, employee.EmailLTE(*i.EmailLTE))
	}
	if i.EmailContains != nil {
		predicates = append(predicates, employee.EmailContains(*i.EmailContains))
	}
	if i.EmailHasPrefix != nil {
		predicates = append(predicates, employee.EmailHasPrefix(*i.EmailHasPrefix))
	}
	if i.EmailHasSuffix != nil {
		predicates = append(predicates, employee.EmailHasSuffix(*i.EmailHasSuffix))
	}
	if i.EmailIsNil {
		predicates = append(predicates, employee.EmailIsNil())
	}
	if i.EmailNotNil {
		predicates = append(predicates, employee.EmailNotNil())
	}
	if i.EmailEqualFold != nil {
		predicates = append(predicates, employee.EmailEqualFold(*i.EmailEqualFold))
	}
	if i.EmailContainsFold != nil {
		predicates = append(predicates, employee.EmailContainsFold(*i.EmailContainsFold))
	}
	if i.Phone != nil {
		predicates = append(predicates, employee.PhoneEQ(*i.Phone))
	}
	if i.PhoneNEQ != nil {
		predicates = append(predicates, employee.PhoneNEQ(*i.PhoneNEQ))
	}
	if len(i.PhoneIn) > 0 {
		predicates = append(predicates, employee.PhoneIn(i.PhoneIn...))
	}
	if len(i.PhoneNotIn) > 0 {
		predicates = append(predicates, employee.PhoneNotIn(i.PhoneNotIn...))
	}
	if i.PhoneGT != nil {
		predicates = append(predicates, employee.PhoneGT(*i.PhoneGT))
	}
	if i.PhoneGTE != nil {
		predicates = append(predicates, employee.PhoneGTE(*i.PhoneGTE))
	}
	if i.PhoneLT != nil {
		predicates = append(predicates, employee.PhoneLT(*i.PhoneLT))
	}
	if i.PhoneLTE != nil {
		predicates = append(predicates, employee.PhoneLTE(*i.PhoneLTE))
	}
	if i.PhoneContains != nil {
		predicates = append(predicates, employee.PhoneContains(*i.PhoneContains))
	}
	if i.PhoneHasPrefix != nil {
		predicates = append(predicates, employee.PhoneHasPrefix(*i.PhoneHasPrefix))
	}
	if i.PhoneHasSuffix != nil {
		predicates = append(predicates, employee.PhoneHasSuffix(*i.PhoneHasSuffix))
	}
	if i.PhoneEqualFold != nil {
		predicates = append(predicates, employee.PhoneEqualFold(*i.PhoneEqualFold))
	}
	if i.PhoneContainsFold != nil {
		predicates = append(predicates, employee.PhoneContainsFold(*i.PhoneContainsFold))
	}

	if i.HasCompany != nil {
		p := employee.HasCompany()
		if !*i.HasCompany {
			p = employee.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasCompanyWith) > 0 {
		with := make([]predicate.Company, 0, len(i.HasCompanyWith))
		for _, w := range i.HasCompanyWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasCompanyWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, employee.HasCompanyWith(with...))
	}
	if i.HasUser != nil {
		p := employee.HasUser()
		if !*i.HasUser {
			p = employee.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasUserWith) > 0 {
		with := make([]predicate.User, 0, len(i.HasUserWith))
		for _, w := range i.HasUserWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasUserWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, employee.HasUserWith(with...))
	}
	if i.HasSubordinates != nil {
		p := employee.HasSubordinates()
		if !*i.HasSubordinates {
			p = employee.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasSubordinatesWith) > 0 {
		with := make([]predicate.Employee, 0, len(i.HasSubordinatesWith))
		for _, w := range i.HasSubordinatesWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasSubordinatesWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, employee.HasSubordinatesWith(with...))
	}
	if i.HasLeader != nil {
		p := employee.HasLeader()
		if !*i.HasLeader {
			p = employee.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasLeaderWith) > 0 {
		with := make([]predicate.Employee, 0, len(i.HasLeaderWith))
		for _, w := range i.HasLeaderWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasLeaderWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, employee.HasLeaderWith(with...))
	}
	if i.HasWorkShifts != nil {
		p := employee.HasWorkShifts()
		if !*i.HasWorkShifts {
			p = employee.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasWorkShiftsWith) > 0 {
		with := make([]predicate.Workshift, 0, len(i.HasWorkShiftsWith))
		for _, w := range i.HasWorkShiftsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasWorkShiftsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, employee.HasWorkShiftsWith(with...))
	}
	if i.HasApprovedWorkShifts != nil {
		p := employee.HasApprovedWorkShifts()
		if !*i.HasApprovedWorkShifts {
			p = employee.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasApprovedWorkShiftsWith) > 0 {
		with := make([]predicate.Workshift, 0, len(i.HasApprovedWorkShiftsWith))
		for _, w := range i.HasApprovedWorkShiftsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasApprovedWorkShiftsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, employee.HasApprovedWorkShiftsWith(with...))
	}
	if i.HasAssignedTasks != nil {
		p := employee.HasAssignedTasks()
		if !*i.HasAssignedTasks {
			p = employee.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasAssignedTasksWith) > 0 {
		with := make([]predicate.Worktask, 0, len(i.HasAssignedTasksWith))
		for _, w := range i.HasAssignedTasksWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasAssignedTasksWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, employee.HasAssignedTasksWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyEmployeeWhereInput
	case 1:
		return predicates[0], nil
	default:
		return employee.And(predicates...), nil
	}
}

// FileWhereInput represents a where input for filtering File queries.
type FileWhereInput struct {
	Predicates []predicate.File  `json:"-"`
	Not        *FileWhereInput   `json:"not,omitempty"`
	Or         []*FileWhereInput `json:"or,omitempty"`
	And        []*FileWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "createdAt" field predicates.
	CreatedAt      *time.Time  `json:"createdat,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdatNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdatIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdatNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdatGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdatGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdatLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdatLTE,omitempty"`

	// "updatedAt" field predicates.
	UpdatedAt      *time.Time  `json:"updatedat,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedatNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedatIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedatNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedatGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedatGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedatLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedatLTE,omitempty"`

	// "deletedAt" field predicates.
	DeletedAt       *time.Time  `json:"deletedat,omitempty"`
	DeletedAtNEQ    *time.Time  `json:"deletedatNEQ,omitempty"`
	DeletedAtIn     []time.Time `json:"deletedatIn,omitempty"`
	DeletedAtNotIn  []time.Time `json:"deletedatNotIn,omitempty"`
	DeletedAtGT     *time.Time  `json:"deletedatGT,omitempty"`
	DeletedAtGTE    *time.Time  `json:"deletedatGTE,omitempty"`
	DeletedAtLT     *time.Time  `json:"deletedatLT,omitempty"`
	DeletedAtLTE    *time.Time  `json:"deletedatLTE,omitempty"`
	DeletedAtIsNil  bool        `json:"deletedatIsNil,omitempty"`
	DeletedAtNotNil bool        `json:"deletedatNotNil,omitempty"`

	// "category" field predicates.
	Category      *file.Category  `json:"category,omitempty"`
	CategoryNEQ   *file.Category  `json:"categoryNEQ,omitempty"`
	CategoryIn    []file.Category `json:"categoryIn,omitempty"`
	CategoryNotIn []file.Category `json:"categoryNotIn,omitempty"`

	// "extension" field predicates.
	Extension             *string  `json:"extension,omitempty"`
	ExtensionNEQ          *string  `json:"extensionNEQ,omitempty"`
	ExtensionIn           []string `json:"extensionIn,omitempty"`
	ExtensionNotIn        []string `json:"extensionNotIn,omitempty"`
	ExtensionGT           *string  `json:"extensionGT,omitempty"`
	ExtensionGTE          *string  `json:"extensionGTE,omitempty"`
	ExtensionLT           *string  `json:"extensionLT,omitempty"`
	ExtensionLTE          *string  `json:"extensionLTE,omitempty"`
	ExtensionContains     *string  `json:"extensionContains,omitempty"`
	ExtensionHasPrefix    *string  `json:"extensionHasPrefix,omitempty"`
	ExtensionHasSuffix    *string  `json:"extensionHasSuffix,omitempty"`
	ExtensionEqualFold    *string  `json:"extensionEqualFold,omitempty"`
	ExtensionContainsFold *string  `json:"extensionContainsFold,omitempty"`

	// "size" field predicates.
	Size             *string  `json:"size,omitempty"`
	SizeNEQ          *string  `json:"sizeNEQ,omitempty"`
	SizeIn           []string `json:"sizeIn,omitempty"`
	SizeNotIn        []string `json:"sizeNotIn,omitempty"`
	SizeGT           *string  `json:"sizeGT,omitempty"`
	SizeGTE          *string  `json:"sizeGTE,omitempty"`
	SizeLT           *string  `json:"sizeLT,omitempty"`
	SizeLTE          *string  `json:"sizeLTE,omitempty"`
	SizeContains     *string  `json:"sizeContains,omitempty"`
	SizeHasPrefix    *string  `json:"sizeHasPrefix,omitempty"`
	SizeHasSuffix    *string  `json:"sizeHasSuffix,omitempty"`
	SizeEqualFold    *string  `json:"sizeEqualFold,omitempty"`
	SizeContainsFold *string  `json:"sizeContainsFold,omitempty"`

	// "url" field predicates.
	URL             *string  `json:"url,omitempty"`
	URLNEQ          *string  `json:"urlNEQ,omitempty"`
	URLIn           []string `json:"urlIn,omitempty"`
	URLNotIn        []string `json:"urlNotIn,omitempty"`
	URLGT           *string  `json:"urlGT,omitempty"`
	URLGTE          *string  `json:"urlGTE,omitempty"`
	URLLT           *string  `json:"urlLT,omitempty"`
	URLLTE          *string  `json:"urlLTE,omitempty"`
	URLContains     *string  `json:"urlContains,omitempty"`
	URLHasPrefix    *string  `json:"urlHasPrefix,omitempty"`
	URLHasSuffix    *string  `json:"urlHasSuffix,omitempty"`
	URLEqualFold    *string  `json:"urlEqualFold,omitempty"`
	URLContainsFold *string  `json:"urlContainsFold,omitempty"`

	// "description" field predicates.
	Description             *string  `json:"description,omitempty"`
	DescriptionNEQ          *string  `json:"descriptionNEQ,omitempty"`
	DescriptionIn           []string `json:"descriptionIn,omitempty"`
	DescriptionNotIn        []string `json:"descriptionNotIn,omitempty"`
	DescriptionGT           *string  `json:"descriptionGT,omitempty"`
	DescriptionGTE          *string  `json:"descriptionGTE,omitempty"`
	DescriptionLT           *string  `json:"descriptionLT,omitempty"`
	DescriptionLTE          *string  `json:"descriptionLTE,omitempty"`
	DescriptionContains     *string  `json:"descriptionContains,omitempty"`
	DescriptionHasPrefix    *string  `json:"descriptionHasPrefix,omitempty"`
	DescriptionHasSuffix    *string  `json:"descriptionHasSuffix,omitempty"`
	DescriptionEqualFold    *string  `json:"descriptionEqualFold,omitempty"`
	DescriptionContainsFold *string  `json:"descriptionContainsFold,omitempty"`

	// "company" edge predicates.
	HasCompany     *bool                `json:"hasCompany,omitempty"`
	HasCompanyWith []*CompanyWhereInput `json:"hasCompanyWith,omitempty"`

	// "product" edge predicates.
	HasProduct     *bool                `json:"hasProduct,omitempty"`
	HasProductWith []*ProductWhereInput `json:"hasProductWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *FileWhereInput) AddPredicates(predicates ...predicate.File) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the FileWhereInput filter on the FileQuery builder.
func (i *FileWhereInput) Filter(q *FileQuery) (*FileQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyFileWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyFileWhereInput is returned in case the FileWhereInput is empty.
var ErrEmptyFileWhereInput = errors.New("generated: empty predicate FileWhereInput")

// P returns a predicate for filtering files.
// An error is returned if the input is empty or invalid.
func (i *FileWhereInput) P() (predicate.File, error) {
	var predicates []predicate.File
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, file.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.File, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, file.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.File, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, file.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, file.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, file.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, file.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, file.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, file.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, file.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, file.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, file.IDLTE(*i.IDLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, file.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, file.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, file.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, file.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, file.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, file.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, file.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, file.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, file.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, file.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, file.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, file.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, file.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, file.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, file.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, file.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.DeletedAt != nil {
		predicates = append(predicates, file.DeletedAtEQ(*i.DeletedAt))
	}
	if i.DeletedAtNEQ != nil {
		predicates = append(predicates, file.DeletedAtNEQ(*i.DeletedAtNEQ))
	}
	if len(i.DeletedAtIn) > 0 {
		predicates = append(predicates, file.DeletedAtIn(i.DeletedAtIn...))
	}
	if len(i.DeletedAtNotIn) > 0 {
		predicates = append(predicates, file.DeletedAtNotIn(i.DeletedAtNotIn...))
	}
	if i.DeletedAtGT != nil {
		predicates = append(predicates, file.DeletedAtGT(*i.DeletedAtGT))
	}
	if i.DeletedAtGTE != nil {
		predicates = append(predicates, file.DeletedAtGTE(*i.DeletedAtGTE))
	}
	if i.DeletedAtLT != nil {
		predicates = append(predicates, file.DeletedAtLT(*i.DeletedAtLT))
	}
	if i.DeletedAtLTE != nil {
		predicates = append(predicates, file.DeletedAtLTE(*i.DeletedAtLTE))
	}
	if i.DeletedAtIsNil {
		predicates = append(predicates, file.DeletedAtIsNil())
	}
	if i.DeletedAtNotNil {
		predicates = append(predicates, file.DeletedAtNotNil())
	}
	if i.Category != nil {
		predicates = append(predicates, file.CategoryEQ(*i.Category))
	}
	if i.CategoryNEQ != nil {
		predicates = append(predicates, file.CategoryNEQ(*i.CategoryNEQ))
	}
	if len(i.CategoryIn) > 0 {
		predicates = append(predicates, file.CategoryIn(i.CategoryIn...))
	}
	if len(i.CategoryNotIn) > 0 {
		predicates = append(predicates, file.CategoryNotIn(i.CategoryNotIn...))
	}
	if i.Extension != nil {
		predicates = append(predicates, file.ExtensionEQ(*i.Extension))
	}
	if i.ExtensionNEQ != nil {
		predicates = append(predicates, file.ExtensionNEQ(*i.ExtensionNEQ))
	}
	if len(i.ExtensionIn) > 0 {
		predicates = append(predicates, file.ExtensionIn(i.ExtensionIn...))
	}
	if len(i.ExtensionNotIn) > 0 {
		predicates = append(predicates, file.ExtensionNotIn(i.ExtensionNotIn...))
	}
	if i.ExtensionGT != nil {
		predicates = append(predicates, file.ExtensionGT(*i.ExtensionGT))
	}
	if i.ExtensionGTE != nil {
		predicates = append(predicates, file.ExtensionGTE(*i.ExtensionGTE))
	}
	if i.ExtensionLT != nil {
		predicates = append(predicates, file.ExtensionLT(*i.ExtensionLT))
	}
	if i.ExtensionLTE != nil {
		predicates = append(predicates, file.ExtensionLTE(*i.ExtensionLTE))
	}
	if i.ExtensionContains != nil {
		predicates = append(predicates, file.ExtensionContains(*i.ExtensionContains))
	}
	if i.ExtensionHasPrefix != nil {
		predicates = append(predicates, file.ExtensionHasPrefix(*i.ExtensionHasPrefix))
	}
	if i.ExtensionHasSuffix != nil {
		predicates = append(predicates, file.ExtensionHasSuffix(*i.ExtensionHasSuffix))
	}
	if i.ExtensionEqualFold != nil {
		predicates = append(predicates, file.ExtensionEqualFold(*i.ExtensionEqualFold))
	}
	if i.ExtensionContainsFold != nil {
		predicates = append(predicates, file.ExtensionContainsFold(*i.ExtensionContainsFold))
	}
	if i.Size != nil {
		predicates = append(predicates, file.SizeEQ(*i.Size))
	}
	if i.SizeNEQ != nil {
		predicates = append(predicates, file.SizeNEQ(*i.SizeNEQ))
	}
	if len(i.SizeIn) > 0 {
		predicates = append(predicates, file.SizeIn(i.SizeIn...))
	}
	if len(i.SizeNotIn) > 0 {
		predicates = append(predicates, file.SizeNotIn(i.SizeNotIn...))
	}
	if i.SizeGT != nil {
		predicates = append(predicates, file.SizeGT(*i.SizeGT))
	}
	if i.SizeGTE != nil {
		predicates = append(predicates, file.SizeGTE(*i.SizeGTE))
	}
	if i.SizeLT != nil {
		predicates = append(predicates, file.SizeLT(*i.SizeLT))
	}
	if i.SizeLTE != nil {
		predicates = append(predicates, file.SizeLTE(*i.SizeLTE))
	}
	if i.SizeContains != nil {
		predicates = append(predicates, file.SizeContains(*i.SizeContains))
	}
	if i.SizeHasPrefix != nil {
		predicates = append(predicates, file.SizeHasPrefix(*i.SizeHasPrefix))
	}
	if i.SizeHasSuffix != nil {
		predicates = append(predicates, file.SizeHasSuffix(*i.SizeHasSuffix))
	}
	if i.SizeEqualFold != nil {
		predicates = append(predicates, file.SizeEqualFold(*i.SizeEqualFold))
	}
	if i.SizeContainsFold != nil {
		predicates = append(predicates, file.SizeContainsFold(*i.SizeContainsFold))
	}
	if i.URL != nil {
		predicates = append(predicates, file.URLEQ(*i.URL))
	}
	if i.URLNEQ != nil {
		predicates = append(predicates, file.URLNEQ(*i.URLNEQ))
	}
	if len(i.URLIn) > 0 {
		predicates = append(predicates, file.URLIn(i.URLIn...))
	}
	if len(i.URLNotIn) > 0 {
		predicates = append(predicates, file.URLNotIn(i.URLNotIn...))
	}
	if i.URLGT != nil {
		predicates = append(predicates, file.URLGT(*i.URLGT))
	}
	if i.URLGTE != nil {
		predicates = append(predicates, file.URLGTE(*i.URLGTE))
	}
	if i.URLLT != nil {
		predicates = append(predicates, file.URLLT(*i.URLLT))
	}
	if i.URLLTE != nil {
		predicates = append(predicates, file.URLLTE(*i.URLLTE))
	}
	if i.URLContains != nil {
		predicates = append(predicates, file.URLContains(*i.URLContains))
	}
	if i.URLHasPrefix != nil {
		predicates = append(predicates, file.URLHasPrefix(*i.URLHasPrefix))
	}
	if i.URLHasSuffix != nil {
		predicates = append(predicates, file.URLHasSuffix(*i.URLHasSuffix))
	}
	if i.URLEqualFold != nil {
		predicates = append(predicates, file.URLEqualFold(*i.URLEqualFold))
	}
	if i.URLContainsFold != nil {
		predicates = append(predicates, file.URLContainsFold(*i.URLContainsFold))
	}
	if i.Description != nil {
		predicates = append(predicates, file.DescriptionEQ(*i.Description))
	}
	if i.DescriptionNEQ != nil {
		predicates = append(predicates, file.DescriptionNEQ(*i.DescriptionNEQ))
	}
	if len(i.DescriptionIn) > 0 {
		predicates = append(predicates, file.DescriptionIn(i.DescriptionIn...))
	}
	if len(i.DescriptionNotIn) > 0 {
		predicates = append(predicates, file.DescriptionNotIn(i.DescriptionNotIn...))
	}
	if i.DescriptionGT != nil {
		predicates = append(predicates, file.DescriptionGT(*i.DescriptionGT))
	}
	if i.DescriptionGTE != nil {
		predicates = append(predicates, file.DescriptionGTE(*i.DescriptionGTE))
	}
	if i.DescriptionLT != nil {
		predicates = append(predicates, file.DescriptionLT(*i.DescriptionLT))
	}
	if i.DescriptionLTE != nil {
		predicates = append(predicates, file.DescriptionLTE(*i.DescriptionLTE))
	}
	if i.DescriptionContains != nil {
		predicates = append(predicates, file.DescriptionContains(*i.DescriptionContains))
	}
	if i.DescriptionHasPrefix != nil {
		predicates = append(predicates, file.DescriptionHasPrefix(*i.DescriptionHasPrefix))
	}
	if i.DescriptionHasSuffix != nil {
		predicates = append(predicates, file.DescriptionHasSuffix(*i.DescriptionHasSuffix))
	}
	if i.DescriptionEqualFold != nil {
		predicates = append(predicates, file.DescriptionEqualFold(*i.DescriptionEqualFold))
	}
	if i.DescriptionContainsFold != nil {
		predicates = append(predicates, file.DescriptionContainsFold(*i.DescriptionContainsFold))
	}

	if i.HasCompany != nil {
		p := file.HasCompany()
		if !*i.HasCompany {
			p = file.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasCompanyWith) > 0 {
		with := make([]predicate.Company, 0, len(i.HasCompanyWith))
		for _, w := range i.HasCompanyWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasCompanyWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, file.HasCompanyWith(with...))
	}
	if i.HasProduct != nil {
		p := file.HasProduct()
		if !*i.HasProduct {
			p = file.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasProductWith) > 0 {
		with := make([]predicate.Product, 0, len(i.HasProductWith))
		for _, w := range i.HasProductWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasProductWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, file.HasProductWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyFileWhereInput
	case 1:
		return predicates[0], nil
	default:
		return file.And(predicates...), nil
	}
}

// PayableWhereInput represents a where input for filtering Payable queries.
type PayableWhereInput struct {
	Predicates []predicate.Payable  `json:"-"`
	Not        *PayableWhereInput   `json:"not,omitempty"`
	Or         []*PayableWhereInput `json:"or,omitempty"`
	And        []*PayableWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "createdAt" field predicates.
	CreatedAt      *time.Time  `json:"createdat,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdatNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdatIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdatNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdatGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdatGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdatLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdatLTE,omitempty"`

	// "updatedAt" field predicates.
	UpdatedAt      *time.Time  `json:"updatedat,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedatNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedatIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedatNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedatGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedatGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedatLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedatLTE,omitempty"`

	// "deletedAt" field predicates.
	DeletedAt       *time.Time  `json:"deletedat,omitempty"`
	DeletedAtNEQ    *time.Time  `json:"deletedatNEQ,omitempty"`
	DeletedAtIn     []time.Time `json:"deletedatIn,omitempty"`
	DeletedAtNotIn  []time.Time `json:"deletedatNotIn,omitempty"`
	DeletedAtGT     *time.Time  `json:"deletedatGT,omitempty"`
	DeletedAtGTE    *time.Time  `json:"deletedatGTE,omitempty"`
	DeletedAtLT     *time.Time  `json:"deletedatLT,omitempty"`
	DeletedAtLTE    *time.Time  `json:"deletedatLTE,omitempty"`
	DeletedAtIsNil  bool        `json:"deletedatIsNil,omitempty"`
	DeletedAtNotNil bool        `json:"deletedatNotNil,omitempty"`

	// "entryGroup" field predicates.
	EntryGroup      *int  `json:"entrygroup,omitempty"`
	EntryGroupNEQ   *int  `json:"entrygroupNEQ,omitempty"`
	EntryGroupIn    []int `json:"entrygroupIn,omitempty"`
	EntryGroupNotIn []int `json:"entrygroupNotIn,omitempty"`
	EntryGroupGT    *int  `json:"entrygroupGT,omitempty"`
	EntryGroupGTE   *int  `json:"entrygroupGTE,omitempty"`
	EntryGroupLT    *int  `json:"entrygroupLT,omitempty"`
	EntryGroupLTE   *int  `json:"entrygroupLTE,omitempty"`

	// "date" field predicates.
	Date      *time.Time  `json:"date,omitempty"`
	DateNEQ   *time.Time  `json:"dateNEQ,omitempty"`
	DateIn    []time.Time `json:"dateIn,omitempty"`
	DateNotIn []time.Time `json:"dateNotIn,omitempty"`
	DateGT    *time.Time  `json:"dateGT,omitempty"`
	DateGTE   *time.Time  `json:"dateGTE,omitempty"`
	DateLT    *time.Time  `json:"dateLT,omitempty"`
	DateLTE   *time.Time  `json:"dateLTE,omitempty"`

	// "outstandingBalance" field predicates.
	OutstandingBalance      *float64  `json:"outstandingbalance,omitempty"`
	OutstandingBalanceNEQ   *float64  `json:"outstandingbalanceNEQ,omitempty"`
	OutstandingBalanceIn    []float64 `json:"outstandingbalanceIn,omitempty"`
	OutstandingBalanceNotIn []float64 `json:"outstandingbalanceNotIn,omitempty"`
	OutstandingBalanceGT    *float64  `json:"outstandingbalanceGT,omitempty"`
	OutstandingBalanceGTE   *float64  `json:"outstandingbalanceGTE,omitempty"`
	OutstandingBalanceLT    *float64  `json:"outstandingbalanceLT,omitempty"`
	OutstandingBalanceLTE   *float64  `json:"outstandingbalanceLTE,omitempty"`

	// "totalTransaction" field predicates.
	TotalTransaction      *float64  `json:"totaltransaction,omitempty"`
	TotalTransactionNEQ   *float64  `json:"totaltransactionNEQ,omitempty"`
	TotalTransactionIn    []float64 `json:"totaltransactionIn,omitempty"`
	TotalTransactionNotIn []float64 `json:"totaltransactionNotIn,omitempty"`
	TotalTransactionGT    *float64  `json:"totaltransactionGT,omitempty"`
	TotalTransactionGTE   *float64  `json:"totaltransactionGTE,omitempty"`
	TotalTransactionLT    *float64  `json:"totaltransactionLT,omitempty"`
	TotalTransactionLTE   *float64  `json:"totaltransactionLTE,omitempty"`

	// "daysDue" field predicates.
	DaysDue      *int  `json:"daysdue,omitempty"`
	DaysDueNEQ   *int  `json:"daysdueNEQ,omitempty"`
	DaysDueIn    []int `json:"daysdueIn,omitempty"`
	DaysDueNotIn []int `json:"daysdueNotIn,omitempty"`
	DaysDueGT    *int  `json:"daysdueGT,omitempty"`
	DaysDueGTE   *int  `json:"daysdueGTE,omitempty"`
	DaysDueLT    *int  `json:"daysdueLT,omitempty"`
	DaysDueLTE   *int  `json:"daysdueLTE,omitempty"`

	// "status" field predicates.
	Status      *payable.Status  `json:"status,omitempty"`
	StatusNEQ   *payable.Status  `json:"statusNEQ,omitempty"`
	StatusIn    []payable.Status `json:"statusIn,omitempty"`
	StatusNotIn []payable.Status `json:"statusNotIn,omitempty"`

	// "supplier" edge predicates.
	HasSupplier     *bool                 `json:"hasSupplier,omitempty"`
	HasSupplierWith []*SupplierWhereInput `json:"hasSupplierWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *PayableWhereInput) AddPredicates(predicates ...predicate.Payable) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the PayableWhereInput filter on the PayableQuery builder.
func (i *PayableWhereInput) Filter(q *PayableQuery) (*PayableQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyPayableWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyPayableWhereInput is returned in case the PayableWhereInput is empty.
var ErrEmptyPayableWhereInput = errors.New("generated: empty predicate PayableWhereInput")

// P returns a predicate for filtering payables.
// An error is returned if the input is empty or invalid.
func (i *PayableWhereInput) P() (predicate.Payable, error) {
	var predicates []predicate.Payable
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, payable.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Payable, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, payable.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Payable, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, payable.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, payable.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, payable.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, payable.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, payable.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, payable.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, payable.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, payable.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, payable.IDLTE(*i.IDLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, payable.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, payable.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, payable.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, payable.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, payable.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, payable.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, payable.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, payable.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, payable.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, payable.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, payable.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, payable.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, payable.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, payable.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, payable.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, payable.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.DeletedAt != nil {
		predicates = append(predicates, payable.DeletedAtEQ(*i.DeletedAt))
	}
	if i.DeletedAtNEQ != nil {
		predicates = append(predicates, payable.DeletedAtNEQ(*i.DeletedAtNEQ))
	}
	if len(i.DeletedAtIn) > 0 {
		predicates = append(predicates, payable.DeletedAtIn(i.DeletedAtIn...))
	}
	if len(i.DeletedAtNotIn) > 0 {
		predicates = append(predicates, payable.DeletedAtNotIn(i.DeletedAtNotIn...))
	}
	if i.DeletedAtGT != nil {
		predicates = append(predicates, payable.DeletedAtGT(*i.DeletedAtGT))
	}
	if i.DeletedAtGTE != nil {
		predicates = append(predicates, payable.DeletedAtGTE(*i.DeletedAtGTE))
	}
	if i.DeletedAtLT != nil {
		predicates = append(predicates, payable.DeletedAtLT(*i.DeletedAtLT))
	}
	if i.DeletedAtLTE != nil {
		predicates = append(predicates, payable.DeletedAtLTE(*i.DeletedAtLTE))
	}
	if i.DeletedAtIsNil {
		predicates = append(predicates, payable.DeletedAtIsNil())
	}
	if i.DeletedAtNotNil {
		predicates = append(predicates, payable.DeletedAtNotNil())
	}
	if i.EntryGroup != nil {
		predicates = append(predicates, payable.EntryGroupEQ(*i.EntryGroup))
	}
	if i.EntryGroupNEQ != nil {
		predicates = append(predicates, payable.EntryGroupNEQ(*i.EntryGroupNEQ))
	}
	if len(i.EntryGroupIn) > 0 {
		predicates = append(predicates, payable.EntryGroupIn(i.EntryGroupIn...))
	}
	if len(i.EntryGroupNotIn) > 0 {
		predicates = append(predicates, payable.EntryGroupNotIn(i.EntryGroupNotIn...))
	}
	if i.EntryGroupGT != nil {
		predicates = append(predicates, payable.EntryGroupGT(*i.EntryGroupGT))
	}
	if i.EntryGroupGTE != nil {
		predicates = append(predicates, payable.EntryGroupGTE(*i.EntryGroupGTE))
	}
	if i.EntryGroupLT != nil {
		predicates = append(predicates, payable.EntryGroupLT(*i.EntryGroupLT))
	}
	if i.EntryGroupLTE != nil {
		predicates = append(predicates, payable.EntryGroupLTE(*i.EntryGroupLTE))
	}
	if i.Date != nil {
		predicates = append(predicates, payable.DateEQ(*i.Date))
	}
	if i.DateNEQ != nil {
		predicates = append(predicates, payable.DateNEQ(*i.DateNEQ))
	}
	if len(i.DateIn) > 0 {
		predicates = append(predicates, payable.DateIn(i.DateIn...))
	}
	if len(i.DateNotIn) > 0 {
		predicates = append(predicates, payable.DateNotIn(i.DateNotIn...))
	}
	if i.DateGT != nil {
		predicates = append(predicates, payable.DateGT(*i.DateGT))
	}
	if i.DateGTE != nil {
		predicates = append(predicates, payable.DateGTE(*i.DateGTE))
	}
	if i.DateLT != nil {
		predicates = append(predicates, payable.DateLT(*i.DateLT))
	}
	if i.DateLTE != nil {
		predicates = append(predicates, payable.DateLTE(*i.DateLTE))
	}
	if i.OutstandingBalance != nil {
		predicates = append(predicates, payable.OutstandingBalanceEQ(*i.OutstandingBalance))
	}
	if i.OutstandingBalanceNEQ != nil {
		predicates = append(predicates, payable.OutstandingBalanceNEQ(*i.OutstandingBalanceNEQ))
	}
	if len(i.OutstandingBalanceIn) > 0 {
		predicates = append(predicates, payable.OutstandingBalanceIn(i.OutstandingBalanceIn...))
	}
	if len(i.OutstandingBalanceNotIn) > 0 {
		predicates = append(predicates, payable.OutstandingBalanceNotIn(i.OutstandingBalanceNotIn...))
	}
	if i.OutstandingBalanceGT != nil {
		predicates = append(predicates, payable.OutstandingBalanceGT(*i.OutstandingBalanceGT))
	}
	if i.OutstandingBalanceGTE != nil {
		predicates = append(predicates, payable.OutstandingBalanceGTE(*i.OutstandingBalanceGTE))
	}
	if i.OutstandingBalanceLT != nil {
		predicates = append(predicates, payable.OutstandingBalanceLT(*i.OutstandingBalanceLT))
	}
	if i.OutstandingBalanceLTE != nil {
		predicates = append(predicates, payable.OutstandingBalanceLTE(*i.OutstandingBalanceLTE))
	}
	if i.TotalTransaction != nil {
		predicates = append(predicates, payable.TotalTransactionEQ(*i.TotalTransaction))
	}
	if i.TotalTransactionNEQ != nil {
		predicates = append(predicates, payable.TotalTransactionNEQ(*i.TotalTransactionNEQ))
	}
	if len(i.TotalTransactionIn) > 0 {
		predicates = append(predicates, payable.TotalTransactionIn(i.TotalTransactionIn...))
	}
	if len(i.TotalTransactionNotIn) > 0 {
		predicates = append(predicates, payable.TotalTransactionNotIn(i.TotalTransactionNotIn...))
	}
	if i.TotalTransactionGT != nil {
		predicates = append(predicates, payable.TotalTransactionGT(*i.TotalTransactionGT))
	}
	if i.TotalTransactionGTE != nil {
		predicates = append(predicates, payable.TotalTransactionGTE(*i.TotalTransactionGTE))
	}
	if i.TotalTransactionLT != nil {
		predicates = append(predicates, payable.TotalTransactionLT(*i.TotalTransactionLT))
	}
	if i.TotalTransactionLTE != nil {
		predicates = append(predicates, payable.TotalTransactionLTE(*i.TotalTransactionLTE))
	}
	if i.DaysDue != nil {
		predicates = append(predicates, payable.DaysDueEQ(*i.DaysDue))
	}
	if i.DaysDueNEQ != nil {
		predicates = append(predicates, payable.DaysDueNEQ(*i.DaysDueNEQ))
	}
	if len(i.DaysDueIn) > 0 {
		predicates = append(predicates, payable.DaysDueIn(i.DaysDueIn...))
	}
	if len(i.DaysDueNotIn) > 0 {
		predicates = append(predicates, payable.DaysDueNotIn(i.DaysDueNotIn...))
	}
	if i.DaysDueGT != nil {
		predicates = append(predicates, payable.DaysDueGT(*i.DaysDueGT))
	}
	if i.DaysDueGTE != nil {
		predicates = append(predicates, payable.DaysDueGTE(*i.DaysDueGTE))
	}
	if i.DaysDueLT != nil {
		predicates = append(predicates, payable.DaysDueLT(*i.DaysDueLT))
	}
	if i.DaysDueLTE != nil {
		predicates = append(predicates, payable.DaysDueLTE(*i.DaysDueLTE))
	}
	if i.Status != nil {
		predicates = append(predicates, payable.StatusEQ(*i.Status))
	}
	if i.StatusNEQ != nil {
		predicates = append(predicates, payable.StatusNEQ(*i.StatusNEQ))
	}
	if len(i.StatusIn) > 0 {
		predicates = append(predicates, payable.StatusIn(i.StatusIn...))
	}
	if len(i.StatusNotIn) > 0 {
		predicates = append(predicates, payable.StatusNotIn(i.StatusNotIn...))
	}

	if i.HasSupplier != nil {
		p := payable.HasSupplier()
		if !*i.HasSupplier {
			p = payable.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasSupplierWith) > 0 {
		with := make([]predicate.Supplier, 0, len(i.HasSupplierWith))
		for _, w := range i.HasSupplierWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasSupplierWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, payable.HasSupplierWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyPayableWhereInput
	case 1:
		return predicates[0], nil
	default:
		return payable.And(predicates...), nil
	}
}

// ProductWhereInput represents a where input for filtering Product queries.
type ProductWhereInput struct {
	Predicates []predicate.Product  `json:"-"`
	Not        *ProductWhereInput   `json:"not,omitempty"`
	Or         []*ProductWhereInput `json:"or,omitempty"`
	And        []*ProductWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "createdAt" field predicates.
	CreatedAt      *time.Time  `json:"createdat,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdatNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdatIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdatNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdatGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdatGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdatLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdatLTE,omitempty"`

	// "updatedAt" field predicates.
	UpdatedAt      *time.Time  `json:"updatedat,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedatNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedatIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedatNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedatGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedatGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedatLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedatLTE,omitempty"`

	// "deletedAt" field predicates.
	DeletedAt       *time.Time  `json:"deletedat,omitempty"`
	DeletedAtNEQ    *time.Time  `json:"deletedatNEQ,omitempty"`
	DeletedAtIn     []time.Time `json:"deletedatIn,omitempty"`
	DeletedAtNotIn  []time.Time `json:"deletedatNotIn,omitempty"`
	DeletedAtGT     *time.Time  `json:"deletedatGT,omitempty"`
	DeletedAtGTE    *time.Time  `json:"deletedatGTE,omitempty"`
	DeletedAtLT     *time.Time  `json:"deletedatLT,omitempty"`
	DeletedAtLTE    *time.Time  `json:"deletedatLTE,omitempty"`
	DeletedAtIsNil  bool        `json:"deletedatIsNil,omitempty"`
	DeletedAtNotNil bool        `json:"deletedatNotNil,omitempty"`

	// "description" field predicates.
	Description             *string  `json:"description,omitempty"`
	DescriptionNEQ          *string  `json:"descriptionNEQ,omitempty"`
	DescriptionIn           []string `json:"descriptionIn,omitempty"`
	DescriptionNotIn        []string `json:"descriptionNotIn,omitempty"`
	DescriptionGT           *string  `json:"descriptionGT,omitempty"`
	DescriptionGTE          *string  `json:"descriptionGTE,omitempty"`
	DescriptionLT           *string  `json:"descriptionLT,omitempty"`
	DescriptionLTE          *string  `json:"descriptionLTE,omitempty"`
	DescriptionContains     *string  `json:"descriptionContains,omitempty"`
	DescriptionHasPrefix    *string  `json:"descriptionHasPrefix,omitempty"`
	DescriptionHasSuffix    *string  `json:"descriptionHasSuffix,omitempty"`
	DescriptionEqualFold    *string  `json:"descriptionEqualFold,omitempty"`
	DescriptionContainsFold *string  `json:"descriptionContainsFold,omitempty"`

	// "isDefault" field predicates.
	IsDefault    *bool `json:"isdefault,omitempty"`
	IsDefaultNEQ *bool `json:"isdefaultNEQ,omitempty"`

	// "minimumStock" field predicates.
	MinimumStock      *int  `json:"minimumstock,omitempty"`
	MinimumStockNEQ   *int  `json:"minimumstockNEQ,omitempty"`
	MinimumStockIn    []int `json:"minimumstockIn,omitempty"`
	MinimumStockNotIn []int `json:"minimumstockNotIn,omitempty"`
	MinimumStockGT    *int  `json:"minimumstockGT,omitempty"`
	MinimumStockGTE   *int  `json:"minimumstockGTE,omitempty"`
	MinimumStockLT    *int  `json:"minimumstockLT,omitempty"`
	MinimumStockLTE   *int  `json:"minimumstockLTE,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "price" field predicates.
	Price      *int  `json:"price,omitempty"`
	PriceNEQ   *int  `json:"priceNEQ,omitempty"`
	PriceIn    []int `json:"priceIn,omitempty"`
	PriceNotIn []int `json:"priceNotIn,omitempty"`
	PriceGT    *int  `json:"priceGT,omitempty"`
	PriceGTE   *int  `json:"priceGTE,omitempty"`
	PriceLT    *int  `json:"priceLT,omitempty"`
	PriceLTE   *int  `json:"priceLTE,omitempty"`

	// "sku" field predicates.
	Sku             *string  `json:"sku,omitempty"`
	SkuNEQ          *string  `json:"skuNEQ,omitempty"`
	SkuIn           []string `json:"skuIn,omitempty"`
	SkuNotIn        []string `json:"skuNotIn,omitempty"`
	SkuGT           *string  `json:"skuGT,omitempty"`
	SkuGTE          *string  `json:"skuGTE,omitempty"`
	SkuLT           *string  `json:"skuLT,omitempty"`
	SkuLTE          *string  `json:"skuLTE,omitempty"`
	SkuContains     *string  `json:"skuContains,omitempty"`
	SkuHasPrefix    *string  `json:"skuHasPrefix,omitempty"`
	SkuHasSuffix    *string  `json:"skuHasSuffix,omitempty"`
	SkuEqualFold    *string  `json:"skuEqualFold,omitempty"`
	SkuContainsFold *string  `json:"skuContainsFold,omitempty"`

	// "stock" field predicates.
	Stock      *float64  `json:"stock,omitempty"`
	StockNEQ   *float64  `json:"stockNEQ,omitempty"`
	StockIn    []float64 `json:"stockIn,omitempty"`
	StockNotIn []float64 `json:"stockNotIn,omitempty"`
	StockGT    *float64  `json:"stockGT,omitempty"`
	StockGTE   *float64  `json:"stockGTE,omitempty"`
	StockLT    *float64  `json:"stockLT,omitempty"`
	StockLTE   *float64  `json:"stockLTE,omitempty"`

	// "category" field predicates.
	Category      *product.Category  `json:"category,omitempty"`
	CategoryNEQ   *product.Category  `json:"categoryNEQ,omitempty"`
	CategoryIn    []product.Category `json:"categoryIn,omitempty"`
	CategoryNotIn []product.Category `json:"categoryNotIn,omitempty"`

	// "unitCost" field predicates.
	UnitCost      *float64  `json:"unitcost,omitempty"`
	UnitCostNEQ   *float64  `json:"unitcostNEQ,omitempty"`
	UnitCostIn    []float64 `json:"unitcostIn,omitempty"`
	UnitCostNotIn []float64 `json:"unitcostNotIn,omitempty"`
	UnitCostGT    *float64  `json:"unitcostGT,omitempty"`
	UnitCostGTE   *float64  `json:"unitcostGTE,omitempty"`
	UnitCostLT    *float64  `json:"unitcostLT,omitempty"`
	UnitCostLTE   *float64  `json:"unitcostLTE,omitempty"`

	// "company" edge predicates.
	HasCompany     *bool                `json:"hasCompany,omitempty"`
	HasCompanyWith []*CompanyWhereInput `json:"hasCompanyWith,omitempty"`

	// "pictures" edge predicates.
	HasPictures     *bool             `json:"hasPictures,omitempty"`
	HasPicturesWith []*FileWhereInput `json:"hasPicturesWith,omitempty"`

	// "productMovements" edge predicates.
	HasProductMovements     *bool                        `json:"hasProductMovements,omitempty"`
	HasProductMovementsWith []*ProductMovementWhereInput `json:"hasProductMovementsWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *ProductWhereInput) AddPredicates(predicates ...predicate.Product) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the ProductWhereInput filter on the ProductQuery builder.
func (i *ProductWhereInput) Filter(q *ProductQuery) (*ProductQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyProductWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyProductWhereInput is returned in case the ProductWhereInput is empty.
var ErrEmptyProductWhereInput = errors.New("generated: empty predicate ProductWhereInput")

// P returns a predicate for filtering products.
// An error is returned if the input is empty or invalid.
func (i *ProductWhereInput) P() (predicate.Product, error) {
	var predicates []predicate.Product
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, product.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Product, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, product.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Product, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, product.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, product.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, product.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, product.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, product.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, product.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, product.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, product.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, product.IDLTE(*i.IDLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, product.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, product.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, product.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, product.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, product.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, product.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, product.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, product.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, product.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, product.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, product.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, product.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, product.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, product.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, product.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, product.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.DeletedAt != nil {
		predicates = append(predicates, product.DeletedAtEQ(*i.DeletedAt))
	}
	if i.DeletedAtNEQ != nil {
		predicates = append(predicates, product.DeletedAtNEQ(*i.DeletedAtNEQ))
	}
	if len(i.DeletedAtIn) > 0 {
		predicates = append(predicates, product.DeletedAtIn(i.DeletedAtIn...))
	}
	if len(i.DeletedAtNotIn) > 0 {
		predicates = append(predicates, product.DeletedAtNotIn(i.DeletedAtNotIn...))
	}
	if i.DeletedAtGT != nil {
		predicates = append(predicates, product.DeletedAtGT(*i.DeletedAtGT))
	}
	if i.DeletedAtGTE != nil {
		predicates = append(predicates, product.DeletedAtGTE(*i.DeletedAtGTE))
	}
	if i.DeletedAtLT != nil {
		predicates = append(predicates, product.DeletedAtLT(*i.DeletedAtLT))
	}
	if i.DeletedAtLTE != nil {
		predicates = append(predicates, product.DeletedAtLTE(*i.DeletedAtLTE))
	}
	if i.DeletedAtIsNil {
		predicates = append(predicates, product.DeletedAtIsNil())
	}
	if i.DeletedAtNotNil {
		predicates = append(predicates, product.DeletedAtNotNil())
	}
	if i.Description != nil {
		predicates = append(predicates, product.DescriptionEQ(*i.Description))
	}
	if i.DescriptionNEQ != nil {
		predicates = append(predicates, product.DescriptionNEQ(*i.DescriptionNEQ))
	}
	if len(i.DescriptionIn) > 0 {
		predicates = append(predicates, product.DescriptionIn(i.DescriptionIn...))
	}
	if len(i.DescriptionNotIn) > 0 {
		predicates = append(predicates, product.DescriptionNotIn(i.DescriptionNotIn...))
	}
	if i.DescriptionGT != nil {
		predicates = append(predicates, product.DescriptionGT(*i.DescriptionGT))
	}
	if i.DescriptionGTE != nil {
		predicates = append(predicates, product.DescriptionGTE(*i.DescriptionGTE))
	}
	if i.DescriptionLT != nil {
		predicates = append(predicates, product.DescriptionLT(*i.DescriptionLT))
	}
	if i.DescriptionLTE != nil {
		predicates = append(predicates, product.DescriptionLTE(*i.DescriptionLTE))
	}
	if i.DescriptionContains != nil {
		predicates = append(predicates, product.DescriptionContains(*i.DescriptionContains))
	}
	if i.DescriptionHasPrefix != nil {
		predicates = append(predicates, product.DescriptionHasPrefix(*i.DescriptionHasPrefix))
	}
	if i.DescriptionHasSuffix != nil {
		predicates = append(predicates, product.DescriptionHasSuffix(*i.DescriptionHasSuffix))
	}
	if i.DescriptionEqualFold != nil {
		predicates = append(predicates, product.DescriptionEqualFold(*i.DescriptionEqualFold))
	}
	if i.DescriptionContainsFold != nil {
		predicates = append(predicates, product.DescriptionContainsFold(*i.DescriptionContainsFold))
	}
	if i.IsDefault != nil {
		predicates = append(predicates, product.IsDefaultEQ(*i.IsDefault))
	}
	if i.IsDefaultNEQ != nil {
		predicates = append(predicates, product.IsDefaultNEQ(*i.IsDefaultNEQ))
	}
	if i.MinimumStock != nil {
		predicates = append(predicates, product.MinimumStockEQ(*i.MinimumStock))
	}
	if i.MinimumStockNEQ != nil {
		predicates = append(predicates, product.MinimumStockNEQ(*i.MinimumStockNEQ))
	}
	if len(i.MinimumStockIn) > 0 {
		predicates = append(predicates, product.MinimumStockIn(i.MinimumStockIn...))
	}
	if len(i.MinimumStockNotIn) > 0 {
		predicates = append(predicates, product.MinimumStockNotIn(i.MinimumStockNotIn...))
	}
	if i.MinimumStockGT != nil {
		predicates = append(predicates, product.MinimumStockGT(*i.MinimumStockGT))
	}
	if i.MinimumStockGTE != nil {
		predicates = append(predicates, product.MinimumStockGTE(*i.MinimumStockGTE))
	}
	if i.MinimumStockLT != nil {
		predicates = append(predicates, product.MinimumStockLT(*i.MinimumStockLT))
	}
	if i.MinimumStockLTE != nil {
		predicates = append(predicates, product.MinimumStockLTE(*i.MinimumStockLTE))
	}
	if i.Name != nil {
		predicates = append(predicates, product.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, product.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, product.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, product.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, product.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, product.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, product.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, product.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, product.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, product.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, product.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, product.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, product.NameContainsFold(*i.NameContainsFold))
	}
	if i.Price != nil {
		predicates = append(predicates, product.PriceEQ(*i.Price))
	}
	if i.PriceNEQ != nil {
		predicates = append(predicates, product.PriceNEQ(*i.PriceNEQ))
	}
	if len(i.PriceIn) > 0 {
		predicates = append(predicates, product.PriceIn(i.PriceIn...))
	}
	if len(i.PriceNotIn) > 0 {
		predicates = append(predicates, product.PriceNotIn(i.PriceNotIn...))
	}
	if i.PriceGT != nil {
		predicates = append(predicates, product.PriceGT(*i.PriceGT))
	}
	if i.PriceGTE != nil {
		predicates = append(predicates, product.PriceGTE(*i.PriceGTE))
	}
	if i.PriceLT != nil {
		predicates = append(predicates, product.PriceLT(*i.PriceLT))
	}
	if i.PriceLTE != nil {
		predicates = append(predicates, product.PriceLTE(*i.PriceLTE))
	}
	if i.Sku != nil {
		predicates = append(predicates, product.SkuEQ(*i.Sku))
	}
	if i.SkuNEQ != nil {
		predicates = append(predicates, product.SkuNEQ(*i.SkuNEQ))
	}
	if len(i.SkuIn) > 0 {
		predicates = append(predicates, product.SkuIn(i.SkuIn...))
	}
	if len(i.SkuNotIn) > 0 {
		predicates = append(predicates, product.SkuNotIn(i.SkuNotIn...))
	}
	if i.SkuGT != nil {
		predicates = append(predicates, product.SkuGT(*i.SkuGT))
	}
	if i.SkuGTE != nil {
		predicates = append(predicates, product.SkuGTE(*i.SkuGTE))
	}
	if i.SkuLT != nil {
		predicates = append(predicates, product.SkuLT(*i.SkuLT))
	}
	if i.SkuLTE != nil {
		predicates = append(predicates, product.SkuLTE(*i.SkuLTE))
	}
	if i.SkuContains != nil {
		predicates = append(predicates, product.SkuContains(*i.SkuContains))
	}
	if i.SkuHasPrefix != nil {
		predicates = append(predicates, product.SkuHasPrefix(*i.SkuHasPrefix))
	}
	if i.SkuHasSuffix != nil {
		predicates = append(predicates, product.SkuHasSuffix(*i.SkuHasSuffix))
	}
	if i.SkuEqualFold != nil {
		predicates = append(predicates, product.SkuEqualFold(*i.SkuEqualFold))
	}
	if i.SkuContainsFold != nil {
		predicates = append(predicates, product.SkuContainsFold(*i.SkuContainsFold))
	}
	if i.Stock != nil {
		predicates = append(predicates, product.StockEQ(*i.Stock))
	}
	if i.StockNEQ != nil {
		predicates = append(predicates, product.StockNEQ(*i.StockNEQ))
	}
	if len(i.StockIn) > 0 {
		predicates = append(predicates, product.StockIn(i.StockIn...))
	}
	if len(i.StockNotIn) > 0 {
		predicates = append(predicates, product.StockNotIn(i.StockNotIn...))
	}
	if i.StockGT != nil {
		predicates = append(predicates, product.StockGT(*i.StockGT))
	}
	if i.StockGTE != nil {
		predicates = append(predicates, product.StockGTE(*i.StockGTE))
	}
	if i.StockLT != nil {
		predicates = append(predicates, product.StockLT(*i.StockLT))
	}
	if i.StockLTE != nil {
		predicates = append(predicates, product.StockLTE(*i.StockLTE))
	}
	if i.Category != nil {
		predicates = append(predicates, product.CategoryEQ(*i.Category))
	}
	if i.CategoryNEQ != nil {
		predicates = append(predicates, product.CategoryNEQ(*i.CategoryNEQ))
	}
	if len(i.CategoryIn) > 0 {
		predicates = append(predicates, product.CategoryIn(i.CategoryIn...))
	}
	if len(i.CategoryNotIn) > 0 {
		predicates = append(predicates, product.CategoryNotIn(i.CategoryNotIn...))
	}
	if i.UnitCost != nil {
		predicates = append(predicates, product.UnitCostEQ(*i.UnitCost))
	}
	if i.UnitCostNEQ != nil {
		predicates = append(predicates, product.UnitCostNEQ(*i.UnitCostNEQ))
	}
	if len(i.UnitCostIn) > 0 {
		predicates = append(predicates, product.UnitCostIn(i.UnitCostIn...))
	}
	if len(i.UnitCostNotIn) > 0 {
		predicates = append(predicates, product.UnitCostNotIn(i.UnitCostNotIn...))
	}
	if i.UnitCostGT != nil {
		predicates = append(predicates, product.UnitCostGT(*i.UnitCostGT))
	}
	if i.UnitCostGTE != nil {
		predicates = append(predicates, product.UnitCostGTE(*i.UnitCostGTE))
	}
	if i.UnitCostLT != nil {
		predicates = append(predicates, product.UnitCostLT(*i.UnitCostLT))
	}
	if i.UnitCostLTE != nil {
		predicates = append(predicates, product.UnitCostLTE(*i.UnitCostLTE))
	}

	if i.HasCompany != nil {
		p := product.HasCompany()
		if !*i.HasCompany {
			p = product.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasCompanyWith) > 0 {
		with := make([]predicate.Company, 0, len(i.HasCompanyWith))
		for _, w := range i.HasCompanyWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasCompanyWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, product.HasCompanyWith(with...))
	}
	if i.HasPictures != nil {
		p := product.HasPictures()
		if !*i.HasPictures {
			p = product.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasPicturesWith) > 0 {
		with := make([]predicate.File, 0, len(i.HasPicturesWith))
		for _, w := range i.HasPicturesWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasPicturesWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, product.HasPicturesWith(with...))
	}
	if i.HasProductMovements != nil {
		p := product.HasProductMovements()
		if !*i.HasProductMovements {
			p = product.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasProductMovementsWith) > 0 {
		with := make([]predicate.ProductMovement, 0, len(i.HasProductMovementsWith))
		for _, w := range i.HasProductMovementsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasProductMovementsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, product.HasProductMovementsWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyProductWhereInput
	case 1:
		return predicates[0], nil
	default:
		return product.And(predicates...), nil
	}
}

// ProductMovementWhereInput represents a where input for filtering ProductMovement queries.
type ProductMovementWhereInput struct {
	Predicates []predicate.ProductMovement  `json:"-"`
	Not        *ProductMovementWhereInput   `json:"not,omitempty"`
	Or         []*ProductMovementWhereInput `json:"or,omitempty"`
	And        []*ProductMovementWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "createdAt" field predicates.
	CreatedAt      *time.Time  `json:"createdat,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdatNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdatIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdatNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdatGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdatGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdatLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdatLTE,omitempty"`

	// "updatedAt" field predicates.
	UpdatedAt      *time.Time  `json:"updatedat,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedatNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedatIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedatNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedatGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedatGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedatLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedatLTE,omitempty"`

	// "deletedAt" field predicates.
	DeletedAt       *time.Time  `json:"deletedat,omitempty"`
	DeletedAtNEQ    *time.Time  `json:"deletedatNEQ,omitempty"`
	DeletedAtIn     []time.Time `json:"deletedatIn,omitempty"`
	DeletedAtNotIn  []time.Time `json:"deletedatNotIn,omitempty"`
	DeletedAtGT     *time.Time  `json:"deletedatGT,omitempty"`
	DeletedAtGTE    *time.Time  `json:"deletedatGTE,omitempty"`
	DeletedAtLT     *time.Time  `json:"deletedatLT,omitempty"`
	DeletedAtLTE    *time.Time  `json:"deletedatLTE,omitempty"`
	DeletedAtIsNil  bool        `json:"deletedatIsNil,omitempty"`
	DeletedAtNotNil bool        `json:"deletedatNotNil,omitempty"`

	// "entryGroup" field predicates.
	EntryGroup      *int  `json:"entrygroup,omitempty"`
	EntryGroupNEQ   *int  `json:"entrygroupNEQ,omitempty"`
	EntryGroupIn    []int `json:"entrygroupIn,omitempty"`
	EntryGroupNotIn []int `json:"entrygroupNotIn,omitempty"`
	EntryGroupGT    *int  `json:"entrygroupGT,omitempty"`
	EntryGroupGTE   *int  `json:"entrygroupGTE,omitempty"`
	EntryGroupLT    *int  `json:"entrygroupLT,omitempty"`
	EntryGroupLTE   *int  `json:"entrygroupLTE,omitempty"`

	// "averageCost" field predicates.
	AverageCost      *float64  `json:"averagecost,omitempty"`
	AverageCostNEQ   *float64  `json:"averagecostNEQ,omitempty"`
	AverageCostIn    []float64 `json:"averagecostIn,omitempty"`
	AverageCostNotIn []float64 `json:"averagecostNotIn,omitempty"`
	AverageCostGT    *float64  `json:"averagecostGT,omitempty"`
	AverageCostGTE   *float64  `json:"averagecostGTE,omitempty"`
	AverageCostLT    *float64  `json:"averagecostLT,omitempty"`
	AverageCostLTE   *float64  `json:"averagecostLTE,omitempty"`

	// "unitCost" field predicates.
	UnitCost      *float64  `json:"unitcost,omitempty"`
	UnitCostNEQ   *float64  `json:"unitcostNEQ,omitempty"`
	UnitCostIn    []float64 `json:"unitcostIn,omitempty"`
	UnitCostNotIn []float64 `json:"unitcostNotIn,omitempty"`
	UnitCostGT    *float64  `json:"unitcostGT,omitempty"`
	UnitCostGTE   *float64  `json:"unitcostGTE,omitempty"`
	UnitCostLT    *float64  `json:"unitcostLT,omitempty"`
	UnitCostLTE   *float64  `json:"unitcostLTE,omitempty"`

	// "price" field predicates.
	Price      *float64  `json:"price,omitempty"`
	PriceNEQ   *float64  `json:"priceNEQ,omitempty"`
	PriceIn    []float64 `json:"priceIn,omitempty"`
	PriceNotIn []float64 `json:"priceNotIn,omitempty"`
	PriceGT    *float64  `json:"priceGT,omitempty"`
	PriceGTE   *float64  `json:"priceGTE,omitempty"`
	PriceLT    *float64  `json:"priceLT,omitempty"`
	PriceLTE   *float64  `json:"priceLTE,omitempty"`

	// "quantity" field predicates.
	Quantity      *int  `json:"quantity,omitempty"`
	QuantityNEQ   *int  `json:"quantityNEQ,omitempty"`
	QuantityIn    []int `json:"quantityIn,omitempty"`
	QuantityNotIn []int `json:"quantityNotIn,omitempty"`
	QuantityGT    *int  `json:"quantityGT,omitempty"`
	QuantityGTE   *int  `json:"quantityGTE,omitempty"`
	QuantityLT    *int  `json:"quantityLT,omitempty"`
	QuantityLTE   *int  `json:"quantityLTE,omitempty"`

	// "product" edge predicates.
	HasProduct     *bool                `json:"hasProduct,omitempty"`
	HasProductWith []*ProductWhereInput `json:"hasProductWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *ProductMovementWhereInput) AddPredicates(predicates ...predicate.ProductMovement) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the ProductMovementWhereInput filter on the ProductMovementQuery builder.
func (i *ProductMovementWhereInput) Filter(q *ProductMovementQuery) (*ProductMovementQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyProductMovementWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyProductMovementWhereInput is returned in case the ProductMovementWhereInput is empty.
var ErrEmptyProductMovementWhereInput = errors.New("generated: empty predicate ProductMovementWhereInput")

// P returns a predicate for filtering productmovements.
// An error is returned if the input is empty or invalid.
func (i *ProductMovementWhereInput) P() (predicate.ProductMovement, error) {
	var predicates []predicate.ProductMovement
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, productmovement.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.ProductMovement, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, productmovement.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.ProductMovement, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, productmovement.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, productmovement.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, productmovement.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, productmovement.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, productmovement.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, productmovement.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, productmovement.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, productmovement.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, productmovement.IDLTE(*i.IDLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, productmovement.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, productmovement.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, productmovement.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, productmovement.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, productmovement.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, productmovement.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, productmovement.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, productmovement.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, productmovement.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, productmovement.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, productmovement.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, productmovement.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, productmovement.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, productmovement.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, productmovement.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, productmovement.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.DeletedAt != nil {
		predicates = append(predicates, productmovement.DeletedAtEQ(*i.DeletedAt))
	}
	if i.DeletedAtNEQ != nil {
		predicates = append(predicates, productmovement.DeletedAtNEQ(*i.DeletedAtNEQ))
	}
	if len(i.DeletedAtIn) > 0 {
		predicates = append(predicates, productmovement.DeletedAtIn(i.DeletedAtIn...))
	}
	if len(i.DeletedAtNotIn) > 0 {
		predicates = append(predicates, productmovement.DeletedAtNotIn(i.DeletedAtNotIn...))
	}
	if i.DeletedAtGT != nil {
		predicates = append(predicates, productmovement.DeletedAtGT(*i.DeletedAtGT))
	}
	if i.DeletedAtGTE != nil {
		predicates = append(predicates, productmovement.DeletedAtGTE(*i.DeletedAtGTE))
	}
	if i.DeletedAtLT != nil {
		predicates = append(predicates, productmovement.DeletedAtLT(*i.DeletedAtLT))
	}
	if i.DeletedAtLTE != nil {
		predicates = append(predicates, productmovement.DeletedAtLTE(*i.DeletedAtLTE))
	}
	if i.DeletedAtIsNil {
		predicates = append(predicates, productmovement.DeletedAtIsNil())
	}
	if i.DeletedAtNotNil {
		predicates = append(predicates, productmovement.DeletedAtNotNil())
	}
	if i.EntryGroup != nil {
		predicates = append(predicates, productmovement.EntryGroupEQ(*i.EntryGroup))
	}
	if i.EntryGroupNEQ != nil {
		predicates = append(predicates, productmovement.EntryGroupNEQ(*i.EntryGroupNEQ))
	}
	if len(i.EntryGroupIn) > 0 {
		predicates = append(predicates, productmovement.EntryGroupIn(i.EntryGroupIn...))
	}
	if len(i.EntryGroupNotIn) > 0 {
		predicates = append(predicates, productmovement.EntryGroupNotIn(i.EntryGroupNotIn...))
	}
	if i.EntryGroupGT != nil {
		predicates = append(predicates, productmovement.EntryGroupGT(*i.EntryGroupGT))
	}
	if i.EntryGroupGTE != nil {
		predicates = append(predicates, productmovement.EntryGroupGTE(*i.EntryGroupGTE))
	}
	if i.EntryGroupLT != nil {
		predicates = append(predicates, productmovement.EntryGroupLT(*i.EntryGroupLT))
	}
	if i.EntryGroupLTE != nil {
		predicates = append(predicates, productmovement.EntryGroupLTE(*i.EntryGroupLTE))
	}
	if i.AverageCost != nil {
		predicates = append(predicates, productmovement.AverageCostEQ(*i.AverageCost))
	}
	if i.AverageCostNEQ != nil {
		predicates = append(predicates, productmovement.AverageCostNEQ(*i.AverageCostNEQ))
	}
	if len(i.AverageCostIn) > 0 {
		predicates = append(predicates, productmovement.AverageCostIn(i.AverageCostIn...))
	}
	if len(i.AverageCostNotIn) > 0 {
		predicates = append(predicates, productmovement.AverageCostNotIn(i.AverageCostNotIn...))
	}
	if i.AverageCostGT != nil {
		predicates = append(predicates, productmovement.AverageCostGT(*i.AverageCostGT))
	}
	if i.AverageCostGTE != nil {
		predicates = append(predicates, productmovement.AverageCostGTE(*i.AverageCostGTE))
	}
	if i.AverageCostLT != nil {
		predicates = append(predicates, productmovement.AverageCostLT(*i.AverageCostLT))
	}
	if i.AverageCostLTE != nil {
		predicates = append(predicates, productmovement.AverageCostLTE(*i.AverageCostLTE))
	}
	if i.UnitCost != nil {
		predicates = append(predicates, productmovement.UnitCostEQ(*i.UnitCost))
	}
	if i.UnitCostNEQ != nil {
		predicates = append(predicates, productmovement.UnitCostNEQ(*i.UnitCostNEQ))
	}
	if len(i.UnitCostIn) > 0 {
		predicates = append(predicates, productmovement.UnitCostIn(i.UnitCostIn...))
	}
	if len(i.UnitCostNotIn) > 0 {
		predicates = append(predicates, productmovement.UnitCostNotIn(i.UnitCostNotIn...))
	}
	if i.UnitCostGT != nil {
		predicates = append(predicates, productmovement.UnitCostGT(*i.UnitCostGT))
	}
	if i.UnitCostGTE != nil {
		predicates = append(predicates, productmovement.UnitCostGTE(*i.UnitCostGTE))
	}
	if i.UnitCostLT != nil {
		predicates = append(predicates, productmovement.UnitCostLT(*i.UnitCostLT))
	}
	if i.UnitCostLTE != nil {
		predicates = append(predicates, productmovement.UnitCostLTE(*i.UnitCostLTE))
	}
	if i.Price != nil {
		predicates = append(predicates, productmovement.PriceEQ(*i.Price))
	}
	if i.PriceNEQ != nil {
		predicates = append(predicates, productmovement.PriceNEQ(*i.PriceNEQ))
	}
	if len(i.PriceIn) > 0 {
		predicates = append(predicates, productmovement.PriceIn(i.PriceIn...))
	}
	if len(i.PriceNotIn) > 0 {
		predicates = append(predicates, productmovement.PriceNotIn(i.PriceNotIn...))
	}
	if i.PriceGT != nil {
		predicates = append(predicates, productmovement.PriceGT(*i.PriceGT))
	}
	if i.PriceGTE != nil {
		predicates = append(predicates, productmovement.PriceGTE(*i.PriceGTE))
	}
	if i.PriceLT != nil {
		predicates = append(predicates, productmovement.PriceLT(*i.PriceLT))
	}
	if i.PriceLTE != nil {
		predicates = append(predicates, productmovement.PriceLTE(*i.PriceLTE))
	}
	if i.Quantity != nil {
		predicates = append(predicates, productmovement.QuantityEQ(*i.Quantity))
	}
	if i.QuantityNEQ != nil {
		predicates = append(predicates, productmovement.QuantityNEQ(*i.QuantityNEQ))
	}
	if len(i.QuantityIn) > 0 {
		predicates = append(predicates, productmovement.QuantityIn(i.QuantityIn...))
	}
	if len(i.QuantityNotIn) > 0 {
		predicates = append(predicates, productmovement.QuantityNotIn(i.QuantityNotIn...))
	}
	if i.QuantityGT != nil {
		predicates = append(predicates, productmovement.QuantityGT(*i.QuantityGT))
	}
	if i.QuantityGTE != nil {
		predicates = append(predicates, productmovement.QuantityGTE(*i.QuantityGTE))
	}
	if i.QuantityLT != nil {
		predicates = append(predicates, productmovement.QuantityLT(*i.QuantityLT))
	}
	if i.QuantityLTE != nil {
		predicates = append(predicates, productmovement.QuantityLTE(*i.QuantityLTE))
	}

	if i.HasProduct != nil {
		p := productmovement.HasProduct()
		if !*i.HasProduct {
			p = productmovement.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasProductWith) > 0 {
		with := make([]predicate.Product, 0, len(i.HasProductWith))
		for _, w := range i.HasProductWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasProductWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, productmovement.HasProductWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyProductMovementWhereInput
	case 1:
		return predicates[0], nil
	default:
		return productmovement.And(predicates...), nil
	}
}

// ReceivableWhereInput represents a where input for filtering Receivable queries.
type ReceivableWhereInput struct {
	Predicates []predicate.Receivable  `json:"-"`
	Not        *ReceivableWhereInput   `json:"not,omitempty"`
	Or         []*ReceivableWhereInput `json:"or,omitempty"`
	And        []*ReceivableWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "createdAt" field predicates.
	CreatedAt      *time.Time  `json:"createdat,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdatNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdatIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdatNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdatGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdatGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdatLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdatLTE,omitempty"`

	// "updatedAt" field predicates.
	UpdatedAt      *time.Time  `json:"updatedat,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedatNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedatIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedatNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedatGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedatGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedatLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedatLTE,omitempty"`

	// "deletedAt" field predicates.
	DeletedAt       *time.Time  `json:"deletedat,omitempty"`
	DeletedAtNEQ    *time.Time  `json:"deletedatNEQ,omitempty"`
	DeletedAtIn     []time.Time `json:"deletedatIn,omitempty"`
	DeletedAtNotIn  []time.Time `json:"deletedatNotIn,omitempty"`
	DeletedAtGT     *time.Time  `json:"deletedatGT,omitempty"`
	DeletedAtGTE    *time.Time  `json:"deletedatGTE,omitempty"`
	DeletedAtLT     *time.Time  `json:"deletedatLT,omitempty"`
	DeletedAtLTE    *time.Time  `json:"deletedatLTE,omitempty"`
	DeletedAtIsNil  bool        `json:"deletedatIsNil,omitempty"`
	DeletedAtNotNil bool        `json:"deletedatNotNil,omitempty"`

	// "entryGroup" field predicates.
	EntryGroup      *int  `json:"entrygroup,omitempty"`
	EntryGroupNEQ   *int  `json:"entrygroupNEQ,omitempty"`
	EntryGroupIn    []int `json:"entrygroupIn,omitempty"`
	EntryGroupNotIn []int `json:"entrygroupNotIn,omitempty"`
	EntryGroupGT    *int  `json:"entrygroupGT,omitempty"`
	EntryGroupGTE   *int  `json:"entrygroupGTE,omitempty"`
	EntryGroupLT    *int  `json:"entrygroupLT,omitempty"`
	EntryGroupLTE   *int  `json:"entrygroupLTE,omitempty"`

	// "date" field predicates.
	Date      *time.Time  `json:"date,omitempty"`
	DateNEQ   *time.Time  `json:"dateNEQ,omitempty"`
	DateIn    []time.Time `json:"dateIn,omitempty"`
	DateNotIn []time.Time `json:"dateNotIn,omitempty"`
	DateGT    *time.Time  `json:"dateGT,omitempty"`
	DateGTE   *time.Time  `json:"dateGTE,omitempty"`
	DateLT    *time.Time  `json:"dateLT,omitempty"`
	DateLTE   *time.Time  `json:"dateLTE,omitempty"`

	// "outstandingBalance" field predicates.
	OutstandingBalance      *float64  `json:"outstandingbalance,omitempty"`
	OutstandingBalanceNEQ   *float64  `json:"outstandingbalanceNEQ,omitempty"`
	OutstandingBalanceIn    []float64 `json:"outstandingbalanceIn,omitempty"`
	OutstandingBalanceNotIn []float64 `json:"outstandingbalanceNotIn,omitempty"`
	OutstandingBalanceGT    *float64  `json:"outstandingbalanceGT,omitempty"`
	OutstandingBalanceGTE   *float64  `json:"outstandingbalanceGTE,omitempty"`
	OutstandingBalanceLT    *float64  `json:"outstandingbalanceLT,omitempty"`
	OutstandingBalanceLTE   *float64  `json:"outstandingbalanceLTE,omitempty"`

	// "totalTransaction" field predicates.
	TotalTransaction      *float64  `json:"totaltransaction,omitempty"`
	TotalTransactionNEQ   *float64  `json:"totaltransactionNEQ,omitempty"`
	TotalTransactionIn    []float64 `json:"totaltransactionIn,omitempty"`
	TotalTransactionNotIn []float64 `json:"totaltransactionNotIn,omitempty"`
	TotalTransactionGT    *float64  `json:"totaltransactionGT,omitempty"`
	TotalTransactionGTE   *float64  `json:"totaltransactionGTE,omitempty"`
	TotalTransactionLT    *float64  `json:"totaltransactionLT,omitempty"`
	TotalTransactionLTE   *float64  `json:"totaltransactionLTE,omitempty"`

	// "daysDue" field predicates.
	DaysDue      *int  `json:"daysdue,omitempty"`
	DaysDueNEQ   *int  `json:"daysdueNEQ,omitempty"`
	DaysDueIn    []int `json:"daysdueIn,omitempty"`
	DaysDueNotIn []int `json:"daysdueNotIn,omitempty"`
	DaysDueGT    *int  `json:"daysdueGT,omitempty"`
	DaysDueGTE   *int  `json:"daysdueGTE,omitempty"`
	DaysDueLT    *int  `json:"daysdueLT,omitempty"`
	DaysDueLTE   *int  `json:"daysdueLTE,omitempty"`

	// "status" field predicates.
	Status      *receivable.Status  `json:"status,omitempty"`
	StatusNEQ   *receivable.Status  `json:"statusNEQ,omitempty"`
	StatusIn    []receivable.Status `json:"statusIn,omitempty"`
	StatusNotIn []receivable.Status `json:"statusNotIn,omitempty"`

	// "customer" edge predicates.
	HasCustomer     *bool                 `json:"hasCustomer,omitempty"`
	HasCustomerWith []*CustomerWhereInput `json:"hasCustomerWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *ReceivableWhereInput) AddPredicates(predicates ...predicate.Receivable) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the ReceivableWhereInput filter on the ReceivableQuery builder.
func (i *ReceivableWhereInput) Filter(q *ReceivableQuery) (*ReceivableQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyReceivableWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyReceivableWhereInput is returned in case the ReceivableWhereInput is empty.
var ErrEmptyReceivableWhereInput = errors.New("generated: empty predicate ReceivableWhereInput")

// P returns a predicate for filtering receivables.
// An error is returned if the input is empty or invalid.
func (i *ReceivableWhereInput) P() (predicate.Receivable, error) {
	var predicates []predicate.Receivable
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, receivable.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Receivable, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, receivable.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Receivable, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, receivable.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, receivable.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, receivable.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, receivable.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, receivable.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, receivable.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, receivable.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, receivable.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, receivable.IDLTE(*i.IDLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, receivable.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, receivable.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, receivable.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, receivable.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, receivable.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, receivable.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, receivable.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, receivable.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, receivable.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, receivable.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, receivable.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, receivable.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, receivable.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, receivable.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, receivable.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, receivable.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.DeletedAt != nil {
		predicates = append(predicates, receivable.DeletedAtEQ(*i.DeletedAt))
	}
	if i.DeletedAtNEQ != nil {
		predicates = append(predicates, receivable.DeletedAtNEQ(*i.DeletedAtNEQ))
	}
	if len(i.DeletedAtIn) > 0 {
		predicates = append(predicates, receivable.DeletedAtIn(i.DeletedAtIn...))
	}
	if len(i.DeletedAtNotIn) > 0 {
		predicates = append(predicates, receivable.DeletedAtNotIn(i.DeletedAtNotIn...))
	}
	if i.DeletedAtGT != nil {
		predicates = append(predicates, receivable.DeletedAtGT(*i.DeletedAtGT))
	}
	if i.DeletedAtGTE != nil {
		predicates = append(predicates, receivable.DeletedAtGTE(*i.DeletedAtGTE))
	}
	if i.DeletedAtLT != nil {
		predicates = append(predicates, receivable.DeletedAtLT(*i.DeletedAtLT))
	}
	if i.DeletedAtLTE != nil {
		predicates = append(predicates, receivable.DeletedAtLTE(*i.DeletedAtLTE))
	}
	if i.DeletedAtIsNil {
		predicates = append(predicates, receivable.DeletedAtIsNil())
	}
	if i.DeletedAtNotNil {
		predicates = append(predicates, receivable.DeletedAtNotNil())
	}
	if i.EntryGroup != nil {
		predicates = append(predicates, receivable.EntryGroupEQ(*i.EntryGroup))
	}
	if i.EntryGroupNEQ != nil {
		predicates = append(predicates, receivable.EntryGroupNEQ(*i.EntryGroupNEQ))
	}
	if len(i.EntryGroupIn) > 0 {
		predicates = append(predicates, receivable.EntryGroupIn(i.EntryGroupIn...))
	}
	if len(i.EntryGroupNotIn) > 0 {
		predicates = append(predicates, receivable.EntryGroupNotIn(i.EntryGroupNotIn...))
	}
	if i.EntryGroupGT != nil {
		predicates = append(predicates, receivable.EntryGroupGT(*i.EntryGroupGT))
	}
	if i.EntryGroupGTE != nil {
		predicates = append(predicates, receivable.EntryGroupGTE(*i.EntryGroupGTE))
	}
	if i.EntryGroupLT != nil {
		predicates = append(predicates, receivable.EntryGroupLT(*i.EntryGroupLT))
	}
	if i.EntryGroupLTE != nil {
		predicates = append(predicates, receivable.EntryGroupLTE(*i.EntryGroupLTE))
	}
	if i.Date != nil {
		predicates = append(predicates, receivable.DateEQ(*i.Date))
	}
	if i.DateNEQ != nil {
		predicates = append(predicates, receivable.DateNEQ(*i.DateNEQ))
	}
	if len(i.DateIn) > 0 {
		predicates = append(predicates, receivable.DateIn(i.DateIn...))
	}
	if len(i.DateNotIn) > 0 {
		predicates = append(predicates, receivable.DateNotIn(i.DateNotIn...))
	}
	if i.DateGT != nil {
		predicates = append(predicates, receivable.DateGT(*i.DateGT))
	}
	if i.DateGTE != nil {
		predicates = append(predicates, receivable.DateGTE(*i.DateGTE))
	}
	if i.DateLT != nil {
		predicates = append(predicates, receivable.DateLT(*i.DateLT))
	}
	if i.DateLTE != nil {
		predicates = append(predicates, receivable.DateLTE(*i.DateLTE))
	}
	if i.OutstandingBalance != nil {
		predicates = append(predicates, receivable.OutstandingBalanceEQ(*i.OutstandingBalance))
	}
	if i.OutstandingBalanceNEQ != nil {
		predicates = append(predicates, receivable.OutstandingBalanceNEQ(*i.OutstandingBalanceNEQ))
	}
	if len(i.OutstandingBalanceIn) > 0 {
		predicates = append(predicates, receivable.OutstandingBalanceIn(i.OutstandingBalanceIn...))
	}
	if len(i.OutstandingBalanceNotIn) > 0 {
		predicates = append(predicates, receivable.OutstandingBalanceNotIn(i.OutstandingBalanceNotIn...))
	}
	if i.OutstandingBalanceGT != nil {
		predicates = append(predicates, receivable.OutstandingBalanceGT(*i.OutstandingBalanceGT))
	}
	if i.OutstandingBalanceGTE != nil {
		predicates = append(predicates, receivable.OutstandingBalanceGTE(*i.OutstandingBalanceGTE))
	}
	if i.OutstandingBalanceLT != nil {
		predicates = append(predicates, receivable.OutstandingBalanceLT(*i.OutstandingBalanceLT))
	}
	if i.OutstandingBalanceLTE != nil {
		predicates = append(predicates, receivable.OutstandingBalanceLTE(*i.OutstandingBalanceLTE))
	}
	if i.TotalTransaction != nil {
		predicates = append(predicates, receivable.TotalTransactionEQ(*i.TotalTransaction))
	}
	if i.TotalTransactionNEQ != nil {
		predicates = append(predicates, receivable.TotalTransactionNEQ(*i.TotalTransactionNEQ))
	}
	if len(i.TotalTransactionIn) > 0 {
		predicates = append(predicates, receivable.TotalTransactionIn(i.TotalTransactionIn...))
	}
	if len(i.TotalTransactionNotIn) > 0 {
		predicates = append(predicates, receivable.TotalTransactionNotIn(i.TotalTransactionNotIn...))
	}
	if i.TotalTransactionGT != nil {
		predicates = append(predicates, receivable.TotalTransactionGT(*i.TotalTransactionGT))
	}
	if i.TotalTransactionGTE != nil {
		predicates = append(predicates, receivable.TotalTransactionGTE(*i.TotalTransactionGTE))
	}
	if i.TotalTransactionLT != nil {
		predicates = append(predicates, receivable.TotalTransactionLT(*i.TotalTransactionLT))
	}
	if i.TotalTransactionLTE != nil {
		predicates = append(predicates, receivable.TotalTransactionLTE(*i.TotalTransactionLTE))
	}
	if i.DaysDue != nil {
		predicates = append(predicates, receivable.DaysDueEQ(*i.DaysDue))
	}
	if i.DaysDueNEQ != nil {
		predicates = append(predicates, receivable.DaysDueNEQ(*i.DaysDueNEQ))
	}
	if len(i.DaysDueIn) > 0 {
		predicates = append(predicates, receivable.DaysDueIn(i.DaysDueIn...))
	}
	if len(i.DaysDueNotIn) > 0 {
		predicates = append(predicates, receivable.DaysDueNotIn(i.DaysDueNotIn...))
	}
	if i.DaysDueGT != nil {
		predicates = append(predicates, receivable.DaysDueGT(*i.DaysDueGT))
	}
	if i.DaysDueGTE != nil {
		predicates = append(predicates, receivable.DaysDueGTE(*i.DaysDueGTE))
	}
	if i.DaysDueLT != nil {
		predicates = append(predicates, receivable.DaysDueLT(*i.DaysDueLT))
	}
	if i.DaysDueLTE != nil {
		predicates = append(predicates, receivable.DaysDueLTE(*i.DaysDueLTE))
	}
	if i.Status != nil {
		predicates = append(predicates, receivable.StatusEQ(*i.Status))
	}
	if i.StatusNEQ != nil {
		predicates = append(predicates, receivable.StatusNEQ(*i.StatusNEQ))
	}
	if len(i.StatusIn) > 0 {
		predicates = append(predicates, receivable.StatusIn(i.StatusIn...))
	}
	if len(i.StatusNotIn) > 0 {
		predicates = append(predicates, receivable.StatusNotIn(i.StatusNotIn...))
	}

	if i.HasCustomer != nil {
		p := receivable.HasCustomer()
		if !*i.HasCustomer {
			p = receivable.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasCustomerWith) > 0 {
		with := make([]predicate.Customer, 0, len(i.HasCustomerWith))
		for _, w := range i.HasCustomerWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasCustomerWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, receivable.HasCustomerWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyReceivableWhereInput
	case 1:
		return predicates[0], nil
	default:
		return receivable.And(predicates...), nil
	}
}

// SupplierWhereInput represents a where input for filtering Supplier queries.
type SupplierWhereInput struct {
	Predicates []predicate.Supplier  `json:"-"`
	Not        *SupplierWhereInput   `json:"not,omitempty"`
	Or         []*SupplierWhereInput `json:"or,omitempty"`
	And        []*SupplierWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "createdAt" field predicates.
	CreatedAt      *time.Time  `json:"createdat,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdatNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdatIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdatNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdatGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdatGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdatLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdatLTE,omitempty"`

	// "updatedAt" field predicates.
	UpdatedAt      *time.Time  `json:"updatedat,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedatNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedatIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedatNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedatGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedatGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedatLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedatLTE,omitempty"`

	// "deletedAt" field predicates.
	DeletedAt       *time.Time  `json:"deletedat,omitempty"`
	DeletedAtNEQ    *time.Time  `json:"deletedatNEQ,omitempty"`
	DeletedAtIn     []time.Time `json:"deletedatIn,omitempty"`
	DeletedAtNotIn  []time.Time `json:"deletedatNotIn,omitempty"`
	DeletedAtGT     *time.Time  `json:"deletedatGT,omitempty"`
	DeletedAtGTE    *time.Time  `json:"deletedatGTE,omitempty"`
	DeletedAtLT     *time.Time  `json:"deletedatLT,omitempty"`
	DeletedAtLTE    *time.Time  `json:"deletedatLTE,omitempty"`
	DeletedAtIsNil  bool        `json:"deletedatIsNil,omitempty"`
	DeletedAtNotNil bool        `json:"deletedatNotNil,omitempty"`

	// "address" field predicates.
	Address             *string  `json:"address,omitempty"`
	AddressNEQ          *string  `json:"addressNEQ,omitempty"`
	AddressIn           []string `json:"addressIn,omitempty"`
	AddressNotIn        []string `json:"addressNotIn,omitempty"`
	AddressGT           *string  `json:"addressGT,omitempty"`
	AddressGTE          *string  `json:"addressGTE,omitempty"`
	AddressLT           *string  `json:"addressLT,omitempty"`
	AddressLTE          *string  `json:"addressLTE,omitempty"`
	AddressContains     *string  `json:"addressContains,omitempty"`
	AddressHasPrefix    *string  `json:"addressHasPrefix,omitempty"`
	AddressHasSuffix    *string  `json:"addressHasSuffix,omitempty"`
	AddressEqualFold    *string  `json:"addressEqualFold,omitempty"`
	AddressContainsFold *string  `json:"addressContainsFold,omitempty"`

	// "city" field predicates.
	City             *string  `json:"city,omitempty"`
	CityNEQ          *string  `json:"cityNEQ,omitempty"`
	CityIn           []string `json:"cityIn,omitempty"`
	CityNotIn        []string `json:"cityNotIn,omitempty"`
	CityGT           *string  `json:"cityGT,omitempty"`
	CityGTE          *string  `json:"cityGTE,omitempty"`
	CityLT           *string  `json:"cityLT,omitempty"`
	CityLTE          *string  `json:"cityLTE,omitempty"`
	CityContains     *string  `json:"cityContains,omitempty"`
	CityHasPrefix    *string  `json:"cityHasPrefix,omitempty"`
	CityHasSuffix    *string  `json:"cityHasSuffix,omitempty"`
	CityEqualFold    *string  `json:"cityEqualFold,omitempty"`
	CityContainsFold *string  `json:"cityContainsFold,omitempty"`

	// "country" field predicates.
	Country             *string  `json:"country,omitempty"`
	CountryNEQ          *string  `json:"countryNEQ,omitempty"`
	CountryIn           []string `json:"countryIn,omitempty"`
	CountryNotIn        []string `json:"countryNotIn,omitempty"`
	CountryGT           *string  `json:"countryGT,omitempty"`
	CountryGTE          *string  `json:"countryGTE,omitempty"`
	CountryLT           *string  `json:"countryLT,omitempty"`
	CountryLTE          *string  `json:"countryLTE,omitempty"`
	CountryContains     *string  `json:"countryContains,omitempty"`
	CountryHasPrefix    *string  `json:"countryHasPrefix,omitempty"`
	CountryHasSuffix    *string  `json:"countryHasSuffix,omitempty"`
	CountryEqualFold    *string  `json:"countryEqualFold,omitempty"`
	CountryContainsFold *string  `json:"countryContainsFold,omitempty"`

	// "description" field predicates.
	Description             *string  `json:"description,omitempty"`
	DescriptionNEQ          *string  `json:"descriptionNEQ,omitempty"`
	DescriptionIn           []string `json:"descriptionIn,omitempty"`
	DescriptionNotIn        []string `json:"descriptionNotIn,omitempty"`
	DescriptionGT           *string  `json:"descriptionGT,omitempty"`
	DescriptionGTE          *string  `json:"descriptionGTE,omitempty"`
	DescriptionLT           *string  `json:"descriptionLT,omitempty"`
	DescriptionLTE          *string  `json:"descriptionLTE,omitempty"`
	DescriptionContains     *string  `json:"descriptionContains,omitempty"`
	DescriptionHasPrefix    *string  `json:"descriptionHasPrefix,omitempty"`
	DescriptionHasSuffix    *string  `json:"descriptionHasSuffix,omitempty"`
	DescriptionEqualFold    *string  `json:"descriptionEqualFold,omitempty"`
	DescriptionContainsFold *string  `json:"descriptionContainsFold,omitempty"`

	// "email" field predicates.
	Email             *string  `json:"email,omitempty"`
	EmailNEQ          *string  `json:"emailNEQ,omitempty"`
	EmailIn           []string `json:"emailIn,omitempty"`
	EmailNotIn        []string `json:"emailNotIn,omitempty"`
	EmailGT           *string  `json:"emailGT,omitempty"`
	EmailGTE          *string  `json:"emailGTE,omitempty"`
	EmailLT           *string  `json:"emailLT,omitempty"`
	EmailLTE          *string  `json:"emailLTE,omitempty"`
	EmailContains     *string  `json:"emailContains,omitempty"`
	EmailHasPrefix    *string  `json:"emailHasPrefix,omitempty"`
	EmailHasSuffix    *string  `json:"emailHasSuffix,omitempty"`
	EmailEqualFold    *string  `json:"emailEqualFold,omitempty"`
	EmailContainsFold *string  `json:"emailContainsFold,omitempty"`

	// "isDefault" field predicates.
	IsDefault       *bool `json:"isdefault,omitempty"`
	IsDefaultNEQ    *bool `json:"isdefaultNEQ,omitempty"`
	IsDefaultIsNil  bool  `json:"isdefaultIsNil,omitempty"`
	IsDefaultNotNil bool  `json:"isdefaultNotNil,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "phone" field predicates.
	Phone             *string  `json:"phone,omitempty"`
	PhoneNEQ          *string  `json:"phoneNEQ,omitempty"`
	PhoneIn           []string `json:"phoneIn,omitempty"`
	PhoneNotIn        []string `json:"phoneNotIn,omitempty"`
	PhoneGT           *string  `json:"phoneGT,omitempty"`
	PhoneGTE          *string  `json:"phoneGTE,omitempty"`
	PhoneLT           *string  `json:"phoneLT,omitempty"`
	PhoneLTE          *string  `json:"phoneLTE,omitempty"`
	PhoneContains     *string  `json:"phoneContains,omitempty"`
	PhoneHasPrefix    *string  `json:"phoneHasPrefix,omitempty"`
	PhoneHasSuffix    *string  `json:"phoneHasSuffix,omitempty"`
	PhoneEqualFold    *string  `json:"phoneEqualFold,omitempty"`
	PhoneContainsFold *string  `json:"phoneContainsFold,omitempty"`

	// "taxId" field predicates.
	TaxId             *string  `json:"taxid,omitempty"`
	TaxIdNEQ          *string  `json:"taxidNEQ,omitempty"`
	TaxIdIn           []string `json:"taxidIn,omitempty"`
	TaxIdNotIn        []string `json:"taxidNotIn,omitempty"`
	TaxIdGT           *string  `json:"taxidGT,omitempty"`
	TaxIdGTE          *string  `json:"taxidGTE,omitempty"`
	TaxIdLT           *string  `json:"taxidLT,omitempty"`
	TaxIdLTE          *string  `json:"taxidLTE,omitempty"`
	TaxIdContains     *string  `json:"taxidContains,omitempty"`
	TaxIdHasPrefix    *string  `json:"taxidHasPrefix,omitempty"`
	TaxIdHasSuffix    *string  `json:"taxidHasSuffix,omitempty"`
	TaxIdEqualFold    *string  `json:"taxidEqualFold,omitempty"`
	TaxIdContainsFold *string  `json:"taxidContainsFold,omitempty"`

	// "company" edge predicates.
	HasCompany     *bool                `json:"hasCompany,omitempty"`
	HasCompanyWith []*CompanyWhereInput `json:"hasCompanyWith,omitempty"`

	// "payables" edge predicates.
	HasPayables     *bool                `json:"hasPayables,omitempty"`
	HasPayablesWith []*PayableWhereInput `json:"hasPayablesWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *SupplierWhereInput) AddPredicates(predicates ...predicate.Supplier) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the SupplierWhereInput filter on the SupplierQuery builder.
func (i *SupplierWhereInput) Filter(q *SupplierQuery) (*SupplierQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptySupplierWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptySupplierWhereInput is returned in case the SupplierWhereInput is empty.
var ErrEmptySupplierWhereInput = errors.New("generated: empty predicate SupplierWhereInput")

// P returns a predicate for filtering suppliers.
// An error is returned if the input is empty or invalid.
func (i *SupplierWhereInput) P() (predicate.Supplier, error) {
	var predicates []predicate.Supplier
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, supplier.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Supplier, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, supplier.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Supplier, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, supplier.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, supplier.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, supplier.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, supplier.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, supplier.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, supplier.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, supplier.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, supplier.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, supplier.IDLTE(*i.IDLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, supplier.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, supplier.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, supplier.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, supplier.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, supplier.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, supplier.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, supplier.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, supplier.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, supplier.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, supplier.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, supplier.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, supplier.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, supplier.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, supplier.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, supplier.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, supplier.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.DeletedAt != nil {
		predicates = append(predicates, supplier.DeletedAtEQ(*i.DeletedAt))
	}
	if i.DeletedAtNEQ != nil {
		predicates = append(predicates, supplier.DeletedAtNEQ(*i.DeletedAtNEQ))
	}
	if len(i.DeletedAtIn) > 0 {
		predicates = append(predicates, supplier.DeletedAtIn(i.DeletedAtIn...))
	}
	if len(i.DeletedAtNotIn) > 0 {
		predicates = append(predicates, supplier.DeletedAtNotIn(i.DeletedAtNotIn...))
	}
	if i.DeletedAtGT != nil {
		predicates = append(predicates, supplier.DeletedAtGT(*i.DeletedAtGT))
	}
	if i.DeletedAtGTE != nil {
		predicates = append(predicates, supplier.DeletedAtGTE(*i.DeletedAtGTE))
	}
	if i.DeletedAtLT != nil {
		predicates = append(predicates, supplier.DeletedAtLT(*i.DeletedAtLT))
	}
	if i.DeletedAtLTE != nil {
		predicates = append(predicates, supplier.DeletedAtLTE(*i.DeletedAtLTE))
	}
	if i.DeletedAtIsNil {
		predicates = append(predicates, supplier.DeletedAtIsNil())
	}
	if i.DeletedAtNotNil {
		predicates = append(predicates, supplier.DeletedAtNotNil())
	}
	if i.Address != nil {
		predicates = append(predicates, supplier.AddressEQ(*i.Address))
	}
	if i.AddressNEQ != nil {
		predicates = append(predicates, supplier.AddressNEQ(*i.AddressNEQ))
	}
	if len(i.AddressIn) > 0 {
		predicates = append(predicates, supplier.AddressIn(i.AddressIn...))
	}
	if len(i.AddressNotIn) > 0 {
		predicates = append(predicates, supplier.AddressNotIn(i.AddressNotIn...))
	}
	if i.AddressGT != nil {
		predicates = append(predicates, supplier.AddressGT(*i.AddressGT))
	}
	if i.AddressGTE != nil {
		predicates = append(predicates, supplier.AddressGTE(*i.AddressGTE))
	}
	if i.AddressLT != nil {
		predicates = append(predicates, supplier.AddressLT(*i.AddressLT))
	}
	if i.AddressLTE != nil {
		predicates = append(predicates, supplier.AddressLTE(*i.AddressLTE))
	}
	if i.AddressContains != nil {
		predicates = append(predicates, supplier.AddressContains(*i.AddressContains))
	}
	if i.AddressHasPrefix != nil {
		predicates = append(predicates, supplier.AddressHasPrefix(*i.AddressHasPrefix))
	}
	if i.AddressHasSuffix != nil {
		predicates = append(predicates, supplier.AddressHasSuffix(*i.AddressHasSuffix))
	}
	if i.AddressEqualFold != nil {
		predicates = append(predicates, supplier.AddressEqualFold(*i.AddressEqualFold))
	}
	if i.AddressContainsFold != nil {
		predicates = append(predicates, supplier.AddressContainsFold(*i.AddressContainsFold))
	}
	if i.City != nil {
		predicates = append(predicates, supplier.CityEQ(*i.City))
	}
	if i.CityNEQ != nil {
		predicates = append(predicates, supplier.CityNEQ(*i.CityNEQ))
	}
	if len(i.CityIn) > 0 {
		predicates = append(predicates, supplier.CityIn(i.CityIn...))
	}
	if len(i.CityNotIn) > 0 {
		predicates = append(predicates, supplier.CityNotIn(i.CityNotIn...))
	}
	if i.CityGT != nil {
		predicates = append(predicates, supplier.CityGT(*i.CityGT))
	}
	if i.CityGTE != nil {
		predicates = append(predicates, supplier.CityGTE(*i.CityGTE))
	}
	if i.CityLT != nil {
		predicates = append(predicates, supplier.CityLT(*i.CityLT))
	}
	if i.CityLTE != nil {
		predicates = append(predicates, supplier.CityLTE(*i.CityLTE))
	}
	if i.CityContains != nil {
		predicates = append(predicates, supplier.CityContains(*i.CityContains))
	}
	if i.CityHasPrefix != nil {
		predicates = append(predicates, supplier.CityHasPrefix(*i.CityHasPrefix))
	}
	if i.CityHasSuffix != nil {
		predicates = append(predicates, supplier.CityHasSuffix(*i.CityHasSuffix))
	}
	if i.CityEqualFold != nil {
		predicates = append(predicates, supplier.CityEqualFold(*i.CityEqualFold))
	}
	if i.CityContainsFold != nil {
		predicates = append(predicates, supplier.CityContainsFold(*i.CityContainsFold))
	}
	if i.Country != nil {
		predicates = append(predicates, supplier.CountryEQ(*i.Country))
	}
	if i.CountryNEQ != nil {
		predicates = append(predicates, supplier.CountryNEQ(*i.CountryNEQ))
	}
	if len(i.CountryIn) > 0 {
		predicates = append(predicates, supplier.CountryIn(i.CountryIn...))
	}
	if len(i.CountryNotIn) > 0 {
		predicates = append(predicates, supplier.CountryNotIn(i.CountryNotIn...))
	}
	if i.CountryGT != nil {
		predicates = append(predicates, supplier.CountryGT(*i.CountryGT))
	}
	if i.CountryGTE != nil {
		predicates = append(predicates, supplier.CountryGTE(*i.CountryGTE))
	}
	if i.CountryLT != nil {
		predicates = append(predicates, supplier.CountryLT(*i.CountryLT))
	}
	if i.CountryLTE != nil {
		predicates = append(predicates, supplier.CountryLTE(*i.CountryLTE))
	}
	if i.CountryContains != nil {
		predicates = append(predicates, supplier.CountryContains(*i.CountryContains))
	}
	if i.CountryHasPrefix != nil {
		predicates = append(predicates, supplier.CountryHasPrefix(*i.CountryHasPrefix))
	}
	if i.CountryHasSuffix != nil {
		predicates = append(predicates, supplier.CountryHasSuffix(*i.CountryHasSuffix))
	}
	if i.CountryEqualFold != nil {
		predicates = append(predicates, supplier.CountryEqualFold(*i.CountryEqualFold))
	}
	if i.CountryContainsFold != nil {
		predicates = append(predicates, supplier.CountryContainsFold(*i.CountryContainsFold))
	}
	if i.Description != nil {
		predicates = append(predicates, supplier.DescriptionEQ(*i.Description))
	}
	if i.DescriptionNEQ != nil {
		predicates = append(predicates, supplier.DescriptionNEQ(*i.DescriptionNEQ))
	}
	if len(i.DescriptionIn) > 0 {
		predicates = append(predicates, supplier.DescriptionIn(i.DescriptionIn...))
	}
	if len(i.DescriptionNotIn) > 0 {
		predicates = append(predicates, supplier.DescriptionNotIn(i.DescriptionNotIn...))
	}
	if i.DescriptionGT != nil {
		predicates = append(predicates, supplier.DescriptionGT(*i.DescriptionGT))
	}
	if i.DescriptionGTE != nil {
		predicates = append(predicates, supplier.DescriptionGTE(*i.DescriptionGTE))
	}
	if i.DescriptionLT != nil {
		predicates = append(predicates, supplier.DescriptionLT(*i.DescriptionLT))
	}
	if i.DescriptionLTE != nil {
		predicates = append(predicates, supplier.DescriptionLTE(*i.DescriptionLTE))
	}
	if i.DescriptionContains != nil {
		predicates = append(predicates, supplier.DescriptionContains(*i.DescriptionContains))
	}
	if i.DescriptionHasPrefix != nil {
		predicates = append(predicates, supplier.DescriptionHasPrefix(*i.DescriptionHasPrefix))
	}
	if i.DescriptionHasSuffix != nil {
		predicates = append(predicates, supplier.DescriptionHasSuffix(*i.DescriptionHasSuffix))
	}
	if i.DescriptionEqualFold != nil {
		predicates = append(predicates, supplier.DescriptionEqualFold(*i.DescriptionEqualFold))
	}
	if i.DescriptionContainsFold != nil {
		predicates = append(predicates, supplier.DescriptionContainsFold(*i.DescriptionContainsFold))
	}
	if i.Email != nil {
		predicates = append(predicates, supplier.EmailEQ(*i.Email))
	}
	if i.EmailNEQ != nil {
		predicates = append(predicates, supplier.EmailNEQ(*i.EmailNEQ))
	}
	if len(i.EmailIn) > 0 {
		predicates = append(predicates, supplier.EmailIn(i.EmailIn...))
	}
	if len(i.EmailNotIn) > 0 {
		predicates = append(predicates, supplier.EmailNotIn(i.EmailNotIn...))
	}
	if i.EmailGT != nil {
		predicates = append(predicates, supplier.EmailGT(*i.EmailGT))
	}
	if i.EmailGTE != nil {
		predicates = append(predicates, supplier.EmailGTE(*i.EmailGTE))
	}
	if i.EmailLT != nil {
		predicates = append(predicates, supplier.EmailLT(*i.EmailLT))
	}
	if i.EmailLTE != nil {
		predicates = append(predicates, supplier.EmailLTE(*i.EmailLTE))
	}
	if i.EmailContains != nil {
		predicates = append(predicates, supplier.EmailContains(*i.EmailContains))
	}
	if i.EmailHasPrefix != nil {
		predicates = append(predicates, supplier.EmailHasPrefix(*i.EmailHasPrefix))
	}
	if i.EmailHasSuffix != nil {
		predicates = append(predicates, supplier.EmailHasSuffix(*i.EmailHasSuffix))
	}
	if i.EmailEqualFold != nil {
		predicates = append(predicates, supplier.EmailEqualFold(*i.EmailEqualFold))
	}
	if i.EmailContainsFold != nil {
		predicates = append(predicates, supplier.EmailContainsFold(*i.EmailContainsFold))
	}
	if i.IsDefault != nil {
		predicates = append(predicates, supplier.IsDefaultEQ(*i.IsDefault))
	}
	if i.IsDefaultNEQ != nil {
		predicates = append(predicates, supplier.IsDefaultNEQ(*i.IsDefaultNEQ))
	}
	if i.IsDefaultIsNil {
		predicates = append(predicates, supplier.IsDefaultIsNil())
	}
	if i.IsDefaultNotNil {
		predicates = append(predicates, supplier.IsDefaultNotNil())
	}
	if i.Name != nil {
		predicates = append(predicates, supplier.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, supplier.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, supplier.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, supplier.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, supplier.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, supplier.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, supplier.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, supplier.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, supplier.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, supplier.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, supplier.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, supplier.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, supplier.NameContainsFold(*i.NameContainsFold))
	}
	if i.Phone != nil {
		predicates = append(predicates, supplier.PhoneEQ(*i.Phone))
	}
	if i.PhoneNEQ != nil {
		predicates = append(predicates, supplier.PhoneNEQ(*i.PhoneNEQ))
	}
	if len(i.PhoneIn) > 0 {
		predicates = append(predicates, supplier.PhoneIn(i.PhoneIn...))
	}
	if len(i.PhoneNotIn) > 0 {
		predicates = append(predicates, supplier.PhoneNotIn(i.PhoneNotIn...))
	}
	if i.PhoneGT != nil {
		predicates = append(predicates, supplier.PhoneGT(*i.PhoneGT))
	}
	if i.PhoneGTE != nil {
		predicates = append(predicates, supplier.PhoneGTE(*i.PhoneGTE))
	}
	if i.PhoneLT != nil {
		predicates = append(predicates, supplier.PhoneLT(*i.PhoneLT))
	}
	if i.PhoneLTE != nil {
		predicates = append(predicates, supplier.PhoneLTE(*i.PhoneLTE))
	}
	if i.PhoneContains != nil {
		predicates = append(predicates, supplier.PhoneContains(*i.PhoneContains))
	}
	if i.PhoneHasPrefix != nil {
		predicates = append(predicates, supplier.PhoneHasPrefix(*i.PhoneHasPrefix))
	}
	if i.PhoneHasSuffix != nil {
		predicates = append(predicates, supplier.PhoneHasSuffix(*i.PhoneHasSuffix))
	}
	if i.PhoneEqualFold != nil {
		predicates = append(predicates, supplier.PhoneEqualFold(*i.PhoneEqualFold))
	}
	if i.PhoneContainsFold != nil {
		predicates = append(predicates, supplier.PhoneContainsFold(*i.PhoneContainsFold))
	}
	if i.TaxId != nil {
		predicates = append(predicates, supplier.TaxIdEQ(*i.TaxId))
	}
	if i.TaxIdNEQ != nil {
		predicates = append(predicates, supplier.TaxIdNEQ(*i.TaxIdNEQ))
	}
	if len(i.TaxIdIn) > 0 {
		predicates = append(predicates, supplier.TaxIdIn(i.TaxIdIn...))
	}
	if len(i.TaxIdNotIn) > 0 {
		predicates = append(predicates, supplier.TaxIdNotIn(i.TaxIdNotIn...))
	}
	if i.TaxIdGT != nil {
		predicates = append(predicates, supplier.TaxIdGT(*i.TaxIdGT))
	}
	if i.TaxIdGTE != nil {
		predicates = append(predicates, supplier.TaxIdGTE(*i.TaxIdGTE))
	}
	if i.TaxIdLT != nil {
		predicates = append(predicates, supplier.TaxIdLT(*i.TaxIdLT))
	}
	if i.TaxIdLTE != nil {
		predicates = append(predicates, supplier.TaxIdLTE(*i.TaxIdLTE))
	}
	if i.TaxIdContains != nil {
		predicates = append(predicates, supplier.TaxIdContains(*i.TaxIdContains))
	}
	if i.TaxIdHasPrefix != nil {
		predicates = append(predicates, supplier.TaxIdHasPrefix(*i.TaxIdHasPrefix))
	}
	if i.TaxIdHasSuffix != nil {
		predicates = append(predicates, supplier.TaxIdHasSuffix(*i.TaxIdHasSuffix))
	}
	if i.TaxIdEqualFold != nil {
		predicates = append(predicates, supplier.TaxIdEqualFold(*i.TaxIdEqualFold))
	}
	if i.TaxIdContainsFold != nil {
		predicates = append(predicates, supplier.TaxIdContainsFold(*i.TaxIdContainsFold))
	}

	if i.HasCompany != nil {
		p := supplier.HasCompany()
		if !*i.HasCompany {
			p = supplier.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasCompanyWith) > 0 {
		with := make([]predicate.Company, 0, len(i.HasCompanyWith))
		for _, w := range i.HasCompanyWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasCompanyWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, supplier.HasCompanyWith(with...))
	}
	if i.HasPayables != nil {
		p := supplier.HasPayables()
		if !*i.HasPayables {
			p = supplier.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasPayablesWith) > 0 {
		with := make([]predicate.Payable, 0, len(i.HasPayablesWith))
		for _, w := range i.HasPayablesWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasPayablesWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, supplier.HasPayablesWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptySupplierWhereInput
	case 1:
		return predicates[0], nil
	default:
		return supplier.And(predicates...), nil
	}
}

// TokenWhereInput represents a where input for filtering Token queries.
type TokenWhereInput struct {
	Predicates []predicate.Token  `json:"-"`
	Not        *TokenWhereInput   `json:"not,omitempty"`
	Or         []*TokenWhereInput `json:"or,omitempty"`
	And        []*TokenWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "expiry" field predicates.
	Expiry      *time.Time  `json:"expiry,omitempty"`
	ExpiryNEQ   *time.Time  `json:"expiryNEQ,omitempty"`
	ExpiryIn    []time.Time `json:"expiryIn,omitempty"`
	ExpiryNotIn []time.Time `json:"expiryNotIn,omitempty"`
	ExpiryGT    *time.Time  `json:"expiryGT,omitempty"`
	ExpiryGTE   *time.Time  `json:"expiryGTE,omitempty"`
	ExpiryLT    *time.Time  `json:"expiryLT,omitempty"`
	ExpiryLTE   *time.Time  `json:"expiryLTE,omitempty"`

	// "category" field predicates.
	Category      *token.Category  `json:"category,omitempty"`
	CategoryNEQ   *token.Category  `json:"categoryNEQ,omitempty"`
	CategoryIn    []token.Category `json:"categoryIn,omitempty"`
	CategoryNotIn []token.Category `json:"categoryNotIn,omitempty"`

	// "token" field predicates.
	Token             *string  `json:"token,omitempty"`
	TokenNEQ          *string  `json:"tokenNEQ,omitempty"`
	TokenIn           []string `json:"tokenIn,omitempty"`
	TokenNotIn        []string `json:"tokenNotIn,omitempty"`
	TokenGT           *string  `json:"tokenGT,omitempty"`
	TokenGTE          *string  `json:"tokenGTE,omitempty"`
	TokenLT           *string  `json:"tokenLT,omitempty"`
	TokenLTE          *string  `json:"tokenLTE,omitempty"`
	TokenContains     *string  `json:"tokenContains,omitempty"`
	TokenHasPrefix    *string  `json:"tokenHasPrefix,omitempty"`
	TokenHasSuffix    *string  `json:"tokenHasSuffix,omitempty"`
	TokenEqualFold    *string  `json:"tokenEqualFold,omitempty"`
	TokenContainsFold *string  `json:"tokenContainsFold,omitempty"`

	// "company" edge predicates.
	HasCompany     *bool                `json:"hasCompany,omitempty"`
	HasCompanyWith []*CompanyWhereInput `json:"hasCompanyWith,omitempty"`

	// "user" edge predicates.
	HasUser     *bool             `json:"hasUser,omitempty"`
	HasUserWith []*UserWhereInput `json:"hasUserWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *TokenWhereInput) AddPredicates(predicates ...predicate.Token) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the TokenWhereInput filter on the TokenQuery builder.
func (i *TokenWhereInput) Filter(q *TokenQuery) (*TokenQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyTokenWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyTokenWhereInput is returned in case the TokenWhereInput is empty.
var ErrEmptyTokenWhereInput = errors.New("generated: empty predicate TokenWhereInput")

// P returns a predicate for filtering tokens.
// An error is returned if the input is empty or invalid.
func (i *TokenWhereInput) P() (predicate.Token, error) {
	var predicates []predicate.Token
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, token.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Token, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, token.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Token, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, token.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, token.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, token.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, token.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, token.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, token.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, token.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, token.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, token.IDLTE(*i.IDLTE))
	}
	if i.Expiry != nil {
		predicates = append(predicates, token.ExpiryEQ(*i.Expiry))
	}
	if i.ExpiryNEQ != nil {
		predicates = append(predicates, token.ExpiryNEQ(*i.ExpiryNEQ))
	}
	if len(i.ExpiryIn) > 0 {
		predicates = append(predicates, token.ExpiryIn(i.ExpiryIn...))
	}
	if len(i.ExpiryNotIn) > 0 {
		predicates = append(predicates, token.ExpiryNotIn(i.ExpiryNotIn...))
	}
	if i.ExpiryGT != nil {
		predicates = append(predicates, token.ExpiryGT(*i.ExpiryGT))
	}
	if i.ExpiryGTE != nil {
		predicates = append(predicates, token.ExpiryGTE(*i.ExpiryGTE))
	}
	if i.ExpiryLT != nil {
		predicates = append(predicates, token.ExpiryLT(*i.ExpiryLT))
	}
	if i.ExpiryLTE != nil {
		predicates = append(predicates, token.ExpiryLTE(*i.ExpiryLTE))
	}
	if i.Category != nil {
		predicates = append(predicates, token.CategoryEQ(*i.Category))
	}
	if i.CategoryNEQ != nil {
		predicates = append(predicates, token.CategoryNEQ(*i.CategoryNEQ))
	}
	if len(i.CategoryIn) > 0 {
		predicates = append(predicates, token.CategoryIn(i.CategoryIn...))
	}
	if len(i.CategoryNotIn) > 0 {
		predicates = append(predicates, token.CategoryNotIn(i.CategoryNotIn...))
	}
	if i.Token != nil {
		predicates = append(predicates, token.TokenEQ(*i.Token))
	}
	if i.TokenNEQ != nil {
		predicates = append(predicates, token.TokenNEQ(*i.TokenNEQ))
	}
	if len(i.TokenIn) > 0 {
		predicates = append(predicates, token.TokenIn(i.TokenIn...))
	}
	if len(i.TokenNotIn) > 0 {
		predicates = append(predicates, token.TokenNotIn(i.TokenNotIn...))
	}
	if i.TokenGT != nil {
		predicates = append(predicates, token.TokenGT(*i.TokenGT))
	}
	if i.TokenGTE != nil {
		predicates = append(predicates, token.TokenGTE(*i.TokenGTE))
	}
	if i.TokenLT != nil {
		predicates = append(predicates, token.TokenLT(*i.TokenLT))
	}
	if i.TokenLTE != nil {
		predicates = append(predicates, token.TokenLTE(*i.TokenLTE))
	}
	if i.TokenContains != nil {
		predicates = append(predicates, token.TokenContains(*i.TokenContains))
	}
	if i.TokenHasPrefix != nil {
		predicates = append(predicates, token.TokenHasPrefix(*i.TokenHasPrefix))
	}
	if i.TokenHasSuffix != nil {
		predicates = append(predicates, token.TokenHasSuffix(*i.TokenHasSuffix))
	}
	if i.TokenEqualFold != nil {
		predicates = append(predicates, token.TokenEqualFold(*i.TokenEqualFold))
	}
	if i.TokenContainsFold != nil {
		predicates = append(predicates, token.TokenContainsFold(*i.TokenContainsFold))
	}

	if i.HasCompany != nil {
		p := token.HasCompany()
		if !*i.HasCompany {
			p = token.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasCompanyWith) > 0 {
		with := make([]predicate.Company, 0, len(i.HasCompanyWith))
		for _, w := range i.HasCompanyWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasCompanyWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, token.HasCompanyWith(with...))
	}
	if i.HasUser != nil {
		p := token.HasUser()
		if !*i.HasUser {
			p = token.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasUserWith) > 0 {
		with := make([]predicate.User, 0, len(i.HasUserWith))
		for _, w := range i.HasUserWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasUserWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, token.HasUserWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyTokenWhereInput
	case 1:
		return predicates[0], nil
	default:
		return token.And(predicates...), nil
	}
}

// TreasuryWhereInput represents a where input for filtering Treasury queries.
type TreasuryWhereInput struct {
	Predicates []predicate.Treasury  `json:"-"`
	Not        *TreasuryWhereInput   `json:"not,omitempty"`
	Or         []*TreasuryWhereInput `json:"or,omitempty"`
	And        []*TreasuryWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "createdAt" field predicates.
	CreatedAt      *time.Time  `json:"createdat,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdatNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdatIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdatNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdatGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdatGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdatLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdatLTE,omitempty"`

	// "updatedAt" field predicates.
	UpdatedAt      *time.Time  `json:"updatedat,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedatNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedatIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedatNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedatGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedatGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedatLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedatLTE,omitempty"`

	// "deletedAt" field predicates.
	DeletedAt       *time.Time  `json:"deletedat,omitempty"`
	DeletedAtNEQ    *time.Time  `json:"deletedatNEQ,omitempty"`
	DeletedAtIn     []time.Time `json:"deletedatIn,omitempty"`
	DeletedAtNotIn  []time.Time `json:"deletedatNotIn,omitempty"`
	DeletedAtGT     *time.Time  `json:"deletedatGT,omitempty"`
	DeletedAtGTE    *time.Time  `json:"deletedatGTE,omitempty"`
	DeletedAtLT     *time.Time  `json:"deletedatLT,omitempty"`
	DeletedAtLTE    *time.Time  `json:"deletedatLTE,omitempty"`
	DeletedAtIsNil  bool        `json:"deletedatIsNil,omitempty"`
	DeletedAtNotNil bool        `json:"deletedatNotNil,omitempty"`

	// "accountNumber" field predicates.
	AccountNumber             *string  `json:"accountnumber,omitempty"`
	AccountNumberNEQ          *string  `json:"accountnumberNEQ,omitempty"`
	AccountNumberIn           []string `json:"accountnumberIn,omitempty"`
	AccountNumberNotIn        []string `json:"accountnumberNotIn,omitempty"`
	AccountNumberGT           *string  `json:"accountnumberGT,omitempty"`
	AccountNumberGTE          *string  `json:"accountnumberGTE,omitempty"`
	AccountNumberLT           *string  `json:"accountnumberLT,omitempty"`
	AccountNumberLTE          *string  `json:"accountnumberLTE,omitempty"`
	AccountNumberContains     *string  `json:"accountnumberContains,omitempty"`
	AccountNumberHasPrefix    *string  `json:"accountnumberHasPrefix,omitempty"`
	AccountNumberHasSuffix    *string  `json:"accountnumberHasSuffix,omitempty"`
	AccountNumberIsNil        bool     `json:"accountnumberIsNil,omitempty"`
	AccountNumberNotNil       bool     `json:"accountnumberNotNil,omitempty"`
	AccountNumberEqualFold    *string  `json:"accountnumberEqualFold,omitempty"`
	AccountNumberContainsFold *string  `json:"accountnumberContainsFold,omitempty"`

	// "balance" field predicates.
	Balance      *float64  `json:"balance,omitempty"`
	BalanceNEQ   *float64  `json:"balanceNEQ,omitempty"`
	BalanceIn    []float64 `json:"balanceIn,omitempty"`
	BalanceNotIn []float64 `json:"balanceNotIn,omitempty"`
	BalanceGT    *float64  `json:"balanceGT,omitempty"`
	BalanceGTE   *float64  `json:"balanceGTE,omitempty"`
	BalanceLT    *float64  `json:"balanceLT,omitempty"`
	BalanceLTE   *float64  `json:"balanceLTE,omitempty"`

	// "bankName" field predicates.
	BankName             *string  `json:"bankname,omitempty"`
	BankNameNEQ          *string  `json:"banknameNEQ,omitempty"`
	BankNameIn           []string `json:"banknameIn,omitempty"`
	BankNameNotIn        []string `json:"banknameNotIn,omitempty"`
	BankNameGT           *string  `json:"banknameGT,omitempty"`
	BankNameGTE          *string  `json:"banknameGTE,omitempty"`
	BankNameLT           *string  `json:"banknameLT,omitempty"`
	BankNameLTE          *string  `json:"banknameLTE,omitempty"`
	BankNameContains     *string  `json:"banknameContains,omitempty"`
	BankNameHasPrefix    *string  `json:"banknameHasPrefix,omitempty"`
	BankNameHasSuffix    *string  `json:"banknameHasSuffix,omitempty"`
	BankNameIsNil        bool     `json:"banknameIsNil,omitempty"`
	BankNameNotNil       bool     `json:"banknameNotNil,omitempty"`
	BankNameEqualFold    *string  `json:"banknameEqualFold,omitempty"`
	BankNameContainsFold *string  `json:"banknameContainsFold,omitempty"`

	// "currency" field predicates.
	Currency      *treasury.Currency  `json:"currency,omitempty"`
	CurrencyNEQ   *treasury.Currency  `json:"currencyNEQ,omitempty"`
	CurrencyIn    []treasury.Currency `json:"currencyIn,omitempty"`
	CurrencyNotIn []treasury.Currency `json:"currencyNotIn,omitempty"`

	// "description" field predicates.
	Description             *string  `json:"description,omitempty"`
	DescriptionNEQ          *string  `json:"descriptionNEQ,omitempty"`
	DescriptionIn           []string `json:"descriptionIn,omitempty"`
	DescriptionNotIn        []string `json:"descriptionNotIn,omitempty"`
	DescriptionGT           *string  `json:"descriptionGT,omitempty"`
	DescriptionGTE          *string  `json:"descriptionGTE,omitempty"`
	DescriptionLT           *string  `json:"descriptionLT,omitempty"`
	DescriptionLTE          *string  `json:"descriptionLTE,omitempty"`
	DescriptionContains     *string  `json:"descriptionContains,omitempty"`
	DescriptionHasPrefix    *string  `json:"descriptionHasPrefix,omitempty"`
	DescriptionHasSuffix    *string  `json:"descriptionHasSuffix,omitempty"`
	DescriptionIsNil        bool     `json:"descriptionIsNil,omitempty"`
	DescriptionNotNil       bool     `json:"descriptionNotNil,omitempty"`
	DescriptionEqualFold    *string  `json:"descriptionEqualFold,omitempty"`
	DescriptionContainsFold *string  `json:"descriptionContainsFold,omitempty"`

	// "iban" field predicates.
	Iban             *string  `json:"iban,omitempty"`
	IbanNEQ          *string  `json:"ibanNEQ,omitempty"`
	IbanIn           []string `json:"ibanIn,omitempty"`
	IbanNotIn        []string `json:"ibanNotIn,omitempty"`
	IbanGT           *string  `json:"ibanGT,omitempty"`
	IbanGTE          *string  `json:"ibanGTE,omitempty"`
	IbanLT           *string  `json:"ibanLT,omitempty"`
	IbanLTE          *string  `json:"ibanLTE,omitempty"`
	IbanContains     *string  `json:"ibanContains,omitempty"`
	IbanHasPrefix    *string  `json:"ibanHasPrefix,omitempty"`
	IbanHasSuffix    *string  `json:"ibanHasSuffix,omitempty"`
	IbanIsNil        bool     `json:"ibanIsNil,omitempty"`
	IbanNotNil       bool     `json:"ibanNotNil,omitempty"`
	IbanEqualFold    *string  `json:"ibanEqualFold,omitempty"`
	IbanContainsFold *string  `json:"ibanContainsFold,omitempty"`

	// "isDefault" field predicates.
	IsDefault       *bool `json:"isdefault,omitempty"`
	IsDefaultNEQ    *bool `json:"isdefaultNEQ,omitempty"`
	IsDefaultIsNil  bool  `json:"isdefaultIsNil,omitempty"`
	IsDefaultNotNil bool  `json:"isdefaultNotNil,omitempty"`

	// "isMainAccount" field predicates.
	IsMainAccount       *bool `json:"ismainaccount,omitempty"`
	IsMainAccountNEQ    *bool `json:"ismainaccountNEQ,omitempty"`
	IsMainAccountIsNil  bool  `json:"ismainaccountIsNil,omitempty"`
	IsMainAccountNotNil bool  `json:"ismainaccountNotNil,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "category" field predicates.
	Category      *treasury.Category  `json:"category,omitempty"`
	CategoryNEQ   *treasury.Category  `json:"categoryNEQ,omitempty"`
	CategoryIn    []treasury.Category `json:"categoryIn,omitempty"`
	CategoryNotIn []treasury.Category `json:"categoryNotIn,omitempty"`

	// "swiftCode" field predicates.
	SwiftCode             *string  `json:"swiftcode,omitempty"`
	SwiftCodeNEQ          *string  `json:"swiftcodeNEQ,omitempty"`
	SwiftCodeIn           []string `json:"swiftcodeIn,omitempty"`
	SwiftCodeNotIn        []string `json:"swiftcodeNotIn,omitempty"`
	SwiftCodeGT           *string  `json:"swiftcodeGT,omitempty"`
	SwiftCodeGTE          *string  `json:"swiftcodeGTE,omitempty"`
	SwiftCodeLT           *string  `json:"swiftcodeLT,omitempty"`
	SwiftCodeLTE          *string  `json:"swiftcodeLTE,omitempty"`
	SwiftCodeContains     *string  `json:"swiftcodeContains,omitempty"`
	SwiftCodeHasPrefix    *string  `json:"swiftcodeHasPrefix,omitempty"`
	SwiftCodeHasSuffix    *string  `json:"swiftcodeHasSuffix,omitempty"`
	SwiftCodeIsNil        bool     `json:"swiftcodeIsNil,omitempty"`
	SwiftCodeNotNil       bool     `json:"swiftcodeNotNil,omitempty"`
	SwiftCodeEqualFold    *string  `json:"swiftcodeEqualFold,omitempty"`
	SwiftCodeContainsFold *string  `json:"swiftcodeContainsFold,omitempty"`

	// "company" edge predicates.
	HasCompany     *bool                `json:"hasCompany,omitempty"`
	HasCompanyWith []*CompanyWhereInput `json:"hasCompanyWith,omitempty"`

	// "cashMovements" edge predicates.
	HasCashMovements     *bool                     `json:"hasCashMovements,omitempty"`
	HasCashMovementsWith []*CashMovementWhereInput `json:"hasCashMovementsWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *TreasuryWhereInput) AddPredicates(predicates ...predicate.Treasury) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the TreasuryWhereInput filter on the TreasuryQuery builder.
func (i *TreasuryWhereInput) Filter(q *TreasuryQuery) (*TreasuryQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyTreasuryWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyTreasuryWhereInput is returned in case the TreasuryWhereInput is empty.
var ErrEmptyTreasuryWhereInput = errors.New("generated: empty predicate TreasuryWhereInput")

// P returns a predicate for filtering treasuries.
// An error is returned if the input is empty or invalid.
func (i *TreasuryWhereInput) P() (predicate.Treasury, error) {
	var predicates []predicate.Treasury
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, treasury.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Treasury, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, treasury.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Treasury, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, treasury.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, treasury.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, treasury.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, treasury.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, treasury.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, treasury.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, treasury.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, treasury.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, treasury.IDLTE(*i.IDLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, treasury.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, treasury.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, treasury.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, treasury.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, treasury.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, treasury.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, treasury.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, treasury.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, treasury.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, treasury.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, treasury.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, treasury.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, treasury.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, treasury.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, treasury.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, treasury.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.DeletedAt != nil {
		predicates = append(predicates, treasury.DeletedAtEQ(*i.DeletedAt))
	}
	if i.DeletedAtNEQ != nil {
		predicates = append(predicates, treasury.DeletedAtNEQ(*i.DeletedAtNEQ))
	}
	if len(i.DeletedAtIn) > 0 {
		predicates = append(predicates, treasury.DeletedAtIn(i.DeletedAtIn...))
	}
	if len(i.DeletedAtNotIn) > 0 {
		predicates = append(predicates, treasury.DeletedAtNotIn(i.DeletedAtNotIn...))
	}
	if i.DeletedAtGT != nil {
		predicates = append(predicates, treasury.DeletedAtGT(*i.DeletedAtGT))
	}
	if i.DeletedAtGTE != nil {
		predicates = append(predicates, treasury.DeletedAtGTE(*i.DeletedAtGTE))
	}
	if i.DeletedAtLT != nil {
		predicates = append(predicates, treasury.DeletedAtLT(*i.DeletedAtLT))
	}
	if i.DeletedAtLTE != nil {
		predicates = append(predicates, treasury.DeletedAtLTE(*i.DeletedAtLTE))
	}
	if i.DeletedAtIsNil {
		predicates = append(predicates, treasury.DeletedAtIsNil())
	}
	if i.DeletedAtNotNil {
		predicates = append(predicates, treasury.DeletedAtNotNil())
	}
	if i.AccountNumber != nil {
		predicates = append(predicates, treasury.AccountNumberEQ(*i.AccountNumber))
	}
	if i.AccountNumberNEQ != nil {
		predicates = append(predicates, treasury.AccountNumberNEQ(*i.AccountNumberNEQ))
	}
	if len(i.AccountNumberIn) > 0 {
		predicates = append(predicates, treasury.AccountNumberIn(i.AccountNumberIn...))
	}
	if len(i.AccountNumberNotIn) > 0 {
		predicates = append(predicates, treasury.AccountNumberNotIn(i.AccountNumberNotIn...))
	}
	if i.AccountNumberGT != nil {
		predicates = append(predicates, treasury.AccountNumberGT(*i.AccountNumberGT))
	}
	if i.AccountNumberGTE != nil {
		predicates = append(predicates, treasury.AccountNumberGTE(*i.AccountNumberGTE))
	}
	if i.AccountNumberLT != nil {
		predicates = append(predicates, treasury.AccountNumberLT(*i.AccountNumberLT))
	}
	if i.AccountNumberLTE != nil {
		predicates = append(predicates, treasury.AccountNumberLTE(*i.AccountNumberLTE))
	}
	if i.AccountNumberContains != nil {
		predicates = append(predicates, treasury.AccountNumberContains(*i.AccountNumberContains))
	}
	if i.AccountNumberHasPrefix != nil {
		predicates = append(predicates, treasury.AccountNumberHasPrefix(*i.AccountNumberHasPrefix))
	}
	if i.AccountNumberHasSuffix != nil {
		predicates = append(predicates, treasury.AccountNumberHasSuffix(*i.AccountNumberHasSuffix))
	}
	if i.AccountNumberIsNil {
		predicates = append(predicates, treasury.AccountNumberIsNil())
	}
	if i.AccountNumberNotNil {
		predicates = append(predicates, treasury.AccountNumberNotNil())
	}
	if i.AccountNumberEqualFold != nil {
		predicates = append(predicates, treasury.AccountNumberEqualFold(*i.AccountNumberEqualFold))
	}
	if i.AccountNumberContainsFold != nil {
		predicates = append(predicates, treasury.AccountNumberContainsFold(*i.AccountNumberContainsFold))
	}
	if i.Balance != nil {
		predicates = append(predicates, treasury.BalanceEQ(*i.Balance))
	}
	if i.BalanceNEQ != nil {
		predicates = append(predicates, treasury.BalanceNEQ(*i.BalanceNEQ))
	}
	if len(i.BalanceIn) > 0 {
		predicates = append(predicates, treasury.BalanceIn(i.BalanceIn...))
	}
	if len(i.BalanceNotIn) > 0 {
		predicates = append(predicates, treasury.BalanceNotIn(i.BalanceNotIn...))
	}
	if i.BalanceGT != nil {
		predicates = append(predicates, treasury.BalanceGT(*i.BalanceGT))
	}
	if i.BalanceGTE != nil {
		predicates = append(predicates, treasury.BalanceGTE(*i.BalanceGTE))
	}
	if i.BalanceLT != nil {
		predicates = append(predicates, treasury.BalanceLT(*i.BalanceLT))
	}
	if i.BalanceLTE != nil {
		predicates = append(predicates, treasury.BalanceLTE(*i.BalanceLTE))
	}
	if i.BankName != nil {
		predicates = append(predicates, treasury.BankNameEQ(*i.BankName))
	}
	if i.BankNameNEQ != nil {
		predicates = append(predicates, treasury.BankNameNEQ(*i.BankNameNEQ))
	}
	if len(i.BankNameIn) > 0 {
		predicates = append(predicates, treasury.BankNameIn(i.BankNameIn...))
	}
	if len(i.BankNameNotIn) > 0 {
		predicates = append(predicates, treasury.BankNameNotIn(i.BankNameNotIn...))
	}
	if i.BankNameGT != nil {
		predicates = append(predicates, treasury.BankNameGT(*i.BankNameGT))
	}
	if i.BankNameGTE != nil {
		predicates = append(predicates, treasury.BankNameGTE(*i.BankNameGTE))
	}
	if i.BankNameLT != nil {
		predicates = append(predicates, treasury.BankNameLT(*i.BankNameLT))
	}
	if i.BankNameLTE != nil {
		predicates = append(predicates, treasury.BankNameLTE(*i.BankNameLTE))
	}
	if i.BankNameContains != nil {
		predicates = append(predicates, treasury.BankNameContains(*i.BankNameContains))
	}
	if i.BankNameHasPrefix != nil {
		predicates = append(predicates, treasury.BankNameHasPrefix(*i.BankNameHasPrefix))
	}
	if i.BankNameHasSuffix != nil {
		predicates = append(predicates, treasury.BankNameHasSuffix(*i.BankNameHasSuffix))
	}
	if i.BankNameIsNil {
		predicates = append(predicates, treasury.BankNameIsNil())
	}
	if i.BankNameNotNil {
		predicates = append(predicates, treasury.BankNameNotNil())
	}
	if i.BankNameEqualFold != nil {
		predicates = append(predicates, treasury.BankNameEqualFold(*i.BankNameEqualFold))
	}
	if i.BankNameContainsFold != nil {
		predicates = append(predicates, treasury.BankNameContainsFold(*i.BankNameContainsFold))
	}
	if i.Currency != nil {
		predicates = append(predicates, treasury.CurrencyEQ(*i.Currency))
	}
	if i.CurrencyNEQ != nil {
		predicates = append(predicates, treasury.CurrencyNEQ(*i.CurrencyNEQ))
	}
	if len(i.CurrencyIn) > 0 {
		predicates = append(predicates, treasury.CurrencyIn(i.CurrencyIn...))
	}
	if len(i.CurrencyNotIn) > 0 {
		predicates = append(predicates, treasury.CurrencyNotIn(i.CurrencyNotIn...))
	}
	if i.Description != nil {
		predicates = append(predicates, treasury.DescriptionEQ(*i.Description))
	}
	if i.DescriptionNEQ != nil {
		predicates = append(predicates, treasury.DescriptionNEQ(*i.DescriptionNEQ))
	}
	if len(i.DescriptionIn) > 0 {
		predicates = append(predicates, treasury.DescriptionIn(i.DescriptionIn...))
	}
	if len(i.DescriptionNotIn) > 0 {
		predicates = append(predicates, treasury.DescriptionNotIn(i.DescriptionNotIn...))
	}
	if i.DescriptionGT != nil {
		predicates = append(predicates, treasury.DescriptionGT(*i.DescriptionGT))
	}
	if i.DescriptionGTE != nil {
		predicates = append(predicates, treasury.DescriptionGTE(*i.DescriptionGTE))
	}
	if i.DescriptionLT != nil {
		predicates = append(predicates, treasury.DescriptionLT(*i.DescriptionLT))
	}
	if i.DescriptionLTE != nil {
		predicates = append(predicates, treasury.DescriptionLTE(*i.DescriptionLTE))
	}
	if i.DescriptionContains != nil {
		predicates = append(predicates, treasury.DescriptionContains(*i.DescriptionContains))
	}
	if i.DescriptionHasPrefix != nil {
		predicates = append(predicates, treasury.DescriptionHasPrefix(*i.DescriptionHasPrefix))
	}
	if i.DescriptionHasSuffix != nil {
		predicates = append(predicates, treasury.DescriptionHasSuffix(*i.DescriptionHasSuffix))
	}
	if i.DescriptionIsNil {
		predicates = append(predicates, treasury.DescriptionIsNil())
	}
	if i.DescriptionNotNil {
		predicates = append(predicates, treasury.DescriptionNotNil())
	}
	if i.DescriptionEqualFold != nil {
		predicates = append(predicates, treasury.DescriptionEqualFold(*i.DescriptionEqualFold))
	}
	if i.DescriptionContainsFold != nil {
		predicates = append(predicates, treasury.DescriptionContainsFold(*i.DescriptionContainsFold))
	}
	if i.Iban != nil {
		predicates = append(predicates, treasury.IbanEQ(*i.Iban))
	}
	if i.IbanNEQ != nil {
		predicates = append(predicates, treasury.IbanNEQ(*i.IbanNEQ))
	}
	if len(i.IbanIn) > 0 {
		predicates = append(predicates, treasury.IbanIn(i.IbanIn...))
	}
	if len(i.IbanNotIn) > 0 {
		predicates = append(predicates, treasury.IbanNotIn(i.IbanNotIn...))
	}
	if i.IbanGT != nil {
		predicates = append(predicates, treasury.IbanGT(*i.IbanGT))
	}
	if i.IbanGTE != nil {
		predicates = append(predicates, treasury.IbanGTE(*i.IbanGTE))
	}
	if i.IbanLT != nil {
		predicates = append(predicates, treasury.IbanLT(*i.IbanLT))
	}
	if i.IbanLTE != nil {
		predicates = append(predicates, treasury.IbanLTE(*i.IbanLTE))
	}
	if i.IbanContains != nil {
		predicates = append(predicates, treasury.IbanContains(*i.IbanContains))
	}
	if i.IbanHasPrefix != nil {
		predicates = append(predicates, treasury.IbanHasPrefix(*i.IbanHasPrefix))
	}
	if i.IbanHasSuffix != nil {
		predicates = append(predicates, treasury.IbanHasSuffix(*i.IbanHasSuffix))
	}
	if i.IbanIsNil {
		predicates = append(predicates, treasury.IbanIsNil())
	}
	if i.IbanNotNil {
		predicates = append(predicates, treasury.IbanNotNil())
	}
	if i.IbanEqualFold != nil {
		predicates = append(predicates, treasury.IbanEqualFold(*i.IbanEqualFold))
	}
	if i.IbanContainsFold != nil {
		predicates = append(predicates, treasury.IbanContainsFold(*i.IbanContainsFold))
	}
	if i.IsDefault != nil {
		predicates = append(predicates, treasury.IsDefaultEQ(*i.IsDefault))
	}
	if i.IsDefaultNEQ != nil {
		predicates = append(predicates, treasury.IsDefaultNEQ(*i.IsDefaultNEQ))
	}
	if i.IsDefaultIsNil {
		predicates = append(predicates, treasury.IsDefaultIsNil())
	}
	if i.IsDefaultNotNil {
		predicates = append(predicates, treasury.IsDefaultNotNil())
	}
	if i.IsMainAccount != nil {
		predicates = append(predicates, treasury.IsMainAccountEQ(*i.IsMainAccount))
	}
	if i.IsMainAccountNEQ != nil {
		predicates = append(predicates, treasury.IsMainAccountNEQ(*i.IsMainAccountNEQ))
	}
	if i.IsMainAccountIsNil {
		predicates = append(predicates, treasury.IsMainAccountIsNil())
	}
	if i.IsMainAccountNotNil {
		predicates = append(predicates, treasury.IsMainAccountNotNil())
	}
	if i.Name != nil {
		predicates = append(predicates, treasury.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, treasury.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, treasury.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, treasury.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, treasury.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, treasury.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, treasury.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, treasury.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, treasury.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, treasury.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, treasury.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, treasury.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, treasury.NameContainsFold(*i.NameContainsFold))
	}
	if i.Category != nil {
		predicates = append(predicates, treasury.CategoryEQ(*i.Category))
	}
	if i.CategoryNEQ != nil {
		predicates = append(predicates, treasury.CategoryNEQ(*i.CategoryNEQ))
	}
	if len(i.CategoryIn) > 0 {
		predicates = append(predicates, treasury.CategoryIn(i.CategoryIn...))
	}
	if len(i.CategoryNotIn) > 0 {
		predicates = append(predicates, treasury.CategoryNotIn(i.CategoryNotIn...))
	}
	if i.SwiftCode != nil {
		predicates = append(predicates, treasury.SwiftCodeEQ(*i.SwiftCode))
	}
	if i.SwiftCodeNEQ != nil {
		predicates = append(predicates, treasury.SwiftCodeNEQ(*i.SwiftCodeNEQ))
	}
	if len(i.SwiftCodeIn) > 0 {
		predicates = append(predicates, treasury.SwiftCodeIn(i.SwiftCodeIn...))
	}
	if len(i.SwiftCodeNotIn) > 0 {
		predicates = append(predicates, treasury.SwiftCodeNotIn(i.SwiftCodeNotIn...))
	}
	if i.SwiftCodeGT != nil {
		predicates = append(predicates, treasury.SwiftCodeGT(*i.SwiftCodeGT))
	}
	if i.SwiftCodeGTE != nil {
		predicates = append(predicates, treasury.SwiftCodeGTE(*i.SwiftCodeGTE))
	}
	if i.SwiftCodeLT != nil {
		predicates = append(predicates, treasury.SwiftCodeLT(*i.SwiftCodeLT))
	}
	if i.SwiftCodeLTE != nil {
		predicates = append(predicates, treasury.SwiftCodeLTE(*i.SwiftCodeLTE))
	}
	if i.SwiftCodeContains != nil {
		predicates = append(predicates, treasury.SwiftCodeContains(*i.SwiftCodeContains))
	}
	if i.SwiftCodeHasPrefix != nil {
		predicates = append(predicates, treasury.SwiftCodeHasPrefix(*i.SwiftCodeHasPrefix))
	}
	if i.SwiftCodeHasSuffix != nil {
		predicates = append(predicates, treasury.SwiftCodeHasSuffix(*i.SwiftCodeHasSuffix))
	}
	if i.SwiftCodeIsNil {
		predicates = append(predicates, treasury.SwiftCodeIsNil())
	}
	if i.SwiftCodeNotNil {
		predicates = append(predicates, treasury.SwiftCodeNotNil())
	}
	if i.SwiftCodeEqualFold != nil {
		predicates = append(predicates, treasury.SwiftCodeEqualFold(*i.SwiftCodeEqualFold))
	}
	if i.SwiftCodeContainsFold != nil {
		predicates = append(predicates, treasury.SwiftCodeContainsFold(*i.SwiftCodeContainsFold))
	}

	if i.HasCompany != nil {
		p := treasury.HasCompany()
		if !*i.HasCompany {
			p = treasury.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasCompanyWith) > 0 {
		with := make([]predicate.Company, 0, len(i.HasCompanyWith))
		for _, w := range i.HasCompanyWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasCompanyWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, treasury.HasCompanyWith(with...))
	}
	if i.HasCashMovements != nil {
		p := treasury.HasCashMovements()
		if !*i.HasCashMovements {
			p = treasury.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasCashMovementsWith) > 0 {
		with := make([]predicate.CashMovement, 0, len(i.HasCashMovementsWith))
		for _, w := range i.HasCashMovementsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasCashMovementsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, treasury.HasCashMovementsWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyTreasuryWhereInput
	case 1:
		return predicates[0], nil
	default:
		return treasury.And(predicates...), nil
	}
}

// UserWhereInput represents a where input for filtering User queries.
type UserWhereInput struct {
	Predicates []predicate.User  `json:"-"`
	Not        *UserWhereInput   `json:"not,omitempty"`
	Or         []*UserWhereInput `json:"or,omitempty"`
	And        []*UserWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "createdAt" field predicates.
	CreatedAt      *time.Time  `json:"createdat,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdatNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdatIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdatNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdatGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdatGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdatLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdatLTE,omitempty"`

	// "updatedAt" field predicates.
	UpdatedAt      *time.Time  `json:"updatedat,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedatNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedatIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedatNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedatGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedatGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedatLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedatLTE,omitempty"`

	// "deletedAt" field predicates.
	DeletedAt       *time.Time  `json:"deletedat,omitempty"`
	DeletedAtNEQ    *time.Time  `json:"deletedatNEQ,omitempty"`
	DeletedAtIn     []time.Time `json:"deletedatIn,omitempty"`
	DeletedAtNotIn  []time.Time `json:"deletedatNotIn,omitempty"`
	DeletedAtGT     *time.Time  `json:"deletedatGT,omitempty"`
	DeletedAtGTE    *time.Time  `json:"deletedatGTE,omitempty"`
	DeletedAtLT     *time.Time  `json:"deletedatLT,omitempty"`
	DeletedAtLTE    *time.Time  `json:"deletedatLTE,omitempty"`
	DeletedAtIsNil  bool        `json:"deletedatIsNil,omitempty"`
	DeletedAtNotNil bool        `json:"deletedatNotNil,omitempty"`

	// "fcmToken" field predicates.
	FcmToken             *string  `json:"fcmtoken,omitempty"`
	FcmTokenNEQ          *string  `json:"fcmtokenNEQ,omitempty"`
	FcmTokenIn           []string `json:"fcmtokenIn,omitempty"`
	FcmTokenNotIn        []string `json:"fcmtokenNotIn,omitempty"`
	FcmTokenGT           *string  `json:"fcmtokenGT,omitempty"`
	FcmTokenGTE          *string  `json:"fcmtokenGTE,omitempty"`
	FcmTokenLT           *string  `json:"fcmtokenLT,omitempty"`
	FcmTokenLTE          *string  `json:"fcmtokenLTE,omitempty"`
	FcmTokenContains     *string  `json:"fcmtokenContains,omitempty"`
	FcmTokenHasPrefix    *string  `json:"fcmtokenHasPrefix,omitempty"`
	FcmTokenHasSuffix    *string  `json:"fcmtokenHasSuffix,omitempty"`
	FcmTokenIsNil        bool     `json:"fcmtokenIsNil,omitempty"`
	FcmTokenNotNil       bool     `json:"fcmtokenNotNil,omitempty"`
	FcmTokenEqualFold    *string  `json:"fcmtokenEqualFold,omitempty"`
	FcmTokenContainsFold *string  `json:"fcmtokenContainsFold,omitempty"`

	// "email" field predicates.
	Email             *string  `json:"email,omitempty"`
	EmailNEQ          *string  `json:"emailNEQ,omitempty"`
	EmailIn           []string `json:"emailIn,omitempty"`
	EmailNotIn        []string `json:"emailNotIn,omitempty"`
	EmailGT           *string  `json:"emailGT,omitempty"`
	EmailGTE          *string  `json:"emailGTE,omitempty"`
	EmailLT           *string  `json:"emailLT,omitempty"`
	EmailLTE          *string  `json:"emailLTE,omitempty"`
	EmailContains     *string  `json:"emailContains,omitempty"`
	EmailHasPrefix    *string  `json:"emailHasPrefix,omitempty"`
	EmailHasSuffix    *string  `json:"emailHasSuffix,omitempty"`
	EmailIsNil        bool     `json:"emailIsNil,omitempty"`
	EmailNotNil       bool     `json:"emailNotNil,omitempty"`
	EmailEqualFold    *string  `json:"emailEqualFold,omitempty"`
	EmailContainsFold *string  `json:"emailContainsFold,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "password" field predicates.
	Password             *string  `json:"password,omitempty"`
	PasswordNEQ          *string  `json:"passwordNEQ,omitempty"`
	PasswordIn           []string `json:"passwordIn,omitempty"`
	PasswordNotIn        []string `json:"passwordNotIn,omitempty"`
	PasswordGT           *string  `json:"passwordGT,omitempty"`
	PasswordGTE          *string  `json:"passwordGTE,omitempty"`
	PasswordLT           *string  `json:"passwordLT,omitempty"`
	PasswordLTE          *string  `json:"passwordLTE,omitempty"`
	PasswordContains     *string  `json:"passwordContains,omitempty"`
	PasswordHasPrefix    *string  `json:"passwordHasPrefix,omitempty"`
	PasswordHasSuffix    *string  `json:"passwordHasSuffix,omitempty"`
	PasswordEqualFold    *string  `json:"passwordEqualFold,omitempty"`
	PasswordContainsFold *string  `json:"passwordContainsFold,omitempty"`

	// "username" field predicates.
	Username             *string  `json:"username,omitempty"`
	UsernameNEQ          *string  `json:"usernameNEQ,omitempty"`
	UsernameIn           []string `json:"usernameIn,omitempty"`
	UsernameNotIn        []string `json:"usernameNotIn,omitempty"`
	UsernameGT           *string  `json:"usernameGT,omitempty"`
	UsernameGTE          *string  `json:"usernameGTE,omitempty"`
	UsernameLT           *string  `json:"usernameLT,omitempty"`
	UsernameLTE          *string  `json:"usernameLTE,omitempty"`
	UsernameContains     *string  `json:"usernameContains,omitempty"`
	UsernameHasPrefix    *string  `json:"usernameHasPrefix,omitempty"`
	UsernameHasSuffix    *string  `json:"usernameHasSuffix,omitempty"`
	UsernameEqualFold    *string  `json:"usernameEqualFold,omitempty"`
	UsernameContainsFold *string  `json:"usernameContainsFold,omitempty"`

	// "disabled" field predicates.
	Disabled       *bool `json:"disabled,omitempty"`
	DisabledNEQ    *bool `json:"disabledNEQ,omitempty"`
	DisabledIsNil  bool  `json:"disabledIsNil,omitempty"`
	DisabledNotNil bool  `json:"disabledNotNil,omitempty"`

	// "notVerified" field predicates.
	NotVerified       *bool `json:"notverified,omitempty"`
	NotVerifiedNEQ    *bool `json:"notverifiedNEQ,omitempty"`
	NotVerifiedIsNil  bool  `json:"notverifiedIsNil,omitempty"`
	NotVerifiedNotNil bool  `json:"notverifiedNotNil,omitempty"`

	// "accountingEntries" edge predicates.
	HasAccountingEntries     *bool                        `json:"hasAccountingEntries,omitempty"`
	HasAccountingEntriesWith []*AccountingEntryWhereInput `json:"hasAccountingEntriesWith,omitempty"`

	// "company" edge predicates.
	HasCompany     *bool                `json:"hasCompany,omitempty"`
	HasCompanyWith []*CompanyWhereInput `json:"hasCompanyWith,omitempty"`

	// "assignedRoles" edge predicates.
	HasAssignedRoles     *bool                 `json:"hasAssignedRoles,omitempty"`
	HasAssignedRolesWith []*UserRoleWhereInput `json:"hasAssignedRolesWith,omitempty"`

	// "createdTasks" edge predicates.
	HasCreatedTasks     *bool                 `json:"hasCreatedTasks,omitempty"`
	HasCreatedTasksWith []*WorktaskWhereInput `json:"hasCreatedTasksWith,omitempty"`

	// "employee" edge predicates.
	HasEmployee     *bool                 `json:"hasEmployee,omitempty"`
	HasEmployeeWith []*EmployeeWhereInput `json:"hasEmployeeWith,omitempty"`

	// "tokens" edge predicates.
	HasTokens     *bool              `json:"hasTokens,omitempty"`
	HasTokensWith []*TokenWhereInput `json:"hasTokensWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *UserWhereInput) AddPredicates(predicates ...predicate.User) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the UserWhereInput filter on the UserQuery builder.
func (i *UserWhereInput) Filter(q *UserQuery) (*UserQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyUserWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyUserWhereInput is returned in case the UserWhereInput is empty.
var ErrEmptyUserWhereInput = errors.New("generated: empty predicate UserWhereInput")

// P returns a predicate for filtering users.
// An error is returned if the input is empty or invalid.
func (i *UserWhereInput) P() (predicate.User, error) {
	var predicates []predicate.User
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, user.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.User, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, user.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.User, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, user.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, user.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, user.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, user.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, user.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, user.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, user.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, user.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, user.IDLTE(*i.IDLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, user.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, user.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, user.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, user.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, user.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, user.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, user.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, user.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, user.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, user.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, user.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, user.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, user.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, user.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, user.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, user.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.DeletedAt != nil {
		predicates = append(predicates, user.DeletedAtEQ(*i.DeletedAt))
	}
	if i.DeletedAtNEQ != nil {
		predicates = append(predicates, user.DeletedAtNEQ(*i.DeletedAtNEQ))
	}
	if len(i.DeletedAtIn) > 0 {
		predicates = append(predicates, user.DeletedAtIn(i.DeletedAtIn...))
	}
	if len(i.DeletedAtNotIn) > 0 {
		predicates = append(predicates, user.DeletedAtNotIn(i.DeletedAtNotIn...))
	}
	if i.DeletedAtGT != nil {
		predicates = append(predicates, user.DeletedAtGT(*i.DeletedAtGT))
	}
	if i.DeletedAtGTE != nil {
		predicates = append(predicates, user.DeletedAtGTE(*i.DeletedAtGTE))
	}
	if i.DeletedAtLT != nil {
		predicates = append(predicates, user.DeletedAtLT(*i.DeletedAtLT))
	}
	if i.DeletedAtLTE != nil {
		predicates = append(predicates, user.DeletedAtLTE(*i.DeletedAtLTE))
	}
	if i.DeletedAtIsNil {
		predicates = append(predicates, user.DeletedAtIsNil())
	}
	if i.DeletedAtNotNil {
		predicates = append(predicates, user.DeletedAtNotNil())
	}
	if i.FcmToken != nil {
		predicates = append(predicates, user.FcmTokenEQ(*i.FcmToken))
	}
	if i.FcmTokenNEQ != nil {
		predicates = append(predicates, user.FcmTokenNEQ(*i.FcmTokenNEQ))
	}
	if len(i.FcmTokenIn) > 0 {
		predicates = append(predicates, user.FcmTokenIn(i.FcmTokenIn...))
	}
	if len(i.FcmTokenNotIn) > 0 {
		predicates = append(predicates, user.FcmTokenNotIn(i.FcmTokenNotIn...))
	}
	if i.FcmTokenGT != nil {
		predicates = append(predicates, user.FcmTokenGT(*i.FcmTokenGT))
	}
	if i.FcmTokenGTE != nil {
		predicates = append(predicates, user.FcmTokenGTE(*i.FcmTokenGTE))
	}
	if i.FcmTokenLT != nil {
		predicates = append(predicates, user.FcmTokenLT(*i.FcmTokenLT))
	}
	if i.FcmTokenLTE != nil {
		predicates = append(predicates, user.FcmTokenLTE(*i.FcmTokenLTE))
	}
	if i.FcmTokenContains != nil {
		predicates = append(predicates, user.FcmTokenContains(*i.FcmTokenContains))
	}
	if i.FcmTokenHasPrefix != nil {
		predicates = append(predicates, user.FcmTokenHasPrefix(*i.FcmTokenHasPrefix))
	}
	if i.FcmTokenHasSuffix != nil {
		predicates = append(predicates, user.FcmTokenHasSuffix(*i.FcmTokenHasSuffix))
	}
	if i.FcmTokenIsNil {
		predicates = append(predicates, user.FcmTokenIsNil())
	}
	if i.FcmTokenNotNil {
		predicates = append(predicates, user.FcmTokenNotNil())
	}
	if i.FcmTokenEqualFold != nil {
		predicates = append(predicates, user.FcmTokenEqualFold(*i.FcmTokenEqualFold))
	}
	if i.FcmTokenContainsFold != nil {
		predicates = append(predicates, user.FcmTokenContainsFold(*i.FcmTokenContainsFold))
	}
	if i.Email != nil {
		predicates = append(predicates, user.EmailEQ(*i.Email))
	}
	if i.EmailNEQ != nil {
		predicates = append(predicates, user.EmailNEQ(*i.EmailNEQ))
	}
	if len(i.EmailIn) > 0 {
		predicates = append(predicates, user.EmailIn(i.EmailIn...))
	}
	if len(i.EmailNotIn) > 0 {
		predicates = append(predicates, user.EmailNotIn(i.EmailNotIn...))
	}
	if i.EmailGT != nil {
		predicates = append(predicates, user.EmailGT(*i.EmailGT))
	}
	if i.EmailGTE != nil {
		predicates = append(predicates, user.EmailGTE(*i.EmailGTE))
	}
	if i.EmailLT != nil {
		predicates = append(predicates, user.EmailLT(*i.EmailLT))
	}
	if i.EmailLTE != nil {
		predicates = append(predicates, user.EmailLTE(*i.EmailLTE))
	}
	if i.EmailContains != nil {
		predicates = append(predicates, user.EmailContains(*i.EmailContains))
	}
	if i.EmailHasPrefix != nil {
		predicates = append(predicates, user.EmailHasPrefix(*i.EmailHasPrefix))
	}
	if i.EmailHasSuffix != nil {
		predicates = append(predicates, user.EmailHasSuffix(*i.EmailHasSuffix))
	}
	if i.EmailIsNil {
		predicates = append(predicates, user.EmailIsNil())
	}
	if i.EmailNotNil {
		predicates = append(predicates, user.EmailNotNil())
	}
	if i.EmailEqualFold != nil {
		predicates = append(predicates, user.EmailEqualFold(*i.EmailEqualFold))
	}
	if i.EmailContainsFold != nil {
		predicates = append(predicates, user.EmailContainsFold(*i.EmailContainsFold))
	}
	if i.Name != nil {
		predicates = append(predicates, user.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, user.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, user.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, user.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, user.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, user.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, user.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, user.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, user.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, user.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, user.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, user.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, user.NameContainsFold(*i.NameContainsFold))
	}
	if i.Password != nil {
		predicates = append(predicates, user.PasswordEQ(*i.Password))
	}
	if i.PasswordNEQ != nil {
		predicates = append(predicates, user.PasswordNEQ(*i.PasswordNEQ))
	}
	if len(i.PasswordIn) > 0 {
		predicates = append(predicates, user.PasswordIn(i.PasswordIn...))
	}
	if len(i.PasswordNotIn) > 0 {
		predicates = append(predicates, user.PasswordNotIn(i.PasswordNotIn...))
	}
	if i.PasswordGT != nil {
		predicates = append(predicates, user.PasswordGT(*i.PasswordGT))
	}
	if i.PasswordGTE != nil {
		predicates = append(predicates, user.PasswordGTE(*i.PasswordGTE))
	}
	if i.PasswordLT != nil {
		predicates = append(predicates, user.PasswordLT(*i.PasswordLT))
	}
	if i.PasswordLTE != nil {
		predicates = append(predicates, user.PasswordLTE(*i.PasswordLTE))
	}
	if i.PasswordContains != nil {
		predicates = append(predicates, user.PasswordContains(*i.PasswordContains))
	}
	if i.PasswordHasPrefix != nil {
		predicates = append(predicates, user.PasswordHasPrefix(*i.PasswordHasPrefix))
	}
	if i.PasswordHasSuffix != nil {
		predicates = append(predicates, user.PasswordHasSuffix(*i.PasswordHasSuffix))
	}
	if i.PasswordEqualFold != nil {
		predicates = append(predicates, user.PasswordEqualFold(*i.PasswordEqualFold))
	}
	if i.PasswordContainsFold != nil {
		predicates = append(predicates, user.PasswordContainsFold(*i.PasswordContainsFold))
	}
	if i.Username != nil {
		predicates = append(predicates, user.UsernameEQ(*i.Username))
	}
	if i.UsernameNEQ != nil {
		predicates = append(predicates, user.UsernameNEQ(*i.UsernameNEQ))
	}
	if len(i.UsernameIn) > 0 {
		predicates = append(predicates, user.UsernameIn(i.UsernameIn...))
	}
	if len(i.UsernameNotIn) > 0 {
		predicates = append(predicates, user.UsernameNotIn(i.UsernameNotIn...))
	}
	if i.UsernameGT != nil {
		predicates = append(predicates, user.UsernameGT(*i.UsernameGT))
	}
	if i.UsernameGTE != nil {
		predicates = append(predicates, user.UsernameGTE(*i.UsernameGTE))
	}
	if i.UsernameLT != nil {
		predicates = append(predicates, user.UsernameLT(*i.UsernameLT))
	}
	if i.UsernameLTE != nil {
		predicates = append(predicates, user.UsernameLTE(*i.UsernameLTE))
	}
	if i.UsernameContains != nil {
		predicates = append(predicates, user.UsernameContains(*i.UsernameContains))
	}
	if i.UsernameHasPrefix != nil {
		predicates = append(predicates, user.UsernameHasPrefix(*i.UsernameHasPrefix))
	}
	if i.UsernameHasSuffix != nil {
		predicates = append(predicates, user.UsernameHasSuffix(*i.UsernameHasSuffix))
	}
	if i.UsernameEqualFold != nil {
		predicates = append(predicates, user.UsernameEqualFold(*i.UsernameEqualFold))
	}
	if i.UsernameContainsFold != nil {
		predicates = append(predicates, user.UsernameContainsFold(*i.UsernameContainsFold))
	}
	if i.Disabled != nil {
		predicates = append(predicates, user.DisabledEQ(*i.Disabled))
	}
	if i.DisabledNEQ != nil {
		predicates = append(predicates, user.DisabledNEQ(*i.DisabledNEQ))
	}
	if i.DisabledIsNil {
		predicates = append(predicates, user.DisabledIsNil())
	}
	if i.DisabledNotNil {
		predicates = append(predicates, user.DisabledNotNil())
	}
	if i.NotVerified != nil {
		predicates = append(predicates, user.NotVerifiedEQ(*i.NotVerified))
	}
	if i.NotVerifiedNEQ != nil {
		predicates = append(predicates, user.NotVerifiedNEQ(*i.NotVerifiedNEQ))
	}
	if i.NotVerifiedIsNil {
		predicates = append(predicates, user.NotVerifiedIsNil())
	}
	if i.NotVerifiedNotNil {
		predicates = append(predicates, user.NotVerifiedNotNil())
	}

	if i.HasAccountingEntries != nil {
		p := user.HasAccountingEntries()
		if !*i.HasAccountingEntries {
			p = user.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasAccountingEntriesWith) > 0 {
		with := make([]predicate.AccountingEntry, 0, len(i.HasAccountingEntriesWith))
		for _, w := range i.HasAccountingEntriesWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasAccountingEntriesWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, user.HasAccountingEntriesWith(with...))
	}
	if i.HasCompany != nil {
		p := user.HasCompany()
		if !*i.HasCompany {
			p = user.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasCompanyWith) > 0 {
		with := make([]predicate.Company, 0, len(i.HasCompanyWith))
		for _, w := range i.HasCompanyWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasCompanyWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, user.HasCompanyWith(with...))
	}
	if i.HasAssignedRoles != nil {
		p := user.HasAssignedRoles()
		if !*i.HasAssignedRoles {
			p = user.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasAssignedRolesWith) > 0 {
		with := make([]predicate.UserRole, 0, len(i.HasAssignedRolesWith))
		for _, w := range i.HasAssignedRolesWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasAssignedRolesWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, user.HasAssignedRolesWith(with...))
	}
	if i.HasCreatedTasks != nil {
		p := user.HasCreatedTasks()
		if !*i.HasCreatedTasks {
			p = user.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasCreatedTasksWith) > 0 {
		with := make([]predicate.Worktask, 0, len(i.HasCreatedTasksWith))
		for _, w := range i.HasCreatedTasksWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasCreatedTasksWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, user.HasCreatedTasksWith(with...))
	}
	if i.HasEmployee != nil {
		p := user.HasEmployee()
		if !*i.HasEmployee {
			p = user.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasEmployeeWith) > 0 {
		with := make([]predicate.Employee, 0, len(i.HasEmployeeWith))
		for _, w := range i.HasEmployeeWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasEmployeeWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, user.HasEmployeeWith(with...))
	}
	if i.HasTokens != nil {
		p := user.HasTokens()
		if !*i.HasTokens {
			p = user.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasTokensWith) > 0 {
		with := make([]predicate.Token, 0, len(i.HasTokensWith))
		for _, w := range i.HasTokensWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasTokensWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, user.HasTokensWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyUserWhereInput
	case 1:
		return predicates[0], nil
	default:
		return user.And(predicates...), nil
	}
}

// UserRoleWhereInput represents a where input for filtering UserRole queries.
type UserRoleWhereInput struct {
	Predicates []predicate.UserRole  `json:"-"`
	Not        *UserRoleWhereInput   `json:"not,omitempty"`
	Or         []*UserRoleWhereInput `json:"or,omitempty"`
	And        []*UserRoleWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "role" field predicates.
	Role      *userrole.Role  `json:"role,omitempty"`
	RoleNEQ   *userrole.Role  `json:"roleNEQ,omitempty"`
	RoleIn    []userrole.Role `json:"roleIn,omitempty"`
	RoleNotIn []userrole.Role `json:"roleNotIn,omitempty"`

	// "company" edge predicates.
	HasCompany     *bool                `json:"hasCompany,omitempty"`
	HasCompanyWith []*CompanyWhereInput `json:"hasCompanyWith,omitempty"`

	// "user" edge predicates.
	HasUser     *bool             `json:"hasUser,omitempty"`
	HasUserWith []*UserWhereInput `json:"hasUserWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *UserRoleWhereInput) AddPredicates(predicates ...predicate.UserRole) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the UserRoleWhereInput filter on the UserRoleQuery builder.
func (i *UserRoleWhereInput) Filter(q *UserRoleQuery) (*UserRoleQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyUserRoleWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyUserRoleWhereInput is returned in case the UserRoleWhereInput is empty.
var ErrEmptyUserRoleWhereInput = errors.New("generated: empty predicate UserRoleWhereInput")

// P returns a predicate for filtering userroles.
// An error is returned if the input is empty or invalid.
func (i *UserRoleWhereInput) P() (predicate.UserRole, error) {
	var predicates []predicate.UserRole
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, userrole.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.UserRole, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, userrole.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.UserRole, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, userrole.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, userrole.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, userrole.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, userrole.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, userrole.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, userrole.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, userrole.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, userrole.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, userrole.IDLTE(*i.IDLTE))
	}
	if i.Role != nil {
		predicates = append(predicates, userrole.RoleEQ(*i.Role))
	}
	if i.RoleNEQ != nil {
		predicates = append(predicates, userrole.RoleNEQ(*i.RoleNEQ))
	}
	if len(i.RoleIn) > 0 {
		predicates = append(predicates, userrole.RoleIn(i.RoleIn...))
	}
	if len(i.RoleNotIn) > 0 {
		predicates = append(predicates, userrole.RoleNotIn(i.RoleNotIn...))
	}

	if i.HasCompany != nil {
		p := userrole.HasCompany()
		if !*i.HasCompany {
			p = userrole.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasCompanyWith) > 0 {
		with := make([]predicate.Company, 0, len(i.HasCompanyWith))
		for _, w := range i.HasCompanyWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasCompanyWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, userrole.HasCompanyWith(with...))
	}
	if i.HasUser != nil {
		p := userrole.HasUser()
		if !*i.HasUser {
			p = userrole.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasUserWith) > 0 {
		with := make([]predicate.User, 0, len(i.HasUserWith))
		for _, w := range i.HasUserWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasUserWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, userrole.HasUserWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyUserRoleWhereInput
	case 1:
		return predicates[0], nil
	default:
		return userrole.And(predicates...), nil
	}
}

// WorkshiftWhereInput represents a where input for filtering Workshift queries.
type WorkshiftWhereInput struct {
	Predicates []predicate.Workshift  `json:"-"`
	Not        *WorkshiftWhereInput   `json:"not,omitempty"`
	Or         []*WorkshiftWhereInput `json:"or,omitempty"`
	And        []*WorkshiftWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "createdAt" field predicates.
	CreatedAt      *time.Time  `json:"createdat,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdatNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdatIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdatNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdatGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdatGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdatLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdatLTE,omitempty"`

	// "updatedAt" field predicates.
	UpdatedAt      *time.Time  `json:"updatedat,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedatNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedatIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedatNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedatGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedatGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedatLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedatLTE,omitempty"`

	// "deletedAt" field predicates.
	DeletedAt       *time.Time  `json:"deletedat,omitempty"`
	DeletedAtNEQ    *time.Time  `json:"deletedatNEQ,omitempty"`
	DeletedAtIn     []time.Time `json:"deletedatIn,omitempty"`
	DeletedAtNotIn  []time.Time `json:"deletedatNotIn,omitempty"`
	DeletedAtGT     *time.Time  `json:"deletedatGT,omitempty"`
	DeletedAtGTE    *time.Time  `json:"deletedatGTE,omitempty"`
	DeletedAtLT     *time.Time  `json:"deletedatLT,omitempty"`
	DeletedAtLTE    *time.Time  `json:"deletedatLTE,omitempty"`
	DeletedAtIsNil  bool        `json:"deletedatIsNil,omitempty"`
	DeletedAtNotNil bool        `json:"deletedatNotNil,omitempty"`

	// "approvedAt" field predicates.
	ApprovedAt       *time.Time  `json:"approvedat,omitempty"`
	ApprovedAtNEQ    *time.Time  `json:"approvedatNEQ,omitempty"`
	ApprovedAtIn     []time.Time `json:"approvedatIn,omitempty"`
	ApprovedAtNotIn  []time.Time `json:"approvedatNotIn,omitempty"`
	ApprovedAtGT     *time.Time  `json:"approvedatGT,omitempty"`
	ApprovedAtGTE    *time.Time  `json:"approvedatGTE,omitempty"`
	ApprovedAtLT     *time.Time  `json:"approvedatLT,omitempty"`
	ApprovedAtLTE    *time.Time  `json:"approvedatLTE,omitempty"`
	ApprovedAtIsNil  bool        `json:"approvedatIsNil,omitempty"`
	ApprovedAtNotNil bool        `json:"approvedatNotNil,omitempty"`

	// "clockIn" field predicates.
	ClockIn      *time.Time  `json:"clockin,omitempty"`
	ClockInNEQ   *time.Time  `json:"clockinNEQ,omitempty"`
	ClockInIn    []time.Time `json:"clockinIn,omitempty"`
	ClockInNotIn []time.Time `json:"clockinNotIn,omitempty"`
	ClockInGT    *time.Time  `json:"clockinGT,omitempty"`
	ClockInGTE   *time.Time  `json:"clockinGTE,omitempty"`
	ClockInLT    *time.Time  `json:"clockinLT,omitempty"`
	ClockInLTE   *time.Time  `json:"clockinLTE,omitempty"`

	// "clockOut" field predicates.
	ClockOut       *time.Time  `json:"clockout,omitempty"`
	ClockOutNEQ    *time.Time  `json:"clockoutNEQ,omitempty"`
	ClockOutIn     []time.Time `json:"clockoutIn,omitempty"`
	ClockOutNotIn  []time.Time `json:"clockoutNotIn,omitempty"`
	ClockOutGT     *time.Time  `json:"clockoutGT,omitempty"`
	ClockOutGTE    *time.Time  `json:"clockoutGTE,omitempty"`
	ClockOutLT     *time.Time  `json:"clockoutLT,omitempty"`
	ClockOutLTE    *time.Time  `json:"clockoutLTE,omitempty"`
	ClockOutIsNil  bool        `json:"clockoutIsNil,omitempty"`
	ClockOutNotNil bool        `json:"clockoutNotNil,omitempty"`

	// "clockInLocation" field predicates.
	ClockInLocation             *string  `json:"clockinlocation,omitempty"`
	ClockInLocationNEQ          *string  `json:"clockinlocationNEQ,omitempty"`
	ClockInLocationIn           []string `json:"clockinlocationIn,omitempty"`
	ClockInLocationNotIn        []string `json:"clockinlocationNotIn,omitempty"`
	ClockInLocationGT           *string  `json:"clockinlocationGT,omitempty"`
	ClockInLocationGTE          *string  `json:"clockinlocationGTE,omitempty"`
	ClockInLocationLT           *string  `json:"clockinlocationLT,omitempty"`
	ClockInLocationLTE          *string  `json:"clockinlocationLTE,omitempty"`
	ClockInLocationContains     *string  `json:"clockinlocationContains,omitempty"`
	ClockInLocationHasPrefix    *string  `json:"clockinlocationHasPrefix,omitempty"`
	ClockInLocationHasSuffix    *string  `json:"clockinlocationHasSuffix,omitempty"`
	ClockInLocationEqualFold    *string  `json:"clockinlocationEqualFold,omitempty"`
	ClockInLocationContainsFold *string  `json:"clockinlocationContainsFold,omitempty"`

	// "clockOutLocation" field predicates.
	ClockOutLocation             *string  `json:"clockoutlocation,omitempty"`
	ClockOutLocationNEQ          *string  `json:"clockoutlocationNEQ,omitempty"`
	ClockOutLocationIn           []string `json:"clockoutlocationIn,omitempty"`
	ClockOutLocationNotIn        []string `json:"clockoutlocationNotIn,omitempty"`
	ClockOutLocationGT           *string  `json:"clockoutlocationGT,omitempty"`
	ClockOutLocationGTE          *string  `json:"clockoutlocationGTE,omitempty"`
	ClockOutLocationLT           *string  `json:"clockoutlocationLT,omitempty"`
	ClockOutLocationLTE          *string  `json:"clockoutlocationLTE,omitempty"`
	ClockOutLocationContains     *string  `json:"clockoutlocationContains,omitempty"`
	ClockOutLocationHasPrefix    *string  `json:"clockoutlocationHasPrefix,omitempty"`
	ClockOutLocationHasSuffix    *string  `json:"clockoutlocationHasSuffix,omitempty"`
	ClockOutLocationIsNil        bool     `json:"clockoutlocationIsNil,omitempty"`
	ClockOutLocationNotNil       bool     `json:"clockoutlocationNotNil,omitempty"`
	ClockOutLocationEqualFold    *string  `json:"clockoutlocationEqualFold,omitempty"`
	ClockOutLocationContainsFold *string  `json:"clockoutlocationContainsFold,omitempty"`

	// "description" field predicates.
	Description             *string  `json:"description,omitempty"`
	DescriptionNEQ          *string  `json:"descriptionNEQ,omitempty"`
	DescriptionIn           []string `json:"descriptionIn,omitempty"`
	DescriptionNotIn        []string `json:"descriptionNotIn,omitempty"`
	DescriptionGT           *string  `json:"descriptionGT,omitempty"`
	DescriptionGTE          *string  `json:"descriptionGTE,omitempty"`
	DescriptionLT           *string  `json:"descriptionLT,omitempty"`
	DescriptionLTE          *string  `json:"descriptionLTE,omitempty"`
	DescriptionContains     *string  `json:"descriptionContains,omitempty"`
	DescriptionHasPrefix    *string  `json:"descriptionHasPrefix,omitempty"`
	DescriptionHasSuffix    *string  `json:"descriptionHasSuffix,omitempty"`
	DescriptionIsNil        bool     `json:"descriptionIsNil,omitempty"`
	DescriptionNotNil       bool     `json:"descriptionNotNil,omitempty"`
	DescriptionEqualFold    *string  `json:"descriptionEqualFold,omitempty"`
	DescriptionContainsFold *string  `json:"descriptionContainsFold,omitempty"`

	// "note" field predicates.
	Note             *string  `json:"note,omitempty"`
	NoteNEQ          *string  `json:"noteNEQ,omitempty"`
	NoteIn           []string `json:"noteIn,omitempty"`
	NoteNotIn        []string `json:"noteNotIn,omitempty"`
	NoteGT           *string  `json:"noteGT,omitempty"`
	NoteGTE          *string  `json:"noteGTE,omitempty"`
	NoteLT           *string  `json:"noteLT,omitempty"`
	NoteLTE          *string  `json:"noteLTE,omitempty"`
	NoteContains     *string  `json:"noteContains,omitempty"`
	NoteHasPrefix    *string  `json:"noteHasPrefix,omitempty"`
	NoteHasSuffix    *string  `json:"noteHasSuffix,omitempty"`
	NoteIsNil        bool     `json:"noteIsNil,omitempty"`
	NoteNotNil       bool     `json:"noteNotNil,omitempty"`
	NoteEqualFold    *string  `json:"noteEqualFold,omitempty"`
	NoteContainsFold *string  `json:"noteContainsFold,omitempty"`

	// "status" field predicates.
	Status      *workshift.Status  `json:"status,omitempty"`
	StatusNEQ   *workshift.Status  `json:"statusNEQ,omitempty"`
	StatusIn    []workshift.Status `json:"statusIn,omitempty"`
	StatusNotIn []workshift.Status `json:"statusNotIn,omitempty"`

	// "company" edge predicates.
	HasCompany     *bool                `json:"hasCompany,omitempty"`
	HasCompanyWith []*CompanyWhereInput `json:"hasCompanyWith,omitempty"`

	// "employee" edge predicates.
	HasEmployee     *bool                 `json:"hasEmployee,omitempty"`
	HasEmployeeWith []*EmployeeWhereInput `json:"hasEmployeeWith,omitempty"`

	// "approvedBy" edge predicates.
	HasApprovedBy     *bool                 `json:"hasApprovedBy,omitempty"`
	HasApprovedByWith []*EmployeeWhereInput `json:"hasApprovedByWith,omitempty"`

	// "workTask" edge predicates.
	HasWorkTask     *bool                 `json:"hasWorkTask,omitempty"`
	HasWorkTaskWith []*WorktaskWhereInput `json:"hasWorkTaskWith,omitempty"`

	// "editRequest" edge predicates.
	HasEditRequest     *bool                  `json:"hasEditRequest,omitempty"`
	HasEditRequestWith []*WorkshiftWhereInput `json:"hasEditRequestWith,omitempty"`

	// "workShift" edge predicates.
	HasWorkShift     *bool                  `json:"hasWorkShift,omitempty"`
	HasWorkShiftWith []*WorkshiftWhereInput `json:"hasWorkShiftWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *WorkshiftWhereInput) AddPredicates(predicates ...predicate.Workshift) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the WorkshiftWhereInput filter on the WorkshiftQuery builder.
func (i *WorkshiftWhereInput) Filter(q *WorkshiftQuery) (*WorkshiftQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyWorkshiftWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyWorkshiftWhereInput is returned in case the WorkshiftWhereInput is empty.
var ErrEmptyWorkshiftWhereInput = errors.New("generated: empty predicate WorkshiftWhereInput")

// P returns a predicate for filtering workshifts.
// An error is returned if the input is empty or invalid.
func (i *WorkshiftWhereInput) P() (predicate.Workshift, error) {
	var predicates []predicate.Workshift
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, workshift.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Workshift, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, workshift.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Workshift, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, workshift.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, workshift.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, workshift.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, workshift.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, workshift.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, workshift.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, workshift.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, workshift.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, workshift.IDLTE(*i.IDLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, workshift.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, workshift.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, workshift.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, workshift.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, workshift.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, workshift.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, workshift.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, workshift.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, workshift.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, workshift.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, workshift.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, workshift.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, workshift.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, workshift.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, workshift.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, workshift.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.DeletedAt != nil {
		predicates = append(predicates, workshift.DeletedAtEQ(*i.DeletedAt))
	}
	if i.DeletedAtNEQ != nil {
		predicates = append(predicates, workshift.DeletedAtNEQ(*i.DeletedAtNEQ))
	}
	if len(i.DeletedAtIn) > 0 {
		predicates = append(predicates, workshift.DeletedAtIn(i.DeletedAtIn...))
	}
	if len(i.DeletedAtNotIn) > 0 {
		predicates = append(predicates, workshift.DeletedAtNotIn(i.DeletedAtNotIn...))
	}
	if i.DeletedAtGT != nil {
		predicates = append(predicates, workshift.DeletedAtGT(*i.DeletedAtGT))
	}
	if i.DeletedAtGTE != nil {
		predicates = append(predicates, workshift.DeletedAtGTE(*i.DeletedAtGTE))
	}
	if i.DeletedAtLT != nil {
		predicates = append(predicates, workshift.DeletedAtLT(*i.DeletedAtLT))
	}
	if i.DeletedAtLTE != nil {
		predicates = append(predicates, workshift.DeletedAtLTE(*i.DeletedAtLTE))
	}
	if i.DeletedAtIsNil {
		predicates = append(predicates, workshift.DeletedAtIsNil())
	}
	if i.DeletedAtNotNil {
		predicates = append(predicates, workshift.DeletedAtNotNil())
	}
	if i.ApprovedAt != nil {
		predicates = append(predicates, workshift.ApprovedAtEQ(*i.ApprovedAt))
	}
	if i.ApprovedAtNEQ != nil {
		predicates = append(predicates, workshift.ApprovedAtNEQ(*i.ApprovedAtNEQ))
	}
	if len(i.ApprovedAtIn) > 0 {
		predicates = append(predicates, workshift.ApprovedAtIn(i.ApprovedAtIn...))
	}
	if len(i.ApprovedAtNotIn) > 0 {
		predicates = append(predicates, workshift.ApprovedAtNotIn(i.ApprovedAtNotIn...))
	}
	if i.ApprovedAtGT != nil {
		predicates = append(predicates, workshift.ApprovedAtGT(*i.ApprovedAtGT))
	}
	if i.ApprovedAtGTE != nil {
		predicates = append(predicates, workshift.ApprovedAtGTE(*i.ApprovedAtGTE))
	}
	if i.ApprovedAtLT != nil {
		predicates = append(predicates, workshift.ApprovedAtLT(*i.ApprovedAtLT))
	}
	if i.ApprovedAtLTE != nil {
		predicates = append(predicates, workshift.ApprovedAtLTE(*i.ApprovedAtLTE))
	}
	if i.ApprovedAtIsNil {
		predicates = append(predicates, workshift.ApprovedAtIsNil())
	}
	if i.ApprovedAtNotNil {
		predicates = append(predicates, workshift.ApprovedAtNotNil())
	}
	if i.ClockIn != nil {
		predicates = append(predicates, workshift.ClockInEQ(*i.ClockIn))
	}
	if i.ClockInNEQ != nil {
		predicates = append(predicates, workshift.ClockInNEQ(*i.ClockInNEQ))
	}
	if len(i.ClockInIn) > 0 {
		predicates = append(predicates, workshift.ClockInIn(i.ClockInIn...))
	}
	if len(i.ClockInNotIn) > 0 {
		predicates = append(predicates, workshift.ClockInNotIn(i.ClockInNotIn...))
	}
	if i.ClockInGT != nil {
		predicates = append(predicates, workshift.ClockInGT(*i.ClockInGT))
	}
	if i.ClockInGTE != nil {
		predicates = append(predicates, workshift.ClockInGTE(*i.ClockInGTE))
	}
	if i.ClockInLT != nil {
		predicates = append(predicates, workshift.ClockInLT(*i.ClockInLT))
	}
	if i.ClockInLTE != nil {
		predicates = append(predicates, workshift.ClockInLTE(*i.ClockInLTE))
	}
	if i.ClockOut != nil {
		predicates = append(predicates, workshift.ClockOutEQ(*i.ClockOut))
	}
	if i.ClockOutNEQ != nil {
		predicates = append(predicates, workshift.ClockOutNEQ(*i.ClockOutNEQ))
	}
	if len(i.ClockOutIn) > 0 {
		predicates = append(predicates, workshift.ClockOutIn(i.ClockOutIn...))
	}
	if len(i.ClockOutNotIn) > 0 {
		predicates = append(predicates, workshift.ClockOutNotIn(i.ClockOutNotIn...))
	}
	if i.ClockOutGT != nil {
		predicates = append(predicates, workshift.ClockOutGT(*i.ClockOutGT))
	}
	if i.ClockOutGTE != nil {
		predicates = append(predicates, workshift.ClockOutGTE(*i.ClockOutGTE))
	}
	if i.ClockOutLT != nil {
		predicates = append(predicates, workshift.ClockOutLT(*i.ClockOutLT))
	}
	if i.ClockOutLTE != nil {
		predicates = append(predicates, workshift.ClockOutLTE(*i.ClockOutLTE))
	}
	if i.ClockOutIsNil {
		predicates = append(predicates, workshift.ClockOutIsNil())
	}
	if i.ClockOutNotNil {
		predicates = append(predicates, workshift.ClockOutNotNil())
	}
	if i.ClockInLocation != nil {
		predicates = append(predicates, workshift.ClockInLocationEQ(*i.ClockInLocation))
	}
	if i.ClockInLocationNEQ != nil {
		predicates = append(predicates, workshift.ClockInLocationNEQ(*i.ClockInLocationNEQ))
	}
	if len(i.ClockInLocationIn) > 0 {
		predicates = append(predicates, workshift.ClockInLocationIn(i.ClockInLocationIn...))
	}
	if len(i.ClockInLocationNotIn) > 0 {
		predicates = append(predicates, workshift.ClockInLocationNotIn(i.ClockInLocationNotIn...))
	}
	if i.ClockInLocationGT != nil {
		predicates = append(predicates, workshift.ClockInLocationGT(*i.ClockInLocationGT))
	}
	if i.ClockInLocationGTE != nil {
		predicates = append(predicates, workshift.ClockInLocationGTE(*i.ClockInLocationGTE))
	}
	if i.ClockInLocationLT != nil {
		predicates = append(predicates, workshift.ClockInLocationLT(*i.ClockInLocationLT))
	}
	if i.ClockInLocationLTE != nil {
		predicates = append(predicates, workshift.ClockInLocationLTE(*i.ClockInLocationLTE))
	}
	if i.ClockInLocationContains != nil {
		predicates = append(predicates, workshift.ClockInLocationContains(*i.ClockInLocationContains))
	}
	if i.ClockInLocationHasPrefix != nil {
		predicates = append(predicates, workshift.ClockInLocationHasPrefix(*i.ClockInLocationHasPrefix))
	}
	if i.ClockInLocationHasSuffix != nil {
		predicates = append(predicates, workshift.ClockInLocationHasSuffix(*i.ClockInLocationHasSuffix))
	}
	if i.ClockInLocationEqualFold != nil {
		predicates = append(predicates, workshift.ClockInLocationEqualFold(*i.ClockInLocationEqualFold))
	}
	if i.ClockInLocationContainsFold != nil {
		predicates = append(predicates, workshift.ClockInLocationContainsFold(*i.ClockInLocationContainsFold))
	}
	if i.ClockOutLocation != nil {
		predicates = append(predicates, workshift.ClockOutLocationEQ(*i.ClockOutLocation))
	}
	if i.ClockOutLocationNEQ != nil {
		predicates = append(predicates, workshift.ClockOutLocationNEQ(*i.ClockOutLocationNEQ))
	}
	if len(i.ClockOutLocationIn) > 0 {
		predicates = append(predicates, workshift.ClockOutLocationIn(i.ClockOutLocationIn...))
	}
	if len(i.ClockOutLocationNotIn) > 0 {
		predicates = append(predicates, workshift.ClockOutLocationNotIn(i.ClockOutLocationNotIn...))
	}
	if i.ClockOutLocationGT != nil {
		predicates = append(predicates, workshift.ClockOutLocationGT(*i.ClockOutLocationGT))
	}
	if i.ClockOutLocationGTE != nil {
		predicates = append(predicates, workshift.ClockOutLocationGTE(*i.ClockOutLocationGTE))
	}
	if i.ClockOutLocationLT != nil {
		predicates = append(predicates, workshift.ClockOutLocationLT(*i.ClockOutLocationLT))
	}
	if i.ClockOutLocationLTE != nil {
		predicates = append(predicates, workshift.ClockOutLocationLTE(*i.ClockOutLocationLTE))
	}
	if i.ClockOutLocationContains != nil {
		predicates = append(predicates, workshift.ClockOutLocationContains(*i.ClockOutLocationContains))
	}
	if i.ClockOutLocationHasPrefix != nil {
		predicates = append(predicates, workshift.ClockOutLocationHasPrefix(*i.ClockOutLocationHasPrefix))
	}
	if i.ClockOutLocationHasSuffix != nil {
		predicates = append(predicates, workshift.ClockOutLocationHasSuffix(*i.ClockOutLocationHasSuffix))
	}
	if i.ClockOutLocationIsNil {
		predicates = append(predicates, workshift.ClockOutLocationIsNil())
	}
	if i.ClockOutLocationNotNil {
		predicates = append(predicates, workshift.ClockOutLocationNotNil())
	}
	if i.ClockOutLocationEqualFold != nil {
		predicates = append(predicates, workshift.ClockOutLocationEqualFold(*i.ClockOutLocationEqualFold))
	}
	if i.ClockOutLocationContainsFold != nil {
		predicates = append(predicates, workshift.ClockOutLocationContainsFold(*i.ClockOutLocationContainsFold))
	}
	if i.Description != nil {
		predicates = append(predicates, workshift.DescriptionEQ(*i.Description))
	}
	if i.DescriptionNEQ != nil {
		predicates = append(predicates, workshift.DescriptionNEQ(*i.DescriptionNEQ))
	}
	if len(i.DescriptionIn) > 0 {
		predicates = append(predicates, workshift.DescriptionIn(i.DescriptionIn...))
	}
	if len(i.DescriptionNotIn) > 0 {
		predicates = append(predicates, workshift.DescriptionNotIn(i.DescriptionNotIn...))
	}
	if i.DescriptionGT != nil {
		predicates = append(predicates, workshift.DescriptionGT(*i.DescriptionGT))
	}
	if i.DescriptionGTE != nil {
		predicates = append(predicates, workshift.DescriptionGTE(*i.DescriptionGTE))
	}
	if i.DescriptionLT != nil {
		predicates = append(predicates, workshift.DescriptionLT(*i.DescriptionLT))
	}
	if i.DescriptionLTE != nil {
		predicates = append(predicates, workshift.DescriptionLTE(*i.DescriptionLTE))
	}
	if i.DescriptionContains != nil {
		predicates = append(predicates, workshift.DescriptionContains(*i.DescriptionContains))
	}
	if i.DescriptionHasPrefix != nil {
		predicates = append(predicates, workshift.DescriptionHasPrefix(*i.DescriptionHasPrefix))
	}
	if i.DescriptionHasSuffix != nil {
		predicates = append(predicates, workshift.DescriptionHasSuffix(*i.DescriptionHasSuffix))
	}
	if i.DescriptionIsNil {
		predicates = append(predicates, workshift.DescriptionIsNil())
	}
	if i.DescriptionNotNil {
		predicates = append(predicates, workshift.DescriptionNotNil())
	}
	if i.DescriptionEqualFold != nil {
		predicates = append(predicates, workshift.DescriptionEqualFold(*i.DescriptionEqualFold))
	}
	if i.DescriptionContainsFold != nil {
		predicates = append(predicates, workshift.DescriptionContainsFold(*i.DescriptionContainsFold))
	}
	if i.Note != nil {
		predicates = append(predicates, workshift.NoteEQ(*i.Note))
	}
	if i.NoteNEQ != nil {
		predicates = append(predicates, workshift.NoteNEQ(*i.NoteNEQ))
	}
	if len(i.NoteIn) > 0 {
		predicates = append(predicates, workshift.NoteIn(i.NoteIn...))
	}
	if len(i.NoteNotIn) > 0 {
		predicates = append(predicates, workshift.NoteNotIn(i.NoteNotIn...))
	}
	if i.NoteGT != nil {
		predicates = append(predicates, workshift.NoteGT(*i.NoteGT))
	}
	if i.NoteGTE != nil {
		predicates = append(predicates, workshift.NoteGTE(*i.NoteGTE))
	}
	if i.NoteLT != nil {
		predicates = append(predicates, workshift.NoteLT(*i.NoteLT))
	}
	if i.NoteLTE != nil {
		predicates = append(predicates, workshift.NoteLTE(*i.NoteLTE))
	}
	if i.NoteContains != nil {
		predicates = append(predicates, workshift.NoteContains(*i.NoteContains))
	}
	if i.NoteHasPrefix != nil {
		predicates = append(predicates, workshift.NoteHasPrefix(*i.NoteHasPrefix))
	}
	if i.NoteHasSuffix != nil {
		predicates = append(predicates, workshift.NoteHasSuffix(*i.NoteHasSuffix))
	}
	if i.NoteIsNil {
		predicates = append(predicates, workshift.NoteIsNil())
	}
	if i.NoteNotNil {
		predicates = append(predicates, workshift.NoteNotNil())
	}
	if i.NoteEqualFold != nil {
		predicates = append(predicates, workshift.NoteEqualFold(*i.NoteEqualFold))
	}
	if i.NoteContainsFold != nil {
		predicates = append(predicates, workshift.NoteContainsFold(*i.NoteContainsFold))
	}
	if i.Status != nil {
		predicates = append(predicates, workshift.StatusEQ(*i.Status))
	}
	if i.StatusNEQ != nil {
		predicates = append(predicates, workshift.StatusNEQ(*i.StatusNEQ))
	}
	if len(i.StatusIn) > 0 {
		predicates = append(predicates, workshift.StatusIn(i.StatusIn...))
	}
	if len(i.StatusNotIn) > 0 {
		predicates = append(predicates, workshift.StatusNotIn(i.StatusNotIn...))
	}

	if i.HasCompany != nil {
		p := workshift.HasCompany()
		if !*i.HasCompany {
			p = workshift.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasCompanyWith) > 0 {
		with := make([]predicate.Company, 0, len(i.HasCompanyWith))
		for _, w := range i.HasCompanyWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasCompanyWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, workshift.HasCompanyWith(with...))
	}
	if i.HasEmployee != nil {
		p := workshift.HasEmployee()
		if !*i.HasEmployee {
			p = workshift.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasEmployeeWith) > 0 {
		with := make([]predicate.Employee, 0, len(i.HasEmployeeWith))
		for _, w := range i.HasEmployeeWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasEmployeeWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, workshift.HasEmployeeWith(with...))
	}
	if i.HasApprovedBy != nil {
		p := workshift.HasApprovedBy()
		if !*i.HasApprovedBy {
			p = workshift.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasApprovedByWith) > 0 {
		with := make([]predicate.Employee, 0, len(i.HasApprovedByWith))
		for _, w := range i.HasApprovedByWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasApprovedByWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, workshift.HasApprovedByWith(with...))
	}
	if i.HasWorkTask != nil {
		p := workshift.HasWorkTask()
		if !*i.HasWorkTask {
			p = workshift.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasWorkTaskWith) > 0 {
		with := make([]predicate.Worktask, 0, len(i.HasWorkTaskWith))
		for _, w := range i.HasWorkTaskWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasWorkTaskWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, workshift.HasWorkTaskWith(with...))
	}
	if i.HasEditRequest != nil {
		p := workshift.HasEditRequest()
		if !*i.HasEditRequest {
			p = workshift.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasEditRequestWith) > 0 {
		with := make([]predicate.Workshift, 0, len(i.HasEditRequestWith))
		for _, w := range i.HasEditRequestWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasEditRequestWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, workshift.HasEditRequestWith(with...))
	}
	if i.HasWorkShift != nil {
		p := workshift.HasWorkShift()
		if !*i.HasWorkShift {
			p = workshift.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasWorkShiftWith) > 0 {
		with := make([]predicate.Workshift, 0, len(i.HasWorkShiftWith))
		for _, w := range i.HasWorkShiftWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasWorkShiftWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, workshift.HasWorkShiftWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyWorkshiftWhereInput
	case 1:
		return predicates[0], nil
	default:
		return workshift.And(predicates...), nil
	}
}

// WorktagWhereInput represents a where input for filtering Worktag queries.
type WorktagWhereInput struct {
	Predicates []predicate.Worktag  `json:"-"`
	Not        *WorktagWhereInput   `json:"not,omitempty"`
	Or         []*WorktagWhereInput `json:"or,omitempty"`
	And        []*WorktagWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "createdAt" field predicates.
	CreatedAt      *time.Time  `json:"createdat,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdatNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdatIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdatNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdatGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdatGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdatLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdatLTE,omitempty"`

	// "updatedAt" field predicates.
	UpdatedAt      *time.Time  `json:"updatedat,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedatNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedatIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedatNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedatGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedatGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedatLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedatLTE,omitempty"`

	// "deletedAt" field predicates.
	DeletedAt       *time.Time  `json:"deletedat,omitempty"`
	DeletedAtNEQ    *time.Time  `json:"deletedatNEQ,omitempty"`
	DeletedAtIn     []time.Time `json:"deletedatIn,omitempty"`
	DeletedAtNotIn  []time.Time `json:"deletedatNotIn,omitempty"`
	DeletedAtGT     *time.Time  `json:"deletedatGT,omitempty"`
	DeletedAtGTE    *time.Time  `json:"deletedatGTE,omitempty"`
	DeletedAtLT     *time.Time  `json:"deletedatLT,omitempty"`
	DeletedAtLTE    *time.Time  `json:"deletedatLTE,omitempty"`
	DeletedAtIsNil  bool        `json:"deletedatIsNil,omitempty"`
	DeletedAtNotNil bool        `json:"deletedatNotNil,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "color" field predicates.
	Color             *string  `json:"color,omitempty"`
	ColorNEQ          *string  `json:"colorNEQ,omitempty"`
	ColorIn           []string `json:"colorIn,omitempty"`
	ColorNotIn        []string `json:"colorNotIn,omitempty"`
	ColorGT           *string  `json:"colorGT,omitempty"`
	ColorGTE          *string  `json:"colorGTE,omitempty"`
	ColorLT           *string  `json:"colorLT,omitempty"`
	ColorLTE          *string  `json:"colorLTE,omitempty"`
	ColorContains     *string  `json:"colorContains,omitempty"`
	ColorHasPrefix    *string  `json:"colorHasPrefix,omitempty"`
	ColorHasSuffix    *string  `json:"colorHasSuffix,omitempty"`
	ColorEqualFold    *string  `json:"colorEqualFold,omitempty"`
	ColorContainsFold *string  `json:"colorContainsFold,omitempty"`

	// "company" edge predicates.
	HasCompany     *bool                `json:"hasCompany,omitempty"`
	HasCompanyWith []*CompanyWhereInput `json:"hasCompanyWith,omitempty"`

	// "workTasks" edge predicates.
	HasWorkTasks     *bool                 `json:"hasWorkTasks,omitempty"`
	HasWorkTasksWith []*WorktaskWhereInput `json:"hasWorkTasksWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *WorktagWhereInput) AddPredicates(predicates ...predicate.Worktag) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the WorktagWhereInput filter on the WorktagQuery builder.
func (i *WorktagWhereInput) Filter(q *WorktagQuery) (*WorktagQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyWorktagWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyWorktagWhereInput is returned in case the WorktagWhereInput is empty.
var ErrEmptyWorktagWhereInput = errors.New("generated: empty predicate WorktagWhereInput")

// P returns a predicate for filtering worktags.
// An error is returned if the input is empty or invalid.
func (i *WorktagWhereInput) P() (predicate.Worktag, error) {
	var predicates []predicate.Worktag
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, worktag.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Worktag, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, worktag.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Worktag, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, worktag.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, worktag.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, worktag.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, worktag.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, worktag.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, worktag.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, worktag.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, worktag.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, worktag.IDLTE(*i.IDLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, worktag.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, worktag.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, worktag.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, worktag.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, worktag.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, worktag.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, worktag.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, worktag.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, worktag.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, worktag.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, worktag.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, worktag.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, worktag.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, worktag.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, worktag.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, worktag.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.DeletedAt != nil {
		predicates = append(predicates, worktag.DeletedAtEQ(*i.DeletedAt))
	}
	if i.DeletedAtNEQ != nil {
		predicates = append(predicates, worktag.DeletedAtNEQ(*i.DeletedAtNEQ))
	}
	if len(i.DeletedAtIn) > 0 {
		predicates = append(predicates, worktag.DeletedAtIn(i.DeletedAtIn...))
	}
	if len(i.DeletedAtNotIn) > 0 {
		predicates = append(predicates, worktag.DeletedAtNotIn(i.DeletedAtNotIn...))
	}
	if i.DeletedAtGT != nil {
		predicates = append(predicates, worktag.DeletedAtGT(*i.DeletedAtGT))
	}
	if i.DeletedAtGTE != nil {
		predicates = append(predicates, worktag.DeletedAtGTE(*i.DeletedAtGTE))
	}
	if i.DeletedAtLT != nil {
		predicates = append(predicates, worktag.DeletedAtLT(*i.DeletedAtLT))
	}
	if i.DeletedAtLTE != nil {
		predicates = append(predicates, worktag.DeletedAtLTE(*i.DeletedAtLTE))
	}
	if i.DeletedAtIsNil {
		predicates = append(predicates, worktag.DeletedAtIsNil())
	}
	if i.DeletedAtNotNil {
		predicates = append(predicates, worktag.DeletedAtNotNil())
	}
	if i.Name != nil {
		predicates = append(predicates, worktag.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, worktag.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, worktag.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, worktag.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, worktag.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, worktag.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, worktag.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, worktag.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, worktag.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, worktag.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, worktag.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, worktag.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, worktag.NameContainsFold(*i.NameContainsFold))
	}
	if i.Color != nil {
		predicates = append(predicates, worktag.ColorEQ(*i.Color))
	}
	if i.ColorNEQ != nil {
		predicates = append(predicates, worktag.ColorNEQ(*i.ColorNEQ))
	}
	if len(i.ColorIn) > 0 {
		predicates = append(predicates, worktag.ColorIn(i.ColorIn...))
	}
	if len(i.ColorNotIn) > 0 {
		predicates = append(predicates, worktag.ColorNotIn(i.ColorNotIn...))
	}
	if i.ColorGT != nil {
		predicates = append(predicates, worktag.ColorGT(*i.ColorGT))
	}
	if i.ColorGTE != nil {
		predicates = append(predicates, worktag.ColorGTE(*i.ColorGTE))
	}
	if i.ColorLT != nil {
		predicates = append(predicates, worktag.ColorLT(*i.ColorLT))
	}
	if i.ColorLTE != nil {
		predicates = append(predicates, worktag.ColorLTE(*i.ColorLTE))
	}
	if i.ColorContains != nil {
		predicates = append(predicates, worktag.ColorContains(*i.ColorContains))
	}
	if i.ColorHasPrefix != nil {
		predicates = append(predicates, worktag.ColorHasPrefix(*i.ColorHasPrefix))
	}
	if i.ColorHasSuffix != nil {
		predicates = append(predicates, worktag.ColorHasSuffix(*i.ColorHasSuffix))
	}
	if i.ColorEqualFold != nil {
		predicates = append(predicates, worktag.ColorEqualFold(*i.ColorEqualFold))
	}
	if i.ColorContainsFold != nil {
		predicates = append(predicates, worktag.ColorContainsFold(*i.ColorContainsFold))
	}

	if i.HasCompany != nil {
		p := worktag.HasCompany()
		if !*i.HasCompany {
			p = worktag.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasCompanyWith) > 0 {
		with := make([]predicate.Company, 0, len(i.HasCompanyWith))
		for _, w := range i.HasCompanyWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasCompanyWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, worktag.HasCompanyWith(with...))
	}
	if i.HasWorkTasks != nil {
		p := worktag.HasWorkTasks()
		if !*i.HasWorkTasks {
			p = worktag.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasWorkTasksWith) > 0 {
		with := make([]predicate.Worktask, 0, len(i.HasWorkTasksWith))
		for _, w := range i.HasWorkTasksWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasWorkTasksWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, worktag.HasWorkTasksWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyWorktagWhereInput
	case 1:
		return predicates[0], nil
	default:
		return worktag.And(predicates...), nil
	}
}

// WorktaskWhereInput represents a where input for filtering Worktask queries.
type WorktaskWhereInput struct {
	Predicates []predicate.Worktask  `json:"-"`
	Not        *WorktaskWhereInput   `json:"not,omitempty"`
	Or         []*WorktaskWhereInput `json:"or,omitempty"`
	And        []*WorktaskWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "createdAt" field predicates.
	CreatedAt      *time.Time  `json:"createdat,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdatNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdatIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdatNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdatGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdatGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdatLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdatLTE,omitempty"`

	// "updatedAt" field predicates.
	UpdatedAt      *time.Time  `json:"updatedat,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedatNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedatIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedatNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedatGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedatGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedatLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedatLTE,omitempty"`

	// "deletedAt" field predicates.
	DeletedAt       *time.Time  `json:"deletedat,omitempty"`
	DeletedAtNEQ    *time.Time  `json:"deletedatNEQ,omitempty"`
	DeletedAtIn     []time.Time `json:"deletedatIn,omitempty"`
	DeletedAtNotIn  []time.Time `json:"deletedatNotIn,omitempty"`
	DeletedAtGT     *time.Time  `json:"deletedatGT,omitempty"`
	DeletedAtGTE    *time.Time  `json:"deletedatGTE,omitempty"`
	DeletedAtLT     *time.Time  `json:"deletedatLT,omitempty"`
	DeletedAtLTE    *time.Time  `json:"deletedatLTE,omitempty"`
	DeletedAtIsNil  bool        `json:"deletedatIsNil,omitempty"`
	DeletedAtNotNil bool        `json:"deletedatNotNil,omitempty"`

	// "description" field predicates.
	Description             *string  `json:"description,omitempty"`
	DescriptionNEQ          *string  `json:"descriptionNEQ,omitempty"`
	DescriptionIn           []string `json:"descriptionIn,omitempty"`
	DescriptionNotIn        []string `json:"descriptionNotIn,omitempty"`
	DescriptionGT           *string  `json:"descriptionGT,omitempty"`
	DescriptionGTE          *string  `json:"descriptionGTE,omitempty"`
	DescriptionLT           *string  `json:"descriptionLT,omitempty"`
	DescriptionLTE          *string  `json:"descriptionLTE,omitempty"`
	DescriptionContains     *string  `json:"descriptionContains,omitempty"`
	DescriptionHasPrefix    *string  `json:"descriptionHasPrefix,omitempty"`
	DescriptionHasSuffix    *string  `json:"descriptionHasSuffix,omitempty"`
	DescriptionIsNil        bool     `json:"descriptionIsNil,omitempty"`
	DescriptionNotNil       bool     `json:"descriptionNotNil,omitempty"`
	DescriptionEqualFold    *string  `json:"descriptionEqualFold,omitempty"`
	DescriptionContainsFold *string  `json:"descriptionContainsFold,omitempty"`

	// "status" field predicates.
	Status      *worktask.Status  `json:"status,omitempty"`
	StatusNEQ   *worktask.Status  `json:"statusNEQ,omitempty"`
	StatusIn    []worktask.Status `json:"statusIn,omitempty"`
	StatusNotIn []worktask.Status `json:"statusNotIn,omitempty"`

	// "title" field predicates.
	Title             *string  `json:"title,omitempty"`
	TitleNEQ          *string  `json:"titleNEQ,omitempty"`
	TitleIn           []string `json:"titleIn,omitempty"`
	TitleNotIn        []string `json:"titleNotIn,omitempty"`
	TitleGT           *string  `json:"titleGT,omitempty"`
	TitleGTE          *string  `json:"titleGTE,omitempty"`
	TitleLT           *string  `json:"titleLT,omitempty"`
	TitleLTE          *string  `json:"titleLTE,omitempty"`
	TitleContains     *string  `json:"titleContains,omitempty"`
	TitleHasPrefix    *string  `json:"titleHasPrefix,omitempty"`
	TitleHasSuffix    *string  `json:"titleHasSuffix,omitempty"`
	TitleEqualFold    *string  `json:"titleEqualFold,omitempty"`
	TitleContainsFold *string  `json:"titleContainsFold,omitempty"`

	// "startTime" field predicates.
	StartTime      *time.Time  `json:"starttime,omitempty"`
	StartTimeNEQ   *time.Time  `json:"starttimeNEQ,omitempty"`
	StartTimeIn    []time.Time `json:"starttimeIn,omitempty"`
	StartTimeNotIn []time.Time `json:"starttimeNotIn,omitempty"`
	StartTimeGT    *time.Time  `json:"starttimeGT,omitempty"`
	StartTimeGTE   *time.Time  `json:"starttimeGTE,omitempty"`
	StartTimeLT    *time.Time  `json:"starttimeLT,omitempty"`
	StartTimeLTE   *time.Time  `json:"starttimeLTE,omitempty"`

	// "endTime" field predicates.
	EndTime       *time.Time  `json:"endtime,omitempty"`
	EndTimeNEQ    *time.Time  `json:"endtimeNEQ,omitempty"`
	EndTimeIn     []time.Time `json:"endtimeIn,omitempty"`
	EndTimeNotIn  []time.Time `json:"endtimeNotIn,omitempty"`
	EndTimeGT     *time.Time  `json:"endtimeGT,omitempty"`
	EndTimeGTE    *time.Time  `json:"endtimeGTE,omitempty"`
	EndTimeLT     *time.Time  `json:"endtimeLT,omitempty"`
	EndTimeLTE    *time.Time  `json:"endtimeLTE,omitempty"`
	EndTimeIsNil  bool        `json:"endtimeIsNil,omitempty"`
	EndTimeNotNil bool        `json:"endtimeNotNil,omitempty"`

	// "company" edge predicates.
	HasCompany     *bool                `json:"hasCompany,omitempty"`
	HasCompanyWith []*CompanyWhereInput `json:"hasCompanyWith,omitempty"`

	// "createdBy" edge predicates.
	HasCreatedBy     *bool             `json:"hasCreatedBy,omitempty"`
	HasCreatedByWith []*UserWhereInput `json:"hasCreatedByWith,omitempty"`

	// "assignedTo" edge predicates.
	HasAssignedTo     *bool                 `json:"hasAssignedTo,omitempty"`
	HasAssignedToWith []*EmployeeWhereInput `json:"hasAssignedToWith,omitempty"`

	// "workShifts" edge predicates.
	HasWorkShifts     *bool                  `json:"hasWorkShifts,omitempty"`
	HasWorkShiftsWith []*WorkshiftWhereInput `json:"hasWorkShiftsWith,omitempty"`

	// "workTags" edge predicates.
	HasWorkTags     *bool                `json:"hasWorkTags,omitempty"`
	HasWorkTagsWith []*WorktagWhereInput `json:"hasWorkTagsWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *WorktaskWhereInput) AddPredicates(predicates ...predicate.Worktask) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the WorktaskWhereInput filter on the WorktaskQuery builder.
func (i *WorktaskWhereInput) Filter(q *WorktaskQuery) (*WorktaskQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyWorktaskWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyWorktaskWhereInput is returned in case the WorktaskWhereInput is empty.
var ErrEmptyWorktaskWhereInput = errors.New("generated: empty predicate WorktaskWhereInput")

// P returns a predicate for filtering worktasks.
// An error is returned if the input is empty or invalid.
func (i *WorktaskWhereInput) P() (predicate.Worktask, error) {
	var predicates []predicate.Worktask
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, worktask.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Worktask, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, worktask.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Worktask, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, worktask.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, worktask.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, worktask.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, worktask.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, worktask.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, worktask.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, worktask.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, worktask.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, worktask.IDLTE(*i.IDLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, worktask.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, worktask.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, worktask.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, worktask.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, worktask.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, worktask.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, worktask.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, worktask.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, worktask.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, worktask.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, worktask.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, worktask.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, worktask.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, worktask.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, worktask.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, worktask.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.DeletedAt != nil {
		predicates = append(predicates, worktask.DeletedAtEQ(*i.DeletedAt))
	}
	if i.DeletedAtNEQ != nil {
		predicates = append(predicates, worktask.DeletedAtNEQ(*i.DeletedAtNEQ))
	}
	if len(i.DeletedAtIn) > 0 {
		predicates = append(predicates, worktask.DeletedAtIn(i.DeletedAtIn...))
	}
	if len(i.DeletedAtNotIn) > 0 {
		predicates = append(predicates, worktask.DeletedAtNotIn(i.DeletedAtNotIn...))
	}
	if i.DeletedAtGT != nil {
		predicates = append(predicates, worktask.DeletedAtGT(*i.DeletedAtGT))
	}
	if i.DeletedAtGTE != nil {
		predicates = append(predicates, worktask.DeletedAtGTE(*i.DeletedAtGTE))
	}
	if i.DeletedAtLT != nil {
		predicates = append(predicates, worktask.DeletedAtLT(*i.DeletedAtLT))
	}
	if i.DeletedAtLTE != nil {
		predicates = append(predicates, worktask.DeletedAtLTE(*i.DeletedAtLTE))
	}
	if i.DeletedAtIsNil {
		predicates = append(predicates, worktask.DeletedAtIsNil())
	}
	if i.DeletedAtNotNil {
		predicates = append(predicates, worktask.DeletedAtNotNil())
	}
	if i.Description != nil {
		predicates = append(predicates, worktask.DescriptionEQ(*i.Description))
	}
	if i.DescriptionNEQ != nil {
		predicates = append(predicates, worktask.DescriptionNEQ(*i.DescriptionNEQ))
	}
	if len(i.DescriptionIn) > 0 {
		predicates = append(predicates, worktask.DescriptionIn(i.DescriptionIn...))
	}
	if len(i.DescriptionNotIn) > 0 {
		predicates = append(predicates, worktask.DescriptionNotIn(i.DescriptionNotIn...))
	}
	if i.DescriptionGT != nil {
		predicates = append(predicates, worktask.DescriptionGT(*i.DescriptionGT))
	}
	if i.DescriptionGTE != nil {
		predicates = append(predicates, worktask.DescriptionGTE(*i.DescriptionGTE))
	}
	if i.DescriptionLT != nil {
		predicates = append(predicates, worktask.DescriptionLT(*i.DescriptionLT))
	}
	if i.DescriptionLTE != nil {
		predicates = append(predicates, worktask.DescriptionLTE(*i.DescriptionLTE))
	}
	if i.DescriptionContains != nil {
		predicates = append(predicates, worktask.DescriptionContains(*i.DescriptionContains))
	}
	if i.DescriptionHasPrefix != nil {
		predicates = append(predicates, worktask.DescriptionHasPrefix(*i.DescriptionHasPrefix))
	}
	if i.DescriptionHasSuffix != nil {
		predicates = append(predicates, worktask.DescriptionHasSuffix(*i.DescriptionHasSuffix))
	}
	if i.DescriptionIsNil {
		predicates = append(predicates, worktask.DescriptionIsNil())
	}
	if i.DescriptionNotNil {
		predicates = append(predicates, worktask.DescriptionNotNil())
	}
	if i.DescriptionEqualFold != nil {
		predicates = append(predicates, worktask.DescriptionEqualFold(*i.DescriptionEqualFold))
	}
	if i.DescriptionContainsFold != nil {
		predicates = append(predicates, worktask.DescriptionContainsFold(*i.DescriptionContainsFold))
	}
	if i.Status != nil {
		predicates = append(predicates, worktask.StatusEQ(*i.Status))
	}
	if i.StatusNEQ != nil {
		predicates = append(predicates, worktask.StatusNEQ(*i.StatusNEQ))
	}
	if len(i.StatusIn) > 0 {
		predicates = append(predicates, worktask.StatusIn(i.StatusIn...))
	}
	if len(i.StatusNotIn) > 0 {
		predicates = append(predicates, worktask.StatusNotIn(i.StatusNotIn...))
	}
	if i.Title != nil {
		predicates = append(predicates, worktask.TitleEQ(*i.Title))
	}
	if i.TitleNEQ != nil {
		predicates = append(predicates, worktask.TitleNEQ(*i.TitleNEQ))
	}
	if len(i.TitleIn) > 0 {
		predicates = append(predicates, worktask.TitleIn(i.TitleIn...))
	}
	if len(i.TitleNotIn) > 0 {
		predicates = append(predicates, worktask.TitleNotIn(i.TitleNotIn...))
	}
	if i.TitleGT != nil {
		predicates = append(predicates, worktask.TitleGT(*i.TitleGT))
	}
	if i.TitleGTE != nil {
		predicates = append(predicates, worktask.TitleGTE(*i.TitleGTE))
	}
	if i.TitleLT != nil {
		predicates = append(predicates, worktask.TitleLT(*i.TitleLT))
	}
	if i.TitleLTE != nil {
		predicates = append(predicates, worktask.TitleLTE(*i.TitleLTE))
	}
	if i.TitleContains != nil {
		predicates = append(predicates, worktask.TitleContains(*i.TitleContains))
	}
	if i.TitleHasPrefix != nil {
		predicates = append(predicates, worktask.TitleHasPrefix(*i.TitleHasPrefix))
	}
	if i.TitleHasSuffix != nil {
		predicates = append(predicates, worktask.TitleHasSuffix(*i.TitleHasSuffix))
	}
	if i.TitleEqualFold != nil {
		predicates = append(predicates, worktask.TitleEqualFold(*i.TitleEqualFold))
	}
	if i.TitleContainsFold != nil {
		predicates = append(predicates, worktask.TitleContainsFold(*i.TitleContainsFold))
	}
	if i.StartTime != nil {
		predicates = append(predicates, worktask.StartTimeEQ(*i.StartTime))
	}
	if i.StartTimeNEQ != nil {
		predicates = append(predicates, worktask.StartTimeNEQ(*i.StartTimeNEQ))
	}
	if len(i.StartTimeIn) > 0 {
		predicates = append(predicates, worktask.StartTimeIn(i.StartTimeIn...))
	}
	if len(i.StartTimeNotIn) > 0 {
		predicates = append(predicates, worktask.StartTimeNotIn(i.StartTimeNotIn...))
	}
	if i.StartTimeGT != nil {
		predicates = append(predicates, worktask.StartTimeGT(*i.StartTimeGT))
	}
	if i.StartTimeGTE != nil {
		predicates = append(predicates, worktask.StartTimeGTE(*i.StartTimeGTE))
	}
	if i.StartTimeLT != nil {
		predicates = append(predicates, worktask.StartTimeLT(*i.StartTimeLT))
	}
	if i.StartTimeLTE != nil {
		predicates = append(predicates, worktask.StartTimeLTE(*i.StartTimeLTE))
	}
	if i.EndTime != nil {
		predicates = append(predicates, worktask.EndTimeEQ(*i.EndTime))
	}
	if i.EndTimeNEQ != nil {
		predicates = append(predicates, worktask.EndTimeNEQ(*i.EndTimeNEQ))
	}
	if len(i.EndTimeIn) > 0 {
		predicates = append(predicates, worktask.EndTimeIn(i.EndTimeIn...))
	}
	if len(i.EndTimeNotIn) > 0 {
		predicates = append(predicates, worktask.EndTimeNotIn(i.EndTimeNotIn...))
	}
	if i.EndTimeGT != nil {
		predicates = append(predicates, worktask.EndTimeGT(*i.EndTimeGT))
	}
	if i.EndTimeGTE != nil {
		predicates = append(predicates, worktask.EndTimeGTE(*i.EndTimeGTE))
	}
	if i.EndTimeLT != nil {
		predicates = append(predicates, worktask.EndTimeLT(*i.EndTimeLT))
	}
	if i.EndTimeLTE != nil {
		predicates = append(predicates, worktask.EndTimeLTE(*i.EndTimeLTE))
	}
	if i.EndTimeIsNil {
		predicates = append(predicates, worktask.EndTimeIsNil())
	}
	if i.EndTimeNotNil {
		predicates = append(predicates, worktask.EndTimeNotNil())
	}

	if i.HasCompany != nil {
		p := worktask.HasCompany()
		if !*i.HasCompany {
			p = worktask.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasCompanyWith) > 0 {
		with := make([]predicate.Company, 0, len(i.HasCompanyWith))
		for _, w := range i.HasCompanyWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasCompanyWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, worktask.HasCompanyWith(with...))
	}
	if i.HasCreatedBy != nil {
		p := worktask.HasCreatedBy()
		if !*i.HasCreatedBy {
			p = worktask.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasCreatedByWith) > 0 {
		with := make([]predicate.User, 0, len(i.HasCreatedByWith))
		for _, w := range i.HasCreatedByWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasCreatedByWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, worktask.HasCreatedByWith(with...))
	}
	if i.HasAssignedTo != nil {
		p := worktask.HasAssignedTo()
		if !*i.HasAssignedTo {
			p = worktask.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasAssignedToWith) > 0 {
		with := make([]predicate.Employee, 0, len(i.HasAssignedToWith))
		for _, w := range i.HasAssignedToWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasAssignedToWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, worktask.HasAssignedToWith(with...))
	}
	if i.HasWorkShifts != nil {
		p := worktask.HasWorkShifts()
		if !*i.HasWorkShifts {
			p = worktask.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasWorkShiftsWith) > 0 {
		with := make([]predicate.Workshift, 0, len(i.HasWorkShiftsWith))
		for _, w := range i.HasWorkShiftsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasWorkShiftsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, worktask.HasWorkShiftsWith(with...))
	}
	if i.HasWorkTags != nil {
		p := worktask.HasWorkTags()
		if !*i.HasWorkTags {
			p = worktask.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasWorkTagsWith) > 0 {
		with := make([]predicate.Worktag, 0, len(i.HasWorkTagsWith))
		for _, w := range i.HasWorkTagsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasWorkTagsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, worktask.HasWorkTagsWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyWorktaskWhereInput
	case 1:
		return predicates[0], nil
	default:
		return worktask.And(predicates...), nil
	}
}
