// Code generated by ent, DO NOT EDIT.

package generated

import (
	"errors"
	"fmt"
	"mazza/ent/generated/accountingentry"
	"mazza/ent/generated/company"
	"mazza/ent/generated/companydocument"
	"mazza/ent/generated/customer"
	"mazza/ent/generated/employee"
	"mazza/ent/generated/file"
	"mazza/ent/generated/membersignuptoken"
	"mazza/ent/generated/payable"
	"mazza/ent/generated/predicate"
	"mazza/ent/generated/product"
	"mazza/ent/generated/project"
	"mazza/ent/generated/projectmilestone"
	"mazza/ent/generated/projecttask"
	"mazza/ent/generated/receivable"
	"mazza/ent/generated/supplier"
	"mazza/ent/generated/token"
	"mazza/ent/generated/treasury"
	"mazza/ent/generated/user"
	"mazza/ent/generated/userrole"
	"mazza/ent/generated/workshift"
	"time"
)

// AccountingEntryWhereInput represents a where input for filtering AccountingEntry queries.
type AccountingEntryWhereInput struct {
	Predicates []predicate.AccountingEntry  `json:"-"`
	Not        *AccountingEntryWhereInput   `json:"not,omitempty"`
	Or         []*AccountingEntryWhereInput `json:"or,omitempty"`
	And        []*AccountingEntryWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "createdAt" field predicates.
	CreatedAt      *time.Time  `json:"createdat,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdatNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdatIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdatNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdatGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdatGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdatLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdatLTE,omitempty"`

	// "updatedAt" field predicates.
	UpdatedAt      *time.Time  `json:"updatedat,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedatNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedatIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedatNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedatGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedatGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedatLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedatLTE,omitempty"`

	// "deletedAt" field predicates.
	DeletedAt       *time.Time  `json:"deletedat,omitempty"`
	DeletedAtNEQ    *time.Time  `json:"deletedatNEQ,omitempty"`
	DeletedAtIn     []time.Time `json:"deletedatIn,omitempty"`
	DeletedAtNotIn  []time.Time `json:"deletedatNotIn,omitempty"`
	DeletedAtGT     *time.Time  `json:"deletedatGT,omitempty"`
	DeletedAtGTE    *time.Time  `json:"deletedatGTE,omitempty"`
	DeletedAtLT     *time.Time  `json:"deletedatLT,omitempty"`
	DeletedAtLTE    *time.Time  `json:"deletedatLTE,omitempty"`
	DeletedAtIsNil  bool        `json:"deletedatIsNil,omitempty"`
	DeletedAtNotNil bool        `json:"deletedatNotNil,omitempty"`

	// "number" field predicates.
	Number      *int  `json:"number,omitempty"`
	NumberNEQ   *int  `json:"numberNEQ,omitempty"`
	NumberIn    []int `json:"numberIn,omitempty"`
	NumberNotIn []int `json:"numberNotIn,omitempty"`
	NumberGT    *int  `json:"numberGT,omitempty"`
	NumberGTE   *int  `json:"numberGTE,omitempty"`
	NumberLT    *int  `json:"numberLT,omitempty"`
	NumberLTE   *int  `json:"numberLTE,omitempty"`

	// "group" field predicates.
	Group      *int  `json:"group,omitempty"`
	GroupNEQ   *int  `json:"groupNEQ,omitempty"`
	GroupIn    []int `json:"groupIn,omitempty"`
	GroupNotIn []int `json:"groupNotIn,omitempty"`
	GroupGT    *int  `json:"groupGT,omitempty"`
	GroupGTE   *int  `json:"groupGTE,omitempty"`
	GroupLT    *int  `json:"groupLT,omitempty"`
	GroupLTE   *int  `json:"groupLTE,omitempty"`

	// "date" field predicates.
	Date      *time.Time  `json:"date,omitempty"`
	DateNEQ   *time.Time  `json:"dateNEQ,omitempty"`
	DateIn    []time.Time `json:"dateIn,omitempty"`
	DateNotIn []time.Time `json:"dateNotIn,omitempty"`
	DateGT    *time.Time  `json:"dateGT,omitempty"`
	DateGTE   *time.Time  `json:"dateGTE,omitempty"`
	DateLT    *time.Time  `json:"dateLT,omitempty"`
	DateLTE   *time.Time  `json:"dateLTE,omitempty"`

	// "account" field predicates.
	Account             *string  `json:"account,omitempty"`
	AccountNEQ          *string  `json:"accountNEQ,omitempty"`
	AccountIn           []string `json:"accountIn,omitempty"`
	AccountNotIn        []string `json:"accountNotIn,omitempty"`
	AccountGT           *string  `json:"accountGT,omitempty"`
	AccountGTE          *string  `json:"accountGTE,omitempty"`
	AccountLT           *string  `json:"accountLT,omitempty"`
	AccountLTE          *string  `json:"accountLTE,omitempty"`
	AccountContains     *string  `json:"accountContains,omitempty"`
	AccountHasPrefix    *string  `json:"accountHasPrefix,omitempty"`
	AccountHasSuffix    *string  `json:"accountHasSuffix,omitempty"`
	AccountEqualFold    *string  `json:"accountEqualFold,omitempty"`
	AccountContainsFold *string  `json:"accountContainsFold,omitempty"`

	// "label" field predicates.
	Label             *string  `json:"label,omitempty"`
	LabelNEQ          *string  `json:"labelNEQ,omitempty"`
	LabelIn           []string `json:"labelIn,omitempty"`
	LabelNotIn        []string `json:"labelNotIn,omitempty"`
	LabelGT           *string  `json:"labelGT,omitempty"`
	LabelGTE          *string  `json:"labelGTE,omitempty"`
	LabelLT           *string  `json:"labelLT,omitempty"`
	LabelLTE          *string  `json:"labelLTE,omitempty"`
	LabelContains     *string  `json:"labelContains,omitempty"`
	LabelHasPrefix    *string  `json:"labelHasPrefix,omitempty"`
	LabelHasSuffix    *string  `json:"labelHasSuffix,omitempty"`
	LabelEqualFold    *string  `json:"labelEqualFold,omitempty"`
	LabelContainsFold *string  `json:"labelContainsFold,omitempty"`

	// "amount" field predicates.
	Amount      *float64  `json:"amount,omitempty"`
	AmountNEQ   *float64  `json:"amountNEQ,omitempty"`
	AmountIn    []float64 `json:"amountIn,omitempty"`
	AmountNotIn []float64 `json:"amountNotIn,omitempty"`
	AmountGT    *float64  `json:"amountGT,omitempty"`
	AmountGTE   *float64  `json:"amountGTE,omitempty"`
	AmountLT    *float64  `json:"amountLT,omitempty"`
	AmountLTE   *float64  `json:"amountLTE,omitempty"`

	// "description" field predicates.
	Description             *string  `json:"description,omitempty"`
	DescriptionNEQ          *string  `json:"descriptionNEQ,omitempty"`
	DescriptionIn           []string `json:"descriptionIn,omitempty"`
	DescriptionNotIn        []string `json:"descriptionNotIn,omitempty"`
	DescriptionGT           *string  `json:"descriptionGT,omitempty"`
	DescriptionGTE          *string  `json:"descriptionGTE,omitempty"`
	DescriptionLT           *string  `json:"descriptionLT,omitempty"`
	DescriptionLTE          *string  `json:"descriptionLTE,omitempty"`
	DescriptionContains     *string  `json:"descriptionContains,omitempty"`
	DescriptionHasPrefix    *string  `json:"descriptionHasPrefix,omitempty"`
	DescriptionHasSuffix    *string  `json:"descriptionHasSuffix,omitempty"`
	DescriptionEqualFold    *string  `json:"descriptionEqualFold,omitempty"`
	DescriptionContainsFold *string  `json:"descriptionContainsFold,omitempty"`

	// "accountType" field predicates.
	AccountType      *accountingentry.AccountType  `json:"accounttype,omitempty"`
	AccountTypeNEQ   *accountingentry.AccountType  `json:"accounttypeNEQ,omitempty"`
	AccountTypeIn    []accountingentry.AccountType `json:"accounttypeIn,omitempty"`
	AccountTypeNotIn []accountingentry.AccountType `json:"accounttypeNotIn,omitempty"`

	// "category" field predicates.
	Category             *string  `json:"category,omitempty"`
	CategoryNEQ          *string  `json:"categoryNEQ,omitempty"`
	CategoryIn           []string `json:"categoryIn,omitempty"`
	CategoryNotIn        []string `json:"categoryNotIn,omitempty"`
	CategoryGT           *string  `json:"categoryGT,omitempty"`
	CategoryGTE          *string  `json:"categoryGTE,omitempty"`
	CategoryLT           *string  `json:"categoryLT,omitempty"`
	CategoryLTE          *string  `json:"categoryLTE,omitempty"`
	CategoryContains     *string  `json:"categoryContains,omitempty"`
	CategoryHasPrefix    *string  `json:"categoryHasPrefix,omitempty"`
	CategoryHasSuffix    *string  `json:"categoryHasSuffix,omitempty"`
	CategoryEqualFold    *string  `json:"categoryEqualFold,omitempty"`
	CategoryContainsFold *string  `json:"categoryContainsFold,omitempty"`

	// "isDebit" field predicates.
	IsDebit    *bool `json:"isdebit,omitempty"`
	IsDebitNEQ *bool `json:"isdebitNEQ,omitempty"`

	// "isReversal" field predicates.
	IsReversal    *bool `json:"isreversal,omitempty"`
	IsReversalNEQ *bool `json:"isreversalNEQ,omitempty"`

	// "reversed" field predicates.
	Reversed    *bool `json:"reversed,omitempty"`
	ReversedNEQ *bool `json:"reversedNEQ,omitempty"`

	// "company" edge predicates.
	HasCompany     *bool                `json:"hasCompany,omitempty"`
	HasCompanyWith []*CompanyWhereInput `json:"hasCompanyWith,omitempty"`

	// "user" edge predicates.
	HasUser     *bool             `json:"hasUser,omitempty"`
	HasUserWith []*UserWhereInput `json:"hasUserWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *AccountingEntryWhereInput) AddPredicates(predicates ...predicate.AccountingEntry) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the AccountingEntryWhereInput filter on the AccountingEntryQuery builder.
func (i *AccountingEntryWhereInput) Filter(q *AccountingEntryQuery) (*AccountingEntryQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyAccountingEntryWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyAccountingEntryWhereInput is returned in case the AccountingEntryWhereInput is empty.
var ErrEmptyAccountingEntryWhereInput = errors.New("generated: empty predicate AccountingEntryWhereInput")

// P returns a predicate for filtering accountingentries.
// An error is returned if the input is empty or invalid.
func (i *AccountingEntryWhereInput) P() (predicate.AccountingEntry, error) {
	var predicates []predicate.AccountingEntry
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, accountingentry.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.AccountingEntry, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, accountingentry.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.AccountingEntry, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, accountingentry.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, accountingentry.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, accountingentry.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, accountingentry.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, accountingentry.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, accountingentry.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, accountingentry.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, accountingentry.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, accountingentry.IDLTE(*i.IDLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, accountingentry.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, accountingentry.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, accountingentry.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, accountingentry.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, accountingentry.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, accountingentry.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, accountingentry.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, accountingentry.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, accountingentry.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, accountingentry.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, accountingentry.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, accountingentry.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, accountingentry.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, accountingentry.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, accountingentry.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, accountingentry.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.DeletedAt != nil {
		predicates = append(predicates, accountingentry.DeletedAtEQ(*i.DeletedAt))
	}
	if i.DeletedAtNEQ != nil {
		predicates = append(predicates, accountingentry.DeletedAtNEQ(*i.DeletedAtNEQ))
	}
	if len(i.DeletedAtIn) > 0 {
		predicates = append(predicates, accountingentry.DeletedAtIn(i.DeletedAtIn...))
	}
	if len(i.DeletedAtNotIn) > 0 {
		predicates = append(predicates, accountingentry.DeletedAtNotIn(i.DeletedAtNotIn...))
	}
	if i.DeletedAtGT != nil {
		predicates = append(predicates, accountingentry.DeletedAtGT(*i.DeletedAtGT))
	}
	if i.DeletedAtGTE != nil {
		predicates = append(predicates, accountingentry.DeletedAtGTE(*i.DeletedAtGTE))
	}
	if i.DeletedAtLT != nil {
		predicates = append(predicates, accountingentry.DeletedAtLT(*i.DeletedAtLT))
	}
	if i.DeletedAtLTE != nil {
		predicates = append(predicates, accountingentry.DeletedAtLTE(*i.DeletedAtLTE))
	}
	if i.DeletedAtIsNil {
		predicates = append(predicates, accountingentry.DeletedAtIsNil())
	}
	if i.DeletedAtNotNil {
		predicates = append(predicates, accountingentry.DeletedAtNotNil())
	}
	if i.Number != nil {
		predicates = append(predicates, accountingentry.NumberEQ(*i.Number))
	}
	if i.NumberNEQ != nil {
		predicates = append(predicates, accountingentry.NumberNEQ(*i.NumberNEQ))
	}
	if len(i.NumberIn) > 0 {
		predicates = append(predicates, accountingentry.NumberIn(i.NumberIn...))
	}
	if len(i.NumberNotIn) > 0 {
		predicates = append(predicates, accountingentry.NumberNotIn(i.NumberNotIn...))
	}
	if i.NumberGT != nil {
		predicates = append(predicates, accountingentry.NumberGT(*i.NumberGT))
	}
	if i.NumberGTE != nil {
		predicates = append(predicates, accountingentry.NumberGTE(*i.NumberGTE))
	}
	if i.NumberLT != nil {
		predicates = append(predicates, accountingentry.NumberLT(*i.NumberLT))
	}
	if i.NumberLTE != nil {
		predicates = append(predicates, accountingentry.NumberLTE(*i.NumberLTE))
	}
	if i.Group != nil {
		predicates = append(predicates, accountingentry.GroupEQ(*i.Group))
	}
	if i.GroupNEQ != nil {
		predicates = append(predicates, accountingentry.GroupNEQ(*i.GroupNEQ))
	}
	if len(i.GroupIn) > 0 {
		predicates = append(predicates, accountingentry.GroupIn(i.GroupIn...))
	}
	if len(i.GroupNotIn) > 0 {
		predicates = append(predicates, accountingentry.GroupNotIn(i.GroupNotIn...))
	}
	if i.GroupGT != nil {
		predicates = append(predicates, accountingentry.GroupGT(*i.GroupGT))
	}
	if i.GroupGTE != nil {
		predicates = append(predicates, accountingentry.GroupGTE(*i.GroupGTE))
	}
	if i.GroupLT != nil {
		predicates = append(predicates, accountingentry.GroupLT(*i.GroupLT))
	}
	if i.GroupLTE != nil {
		predicates = append(predicates, accountingentry.GroupLTE(*i.GroupLTE))
	}
	if i.Date != nil {
		predicates = append(predicates, accountingentry.DateEQ(*i.Date))
	}
	if i.DateNEQ != nil {
		predicates = append(predicates, accountingentry.DateNEQ(*i.DateNEQ))
	}
	if len(i.DateIn) > 0 {
		predicates = append(predicates, accountingentry.DateIn(i.DateIn...))
	}
	if len(i.DateNotIn) > 0 {
		predicates = append(predicates, accountingentry.DateNotIn(i.DateNotIn...))
	}
	if i.DateGT != nil {
		predicates = append(predicates, accountingentry.DateGT(*i.DateGT))
	}
	if i.DateGTE != nil {
		predicates = append(predicates, accountingentry.DateGTE(*i.DateGTE))
	}
	if i.DateLT != nil {
		predicates = append(predicates, accountingentry.DateLT(*i.DateLT))
	}
	if i.DateLTE != nil {
		predicates = append(predicates, accountingentry.DateLTE(*i.DateLTE))
	}
	if i.Account != nil {
		predicates = append(predicates, accountingentry.AccountEQ(*i.Account))
	}
	if i.AccountNEQ != nil {
		predicates = append(predicates, accountingentry.AccountNEQ(*i.AccountNEQ))
	}
	if len(i.AccountIn) > 0 {
		predicates = append(predicates, accountingentry.AccountIn(i.AccountIn...))
	}
	if len(i.AccountNotIn) > 0 {
		predicates = append(predicates, accountingentry.AccountNotIn(i.AccountNotIn...))
	}
	if i.AccountGT != nil {
		predicates = append(predicates, accountingentry.AccountGT(*i.AccountGT))
	}
	if i.AccountGTE != nil {
		predicates = append(predicates, accountingentry.AccountGTE(*i.AccountGTE))
	}
	if i.AccountLT != nil {
		predicates = append(predicates, accountingentry.AccountLT(*i.AccountLT))
	}
	if i.AccountLTE != nil {
		predicates = append(predicates, accountingentry.AccountLTE(*i.AccountLTE))
	}
	if i.AccountContains != nil {
		predicates = append(predicates, accountingentry.AccountContains(*i.AccountContains))
	}
	if i.AccountHasPrefix != nil {
		predicates = append(predicates, accountingentry.AccountHasPrefix(*i.AccountHasPrefix))
	}
	if i.AccountHasSuffix != nil {
		predicates = append(predicates, accountingentry.AccountHasSuffix(*i.AccountHasSuffix))
	}
	if i.AccountEqualFold != nil {
		predicates = append(predicates, accountingentry.AccountEqualFold(*i.AccountEqualFold))
	}
	if i.AccountContainsFold != nil {
		predicates = append(predicates, accountingentry.AccountContainsFold(*i.AccountContainsFold))
	}
	if i.Label != nil {
		predicates = append(predicates, accountingentry.LabelEQ(*i.Label))
	}
	if i.LabelNEQ != nil {
		predicates = append(predicates, accountingentry.LabelNEQ(*i.LabelNEQ))
	}
	if len(i.LabelIn) > 0 {
		predicates = append(predicates, accountingentry.LabelIn(i.LabelIn...))
	}
	if len(i.LabelNotIn) > 0 {
		predicates = append(predicates, accountingentry.LabelNotIn(i.LabelNotIn...))
	}
	if i.LabelGT != nil {
		predicates = append(predicates, accountingentry.LabelGT(*i.LabelGT))
	}
	if i.LabelGTE != nil {
		predicates = append(predicates, accountingentry.LabelGTE(*i.LabelGTE))
	}
	if i.LabelLT != nil {
		predicates = append(predicates, accountingentry.LabelLT(*i.LabelLT))
	}
	if i.LabelLTE != nil {
		predicates = append(predicates, accountingentry.LabelLTE(*i.LabelLTE))
	}
	if i.LabelContains != nil {
		predicates = append(predicates, accountingentry.LabelContains(*i.LabelContains))
	}
	if i.LabelHasPrefix != nil {
		predicates = append(predicates, accountingentry.LabelHasPrefix(*i.LabelHasPrefix))
	}
	if i.LabelHasSuffix != nil {
		predicates = append(predicates, accountingentry.LabelHasSuffix(*i.LabelHasSuffix))
	}
	if i.LabelEqualFold != nil {
		predicates = append(predicates, accountingentry.LabelEqualFold(*i.LabelEqualFold))
	}
	if i.LabelContainsFold != nil {
		predicates = append(predicates, accountingentry.LabelContainsFold(*i.LabelContainsFold))
	}
	if i.Amount != nil {
		predicates = append(predicates, accountingentry.AmountEQ(*i.Amount))
	}
	if i.AmountNEQ != nil {
		predicates = append(predicates, accountingentry.AmountNEQ(*i.AmountNEQ))
	}
	if len(i.AmountIn) > 0 {
		predicates = append(predicates, accountingentry.AmountIn(i.AmountIn...))
	}
	if len(i.AmountNotIn) > 0 {
		predicates = append(predicates, accountingentry.AmountNotIn(i.AmountNotIn...))
	}
	if i.AmountGT != nil {
		predicates = append(predicates, accountingentry.AmountGT(*i.AmountGT))
	}
	if i.AmountGTE != nil {
		predicates = append(predicates, accountingentry.AmountGTE(*i.AmountGTE))
	}
	if i.AmountLT != nil {
		predicates = append(predicates, accountingentry.AmountLT(*i.AmountLT))
	}
	if i.AmountLTE != nil {
		predicates = append(predicates, accountingentry.AmountLTE(*i.AmountLTE))
	}
	if i.Description != nil {
		predicates = append(predicates, accountingentry.DescriptionEQ(*i.Description))
	}
	if i.DescriptionNEQ != nil {
		predicates = append(predicates, accountingentry.DescriptionNEQ(*i.DescriptionNEQ))
	}
	if len(i.DescriptionIn) > 0 {
		predicates = append(predicates, accountingentry.DescriptionIn(i.DescriptionIn...))
	}
	if len(i.DescriptionNotIn) > 0 {
		predicates = append(predicates, accountingentry.DescriptionNotIn(i.DescriptionNotIn...))
	}
	if i.DescriptionGT != nil {
		predicates = append(predicates, accountingentry.DescriptionGT(*i.DescriptionGT))
	}
	if i.DescriptionGTE != nil {
		predicates = append(predicates, accountingentry.DescriptionGTE(*i.DescriptionGTE))
	}
	if i.DescriptionLT != nil {
		predicates = append(predicates, accountingentry.DescriptionLT(*i.DescriptionLT))
	}
	if i.DescriptionLTE != nil {
		predicates = append(predicates, accountingentry.DescriptionLTE(*i.DescriptionLTE))
	}
	if i.DescriptionContains != nil {
		predicates = append(predicates, accountingentry.DescriptionContains(*i.DescriptionContains))
	}
	if i.DescriptionHasPrefix != nil {
		predicates = append(predicates, accountingentry.DescriptionHasPrefix(*i.DescriptionHasPrefix))
	}
	if i.DescriptionHasSuffix != nil {
		predicates = append(predicates, accountingentry.DescriptionHasSuffix(*i.DescriptionHasSuffix))
	}
	if i.DescriptionEqualFold != nil {
		predicates = append(predicates, accountingentry.DescriptionEqualFold(*i.DescriptionEqualFold))
	}
	if i.DescriptionContainsFold != nil {
		predicates = append(predicates, accountingentry.DescriptionContainsFold(*i.DescriptionContainsFold))
	}
	if i.AccountType != nil {
		predicates = append(predicates, accountingentry.AccountTypeEQ(*i.AccountType))
	}
	if i.AccountTypeNEQ != nil {
		predicates = append(predicates, accountingentry.AccountTypeNEQ(*i.AccountTypeNEQ))
	}
	if len(i.AccountTypeIn) > 0 {
		predicates = append(predicates, accountingentry.AccountTypeIn(i.AccountTypeIn...))
	}
	if len(i.AccountTypeNotIn) > 0 {
		predicates = append(predicates, accountingentry.AccountTypeNotIn(i.AccountTypeNotIn...))
	}
	if i.Category != nil {
		predicates = append(predicates, accountingentry.CategoryEQ(*i.Category))
	}
	if i.CategoryNEQ != nil {
		predicates = append(predicates, accountingentry.CategoryNEQ(*i.CategoryNEQ))
	}
	if len(i.CategoryIn) > 0 {
		predicates = append(predicates, accountingentry.CategoryIn(i.CategoryIn...))
	}
	if len(i.CategoryNotIn) > 0 {
		predicates = append(predicates, accountingentry.CategoryNotIn(i.CategoryNotIn...))
	}
	if i.CategoryGT != nil {
		predicates = append(predicates, accountingentry.CategoryGT(*i.CategoryGT))
	}
	if i.CategoryGTE != nil {
		predicates = append(predicates, accountingentry.CategoryGTE(*i.CategoryGTE))
	}
	if i.CategoryLT != nil {
		predicates = append(predicates, accountingentry.CategoryLT(*i.CategoryLT))
	}
	if i.CategoryLTE != nil {
		predicates = append(predicates, accountingentry.CategoryLTE(*i.CategoryLTE))
	}
	if i.CategoryContains != nil {
		predicates = append(predicates, accountingentry.CategoryContains(*i.CategoryContains))
	}
	if i.CategoryHasPrefix != nil {
		predicates = append(predicates, accountingentry.CategoryHasPrefix(*i.CategoryHasPrefix))
	}
	if i.CategoryHasSuffix != nil {
		predicates = append(predicates, accountingentry.CategoryHasSuffix(*i.CategoryHasSuffix))
	}
	if i.CategoryEqualFold != nil {
		predicates = append(predicates, accountingentry.CategoryEqualFold(*i.CategoryEqualFold))
	}
	if i.CategoryContainsFold != nil {
		predicates = append(predicates, accountingentry.CategoryContainsFold(*i.CategoryContainsFold))
	}
	if i.IsDebit != nil {
		predicates = append(predicates, accountingentry.IsDebitEQ(*i.IsDebit))
	}
	if i.IsDebitNEQ != nil {
		predicates = append(predicates, accountingentry.IsDebitNEQ(*i.IsDebitNEQ))
	}
	if i.IsReversal != nil {
		predicates = append(predicates, accountingentry.IsReversalEQ(*i.IsReversal))
	}
	if i.IsReversalNEQ != nil {
		predicates = append(predicates, accountingentry.IsReversalNEQ(*i.IsReversalNEQ))
	}
	if i.Reversed != nil {
		predicates = append(predicates, accountingentry.ReversedEQ(*i.Reversed))
	}
	if i.ReversedNEQ != nil {
		predicates = append(predicates, accountingentry.ReversedNEQ(*i.ReversedNEQ))
	}

	if i.HasCompany != nil {
		p := accountingentry.HasCompany()
		if !*i.HasCompany {
			p = accountingentry.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasCompanyWith) > 0 {
		with := make([]predicate.Company, 0, len(i.HasCompanyWith))
		for _, w := range i.HasCompanyWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasCompanyWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, accountingentry.HasCompanyWith(with...))
	}
	if i.HasUser != nil {
		p := accountingentry.HasUser()
		if !*i.HasUser {
			p = accountingentry.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasUserWith) > 0 {
		with := make([]predicate.User, 0, len(i.HasUserWith))
		for _, w := range i.HasUserWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasUserWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, accountingentry.HasUserWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyAccountingEntryWhereInput
	case 1:
		return predicates[0], nil
	default:
		return accountingentry.And(predicates...), nil
	}
}

// CompanyWhereInput represents a where input for filtering Company queries.
type CompanyWhereInput struct {
	Predicates []predicate.Company  `json:"-"`
	Not        *CompanyWhereInput   `json:"not,omitempty"`
	Or         []*CompanyWhereInput `json:"or,omitempty"`
	And        []*CompanyWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "createdAt" field predicates.
	CreatedAt      *time.Time  `json:"createdat,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdatNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdatIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdatNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdatGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdatGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdatLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdatLTE,omitempty"`

	// "updatedAt" field predicates.
	UpdatedAt      *time.Time  `json:"updatedat,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedatNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedatIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedatNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedatGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedatGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedatLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedatLTE,omitempty"`

	// "deletedAt" field predicates.
	DeletedAt       *time.Time  `json:"deletedat,omitempty"`
	DeletedAtNEQ    *time.Time  `json:"deletedatNEQ,omitempty"`
	DeletedAtIn     []time.Time `json:"deletedatIn,omitempty"`
	DeletedAtNotIn  []time.Time `json:"deletedatNotIn,omitempty"`
	DeletedAtGT     *time.Time  `json:"deletedatGT,omitempty"`
	DeletedAtGTE    *time.Time  `json:"deletedatGTE,omitempty"`
	DeletedAtLT     *time.Time  `json:"deletedatLT,omitempty"`
	DeletedAtLTE    *time.Time  `json:"deletedatLTE,omitempty"`
	DeletedAtIsNil  bool        `json:"deletedatIsNil,omitempty"`
	DeletedAtNotNil bool        `json:"deletedatNotNil,omitempty"`

	// "address" field predicates.
	Address             *string  `json:"address,omitempty"`
	AddressNEQ          *string  `json:"addressNEQ,omitempty"`
	AddressIn           []string `json:"addressIn,omitempty"`
	AddressNotIn        []string `json:"addressNotIn,omitempty"`
	AddressGT           *string  `json:"addressGT,omitempty"`
	AddressGTE          *string  `json:"addressGTE,omitempty"`
	AddressLT           *string  `json:"addressLT,omitempty"`
	AddressLTE          *string  `json:"addressLTE,omitempty"`
	AddressContains     *string  `json:"addressContains,omitempty"`
	AddressHasPrefix    *string  `json:"addressHasPrefix,omitempty"`
	AddressHasSuffix    *string  `json:"addressHasSuffix,omitempty"`
	AddressIsNil        bool     `json:"addressIsNil,omitempty"`
	AddressNotNil       bool     `json:"addressNotNil,omitempty"`
	AddressEqualFold    *string  `json:"addressEqualFold,omitempty"`
	AddressContainsFold *string  `json:"addressContainsFold,omitempty"`

	// "baseCurrency" field predicates.
	BaseCurrency             *string  `json:"basecurrency,omitempty"`
	BaseCurrencyNEQ          *string  `json:"basecurrencyNEQ,omitempty"`
	BaseCurrencyIn           []string `json:"basecurrencyIn,omitempty"`
	BaseCurrencyNotIn        []string `json:"basecurrencyNotIn,omitempty"`
	BaseCurrencyGT           *string  `json:"basecurrencyGT,omitempty"`
	BaseCurrencyGTE          *string  `json:"basecurrencyGTE,omitempty"`
	BaseCurrencyLT           *string  `json:"basecurrencyLT,omitempty"`
	BaseCurrencyLTE          *string  `json:"basecurrencyLTE,omitempty"`
	BaseCurrencyContains     *string  `json:"basecurrencyContains,omitempty"`
	BaseCurrencyHasPrefix    *string  `json:"basecurrencyHasPrefix,omitempty"`
	BaseCurrencyHasSuffix    *string  `json:"basecurrencyHasSuffix,omitempty"`
	BaseCurrencyEqualFold    *string  `json:"basecurrencyEqualFold,omitempty"`
	BaseCurrencyContainsFold *string  `json:"basecurrencyContainsFold,omitempty"`

	// "ceoName" field predicates.
	CeoName             *string  `json:"ceoname,omitempty"`
	CeoNameNEQ          *string  `json:"ceonameNEQ,omitempty"`
	CeoNameIn           []string `json:"ceonameIn,omitempty"`
	CeoNameNotIn        []string `json:"ceonameNotIn,omitempty"`
	CeoNameGT           *string  `json:"ceonameGT,omitempty"`
	CeoNameGTE          *string  `json:"ceonameGTE,omitempty"`
	CeoNameLT           *string  `json:"ceonameLT,omitempty"`
	CeoNameLTE          *string  `json:"ceonameLTE,omitempty"`
	CeoNameContains     *string  `json:"ceonameContains,omitempty"`
	CeoNameHasPrefix    *string  `json:"ceonameHasPrefix,omitempty"`
	CeoNameHasSuffix    *string  `json:"ceonameHasSuffix,omitempty"`
	CeoNameIsNil        bool     `json:"ceonameIsNil,omitempty"`
	CeoNameNotNil       bool     `json:"ceonameNotNil,omitempty"`
	CeoNameEqualFold    *string  `json:"ceonameEqualFold,omitempty"`
	CeoNameContainsFold *string  `json:"ceonameContainsFold,omitempty"`

	// "city" field predicates.
	City             *string  `json:"city,omitempty"`
	CityNEQ          *string  `json:"cityNEQ,omitempty"`
	CityIn           []string `json:"cityIn,omitempty"`
	CityNotIn        []string `json:"cityNotIn,omitempty"`
	CityGT           *string  `json:"cityGT,omitempty"`
	CityGTE          *string  `json:"cityGTE,omitempty"`
	CityLT           *string  `json:"cityLT,omitempty"`
	CityLTE          *string  `json:"cityLTE,omitempty"`
	CityContains     *string  `json:"cityContains,omitempty"`
	CityHasPrefix    *string  `json:"cityHasPrefix,omitempty"`
	CityHasSuffix    *string  `json:"cityHasSuffix,omitempty"`
	CityEqualFold    *string  `json:"cityEqualFold,omitempty"`
	CityContainsFold *string  `json:"cityContainsFold,omitempty"`

	// "country" field predicates.
	Country             *string  `json:"country,omitempty"`
	CountryNEQ          *string  `json:"countryNEQ,omitempty"`
	CountryIn           []string `json:"countryIn,omitempty"`
	CountryNotIn        []string `json:"countryNotIn,omitempty"`
	CountryGT           *string  `json:"countryGT,omitempty"`
	CountryGTE          *string  `json:"countryGTE,omitempty"`
	CountryLT           *string  `json:"countryLT,omitempty"`
	CountryLTE          *string  `json:"countryLTE,omitempty"`
	CountryContains     *string  `json:"countryContains,omitempty"`
	CountryHasPrefix    *string  `json:"countryHasPrefix,omitempty"`
	CountryHasSuffix    *string  `json:"countryHasSuffix,omitempty"`
	CountryEqualFold    *string  `json:"countryEqualFold,omitempty"`
	CountryContainsFold *string  `json:"countryContainsFold,omitempty"`

	// "establishedAt" field predicates.
	EstablishedAt      *time.Time  `json:"establishedat,omitempty"`
	EstablishedAtNEQ   *time.Time  `json:"establishedatNEQ,omitempty"`
	EstablishedAtIn    []time.Time `json:"establishedatIn,omitempty"`
	EstablishedAtNotIn []time.Time `json:"establishedatNotIn,omitempty"`
	EstablishedAtGT    *time.Time  `json:"establishedatGT,omitempty"`
	EstablishedAtGTE   *time.Time  `json:"establishedatGTE,omitempty"`
	EstablishedAtLT    *time.Time  `json:"establishedatLT,omitempty"`
	EstablishedAtLTE   *time.Time  `json:"establishedatLTE,omitempty"`

	// "description" field predicates.
	Description             *string  `json:"description,omitempty"`
	DescriptionNEQ          *string  `json:"descriptionNEQ,omitempty"`
	DescriptionIn           []string `json:"descriptionIn,omitempty"`
	DescriptionNotIn        []string `json:"descriptionNotIn,omitempty"`
	DescriptionGT           *string  `json:"descriptionGT,omitempty"`
	DescriptionGTE          *string  `json:"descriptionGTE,omitempty"`
	DescriptionLT           *string  `json:"descriptionLT,omitempty"`
	DescriptionLTE          *string  `json:"descriptionLTE,omitempty"`
	DescriptionContains     *string  `json:"descriptionContains,omitempty"`
	DescriptionHasPrefix    *string  `json:"descriptionHasPrefix,omitempty"`
	DescriptionHasSuffix    *string  `json:"descriptionHasSuffix,omitempty"`
	DescriptionIsNil        bool     `json:"descriptionIsNil,omitempty"`
	DescriptionNotNil       bool     `json:"descriptionNotNil,omitempty"`
	DescriptionEqualFold    *string  `json:"descriptionEqualFold,omitempty"`
	DescriptionContainsFold *string  `json:"descriptionContainsFold,omitempty"`

	// "email" field predicates.
	Email             *string  `json:"email,omitempty"`
	EmailNEQ          *string  `json:"emailNEQ,omitempty"`
	EmailIn           []string `json:"emailIn,omitempty"`
	EmailNotIn        []string `json:"emailNotIn,omitempty"`
	EmailGT           *string  `json:"emailGT,omitempty"`
	EmailGTE          *string  `json:"emailGTE,omitempty"`
	EmailLT           *string  `json:"emailLT,omitempty"`
	EmailLTE          *string  `json:"emailLTE,omitempty"`
	EmailContains     *string  `json:"emailContains,omitempty"`
	EmailHasPrefix    *string  `json:"emailHasPrefix,omitempty"`
	EmailHasSuffix    *string  `json:"emailHasSuffix,omitempty"`
	EmailIsNil        bool     `json:"emailIsNil,omitempty"`
	EmailNotNil       bool     `json:"emailNotNil,omitempty"`
	EmailEqualFold    *string  `json:"emailEqualFold,omitempty"`
	EmailContainsFold *string  `json:"emailContainsFold,omitempty"`

	// "industry" field predicates.
	Industry             *string  `json:"industry,omitempty"`
	IndustryNEQ          *string  `json:"industryNEQ,omitempty"`
	IndustryIn           []string `json:"industryIn,omitempty"`
	IndustryNotIn        []string `json:"industryNotIn,omitempty"`
	IndustryGT           *string  `json:"industryGT,omitempty"`
	IndustryGTE          *string  `json:"industryGTE,omitempty"`
	IndustryLT           *string  `json:"industryLT,omitempty"`
	IndustryLTE          *string  `json:"industryLTE,omitempty"`
	IndustryContains     *string  `json:"industryContains,omitempty"`
	IndustryHasPrefix    *string  `json:"industryHasPrefix,omitempty"`
	IndustryHasSuffix    *string  `json:"industryHasSuffix,omitempty"`
	IndustryIsNil        bool     `json:"industryIsNil,omitempty"`
	IndustryNotNil       bool     `json:"industryNotNil,omitempty"`
	IndustryEqualFold    *string  `json:"industryEqualFold,omitempty"`
	IndustryContainsFold *string  `json:"industryContainsFold,omitempty"`

	// "lastEntryDate" field predicates.
	LastEntryDate      *time.Time  `json:"lastentrydate,omitempty"`
	LastEntryDateNEQ   *time.Time  `json:"lastentrydateNEQ,omitempty"`
	LastEntryDateIn    []time.Time `json:"lastentrydateIn,omitempty"`
	LastEntryDateNotIn []time.Time `json:"lastentrydateNotIn,omitempty"`
	LastEntryDateGT    *time.Time  `json:"lastentrydateGT,omitempty"`
	LastEntryDateGTE   *time.Time  `json:"lastentrydateGTE,omitempty"`
	LastEntryDateLT    *time.Time  `json:"lastentrydateLT,omitempty"`
	LastEntryDateLTE   *time.Time  `json:"lastentrydateLTE,omitempty"`

	// "lastInvoiceNumber" field predicates.
	LastInvoiceNumber       *int32  `json:"lastinvoicenumber,omitempty"`
	LastInvoiceNumberNEQ    *int32  `json:"lastinvoicenumberNEQ,omitempty"`
	LastInvoiceNumberIn     []int32 `json:"lastinvoicenumberIn,omitempty"`
	LastInvoiceNumberNotIn  []int32 `json:"lastinvoicenumberNotIn,omitempty"`
	LastInvoiceNumberGT     *int32  `json:"lastinvoicenumberGT,omitempty"`
	LastInvoiceNumberGTE    *int32  `json:"lastinvoicenumberGTE,omitempty"`
	LastInvoiceNumberLT     *int32  `json:"lastinvoicenumberLT,omitempty"`
	LastInvoiceNumberLTE    *int32  `json:"lastinvoicenumberLTE,omitempty"`
	LastInvoiceNumberIsNil  bool    `json:"lastinvoicenumberIsNil,omitempty"`
	LastInvoiceNumberNotNil bool    `json:"lastinvoicenumberNotNil,omitempty"`

	// "logoURL" field predicates.
	LogoURL             *string  `json:"logourl,omitempty"`
	LogoURLNEQ          *string  `json:"logourlNEQ,omitempty"`
	LogoURLIn           []string `json:"logourlIn,omitempty"`
	LogoURLNotIn        []string `json:"logourlNotIn,omitempty"`
	LogoURLGT           *string  `json:"logourlGT,omitempty"`
	LogoURLGTE          *string  `json:"logourlGTE,omitempty"`
	LogoURLLT           *string  `json:"logourlLT,omitempty"`
	LogoURLLTE          *string  `json:"logourlLTE,omitempty"`
	LogoURLContains     *string  `json:"logourlContains,omitempty"`
	LogoURLHasPrefix    *string  `json:"logourlHasPrefix,omitempty"`
	LogoURLHasSuffix    *string  `json:"logourlHasSuffix,omitempty"`
	LogoURLIsNil        bool     `json:"logourlIsNil,omitempty"`
	LogoURLNotNil       bool     `json:"logourlNotNil,omitempty"`
	LogoURLEqualFold    *string  `json:"logourlEqualFold,omitempty"`
	LogoURLContainsFold *string  `json:"logourlContainsFold,omitempty"`

	// "logoStorageURI" field predicates.
	LogoStorageURI             *string  `json:"logostorageuri,omitempty"`
	LogoStorageURINEQ          *string  `json:"logostorageuriNEQ,omitempty"`
	LogoStorageURIIn           []string `json:"logostorageuriIn,omitempty"`
	LogoStorageURINotIn        []string `json:"logostorageuriNotIn,omitempty"`
	LogoStorageURIGT           *string  `json:"logostorageuriGT,omitempty"`
	LogoStorageURIGTE          *string  `json:"logostorageuriGTE,omitempty"`
	LogoStorageURILT           *string  `json:"logostorageuriLT,omitempty"`
	LogoStorageURILTE          *string  `json:"logostorageuriLTE,omitempty"`
	LogoStorageURIContains     *string  `json:"logostorageuriContains,omitempty"`
	LogoStorageURIHasPrefix    *string  `json:"logostorageuriHasPrefix,omitempty"`
	LogoStorageURIHasSuffix    *string  `json:"logostorageuriHasSuffix,omitempty"`
	LogoStorageURIIsNil        bool     `json:"logostorageuriIsNil,omitempty"`
	LogoStorageURINotNil       bool     `json:"logostorageuriNotNil,omitempty"`
	LogoStorageURIEqualFold    *string  `json:"logostorageuriEqualFold,omitempty"`
	LogoStorageURIContainsFold *string  `json:"logostorageuriContainsFold,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "numberOfEmployees" field predicates.
	NumberOfEmployees      *int32  `json:"numberofemployees,omitempty"`
	NumberOfEmployeesNEQ   *int32  `json:"numberofemployeesNEQ,omitempty"`
	NumberOfEmployeesIn    []int32 `json:"numberofemployeesIn,omitempty"`
	NumberOfEmployeesNotIn []int32 `json:"numberofemployeesNotIn,omitempty"`
	NumberOfEmployeesGT    *int32  `json:"numberofemployeesGT,omitempty"`
	NumberOfEmployeesGTE   *int32  `json:"numberofemployeesGTE,omitempty"`
	NumberOfEmployeesLT    *int32  `json:"numberofemployeesLT,omitempty"`
	NumberOfEmployeesLTE   *int32  `json:"numberofemployeesLTE,omitempty"`

	// "phone" field predicates.
	Phone             *string  `json:"phone,omitempty"`
	PhoneNEQ          *string  `json:"phoneNEQ,omitempty"`
	PhoneIn           []string `json:"phoneIn,omitempty"`
	PhoneNotIn        []string `json:"phoneNotIn,omitempty"`
	PhoneGT           *string  `json:"phoneGT,omitempty"`
	PhoneGTE          *string  `json:"phoneGTE,omitempty"`
	PhoneLT           *string  `json:"phoneLT,omitempty"`
	PhoneLTE          *string  `json:"phoneLTE,omitempty"`
	PhoneContains     *string  `json:"phoneContains,omitempty"`
	PhoneHasPrefix    *string  `json:"phoneHasPrefix,omitempty"`
	PhoneHasSuffix    *string  `json:"phoneHasSuffix,omitempty"`
	PhoneIsNil        bool     `json:"phoneIsNil,omitempty"`
	PhoneNotNil       bool     `json:"phoneNotNil,omitempty"`
	PhoneEqualFold    *string  `json:"phoneEqualFold,omitempty"`
	PhoneContainsFold *string  `json:"phoneContainsFold,omitempty"`

	// "taxId" field predicates.
	TaxId             *string  `json:"taxid,omitempty"`
	TaxIdNEQ          *string  `json:"taxidNEQ,omitempty"`
	TaxIdIn           []string `json:"taxidIn,omitempty"`
	TaxIdNotIn        []string `json:"taxidNotIn,omitempty"`
	TaxIdGT           *string  `json:"taxidGT,omitempty"`
	TaxIdGTE          *string  `json:"taxidGTE,omitempty"`
	TaxIdLT           *string  `json:"taxidLT,omitempty"`
	TaxIdLTE          *string  `json:"taxidLTE,omitempty"`
	TaxIdContains     *string  `json:"taxidContains,omitempty"`
	TaxIdHasPrefix    *string  `json:"taxidHasPrefix,omitempty"`
	TaxIdHasSuffix    *string  `json:"taxidHasSuffix,omitempty"`
	TaxIdEqualFold    *string  `json:"taxidEqualFold,omitempty"`
	TaxIdContainsFold *string  `json:"taxidContainsFold,omitempty"`

	// "vatRate" field predicates.
	VatRate      *float64  `json:"vatrate,omitempty"`
	VatRateNEQ   *float64  `json:"vatrateNEQ,omitempty"`
	VatRateIn    []float64 `json:"vatrateIn,omitempty"`
	VatRateNotIn []float64 `json:"vatrateNotIn,omitempty"`
	VatRateGT    *float64  `json:"vatrateGT,omitempty"`
	VatRateGTE   *float64  `json:"vatrateGTE,omitempty"`
	VatRateLT    *float64  `json:"vatrateLT,omitempty"`
	VatRateLTE   *float64  `json:"vatrateLTE,omitempty"`

	// "website" field predicates.
	Website             *string  `json:"website,omitempty"`
	WebsiteNEQ          *string  `json:"websiteNEQ,omitempty"`
	WebsiteIn           []string `json:"websiteIn,omitempty"`
	WebsiteNotIn        []string `json:"websiteNotIn,omitempty"`
	WebsiteGT           *string  `json:"websiteGT,omitempty"`
	WebsiteGTE          *string  `json:"websiteGTE,omitempty"`
	WebsiteLT           *string  `json:"websiteLT,omitempty"`
	WebsiteLTE          *string  `json:"websiteLTE,omitempty"`
	WebsiteContains     *string  `json:"websiteContains,omitempty"`
	WebsiteHasPrefix    *string  `json:"websiteHasPrefix,omitempty"`
	WebsiteHasSuffix    *string  `json:"websiteHasSuffix,omitempty"`
	WebsiteIsNil        bool     `json:"websiteIsNil,omitempty"`
	WebsiteNotNil       bool     `json:"websiteNotNil,omitempty"`
	WebsiteEqualFold    *string  `json:"websiteEqualFold,omitempty"`
	WebsiteContainsFold *string  `json:"websiteContainsFold,omitempty"`

	// "incompleteSetup" field predicates.
	IncompleteSetup       *bool `json:"incompletesetup,omitempty"`
	IncompleteSetupNEQ    *bool `json:"incompletesetupNEQ,omitempty"`
	IncompleteSetupIsNil  bool  `json:"incompletesetupIsNil,omitempty"`
	IncompleteSetupNotNil bool  `json:"incompletesetupNotNil,omitempty"`

	// "availableRoles" edge predicates.
	HasAvailableRoles     *bool                 `json:"hasAvailableRoles,omitempty"`
	HasAvailableRolesWith []*UserRoleWhereInput `json:"hasAvailableRolesWith,omitempty"`

	// "accountingEntries" edge predicates.
	HasAccountingEntries     *bool                        `json:"hasAccountingEntries,omitempty"`
	HasAccountingEntriesWith []*AccountingEntryWhereInput `json:"hasAccountingEntriesWith,omitempty"`

	// "customers" edge predicates.
	HasCustomers     *bool                 `json:"hasCustomers,omitempty"`
	HasCustomersWith []*CustomerWhereInput `json:"hasCustomersWith,omitempty"`

	// "documents" edge predicates.
	HasDocuments     *bool                        `json:"hasDocuments,omitempty"`
	HasDocumentsWith []*CompanyDocumentWhereInput `json:"hasDocumentsWith,omitempty"`

	// "employees" edge predicates.
	HasEmployees     *bool                 `json:"hasEmployees,omitempty"`
	HasEmployeesWith []*EmployeeWhereInput `json:"hasEmployeesWith,omitempty"`

	// "files" edge predicates.
	HasFiles     *bool             `json:"hasFiles,omitempty"`
	HasFilesWith []*FileWhereInput `json:"hasFilesWith,omitempty"`

	// "memberSignupTokens" edge predicates.
	HasMemberSignupTokens     *bool                          `json:"hasMemberSignupTokens,omitempty"`
	HasMemberSignupTokensWith []*MemberSignupTokenWhereInput `json:"hasMemberSignupTokensWith,omitempty"`

	// "products" edge predicates.
	HasProducts     *bool                `json:"hasProducts,omitempty"`
	HasProductsWith []*ProductWhereInput `json:"hasProductsWith,omitempty"`

	// "projects" edge predicates.
	HasProjects     *bool                `json:"hasProjects,omitempty"`
	HasProjectsWith []*ProjectWhereInput `json:"hasProjectsWith,omitempty"`

	// "payables" edge predicates.
	HasPayables     *bool                `json:"hasPayables,omitempty"`
	HasPayablesWith []*PayableWhereInput `json:"hasPayablesWith,omitempty"`

	// "receivables" edge predicates.
	HasReceivables     *bool                   `json:"hasReceivables,omitempty"`
	HasReceivablesWith []*ReceivableWhereInput `json:"hasReceivablesWith,omitempty"`

	// "suppliers" edge predicates.
	HasSuppliers     *bool                 `json:"hasSuppliers,omitempty"`
	HasSuppliersWith []*SupplierWhereInput `json:"hasSuppliersWith,omitempty"`

	// "tokens" edge predicates.
	HasTokens     *bool              `json:"hasTokens,omitempty"`
	HasTokensWith []*TokenWhereInput `json:"hasTokensWith,omitempty"`

	// "treasuries" edge predicates.
	HasTreasuries     *bool                 `json:"hasTreasuries,omitempty"`
	HasTreasuriesWith []*TreasuryWhereInput `json:"hasTreasuriesWith,omitempty"`

	// "workShifts" edge predicates.
	HasWorkShifts     *bool                  `json:"hasWorkShifts,omitempty"`
	HasWorkShiftsWith []*WorkshiftWhereInput `json:"hasWorkShiftsWith,omitempty"`

	// "users" edge predicates.
	HasUsers     *bool             `json:"hasUsers,omitempty"`
	HasUsersWith []*UserWhereInput `json:"hasUsersWith,omitempty"`

	// "daughterCompanies" edge predicates.
	HasDaughterCompanies     *bool                `json:"hasDaughterCompanies,omitempty"`
	HasDaughterCompaniesWith []*CompanyWhereInput `json:"hasDaughterCompaniesWith,omitempty"`

	// "parentCompany" edge predicates.
	HasParentCompany     *bool                `json:"hasParentCompany,omitempty"`
	HasParentCompanyWith []*CompanyWhereInput `json:"hasParentCompanyWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *CompanyWhereInput) AddPredicates(predicates ...predicate.Company) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the CompanyWhereInput filter on the CompanyQuery builder.
func (i *CompanyWhereInput) Filter(q *CompanyQuery) (*CompanyQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyCompanyWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyCompanyWhereInput is returned in case the CompanyWhereInput is empty.
var ErrEmptyCompanyWhereInput = errors.New("generated: empty predicate CompanyWhereInput")

// P returns a predicate for filtering companies.
// An error is returned if the input is empty or invalid.
func (i *CompanyWhereInput) P() (predicate.Company, error) {
	var predicates []predicate.Company
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, company.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Company, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, company.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Company, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, company.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, company.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, company.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, company.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, company.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, company.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, company.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, company.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, company.IDLTE(*i.IDLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, company.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, company.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, company.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, company.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, company.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, company.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, company.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, company.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, company.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, company.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, company.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, company.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, company.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, company.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, company.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, company.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.DeletedAt != nil {
		predicates = append(predicates, company.DeletedAtEQ(*i.DeletedAt))
	}
	if i.DeletedAtNEQ != nil {
		predicates = append(predicates, company.DeletedAtNEQ(*i.DeletedAtNEQ))
	}
	if len(i.DeletedAtIn) > 0 {
		predicates = append(predicates, company.DeletedAtIn(i.DeletedAtIn...))
	}
	if len(i.DeletedAtNotIn) > 0 {
		predicates = append(predicates, company.DeletedAtNotIn(i.DeletedAtNotIn...))
	}
	if i.DeletedAtGT != nil {
		predicates = append(predicates, company.DeletedAtGT(*i.DeletedAtGT))
	}
	if i.DeletedAtGTE != nil {
		predicates = append(predicates, company.DeletedAtGTE(*i.DeletedAtGTE))
	}
	if i.DeletedAtLT != nil {
		predicates = append(predicates, company.DeletedAtLT(*i.DeletedAtLT))
	}
	if i.DeletedAtLTE != nil {
		predicates = append(predicates, company.DeletedAtLTE(*i.DeletedAtLTE))
	}
	if i.DeletedAtIsNil {
		predicates = append(predicates, company.DeletedAtIsNil())
	}
	if i.DeletedAtNotNil {
		predicates = append(predicates, company.DeletedAtNotNil())
	}
	if i.Address != nil {
		predicates = append(predicates, company.AddressEQ(*i.Address))
	}
	if i.AddressNEQ != nil {
		predicates = append(predicates, company.AddressNEQ(*i.AddressNEQ))
	}
	if len(i.AddressIn) > 0 {
		predicates = append(predicates, company.AddressIn(i.AddressIn...))
	}
	if len(i.AddressNotIn) > 0 {
		predicates = append(predicates, company.AddressNotIn(i.AddressNotIn...))
	}
	if i.AddressGT != nil {
		predicates = append(predicates, company.AddressGT(*i.AddressGT))
	}
	if i.AddressGTE != nil {
		predicates = append(predicates, company.AddressGTE(*i.AddressGTE))
	}
	if i.AddressLT != nil {
		predicates = append(predicates, company.AddressLT(*i.AddressLT))
	}
	if i.AddressLTE != nil {
		predicates = append(predicates, company.AddressLTE(*i.AddressLTE))
	}
	if i.AddressContains != nil {
		predicates = append(predicates, company.AddressContains(*i.AddressContains))
	}
	if i.AddressHasPrefix != nil {
		predicates = append(predicates, company.AddressHasPrefix(*i.AddressHasPrefix))
	}
	if i.AddressHasSuffix != nil {
		predicates = append(predicates, company.AddressHasSuffix(*i.AddressHasSuffix))
	}
	if i.AddressIsNil {
		predicates = append(predicates, company.AddressIsNil())
	}
	if i.AddressNotNil {
		predicates = append(predicates, company.AddressNotNil())
	}
	if i.AddressEqualFold != nil {
		predicates = append(predicates, company.AddressEqualFold(*i.AddressEqualFold))
	}
	if i.AddressContainsFold != nil {
		predicates = append(predicates, company.AddressContainsFold(*i.AddressContainsFold))
	}
	if i.BaseCurrency != nil {
		predicates = append(predicates, company.BaseCurrencyEQ(*i.BaseCurrency))
	}
	if i.BaseCurrencyNEQ != nil {
		predicates = append(predicates, company.BaseCurrencyNEQ(*i.BaseCurrencyNEQ))
	}
	if len(i.BaseCurrencyIn) > 0 {
		predicates = append(predicates, company.BaseCurrencyIn(i.BaseCurrencyIn...))
	}
	if len(i.BaseCurrencyNotIn) > 0 {
		predicates = append(predicates, company.BaseCurrencyNotIn(i.BaseCurrencyNotIn...))
	}
	if i.BaseCurrencyGT != nil {
		predicates = append(predicates, company.BaseCurrencyGT(*i.BaseCurrencyGT))
	}
	if i.BaseCurrencyGTE != nil {
		predicates = append(predicates, company.BaseCurrencyGTE(*i.BaseCurrencyGTE))
	}
	if i.BaseCurrencyLT != nil {
		predicates = append(predicates, company.BaseCurrencyLT(*i.BaseCurrencyLT))
	}
	if i.BaseCurrencyLTE != nil {
		predicates = append(predicates, company.BaseCurrencyLTE(*i.BaseCurrencyLTE))
	}
	if i.BaseCurrencyContains != nil {
		predicates = append(predicates, company.BaseCurrencyContains(*i.BaseCurrencyContains))
	}
	if i.BaseCurrencyHasPrefix != nil {
		predicates = append(predicates, company.BaseCurrencyHasPrefix(*i.BaseCurrencyHasPrefix))
	}
	if i.BaseCurrencyHasSuffix != nil {
		predicates = append(predicates, company.BaseCurrencyHasSuffix(*i.BaseCurrencyHasSuffix))
	}
	if i.BaseCurrencyEqualFold != nil {
		predicates = append(predicates, company.BaseCurrencyEqualFold(*i.BaseCurrencyEqualFold))
	}
	if i.BaseCurrencyContainsFold != nil {
		predicates = append(predicates, company.BaseCurrencyContainsFold(*i.BaseCurrencyContainsFold))
	}
	if i.CeoName != nil {
		predicates = append(predicates, company.CeoNameEQ(*i.CeoName))
	}
	if i.CeoNameNEQ != nil {
		predicates = append(predicates, company.CeoNameNEQ(*i.CeoNameNEQ))
	}
	if len(i.CeoNameIn) > 0 {
		predicates = append(predicates, company.CeoNameIn(i.CeoNameIn...))
	}
	if len(i.CeoNameNotIn) > 0 {
		predicates = append(predicates, company.CeoNameNotIn(i.CeoNameNotIn...))
	}
	if i.CeoNameGT != nil {
		predicates = append(predicates, company.CeoNameGT(*i.CeoNameGT))
	}
	if i.CeoNameGTE != nil {
		predicates = append(predicates, company.CeoNameGTE(*i.CeoNameGTE))
	}
	if i.CeoNameLT != nil {
		predicates = append(predicates, company.CeoNameLT(*i.CeoNameLT))
	}
	if i.CeoNameLTE != nil {
		predicates = append(predicates, company.CeoNameLTE(*i.CeoNameLTE))
	}
	if i.CeoNameContains != nil {
		predicates = append(predicates, company.CeoNameContains(*i.CeoNameContains))
	}
	if i.CeoNameHasPrefix != nil {
		predicates = append(predicates, company.CeoNameHasPrefix(*i.CeoNameHasPrefix))
	}
	if i.CeoNameHasSuffix != nil {
		predicates = append(predicates, company.CeoNameHasSuffix(*i.CeoNameHasSuffix))
	}
	if i.CeoNameIsNil {
		predicates = append(predicates, company.CeoNameIsNil())
	}
	if i.CeoNameNotNil {
		predicates = append(predicates, company.CeoNameNotNil())
	}
	if i.CeoNameEqualFold != nil {
		predicates = append(predicates, company.CeoNameEqualFold(*i.CeoNameEqualFold))
	}
	if i.CeoNameContainsFold != nil {
		predicates = append(predicates, company.CeoNameContainsFold(*i.CeoNameContainsFold))
	}
	if i.City != nil {
		predicates = append(predicates, company.CityEQ(*i.City))
	}
	if i.CityNEQ != nil {
		predicates = append(predicates, company.CityNEQ(*i.CityNEQ))
	}
	if len(i.CityIn) > 0 {
		predicates = append(predicates, company.CityIn(i.CityIn...))
	}
	if len(i.CityNotIn) > 0 {
		predicates = append(predicates, company.CityNotIn(i.CityNotIn...))
	}
	if i.CityGT != nil {
		predicates = append(predicates, company.CityGT(*i.CityGT))
	}
	if i.CityGTE != nil {
		predicates = append(predicates, company.CityGTE(*i.CityGTE))
	}
	if i.CityLT != nil {
		predicates = append(predicates, company.CityLT(*i.CityLT))
	}
	if i.CityLTE != nil {
		predicates = append(predicates, company.CityLTE(*i.CityLTE))
	}
	if i.CityContains != nil {
		predicates = append(predicates, company.CityContains(*i.CityContains))
	}
	if i.CityHasPrefix != nil {
		predicates = append(predicates, company.CityHasPrefix(*i.CityHasPrefix))
	}
	if i.CityHasSuffix != nil {
		predicates = append(predicates, company.CityHasSuffix(*i.CityHasSuffix))
	}
	if i.CityEqualFold != nil {
		predicates = append(predicates, company.CityEqualFold(*i.CityEqualFold))
	}
	if i.CityContainsFold != nil {
		predicates = append(predicates, company.CityContainsFold(*i.CityContainsFold))
	}
	if i.Country != nil {
		predicates = append(predicates, company.CountryEQ(*i.Country))
	}
	if i.CountryNEQ != nil {
		predicates = append(predicates, company.CountryNEQ(*i.CountryNEQ))
	}
	if len(i.CountryIn) > 0 {
		predicates = append(predicates, company.CountryIn(i.CountryIn...))
	}
	if len(i.CountryNotIn) > 0 {
		predicates = append(predicates, company.CountryNotIn(i.CountryNotIn...))
	}
	if i.CountryGT != nil {
		predicates = append(predicates, company.CountryGT(*i.CountryGT))
	}
	if i.CountryGTE != nil {
		predicates = append(predicates, company.CountryGTE(*i.CountryGTE))
	}
	if i.CountryLT != nil {
		predicates = append(predicates, company.CountryLT(*i.CountryLT))
	}
	if i.CountryLTE != nil {
		predicates = append(predicates, company.CountryLTE(*i.CountryLTE))
	}
	if i.CountryContains != nil {
		predicates = append(predicates, company.CountryContains(*i.CountryContains))
	}
	if i.CountryHasPrefix != nil {
		predicates = append(predicates, company.CountryHasPrefix(*i.CountryHasPrefix))
	}
	if i.CountryHasSuffix != nil {
		predicates = append(predicates, company.CountryHasSuffix(*i.CountryHasSuffix))
	}
	if i.CountryEqualFold != nil {
		predicates = append(predicates, company.CountryEqualFold(*i.CountryEqualFold))
	}
	if i.CountryContainsFold != nil {
		predicates = append(predicates, company.CountryContainsFold(*i.CountryContainsFold))
	}
	if i.EstablishedAt != nil {
		predicates = append(predicates, company.EstablishedAtEQ(*i.EstablishedAt))
	}
	if i.EstablishedAtNEQ != nil {
		predicates = append(predicates, company.EstablishedAtNEQ(*i.EstablishedAtNEQ))
	}
	if len(i.EstablishedAtIn) > 0 {
		predicates = append(predicates, company.EstablishedAtIn(i.EstablishedAtIn...))
	}
	if len(i.EstablishedAtNotIn) > 0 {
		predicates = append(predicates, company.EstablishedAtNotIn(i.EstablishedAtNotIn...))
	}
	if i.EstablishedAtGT != nil {
		predicates = append(predicates, company.EstablishedAtGT(*i.EstablishedAtGT))
	}
	if i.EstablishedAtGTE != nil {
		predicates = append(predicates, company.EstablishedAtGTE(*i.EstablishedAtGTE))
	}
	if i.EstablishedAtLT != nil {
		predicates = append(predicates, company.EstablishedAtLT(*i.EstablishedAtLT))
	}
	if i.EstablishedAtLTE != nil {
		predicates = append(predicates, company.EstablishedAtLTE(*i.EstablishedAtLTE))
	}
	if i.Description != nil {
		predicates = append(predicates, company.DescriptionEQ(*i.Description))
	}
	if i.DescriptionNEQ != nil {
		predicates = append(predicates, company.DescriptionNEQ(*i.DescriptionNEQ))
	}
	if len(i.DescriptionIn) > 0 {
		predicates = append(predicates, company.DescriptionIn(i.DescriptionIn...))
	}
	if len(i.DescriptionNotIn) > 0 {
		predicates = append(predicates, company.DescriptionNotIn(i.DescriptionNotIn...))
	}
	if i.DescriptionGT != nil {
		predicates = append(predicates, company.DescriptionGT(*i.DescriptionGT))
	}
	if i.DescriptionGTE != nil {
		predicates = append(predicates, company.DescriptionGTE(*i.DescriptionGTE))
	}
	if i.DescriptionLT != nil {
		predicates = append(predicates, company.DescriptionLT(*i.DescriptionLT))
	}
	if i.DescriptionLTE != nil {
		predicates = append(predicates, company.DescriptionLTE(*i.DescriptionLTE))
	}
	if i.DescriptionContains != nil {
		predicates = append(predicates, company.DescriptionContains(*i.DescriptionContains))
	}
	if i.DescriptionHasPrefix != nil {
		predicates = append(predicates, company.DescriptionHasPrefix(*i.DescriptionHasPrefix))
	}
	if i.DescriptionHasSuffix != nil {
		predicates = append(predicates, company.DescriptionHasSuffix(*i.DescriptionHasSuffix))
	}
	if i.DescriptionIsNil {
		predicates = append(predicates, company.DescriptionIsNil())
	}
	if i.DescriptionNotNil {
		predicates = append(predicates, company.DescriptionNotNil())
	}
	if i.DescriptionEqualFold != nil {
		predicates = append(predicates, company.DescriptionEqualFold(*i.DescriptionEqualFold))
	}
	if i.DescriptionContainsFold != nil {
		predicates = append(predicates, company.DescriptionContainsFold(*i.DescriptionContainsFold))
	}
	if i.Email != nil {
		predicates = append(predicates, company.EmailEQ(*i.Email))
	}
	if i.EmailNEQ != nil {
		predicates = append(predicates, company.EmailNEQ(*i.EmailNEQ))
	}
	if len(i.EmailIn) > 0 {
		predicates = append(predicates, company.EmailIn(i.EmailIn...))
	}
	if len(i.EmailNotIn) > 0 {
		predicates = append(predicates, company.EmailNotIn(i.EmailNotIn...))
	}
	if i.EmailGT != nil {
		predicates = append(predicates, company.EmailGT(*i.EmailGT))
	}
	if i.EmailGTE != nil {
		predicates = append(predicates, company.EmailGTE(*i.EmailGTE))
	}
	if i.EmailLT != nil {
		predicates = append(predicates, company.EmailLT(*i.EmailLT))
	}
	if i.EmailLTE != nil {
		predicates = append(predicates, company.EmailLTE(*i.EmailLTE))
	}
	if i.EmailContains != nil {
		predicates = append(predicates, company.EmailContains(*i.EmailContains))
	}
	if i.EmailHasPrefix != nil {
		predicates = append(predicates, company.EmailHasPrefix(*i.EmailHasPrefix))
	}
	if i.EmailHasSuffix != nil {
		predicates = append(predicates, company.EmailHasSuffix(*i.EmailHasSuffix))
	}
	if i.EmailIsNil {
		predicates = append(predicates, company.EmailIsNil())
	}
	if i.EmailNotNil {
		predicates = append(predicates, company.EmailNotNil())
	}
	if i.EmailEqualFold != nil {
		predicates = append(predicates, company.EmailEqualFold(*i.EmailEqualFold))
	}
	if i.EmailContainsFold != nil {
		predicates = append(predicates, company.EmailContainsFold(*i.EmailContainsFold))
	}
	if i.Industry != nil {
		predicates = append(predicates, company.IndustryEQ(*i.Industry))
	}
	if i.IndustryNEQ != nil {
		predicates = append(predicates, company.IndustryNEQ(*i.IndustryNEQ))
	}
	if len(i.IndustryIn) > 0 {
		predicates = append(predicates, company.IndustryIn(i.IndustryIn...))
	}
	if len(i.IndustryNotIn) > 0 {
		predicates = append(predicates, company.IndustryNotIn(i.IndustryNotIn...))
	}
	if i.IndustryGT != nil {
		predicates = append(predicates, company.IndustryGT(*i.IndustryGT))
	}
	if i.IndustryGTE != nil {
		predicates = append(predicates, company.IndustryGTE(*i.IndustryGTE))
	}
	if i.IndustryLT != nil {
		predicates = append(predicates, company.IndustryLT(*i.IndustryLT))
	}
	if i.IndustryLTE != nil {
		predicates = append(predicates, company.IndustryLTE(*i.IndustryLTE))
	}
	if i.IndustryContains != nil {
		predicates = append(predicates, company.IndustryContains(*i.IndustryContains))
	}
	if i.IndustryHasPrefix != nil {
		predicates = append(predicates, company.IndustryHasPrefix(*i.IndustryHasPrefix))
	}
	if i.IndustryHasSuffix != nil {
		predicates = append(predicates, company.IndustryHasSuffix(*i.IndustryHasSuffix))
	}
	if i.IndustryIsNil {
		predicates = append(predicates, company.IndustryIsNil())
	}
	if i.IndustryNotNil {
		predicates = append(predicates, company.IndustryNotNil())
	}
	if i.IndustryEqualFold != nil {
		predicates = append(predicates, company.IndustryEqualFold(*i.IndustryEqualFold))
	}
	if i.IndustryContainsFold != nil {
		predicates = append(predicates, company.IndustryContainsFold(*i.IndustryContainsFold))
	}
	if i.LastEntryDate != nil {
		predicates = append(predicates, company.LastEntryDateEQ(*i.LastEntryDate))
	}
	if i.LastEntryDateNEQ != nil {
		predicates = append(predicates, company.LastEntryDateNEQ(*i.LastEntryDateNEQ))
	}
	if len(i.LastEntryDateIn) > 0 {
		predicates = append(predicates, company.LastEntryDateIn(i.LastEntryDateIn...))
	}
	if len(i.LastEntryDateNotIn) > 0 {
		predicates = append(predicates, company.LastEntryDateNotIn(i.LastEntryDateNotIn...))
	}
	if i.LastEntryDateGT != nil {
		predicates = append(predicates, company.LastEntryDateGT(*i.LastEntryDateGT))
	}
	if i.LastEntryDateGTE != nil {
		predicates = append(predicates, company.LastEntryDateGTE(*i.LastEntryDateGTE))
	}
	if i.LastEntryDateLT != nil {
		predicates = append(predicates, company.LastEntryDateLT(*i.LastEntryDateLT))
	}
	if i.LastEntryDateLTE != nil {
		predicates = append(predicates, company.LastEntryDateLTE(*i.LastEntryDateLTE))
	}
	if i.LastInvoiceNumber != nil {
		predicates = append(predicates, company.LastInvoiceNumberEQ(*i.LastInvoiceNumber))
	}
	if i.LastInvoiceNumberNEQ != nil {
		predicates = append(predicates, company.LastInvoiceNumberNEQ(*i.LastInvoiceNumberNEQ))
	}
	if len(i.LastInvoiceNumberIn) > 0 {
		predicates = append(predicates, company.LastInvoiceNumberIn(i.LastInvoiceNumberIn...))
	}
	if len(i.LastInvoiceNumberNotIn) > 0 {
		predicates = append(predicates, company.LastInvoiceNumberNotIn(i.LastInvoiceNumberNotIn...))
	}
	if i.LastInvoiceNumberGT != nil {
		predicates = append(predicates, company.LastInvoiceNumberGT(*i.LastInvoiceNumberGT))
	}
	if i.LastInvoiceNumberGTE != nil {
		predicates = append(predicates, company.LastInvoiceNumberGTE(*i.LastInvoiceNumberGTE))
	}
	if i.LastInvoiceNumberLT != nil {
		predicates = append(predicates, company.LastInvoiceNumberLT(*i.LastInvoiceNumberLT))
	}
	if i.LastInvoiceNumberLTE != nil {
		predicates = append(predicates, company.LastInvoiceNumberLTE(*i.LastInvoiceNumberLTE))
	}
	if i.LastInvoiceNumberIsNil {
		predicates = append(predicates, company.LastInvoiceNumberIsNil())
	}
	if i.LastInvoiceNumberNotNil {
		predicates = append(predicates, company.LastInvoiceNumberNotNil())
	}
	if i.LogoURL != nil {
		predicates = append(predicates, company.LogoURLEQ(*i.LogoURL))
	}
	if i.LogoURLNEQ != nil {
		predicates = append(predicates, company.LogoURLNEQ(*i.LogoURLNEQ))
	}
	if len(i.LogoURLIn) > 0 {
		predicates = append(predicates, company.LogoURLIn(i.LogoURLIn...))
	}
	if len(i.LogoURLNotIn) > 0 {
		predicates = append(predicates, company.LogoURLNotIn(i.LogoURLNotIn...))
	}
	if i.LogoURLGT != nil {
		predicates = append(predicates, company.LogoURLGT(*i.LogoURLGT))
	}
	if i.LogoURLGTE != nil {
		predicates = append(predicates, company.LogoURLGTE(*i.LogoURLGTE))
	}
	if i.LogoURLLT != nil {
		predicates = append(predicates, company.LogoURLLT(*i.LogoURLLT))
	}
	if i.LogoURLLTE != nil {
		predicates = append(predicates, company.LogoURLLTE(*i.LogoURLLTE))
	}
	if i.LogoURLContains != nil {
		predicates = append(predicates, company.LogoURLContains(*i.LogoURLContains))
	}
	if i.LogoURLHasPrefix != nil {
		predicates = append(predicates, company.LogoURLHasPrefix(*i.LogoURLHasPrefix))
	}
	if i.LogoURLHasSuffix != nil {
		predicates = append(predicates, company.LogoURLHasSuffix(*i.LogoURLHasSuffix))
	}
	if i.LogoURLIsNil {
		predicates = append(predicates, company.LogoURLIsNil())
	}
	if i.LogoURLNotNil {
		predicates = append(predicates, company.LogoURLNotNil())
	}
	if i.LogoURLEqualFold != nil {
		predicates = append(predicates, company.LogoURLEqualFold(*i.LogoURLEqualFold))
	}
	if i.LogoURLContainsFold != nil {
		predicates = append(predicates, company.LogoURLContainsFold(*i.LogoURLContainsFold))
	}
	if i.LogoStorageURI != nil {
		predicates = append(predicates, company.LogoStorageURIEQ(*i.LogoStorageURI))
	}
	if i.LogoStorageURINEQ != nil {
		predicates = append(predicates, company.LogoStorageURINEQ(*i.LogoStorageURINEQ))
	}
	if len(i.LogoStorageURIIn) > 0 {
		predicates = append(predicates, company.LogoStorageURIIn(i.LogoStorageURIIn...))
	}
	if len(i.LogoStorageURINotIn) > 0 {
		predicates = append(predicates, company.LogoStorageURINotIn(i.LogoStorageURINotIn...))
	}
	if i.LogoStorageURIGT != nil {
		predicates = append(predicates, company.LogoStorageURIGT(*i.LogoStorageURIGT))
	}
	if i.LogoStorageURIGTE != nil {
		predicates = append(predicates, company.LogoStorageURIGTE(*i.LogoStorageURIGTE))
	}
	if i.LogoStorageURILT != nil {
		predicates = append(predicates, company.LogoStorageURILT(*i.LogoStorageURILT))
	}
	if i.LogoStorageURILTE != nil {
		predicates = append(predicates, company.LogoStorageURILTE(*i.LogoStorageURILTE))
	}
	if i.LogoStorageURIContains != nil {
		predicates = append(predicates, company.LogoStorageURIContains(*i.LogoStorageURIContains))
	}
	if i.LogoStorageURIHasPrefix != nil {
		predicates = append(predicates, company.LogoStorageURIHasPrefix(*i.LogoStorageURIHasPrefix))
	}
	if i.LogoStorageURIHasSuffix != nil {
		predicates = append(predicates, company.LogoStorageURIHasSuffix(*i.LogoStorageURIHasSuffix))
	}
	if i.LogoStorageURIIsNil {
		predicates = append(predicates, company.LogoStorageURIIsNil())
	}
	if i.LogoStorageURINotNil {
		predicates = append(predicates, company.LogoStorageURINotNil())
	}
	if i.LogoStorageURIEqualFold != nil {
		predicates = append(predicates, company.LogoStorageURIEqualFold(*i.LogoStorageURIEqualFold))
	}
	if i.LogoStorageURIContainsFold != nil {
		predicates = append(predicates, company.LogoStorageURIContainsFold(*i.LogoStorageURIContainsFold))
	}
	if i.Name != nil {
		predicates = append(predicates, company.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, company.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, company.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, company.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, company.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, company.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, company.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, company.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, company.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, company.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, company.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, company.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, company.NameContainsFold(*i.NameContainsFold))
	}
	if i.NumberOfEmployees != nil {
		predicates = append(predicates, company.NumberOfEmployeesEQ(*i.NumberOfEmployees))
	}
	if i.NumberOfEmployeesNEQ != nil {
		predicates = append(predicates, company.NumberOfEmployeesNEQ(*i.NumberOfEmployeesNEQ))
	}
	if len(i.NumberOfEmployeesIn) > 0 {
		predicates = append(predicates, company.NumberOfEmployeesIn(i.NumberOfEmployeesIn...))
	}
	if len(i.NumberOfEmployeesNotIn) > 0 {
		predicates = append(predicates, company.NumberOfEmployeesNotIn(i.NumberOfEmployeesNotIn...))
	}
	if i.NumberOfEmployeesGT != nil {
		predicates = append(predicates, company.NumberOfEmployeesGT(*i.NumberOfEmployeesGT))
	}
	if i.NumberOfEmployeesGTE != nil {
		predicates = append(predicates, company.NumberOfEmployeesGTE(*i.NumberOfEmployeesGTE))
	}
	if i.NumberOfEmployeesLT != nil {
		predicates = append(predicates, company.NumberOfEmployeesLT(*i.NumberOfEmployeesLT))
	}
	if i.NumberOfEmployeesLTE != nil {
		predicates = append(predicates, company.NumberOfEmployeesLTE(*i.NumberOfEmployeesLTE))
	}
	if i.Phone != nil {
		predicates = append(predicates, company.PhoneEQ(*i.Phone))
	}
	if i.PhoneNEQ != nil {
		predicates = append(predicates, company.PhoneNEQ(*i.PhoneNEQ))
	}
	if len(i.PhoneIn) > 0 {
		predicates = append(predicates, company.PhoneIn(i.PhoneIn...))
	}
	if len(i.PhoneNotIn) > 0 {
		predicates = append(predicates, company.PhoneNotIn(i.PhoneNotIn...))
	}
	if i.PhoneGT != nil {
		predicates = append(predicates, company.PhoneGT(*i.PhoneGT))
	}
	if i.PhoneGTE != nil {
		predicates = append(predicates, company.PhoneGTE(*i.PhoneGTE))
	}
	if i.PhoneLT != nil {
		predicates = append(predicates, company.PhoneLT(*i.PhoneLT))
	}
	if i.PhoneLTE != nil {
		predicates = append(predicates, company.PhoneLTE(*i.PhoneLTE))
	}
	if i.PhoneContains != nil {
		predicates = append(predicates, company.PhoneContains(*i.PhoneContains))
	}
	if i.PhoneHasPrefix != nil {
		predicates = append(predicates, company.PhoneHasPrefix(*i.PhoneHasPrefix))
	}
	if i.PhoneHasSuffix != nil {
		predicates = append(predicates, company.PhoneHasSuffix(*i.PhoneHasSuffix))
	}
	if i.PhoneIsNil {
		predicates = append(predicates, company.PhoneIsNil())
	}
	if i.PhoneNotNil {
		predicates = append(predicates, company.PhoneNotNil())
	}
	if i.PhoneEqualFold != nil {
		predicates = append(predicates, company.PhoneEqualFold(*i.PhoneEqualFold))
	}
	if i.PhoneContainsFold != nil {
		predicates = append(predicates, company.PhoneContainsFold(*i.PhoneContainsFold))
	}
	if i.TaxId != nil {
		predicates = append(predicates, company.TaxIdEQ(*i.TaxId))
	}
	if i.TaxIdNEQ != nil {
		predicates = append(predicates, company.TaxIdNEQ(*i.TaxIdNEQ))
	}
	if len(i.TaxIdIn) > 0 {
		predicates = append(predicates, company.TaxIdIn(i.TaxIdIn...))
	}
	if len(i.TaxIdNotIn) > 0 {
		predicates = append(predicates, company.TaxIdNotIn(i.TaxIdNotIn...))
	}
	if i.TaxIdGT != nil {
		predicates = append(predicates, company.TaxIdGT(*i.TaxIdGT))
	}
	if i.TaxIdGTE != nil {
		predicates = append(predicates, company.TaxIdGTE(*i.TaxIdGTE))
	}
	if i.TaxIdLT != nil {
		predicates = append(predicates, company.TaxIdLT(*i.TaxIdLT))
	}
	if i.TaxIdLTE != nil {
		predicates = append(predicates, company.TaxIdLTE(*i.TaxIdLTE))
	}
	if i.TaxIdContains != nil {
		predicates = append(predicates, company.TaxIdContains(*i.TaxIdContains))
	}
	if i.TaxIdHasPrefix != nil {
		predicates = append(predicates, company.TaxIdHasPrefix(*i.TaxIdHasPrefix))
	}
	if i.TaxIdHasSuffix != nil {
		predicates = append(predicates, company.TaxIdHasSuffix(*i.TaxIdHasSuffix))
	}
	if i.TaxIdEqualFold != nil {
		predicates = append(predicates, company.TaxIdEqualFold(*i.TaxIdEqualFold))
	}
	if i.TaxIdContainsFold != nil {
		predicates = append(predicates, company.TaxIdContainsFold(*i.TaxIdContainsFold))
	}
	if i.VatRate != nil {
		predicates = append(predicates, company.VatRateEQ(*i.VatRate))
	}
	if i.VatRateNEQ != nil {
		predicates = append(predicates, company.VatRateNEQ(*i.VatRateNEQ))
	}
	if len(i.VatRateIn) > 0 {
		predicates = append(predicates, company.VatRateIn(i.VatRateIn...))
	}
	if len(i.VatRateNotIn) > 0 {
		predicates = append(predicates, company.VatRateNotIn(i.VatRateNotIn...))
	}
	if i.VatRateGT != nil {
		predicates = append(predicates, company.VatRateGT(*i.VatRateGT))
	}
	if i.VatRateGTE != nil {
		predicates = append(predicates, company.VatRateGTE(*i.VatRateGTE))
	}
	if i.VatRateLT != nil {
		predicates = append(predicates, company.VatRateLT(*i.VatRateLT))
	}
	if i.VatRateLTE != nil {
		predicates = append(predicates, company.VatRateLTE(*i.VatRateLTE))
	}
	if i.Website != nil {
		predicates = append(predicates, company.WebsiteEQ(*i.Website))
	}
	if i.WebsiteNEQ != nil {
		predicates = append(predicates, company.WebsiteNEQ(*i.WebsiteNEQ))
	}
	if len(i.WebsiteIn) > 0 {
		predicates = append(predicates, company.WebsiteIn(i.WebsiteIn...))
	}
	if len(i.WebsiteNotIn) > 0 {
		predicates = append(predicates, company.WebsiteNotIn(i.WebsiteNotIn...))
	}
	if i.WebsiteGT != nil {
		predicates = append(predicates, company.WebsiteGT(*i.WebsiteGT))
	}
	if i.WebsiteGTE != nil {
		predicates = append(predicates, company.WebsiteGTE(*i.WebsiteGTE))
	}
	if i.WebsiteLT != nil {
		predicates = append(predicates, company.WebsiteLT(*i.WebsiteLT))
	}
	if i.WebsiteLTE != nil {
		predicates = append(predicates, company.WebsiteLTE(*i.WebsiteLTE))
	}
	if i.WebsiteContains != nil {
		predicates = append(predicates, company.WebsiteContains(*i.WebsiteContains))
	}
	if i.WebsiteHasPrefix != nil {
		predicates = append(predicates, company.WebsiteHasPrefix(*i.WebsiteHasPrefix))
	}
	if i.WebsiteHasSuffix != nil {
		predicates = append(predicates, company.WebsiteHasSuffix(*i.WebsiteHasSuffix))
	}
	if i.WebsiteIsNil {
		predicates = append(predicates, company.WebsiteIsNil())
	}
	if i.WebsiteNotNil {
		predicates = append(predicates, company.WebsiteNotNil())
	}
	if i.WebsiteEqualFold != nil {
		predicates = append(predicates, company.WebsiteEqualFold(*i.WebsiteEqualFold))
	}
	if i.WebsiteContainsFold != nil {
		predicates = append(predicates, company.WebsiteContainsFold(*i.WebsiteContainsFold))
	}
	if i.IncompleteSetup != nil {
		predicates = append(predicates, company.IncompleteSetupEQ(*i.IncompleteSetup))
	}
	if i.IncompleteSetupNEQ != nil {
		predicates = append(predicates, company.IncompleteSetupNEQ(*i.IncompleteSetupNEQ))
	}
	if i.IncompleteSetupIsNil {
		predicates = append(predicates, company.IncompleteSetupIsNil())
	}
	if i.IncompleteSetupNotNil {
		predicates = append(predicates, company.IncompleteSetupNotNil())
	}

	if i.HasAvailableRoles != nil {
		p := company.HasAvailableRoles()
		if !*i.HasAvailableRoles {
			p = company.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasAvailableRolesWith) > 0 {
		with := make([]predicate.UserRole, 0, len(i.HasAvailableRolesWith))
		for _, w := range i.HasAvailableRolesWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasAvailableRolesWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, company.HasAvailableRolesWith(with...))
	}
	if i.HasAccountingEntries != nil {
		p := company.HasAccountingEntries()
		if !*i.HasAccountingEntries {
			p = company.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasAccountingEntriesWith) > 0 {
		with := make([]predicate.AccountingEntry, 0, len(i.HasAccountingEntriesWith))
		for _, w := range i.HasAccountingEntriesWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasAccountingEntriesWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, company.HasAccountingEntriesWith(with...))
	}
	if i.HasCustomers != nil {
		p := company.HasCustomers()
		if !*i.HasCustomers {
			p = company.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasCustomersWith) > 0 {
		with := make([]predicate.Customer, 0, len(i.HasCustomersWith))
		for _, w := range i.HasCustomersWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasCustomersWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, company.HasCustomersWith(with...))
	}
	if i.HasDocuments != nil {
		p := company.HasDocuments()
		if !*i.HasDocuments {
			p = company.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasDocumentsWith) > 0 {
		with := make([]predicate.CompanyDocument, 0, len(i.HasDocumentsWith))
		for _, w := range i.HasDocumentsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasDocumentsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, company.HasDocumentsWith(with...))
	}
	if i.HasEmployees != nil {
		p := company.HasEmployees()
		if !*i.HasEmployees {
			p = company.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasEmployeesWith) > 0 {
		with := make([]predicate.Employee, 0, len(i.HasEmployeesWith))
		for _, w := range i.HasEmployeesWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasEmployeesWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, company.HasEmployeesWith(with...))
	}
	if i.HasFiles != nil {
		p := company.HasFiles()
		if !*i.HasFiles {
			p = company.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasFilesWith) > 0 {
		with := make([]predicate.File, 0, len(i.HasFilesWith))
		for _, w := range i.HasFilesWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasFilesWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, company.HasFilesWith(with...))
	}
	if i.HasMemberSignupTokens != nil {
		p := company.HasMemberSignupTokens()
		if !*i.HasMemberSignupTokens {
			p = company.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasMemberSignupTokensWith) > 0 {
		with := make([]predicate.MemberSignupToken, 0, len(i.HasMemberSignupTokensWith))
		for _, w := range i.HasMemberSignupTokensWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasMemberSignupTokensWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, company.HasMemberSignupTokensWith(with...))
	}
	if i.HasProducts != nil {
		p := company.HasProducts()
		if !*i.HasProducts {
			p = company.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasProductsWith) > 0 {
		with := make([]predicate.Product, 0, len(i.HasProductsWith))
		for _, w := range i.HasProductsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasProductsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, company.HasProductsWith(with...))
	}
	if i.HasProjects != nil {
		p := company.HasProjects()
		if !*i.HasProjects {
			p = company.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasProjectsWith) > 0 {
		with := make([]predicate.Project, 0, len(i.HasProjectsWith))
		for _, w := range i.HasProjectsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasProjectsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, company.HasProjectsWith(with...))
	}
	if i.HasPayables != nil {
		p := company.HasPayables()
		if !*i.HasPayables {
			p = company.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasPayablesWith) > 0 {
		with := make([]predicate.Payable, 0, len(i.HasPayablesWith))
		for _, w := range i.HasPayablesWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasPayablesWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, company.HasPayablesWith(with...))
	}
	if i.HasReceivables != nil {
		p := company.HasReceivables()
		if !*i.HasReceivables {
			p = company.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasReceivablesWith) > 0 {
		with := make([]predicate.Receivable, 0, len(i.HasReceivablesWith))
		for _, w := range i.HasReceivablesWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasReceivablesWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, company.HasReceivablesWith(with...))
	}
	if i.HasSuppliers != nil {
		p := company.HasSuppliers()
		if !*i.HasSuppliers {
			p = company.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasSuppliersWith) > 0 {
		with := make([]predicate.Supplier, 0, len(i.HasSuppliersWith))
		for _, w := range i.HasSuppliersWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasSuppliersWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, company.HasSuppliersWith(with...))
	}
	if i.HasTokens != nil {
		p := company.HasTokens()
		if !*i.HasTokens {
			p = company.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasTokensWith) > 0 {
		with := make([]predicate.Token, 0, len(i.HasTokensWith))
		for _, w := range i.HasTokensWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasTokensWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, company.HasTokensWith(with...))
	}
	if i.HasTreasuries != nil {
		p := company.HasTreasuries()
		if !*i.HasTreasuries {
			p = company.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasTreasuriesWith) > 0 {
		with := make([]predicate.Treasury, 0, len(i.HasTreasuriesWith))
		for _, w := range i.HasTreasuriesWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasTreasuriesWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, company.HasTreasuriesWith(with...))
	}
	if i.HasWorkShifts != nil {
		p := company.HasWorkShifts()
		if !*i.HasWorkShifts {
			p = company.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasWorkShiftsWith) > 0 {
		with := make([]predicate.Workshift, 0, len(i.HasWorkShiftsWith))
		for _, w := range i.HasWorkShiftsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasWorkShiftsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, company.HasWorkShiftsWith(with...))
	}
	if i.HasUsers != nil {
		p := company.HasUsers()
		if !*i.HasUsers {
			p = company.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasUsersWith) > 0 {
		with := make([]predicate.User, 0, len(i.HasUsersWith))
		for _, w := range i.HasUsersWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasUsersWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, company.HasUsersWith(with...))
	}
	if i.HasDaughterCompanies != nil {
		p := company.HasDaughterCompanies()
		if !*i.HasDaughterCompanies {
			p = company.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasDaughterCompaniesWith) > 0 {
		with := make([]predicate.Company, 0, len(i.HasDaughterCompaniesWith))
		for _, w := range i.HasDaughterCompaniesWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasDaughterCompaniesWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, company.HasDaughterCompaniesWith(with...))
	}
	if i.HasParentCompany != nil {
		p := company.HasParentCompany()
		if !*i.HasParentCompany {
			p = company.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasParentCompanyWith) > 0 {
		with := make([]predicate.Company, 0, len(i.HasParentCompanyWith))
		for _, w := range i.HasParentCompanyWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasParentCompanyWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, company.HasParentCompanyWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyCompanyWhereInput
	case 1:
		return predicates[0], nil
	default:
		return company.And(predicates...), nil
	}
}

// CompanyDocumentWhereInput represents a where input for filtering CompanyDocument queries.
type CompanyDocumentWhereInput struct {
	Predicates []predicate.CompanyDocument  `json:"-"`
	Not        *CompanyDocumentWhereInput   `json:"not,omitempty"`
	Or         []*CompanyDocumentWhereInput `json:"or,omitempty"`
	And        []*CompanyDocumentWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "createdAt" field predicates.
	CreatedAt      *time.Time  `json:"createdat,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdatNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdatIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdatNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdatGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdatGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdatLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdatLTE,omitempty"`

	// "updatedAt" field predicates.
	UpdatedAt      *time.Time  `json:"updatedat,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedatNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedatIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedatNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedatGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedatGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedatLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedatLTE,omitempty"`

	// "deletedAt" field predicates.
	DeletedAt       *time.Time  `json:"deletedat,omitempty"`
	DeletedAtNEQ    *time.Time  `json:"deletedatNEQ,omitempty"`
	DeletedAtIn     []time.Time `json:"deletedatIn,omitempty"`
	DeletedAtNotIn  []time.Time `json:"deletedatNotIn,omitempty"`
	DeletedAtGT     *time.Time  `json:"deletedatGT,omitempty"`
	DeletedAtGTE    *time.Time  `json:"deletedatGTE,omitempty"`
	DeletedAtLT     *time.Time  `json:"deletedatLT,omitempty"`
	DeletedAtLTE    *time.Time  `json:"deletedatLTE,omitempty"`
	DeletedAtIsNil  bool        `json:"deletedatIsNil,omitempty"`
	DeletedAtNotNil bool        `json:"deletedatNotNil,omitempty"`

	// "filename" field predicates.
	Filename             *string  `json:"filename,omitempty"`
	FilenameNEQ          *string  `json:"filenameNEQ,omitempty"`
	FilenameIn           []string `json:"filenameIn,omitempty"`
	FilenameNotIn        []string `json:"filenameNotIn,omitempty"`
	FilenameGT           *string  `json:"filenameGT,omitempty"`
	FilenameGTE          *string  `json:"filenameGTE,omitempty"`
	FilenameLT           *string  `json:"filenameLT,omitempty"`
	FilenameLTE          *string  `json:"filenameLTE,omitempty"`
	FilenameContains     *string  `json:"filenameContains,omitempty"`
	FilenameHasPrefix    *string  `json:"filenameHasPrefix,omitempty"`
	FilenameHasSuffix    *string  `json:"filenameHasSuffix,omitempty"`
	FilenameEqualFold    *string  `json:"filenameEqualFold,omitempty"`
	FilenameContainsFold *string  `json:"filenameContainsFold,omitempty"`

	// "title" field predicates.
	Title             *string  `json:"title,omitempty"`
	TitleNEQ          *string  `json:"titleNEQ,omitempty"`
	TitleIn           []string `json:"titleIn,omitempty"`
	TitleNotIn        []string `json:"titleNotIn,omitempty"`
	TitleGT           *string  `json:"titleGT,omitempty"`
	TitleGTE          *string  `json:"titleGTE,omitempty"`
	TitleLT           *string  `json:"titleLT,omitempty"`
	TitleLTE          *string  `json:"titleLTE,omitempty"`
	TitleContains     *string  `json:"titleContains,omitempty"`
	TitleHasPrefix    *string  `json:"titleHasPrefix,omitempty"`
	TitleHasSuffix    *string  `json:"titleHasSuffix,omitempty"`
	TitleEqualFold    *string  `json:"titleEqualFold,omitempty"`
	TitleContainsFold *string  `json:"titleContainsFold,omitempty"`

	// "keywords" field predicates.
	Keywords             *string  `json:"keywords,omitempty"`
	KeywordsNEQ          *string  `json:"keywordsNEQ,omitempty"`
	KeywordsIn           []string `json:"keywordsIn,omitempty"`
	KeywordsNotIn        []string `json:"keywordsNotIn,omitempty"`
	KeywordsGT           *string  `json:"keywordsGT,omitempty"`
	KeywordsGTE          *string  `json:"keywordsGTE,omitempty"`
	KeywordsLT           *string  `json:"keywordsLT,omitempty"`
	KeywordsLTE          *string  `json:"keywordsLTE,omitempty"`
	KeywordsContains     *string  `json:"keywordsContains,omitempty"`
	KeywordsHasPrefix    *string  `json:"keywordsHasPrefix,omitempty"`
	KeywordsHasSuffix    *string  `json:"keywordsHasSuffix,omitempty"`
	KeywordsEqualFold    *string  `json:"keywordsEqualFold,omitempty"`
	KeywordsContainsFold *string  `json:"keywordsContainsFold,omitempty"`

	// "category" field predicates.
	Category      *companydocument.Category  `json:"category,omitempty"`
	CategoryNEQ   *companydocument.Category  `json:"categoryNEQ,omitempty"`
	CategoryIn    []companydocument.Category `json:"categoryIn,omitempty"`
	CategoryNotIn []companydocument.Category `json:"categoryNotIn,omitempty"`

	// "size" field predicates.
	Size      *int  `json:"size,omitempty"`
	SizeNEQ   *int  `json:"sizeNEQ,omitempty"`
	SizeIn    []int `json:"sizeIn,omitempty"`
	SizeNotIn []int `json:"sizeNotIn,omitempty"`
	SizeGT    *int  `json:"sizeGT,omitempty"`
	SizeGTE   *int  `json:"sizeGTE,omitempty"`
	SizeLT    *int  `json:"sizeLT,omitempty"`
	SizeLTE   *int  `json:"sizeLTE,omitempty"`

	// "fileType" field predicates.
	FileType             *string  `json:"filetype,omitempty"`
	FileTypeNEQ          *string  `json:"filetypeNEQ,omitempty"`
	FileTypeIn           []string `json:"filetypeIn,omitempty"`
	FileTypeNotIn        []string `json:"filetypeNotIn,omitempty"`
	FileTypeGT           *string  `json:"filetypeGT,omitempty"`
	FileTypeGTE          *string  `json:"filetypeGTE,omitempty"`
	FileTypeLT           *string  `json:"filetypeLT,omitempty"`
	FileTypeLTE          *string  `json:"filetypeLTE,omitempty"`
	FileTypeContains     *string  `json:"filetypeContains,omitempty"`
	FileTypeHasPrefix    *string  `json:"filetypeHasPrefix,omitempty"`
	FileTypeHasSuffix    *string  `json:"filetypeHasSuffix,omitempty"`
	FileTypeEqualFold    *string  `json:"filetypeEqualFold,omitempty"`
	FileTypeContainsFold *string  `json:"filetypeContainsFold,omitempty"`

	// "status" field predicates.
	Status      *companydocument.Status  `json:"status,omitempty"`
	StatusNEQ   *companydocument.Status  `json:"statusNEQ,omitempty"`
	StatusIn    []companydocument.Status `json:"statusIn,omitempty"`
	StatusNotIn []companydocument.Status `json:"statusNotIn,omitempty"`

	// "url" field predicates.
	URL             *string  `json:"url,omitempty"`
	URLNEQ          *string  `json:"urlNEQ,omitempty"`
	URLIn           []string `json:"urlIn,omitempty"`
	URLNotIn        []string `json:"urlNotIn,omitempty"`
	URLGT           *string  `json:"urlGT,omitempty"`
	URLGTE          *string  `json:"urlGTE,omitempty"`
	URLLT           *string  `json:"urlLT,omitempty"`
	URLLTE          *string  `json:"urlLTE,omitempty"`
	URLContains     *string  `json:"urlContains,omitempty"`
	URLHasPrefix    *string  `json:"urlHasPrefix,omitempty"`
	URLHasSuffix    *string  `json:"urlHasSuffix,omitempty"`
	URLEqualFold    *string  `json:"urlEqualFold,omitempty"`
	URLContainsFold *string  `json:"urlContainsFold,omitempty"`

	// "storageURI" field predicates.
	StorageURI             *string  `json:"storageuri,omitempty"`
	StorageURINEQ          *string  `json:"storageuriNEQ,omitempty"`
	StorageURIIn           []string `json:"storageuriIn,omitempty"`
	StorageURINotIn        []string `json:"storageuriNotIn,omitempty"`
	StorageURIGT           *string  `json:"storageuriGT,omitempty"`
	StorageURIGTE          *string  `json:"storageuriGTE,omitempty"`
	StorageURILT           *string  `json:"storageuriLT,omitempty"`
	StorageURILTE          *string  `json:"storageuriLTE,omitempty"`
	StorageURIContains     *string  `json:"storageuriContains,omitempty"`
	StorageURIHasPrefix    *string  `json:"storageuriHasPrefix,omitempty"`
	StorageURIHasSuffix    *string  `json:"storageuriHasSuffix,omitempty"`
	StorageURIEqualFold    *string  `json:"storageuriEqualFold,omitempty"`
	StorageURIContainsFold *string  `json:"storageuriContainsFold,omitempty"`

	// "thumbnail" field predicates.
	Thumbnail             *string  `json:"thumbnail,omitempty"`
	ThumbnailNEQ          *string  `json:"thumbnailNEQ,omitempty"`
	ThumbnailIn           []string `json:"thumbnailIn,omitempty"`
	ThumbnailNotIn        []string `json:"thumbnailNotIn,omitempty"`
	ThumbnailGT           *string  `json:"thumbnailGT,omitempty"`
	ThumbnailGTE          *string  `json:"thumbnailGTE,omitempty"`
	ThumbnailLT           *string  `json:"thumbnailLT,omitempty"`
	ThumbnailLTE          *string  `json:"thumbnailLTE,omitempty"`
	ThumbnailContains     *string  `json:"thumbnailContains,omitempty"`
	ThumbnailHasPrefix    *string  `json:"thumbnailHasPrefix,omitempty"`
	ThumbnailHasSuffix    *string  `json:"thumbnailHasSuffix,omitempty"`
	ThumbnailIsNil        bool     `json:"thumbnailIsNil,omitempty"`
	ThumbnailNotNil       bool     `json:"thumbnailNotNil,omitempty"`
	ThumbnailEqualFold    *string  `json:"thumbnailEqualFold,omitempty"`
	ThumbnailContainsFold *string  `json:"thumbnailContainsFold,omitempty"`

	// "expiryDate" field predicates.
	ExpiryDate      *time.Time  `json:"expirydate,omitempty"`
	ExpiryDateNEQ   *time.Time  `json:"expirydateNEQ,omitempty"`
	ExpiryDateIn    []time.Time `json:"expirydateIn,omitempty"`
	ExpiryDateNotIn []time.Time `json:"expirydateNotIn,omitempty"`
	ExpiryDateGT    *time.Time  `json:"expirydateGT,omitempty"`
	ExpiryDateGTE   *time.Time  `json:"expirydateGTE,omitempty"`
	ExpiryDateLT    *time.Time  `json:"expirydateLT,omitempty"`
	ExpiryDateLTE   *time.Time  `json:"expirydateLTE,omitempty"`

	// "company" edge predicates.
	HasCompany     *bool                `json:"hasCompany,omitempty"`
	HasCompanyWith []*CompanyWhereInput `json:"hasCompanyWith,omitempty"`

	// "uploadedBy" edge predicates.
	HasUploadedBy     *bool             `json:"hasUploadedBy,omitempty"`
	HasUploadedByWith []*UserWhereInput `json:"hasUploadedByWith,omitempty"`

	// "approvedBy" edge predicates.
	HasApprovedBy     *bool             `json:"hasApprovedBy,omitempty"`
	HasApprovedByWith []*UserWhereInput `json:"hasApprovedByWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *CompanyDocumentWhereInput) AddPredicates(predicates ...predicate.CompanyDocument) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the CompanyDocumentWhereInput filter on the CompanyDocumentQuery builder.
func (i *CompanyDocumentWhereInput) Filter(q *CompanyDocumentQuery) (*CompanyDocumentQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyCompanyDocumentWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyCompanyDocumentWhereInput is returned in case the CompanyDocumentWhereInput is empty.
var ErrEmptyCompanyDocumentWhereInput = errors.New("generated: empty predicate CompanyDocumentWhereInput")

// P returns a predicate for filtering companydocuments.
// An error is returned if the input is empty or invalid.
func (i *CompanyDocumentWhereInput) P() (predicate.CompanyDocument, error) {
	var predicates []predicate.CompanyDocument
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, companydocument.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.CompanyDocument, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, companydocument.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.CompanyDocument, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, companydocument.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, companydocument.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, companydocument.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, companydocument.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, companydocument.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, companydocument.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, companydocument.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, companydocument.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, companydocument.IDLTE(*i.IDLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, companydocument.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, companydocument.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, companydocument.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, companydocument.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, companydocument.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, companydocument.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, companydocument.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, companydocument.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, companydocument.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, companydocument.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, companydocument.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, companydocument.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, companydocument.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, companydocument.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, companydocument.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, companydocument.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.DeletedAt != nil {
		predicates = append(predicates, companydocument.DeletedAtEQ(*i.DeletedAt))
	}
	if i.DeletedAtNEQ != nil {
		predicates = append(predicates, companydocument.DeletedAtNEQ(*i.DeletedAtNEQ))
	}
	if len(i.DeletedAtIn) > 0 {
		predicates = append(predicates, companydocument.DeletedAtIn(i.DeletedAtIn...))
	}
	if len(i.DeletedAtNotIn) > 0 {
		predicates = append(predicates, companydocument.DeletedAtNotIn(i.DeletedAtNotIn...))
	}
	if i.DeletedAtGT != nil {
		predicates = append(predicates, companydocument.DeletedAtGT(*i.DeletedAtGT))
	}
	if i.DeletedAtGTE != nil {
		predicates = append(predicates, companydocument.DeletedAtGTE(*i.DeletedAtGTE))
	}
	if i.DeletedAtLT != nil {
		predicates = append(predicates, companydocument.DeletedAtLT(*i.DeletedAtLT))
	}
	if i.DeletedAtLTE != nil {
		predicates = append(predicates, companydocument.DeletedAtLTE(*i.DeletedAtLTE))
	}
	if i.DeletedAtIsNil {
		predicates = append(predicates, companydocument.DeletedAtIsNil())
	}
	if i.DeletedAtNotNil {
		predicates = append(predicates, companydocument.DeletedAtNotNil())
	}
	if i.Filename != nil {
		predicates = append(predicates, companydocument.FilenameEQ(*i.Filename))
	}
	if i.FilenameNEQ != nil {
		predicates = append(predicates, companydocument.FilenameNEQ(*i.FilenameNEQ))
	}
	if len(i.FilenameIn) > 0 {
		predicates = append(predicates, companydocument.FilenameIn(i.FilenameIn...))
	}
	if len(i.FilenameNotIn) > 0 {
		predicates = append(predicates, companydocument.FilenameNotIn(i.FilenameNotIn...))
	}
	if i.FilenameGT != nil {
		predicates = append(predicates, companydocument.FilenameGT(*i.FilenameGT))
	}
	if i.FilenameGTE != nil {
		predicates = append(predicates, companydocument.FilenameGTE(*i.FilenameGTE))
	}
	if i.FilenameLT != nil {
		predicates = append(predicates, companydocument.FilenameLT(*i.FilenameLT))
	}
	if i.FilenameLTE != nil {
		predicates = append(predicates, companydocument.FilenameLTE(*i.FilenameLTE))
	}
	if i.FilenameContains != nil {
		predicates = append(predicates, companydocument.FilenameContains(*i.FilenameContains))
	}
	if i.FilenameHasPrefix != nil {
		predicates = append(predicates, companydocument.FilenameHasPrefix(*i.FilenameHasPrefix))
	}
	if i.FilenameHasSuffix != nil {
		predicates = append(predicates, companydocument.FilenameHasSuffix(*i.FilenameHasSuffix))
	}
	if i.FilenameEqualFold != nil {
		predicates = append(predicates, companydocument.FilenameEqualFold(*i.FilenameEqualFold))
	}
	if i.FilenameContainsFold != nil {
		predicates = append(predicates, companydocument.FilenameContainsFold(*i.FilenameContainsFold))
	}
	if i.Title != nil {
		predicates = append(predicates, companydocument.TitleEQ(*i.Title))
	}
	if i.TitleNEQ != nil {
		predicates = append(predicates, companydocument.TitleNEQ(*i.TitleNEQ))
	}
	if len(i.TitleIn) > 0 {
		predicates = append(predicates, companydocument.TitleIn(i.TitleIn...))
	}
	if len(i.TitleNotIn) > 0 {
		predicates = append(predicates, companydocument.TitleNotIn(i.TitleNotIn...))
	}
	if i.TitleGT != nil {
		predicates = append(predicates, companydocument.TitleGT(*i.TitleGT))
	}
	if i.TitleGTE != nil {
		predicates = append(predicates, companydocument.TitleGTE(*i.TitleGTE))
	}
	if i.TitleLT != nil {
		predicates = append(predicates, companydocument.TitleLT(*i.TitleLT))
	}
	if i.TitleLTE != nil {
		predicates = append(predicates, companydocument.TitleLTE(*i.TitleLTE))
	}
	if i.TitleContains != nil {
		predicates = append(predicates, companydocument.TitleContains(*i.TitleContains))
	}
	if i.TitleHasPrefix != nil {
		predicates = append(predicates, companydocument.TitleHasPrefix(*i.TitleHasPrefix))
	}
	if i.TitleHasSuffix != nil {
		predicates = append(predicates, companydocument.TitleHasSuffix(*i.TitleHasSuffix))
	}
	if i.TitleEqualFold != nil {
		predicates = append(predicates, companydocument.TitleEqualFold(*i.TitleEqualFold))
	}
	if i.TitleContainsFold != nil {
		predicates = append(predicates, companydocument.TitleContainsFold(*i.TitleContainsFold))
	}
	if i.Keywords != nil {
		predicates = append(predicates, companydocument.KeywordsEQ(*i.Keywords))
	}
	if i.KeywordsNEQ != nil {
		predicates = append(predicates, companydocument.KeywordsNEQ(*i.KeywordsNEQ))
	}
	if len(i.KeywordsIn) > 0 {
		predicates = append(predicates, companydocument.KeywordsIn(i.KeywordsIn...))
	}
	if len(i.KeywordsNotIn) > 0 {
		predicates = append(predicates, companydocument.KeywordsNotIn(i.KeywordsNotIn...))
	}
	if i.KeywordsGT != nil {
		predicates = append(predicates, companydocument.KeywordsGT(*i.KeywordsGT))
	}
	if i.KeywordsGTE != nil {
		predicates = append(predicates, companydocument.KeywordsGTE(*i.KeywordsGTE))
	}
	if i.KeywordsLT != nil {
		predicates = append(predicates, companydocument.KeywordsLT(*i.KeywordsLT))
	}
	if i.KeywordsLTE != nil {
		predicates = append(predicates, companydocument.KeywordsLTE(*i.KeywordsLTE))
	}
	if i.KeywordsContains != nil {
		predicates = append(predicates, companydocument.KeywordsContains(*i.KeywordsContains))
	}
	if i.KeywordsHasPrefix != nil {
		predicates = append(predicates, companydocument.KeywordsHasPrefix(*i.KeywordsHasPrefix))
	}
	if i.KeywordsHasSuffix != nil {
		predicates = append(predicates, companydocument.KeywordsHasSuffix(*i.KeywordsHasSuffix))
	}
	if i.KeywordsEqualFold != nil {
		predicates = append(predicates, companydocument.KeywordsEqualFold(*i.KeywordsEqualFold))
	}
	if i.KeywordsContainsFold != nil {
		predicates = append(predicates, companydocument.KeywordsContainsFold(*i.KeywordsContainsFold))
	}
	if i.Category != nil {
		predicates = append(predicates, companydocument.CategoryEQ(*i.Category))
	}
	if i.CategoryNEQ != nil {
		predicates = append(predicates, companydocument.CategoryNEQ(*i.CategoryNEQ))
	}
	if len(i.CategoryIn) > 0 {
		predicates = append(predicates, companydocument.CategoryIn(i.CategoryIn...))
	}
	if len(i.CategoryNotIn) > 0 {
		predicates = append(predicates, companydocument.CategoryNotIn(i.CategoryNotIn...))
	}
	if i.Size != nil {
		predicates = append(predicates, companydocument.SizeEQ(*i.Size))
	}
	if i.SizeNEQ != nil {
		predicates = append(predicates, companydocument.SizeNEQ(*i.SizeNEQ))
	}
	if len(i.SizeIn) > 0 {
		predicates = append(predicates, companydocument.SizeIn(i.SizeIn...))
	}
	if len(i.SizeNotIn) > 0 {
		predicates = append(predicates, companydocument.SizeNotIn(i.SizeNotIn...))
	}
	if i.SizeGT != nil {
		predicates = append(predicates, companydocument.SizeGT(*i.SizeGT))
	}
	if i.SizeGTE != nil {
		predicates = append(predicates, companydocument.SizeGTE(*i.SizeGTE))
	}
	if i.SizeLT != nil {
		predicates = append(predicates, companydocument.SizeLT(*i.SizeLT))
	}
	if i.SizeLTE != nil {
		predicates = append(predicates, companydocument.SizeLTE(*i.SizeLTE))
	}
	if i.FileType != nil {
		predicates = append(predicates, companydocument.FileTypeEQ(*i.FileType))
	}
	if i.FileTypeNEQ != nil {
		predicates = append(predicates, companydocument.FileTypeNEQ(*i.FileTypeNEQ))
	}
	if len(i.FileTypeIn) > 0 {
		predicates = append(predicates, companydocument.FileTypeIn(i.FileTypeIn...))
	}
	if len(i.FileTypeNotIn) > 0 {
		predicates = append(predicates, companydocument.FileTypeNotIn(i.FileTypeNotIn...))
	}
	if i.FileTypeGT != nil {
		predicates = append(predicates, companydocument.FileTypeGT(*i.FileTypeGT))
	}
	if i.FileTypeGTE != nil {
		predicates = append(predicates, companydocument.FileTypeGTE(*i.FileTypeGTE))
	}
	if i.FileTypeLT != nil {
		predicates = append(predicates, companydocument.FileTypeLT(*i.FileTypeLT))
	}
	if i.FileTypeLTE != nil {
		predicates = append(predicates, companydocument.FileTypeLTE(*i.FileTypeLTE))
	}
	if i.FileTypeContains != nil {
		predicates = append(predicates, companydocument.FileTypeContains(*i.FileTypeContains))
	}
	if i.FileTypeHasPrefix != nil {
		predicates = append(predicates, companydocument.FileTypeHasPrefix(*i.FileTypeHasPrefix))
	}
	if i.FileTypeHasSuffix != nil {
		predicates = append(predicates, companydocument.FileTypeHasSuffix(*i.FileTypeHasSuffix))
	}
	if i.FileTypeEqualFold != nil {
		predicates = append(predicates, companydocument.FileTypeEqualFold(*i.FileTypeEqualFold))
	}
	if i.FileTypeContainsFold != nil {
		predicates = append(predicates, companydocument.FileTypeContainsFold(*i.FileTypeContainsFold))
	}
	if i.Status != nil {
		predicates = append(predicates, companydocument.StatusEQ(*i.Status))
	}
	if i.StatusNEQ != nil {
		predicates = append(predicates, companydocument.StatusNEQ(*i.StatusNEQ))
	}
	if len(i.StatusIn) > 0 {
		predicates = append(predicates, companydocument.StatusIn(i.StatusIn...))
	}
	if len(i.StatusNotIn) > 0 {
		predicates = append(predicates, companydocument.StatusNotIn(i.StatusNotIn...))
	}
	if i.URL != nil {
		predicates = append(predicates, companydocument.URLEQ(*i.URL))
	}
	if i.URLNEQ != nil {
		predicates = append(predicates, companydocument.URLNEQ(*i.URLNEQ))
	}
	if len(i.URLIn) > 0 {
		predicates = append(predicates, companydocument.URLIn(i.URLIn...))
	}
	if len(i.URLNotIn) > 0 {
		predicates = append(predicates, companydocument.URLNotIn(i.URLNotIn...))
	}
	if i.URLGT != nil {
		predicates = append(predicates, companydocument.URLGT(*i.URLGT))
	}
	if i.URLGTE != nil {
		predicates = append(predicates, companydocument.URLGTE(*i.URLGTE))
	}
	if i.URLLT != nil {
		predicates = append(predicates, companydocument.URLLT(*i.URLLT))
	}
	if i.URLLTE != nil {
		predicates = append(predicates, companydocument.URLLTE(*i.URLLTE))
	}
	if i.URLContains != nil {
		predicates = append(predicates, companydocument.URLContains(*i.URLContains))
	}
	if i.URLHasPrefix != nil {
		predicates = append(predicates, companydocument.URLHasPrefix(*i.URLHasPrefix))
	}
	if i.URLHasSuffix != nil {
		predicates = append(predicates, companydocument.URLHasSuffix(*i.URLHasSuffix))
	}
	if i.URLEqualFold != nil {
		predicates = append(predicates, companydocument.URLEqualFold(*i.URLEqualFold))
	}
	if i.URLContainsFold != nil {
		predicates = append(predicates, companydocument.URLContainsFold(*i.URLContainsFold))
	}
	if i.StorageURI != nil {
		predicates = append(predicates, companydocument.StorageURIEQ(*i.StorageURI))
	}
	if i.StorageURINEQ != nil {
		predicates = append(predicates, companydocument.StorageURINEQ(*i.StorageURINEQ))
	}
	if len(i.StorageURIIn) > 0 {
		predicates = append(predicates, companydocument.StorageURIIn(i.StorageURIIn...))
	}
	if len(i.StorageURINotIn) > 0 {
		predicates = append(predicates, companydocument.StorageURINotIn(i.StorageURINotIn...))
	}
	if i.StorageURIGT != nil {
		predicates = append(predicates, companydocument.StorageURIGT(*i.StorageURIGT))
	}
	if i.StorageURIGTE != nil {
		predicates = append(predicates, companydocument.StorageURIGTE(*i.StorageURIGTE))
	}
	if i.StorageURILT != nil {
		predicates = append(predicates, companydocument.StorageURILT(*i.StorageURILT))
	}
	if i.StorageURILTE != nil {
		predicates = append(predicates, companydocument.StorageURILTE(*i.StorageURILTE))
	}
	if i.StorageURIContains != nil {
		predicates = append(predicates, companydocument.StorageURIContains(*i.StorageURIContains))
	}
	if i.StorageURIHasPrefix != nil {
		predicates = append(predicates, companydocument.StorageURIHasPrefix(*i.StorageURIHasPrefix))
	}
	if i.StorageURIHasSuffix != nil {
		predicates = append(predicates, companydocument.StorageURIHasSuffix(*i.StorageURIHasSuffix))
	}
	if i.StorageURIEqualFold != nil {
		predicates = append(predicates, companydocument.StorageURIEqualFold(*i.StorageURIEqualFold))
	}
	if i.StorageURIContainsFold != nil {
		predicates = append(predicates, companydocument.StorageURIContainsFold(*i.StorageURIContainsFold))
	}
	if i.Thumbnail != nil {
		predicates = append(predicates, companydocument.ThumbnailEQ(*i.Thumbnail))
	}
	if i.ThumbnailNEQ != nil {
		predicates = append(predicates, companydocument.ThumbnailNEQ(*i.ThumbnailNEQ))
	}
	if len(i.ThumbnailIn) > 0 {
		predicates = append(predicates, companydocument.ThumbnailIn(i.ThumbnailIn...))
	}
	if len(i.ThumbnailNotIn) > 0 {
		predicates = append(predicates, companydocument.ThumbnailNotIn(i.ThumbnailNotIn...))
	}
	if i.ThumbnailGT != nil {
		predicates = append(predicates, companydocument.ThumbnailGT(*i.ThumbnailGT))
	}
	if i.ThumbnailGTE != nil {
		predicates = append(predicates, companydocument.ThumbnailGTE(*i.ThumbnailGTE))
	}
	if i.ThumbnailLT != nil {
		predicates = append(predicates, companydocument.ThumbnailLT(*i.ThumbnailLT))
	}
	if i.ThumbnailLTE != nil {
		predicates = append(predicates, companydocument.ThumbnailLTE(*i.ThumbnailLTE))
	}
	if i.ThumbnailContains != nil {
		predicates = append(predicates, companydocument.ThumbnailContains(*i.ThumbnailContains))
	}
	if i.ThumbnailHasPrefix != nil {
		predicates = append(predicates, companydocument.ThumbnailHasPrefix(*i.ThumbnailHasPrefix))
	}
	if i.ThumbnailHasSuffix != nil {
		predicates = append(predicates, companydocument.ThumbnailHasSuffix(*i.ThumbnailHasSuffix))
	}
	if i.ThumbnailIsNil {
		predicates = append(predicates, companydocument.ThumbnailIsNil())
	}
	if i.ThumbnailNotNil {
		predicates = append(predicates, companydocument.ThumbnailNotNil())
	}
	if i.ThumbnailEqualFold != nil {
		predicates = append(predicates, companydocument.ThumbnailEqualFold(*i.ThumbnailEqualFold))
	}
	if i.ThumbnailContainsFold != nil {
		predicates = append(predicates, companydocument.ThumbnailContainsFold(*i.ThumbnailContainsFold))
	}
	if i.ExpiryDate != nil {
		predicates = append(predicates, companydocument.ExpiryDateEQ(*i.ExpiryDate))
	}
	if i.ExpiryDateNEQ != nil {
		predicates = append(predicates, companydocument.ExpiryDateNEQ(*i.ExpiryDateNEQ))
	}
	if len(i.ExpiryDateIn) > 0 {
		predicates = append(predicates, companydocument.ExpiryDateIn(i.ExpiryDateIn...))
	}
	if len(i.ExpiryDateNotIn) > 0 {
		predicates = append(predicates, companydocument.ExpiryDateNotIn(i.ExpiryDateNotIn...))
	}
	if i.ExpiryDateGT != nil {
		predicates = append(predicates, companydocument.ExpiryDateGT(*i.ExpiryDateGT))
	}
	if i.ExpiryDateGTE != nil {
		predicates = append(predicates, companydocument.ExpiryDateGTE(*i.ExpiryDateGTE))
	}
	if i.ExpiryDateLT != nil {
		predicates = append(predicates, companydocument.ExpiryDateLT(*i.ExpiryDateLT))
	}
	if i.ExpiryDateLTE != nil {
		predicates = append(predicates, companydocument.ExpiryDateLTE(*i.ExpiryDateLTE))
	}

	if i.HasCompany != nil {
		p := companydocument.HasCompany()
		if !*i.HasCompany {
			p = companydocument.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasCompanyWith) > 0 {
		with := make([]predicate.Company, 0, len(i.HasCompanyWith))
		for _, w := range i.HasCompanyWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasCompanyWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, companydocument.HasCompanyWith(with...))
	}
	if i.HasUploadedBy != nil {
		p := companydocument.HasUploadedBy()
		if !*i.HasUploadedBy {
			p = companydocument.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasUploadedByWith) > 0 {
		with := make([]predicate.User, 0, len(i.HasUploadedByWith))
		for _, w := range i.HasUploadedByWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasUploadedByWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, companydocument.HasUploadedByWith(with...))
	}
	if i.HasApprovedBy != nil {
		p := companydocument.HasApprovedBy()
		if !*i.HasApprovedBy {
			p = companydocument.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasApprovedByWith) > 0 {
		with := make([]predicate.User, 0, len(i.HasApprovedByWith))
		for _, w := range i.HasApprovedByWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasApprovedByWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, companydocument.HasApprovedByWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyCompanyDocumentWhereInput
	case 1:
		return predicates[0], nil
	default:
		return companydocument.And(predicates...), nil
	}
}

// CustomerWhereInput represents a where input for filtering Customer queries.
type CustomerWhereInput struct {
	Predicates []predicate.Customer  `json:"-"`
	Not        *CustomerWhereInput   `json:"not,omitempty"`
	Or         []*CustomerWhereInput `json:"or,omitempty"`
	And        []*CustomerWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "createdAt" field predicates.
	CreatedAt      *time.Time  `json:"createdat,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdatNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdatIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdatNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdatGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdatGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdatLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdatLTE,omitempty"`

	// "updatedAt" field predicates.
	UpdatedAt      *time.Time  `json:"updatedat,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedatNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedatIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedatNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedatGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedatGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedatLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedatLTE,omitempty"`

	// "deletedAt" field predicates.
	DeletedAt       *time.Time  `json:"deletedat,omitempty"`
	DeletedAtNEQ    *time.Time  `json:"deletedatNEQ,omitempty"`
	DeletedAtIn     []time.Time `json:"deletedatIn,omitempty"`
	DeletedAtNotIn  []time.Time `json:"deletedatNotIn,omitempty"`
	DeletedAtGT     *time.Time  `json:"deletedatGT,omitempty"`
	DeletedAtGTE    *time.Time  `json:"deletedatGTE,omitempty"`
	DeletedAtLT     *time.Time  `json:"deletedatLT,omitempty"`
	DeletedAtLTE    *time.Time  `json:"deletedatLTE,omitempty"`
	DeletedAtIsNil  bool        `json:"deletedatIsNil,omitempty"`
	DeletedAtNotNil bool        `json:"deletedatNotNil,omitempty"`

	// "address" field predicates.
	Address             *string  `json:"address,omitempty"`
	AddressNEQ          *string  `json:"addressNEQ,omitempty"`
	AddressIn           []string `json:"addressIn,omitempty"`
	AddressNotIn        []string `json:"addressNotIn,omitempty"`
	AddressGT           *string  `json:"addressGT,omitempty"`
	AddressGTE          *string  `json:"addressGTE,omitempty"`
	AddressLT           *string  `json:"addressLT,omitempty"`
	AddressLTE          *string  `json:"addressLTE,omitempty"`
	AddressContains     *string  `json:"addressContains,omitempty"`
	AddressHasPrefix    *string  `json:"addressHasPrefix,omitempty"`
	AddressHasSuffix    *string  `json:"addressHasSuffix,omitempty"`
	AddressEqualFold    *string  `json:"addressEqualFold,omitempty"`
	AddressContainsFold *string  `json:"addressContainsFold,omitempty"`

	// "city" field predicates.
	City             *string  `json:"city,omitempty"`
	CityNEQ          *string  `json:"cityNEQ,omitempty"`
	CityIn           []string `json:"cityIn,omitempty"`
	CityNotIn        []string `json:"cityNotIn,omitempty"`
	CityGT           *string  `json:"cityGT,omitempty"`
	CityGTE          *string  `json:"cityGTE,omitempty"`
	CityLT           *string  `json:"cityLT,omitempty"`
	CityLTE          *string  `json:"cityLTE,omitempty"`
	CityContains     *string  `json:"cityContains,omitempty"`
	CityHasPrefix    *string  `json:"cityHasPrefix,omitempty"`
	CityHasSuffix    *string  `json:"cityHasSuffix,omitempty"`
	CityEqualFold    *string  `json:"cityEqualFold,omitempty"`
	CityContainsFold *string  `json:"cityContainsFold,omitempty"`

	// "country" field predicates.
	Country             *string  `json:"country,omitempty"`
	CountryNEQ          *string  `json:"countryNEQ,omitempty"`
	CountryIn           []string `json:"countryIn,omitempty"`
	CountryNotIn        []string `json:"countryNotIn,omitempty"`
	CountryGT           *string  `json:"countryGT,omitempty"`
	CountryGTE          *string  `json:"countryGTE,omitempty"`
	CountryLT           *string  `json:"countryLT,omitempty"`
	CountryLTE          *string  `json:"countryLTE,omitempty"`
	CountryContains     *string  `json:"countryContains,omitempty"`
	CountryHasPrefix    *string  `json:"countryHasPrefix,omitempty"`
	CountryHasSuffix    *string  `json:"countryHasSuffix,omitempty"`
	CountryEqualFold    *string  `json:"countryEqualFold,omitempty"`
	CountryContainsFold *string  `json:"countryContainsFold,omitempty"`

	// "description" field predicates.
	Description             *string  `json:"description,omitempty"`
	DescriptionNEQ          *string  `json:"descriptionNEQ,omitempty"`
	DescriptionIn           []string `json:"descriptionIn,omitempty"`
	DescriptionNotIn        []string `json:"descriptionNotIn,omitempty"`
	DescriptionGT           *string  `json:"descriptionGT,omitempty"`
	DescriptionGTE          *string  `json:"descriptionGTE,omitempty"`
	DescriptionLT           *string  `json:"descriptionLT,omitempty"`
	DescriptionLTE          *string  `json:"descriptionLTE,omitempty"`
	DescriptionContains     *string  `json:"descriptionContains,omitempty"`
	DescriptionHasPrefix    *string  `json:"descriptionHasPrefix,omitempty"`
	DescriptionHasSuffix    *string  `json:"descriptionHasSuffix,omitempty"`
	DescriptionIsNil        bool     `json:"descriptionIsNil,omitempty"`
	DescriptionNotNil       bool     `json:"descriptionNotNil,omitempty"`
	DescriptionEqualFold    *string  `json:"descriptionEqualFold,omitempty"`
	DescriptionContainsFold *string  `json:"descriptionContainsFold,omitempty"`

	// "email" field predicates.
	Email             *string  `json:"email,omitempty"`
	EmailNEQ          *string  `json:"emailNEQ,omitempty"`
	EmailIn           []string `json:"emailIn,omitempty"`
	EmailNotIn        []string `json:"emailNotIn,omitempty"`
	EmailGT           *string  `json:"emailGT,omitempty"`
	EmailGTE          *string  `json:"emailGTE,omitempty"`
	EmailLT           *string  `json:"emailLT,omitempty"`
	EmailLTE          *string  `json:"emailLTE,omitempty"`
	EmailContains     *string  `json:"emailContains,omitempty"`
	EmailHasPrefix    *string  `json:"emailHasPrefix,omitempty"`
	EmailHasSuffix    *string  `json:"emailHasSuffix,omitempty"`
	EmailIsNil        bool     `json:"emailIsNil,omitempty"`
	EmailNotNil       bool     `json:"emailNotNil,omitempty"`
	EmailEqualFold    *string  `json:"emailEqualFold,omitempty"`
	EmailContainsFold *string  `json:"emailContainsFold,omitempty"`

	// "isDefault" field predicates.
	IsDefault       *bool `json:"isdefault,omitempty"`
	IsDefaultNEQ    *bool `json:"isdefaultNEQ,omitempty"`
	IsDefaultIsNil  bool  `json:"isdefaultIsNil,omitempty"`
	IsDefaultNotNil bool  `json:"isdefaultNotNil,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "phone" field predicates.
	Phone             *string  `json:"phone,omitempty"`
	PhoneNEQ          *string  `json:"phoneNEQ,omitempty"`
	PhoneIn           []string `json:"phoneIn,omitempty"`
	PhoneNotIn        []string `json:"phoneNotIn,omitempty"`
	PhoneGT           *string  `json:"phoneGT,omitempty"`
	PhoneGTE          *string  `json:"phoneGTE,omitempty"`
	PhoneLT           *string  `json:"phoneLT,omitempty"`
	PhoneLTE          *string  `json:"phoneLTE,omitempty"`
	PhoneContains     *string  `json:"phoneContains,omitempty"`
	PhoneHasPrefix    *string  `json:"phoneHasPrefix,omitempty"`
	PhoneHasSuffix    *string  `json:"phoneHasSuffix,omitempty"`
	PhoneEqualFold    *string  `json:"phoneEqualFold,omitempty"`
	PhoneContainsFold *string  `json:"phoneContainsFold,omitempty"`

	// "taxId" field predicates.
	TaxId             *string  `json:"taxid,omitempty"`
	TaxIdNEQ          *string  `json:"taxidNEQ,omitempty"`
	TaxIdIn           []string `json:"taxidIn,omitempty"`
	TaxIdNotIn        []string `json:"taxidNotIn,omitempty"`
	TaxIdGT           *string  `json:"taxidGT,omitempty"`
	TaxIdGTE          *string  `json:"taxidGTE,omitempty"`
	TaxIdLT           *string  `json:"taxidLT,omitempty"`
	TaxIdLTE          *string  `json:"taxidLTE,omitempty"`
	TaxIdContains     *string  `json:"taxidContains,omitempty"`
	TaxIdHasPrefix    *string  `json:"taxidHasPrefix,omitempty"`
	TaxIdHasSuffix    *string  `json:"taxidHasSuffix,omitempty"`
	TaxIdEqualFold    *string  `json:"taxidEqualFold,omitempty"`
	TaxIdContainsFold *string  `json:"taxidContainsFold,omitempty"`

	// "company" edge predicates.
	HasCompany     *bool                `json:"hasCompany,omitempty"`
	HasCompanyWith []*CompanyWhereInput `json:"hasCompanyWith,omitempty"`

	// "receivables" edge predicates.
	HasReceivables     *bool                   `json:"hasReceivables,omitempty"`
	HasReceivablesWith []*ReceivableWhereInput `json:"hasReceivablesWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *CustomerWhereInput) AddPredicates(predicates ...predicate.Customer) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the CustomerWhereInput filter on the CustomerQuery builder.
func (i *CustomerWhereInput) Filter(q *CustomerQuery) (*CustomerQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyCustomerWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyCustomerWhereInput is returned in case the CustomerWhereInput is empty.
var ErrEmptyCustomerWhereInput = errors.New("generated: empty predicate CustomerWhereInput")

// P returns a predicate for filtering customers.
// An error is returned if the input is empty or invalid.
func (i *CustomerWhereInput) P() (predicate.Customer, error) {
	var predicates []predicate.Customer
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, customer.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Customer, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, customer.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Customer, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, customer.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, customer.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, customer.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, customer.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, customer.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, customer.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, customer.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, customer.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, customer.IDLTE(*i.IDLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, customer.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, customer.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, customer.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, customer.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, customer.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, customer.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, customer.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, customer.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, customer.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, customer.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, customer.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, customer.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, customer.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, customer.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, customer.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, customer.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.DeletedAt != nil {
		predicates = append(predicates, customer.DeletedAtEQ(*i.DeletedAt))
	}
	if i.DeletedAtNEQ != nil {
		predicates = append(predicates, customer.DeletedAtNEQ(*i.DeletedAtNEQ))
	}
	if len(i.DeletedAtIn) > 0 {
		predicates = append(predicates, customer.DeletedAtIn(i.DeletedAtIn...))
	}
	if len(i.DeletedAtNotIn) > 0 {
		predicates = append(predicates, customer.DeletedAtNotIn(i.DeletedAtNotIn...))
	}
	if i.DeletedAtGT != nil {
		predicates = append(predicates, customer.DeletedAtGT(*i.DeletedAtGT))
	}
	if i.DeletedAtGTE != nil {
		predicates = append(predicates, customer.DeletedAtGTE(*i.DeletedAtGTE))
	}
	if i.DeletedAtLT != nil {
		predicates = append(predicates, customer.DeletedAtLT(*i.DeletedAtLT))
	}
	if i.DeletedAtLTE != nil {
		predicates = append(predicates, customer.DeletedAtLTE(*i.DeletedAtLTE))
	}
	if i.DeletedAtIsNil {
		predicates = append(predicates, customer.DeletedAtIsNil())
	}
	if i.DeletedAtNotNil {
		predicates = append(predicates, customer.DeletedAtNotNil())
	}
	if i.Address != nil {
		predicates = append(predicates, customer.AddressEQ(*i.Address))
	}
	if i.AddressNEQ != nil {
		predicates = append(predicates, customer.AddressNEQ(*i.AddressNEQ))
	}
	if len(i.AddressIn) > 0 {
		predicates = append(predicates, customer.AddressIn(i.AddressIn...))
	}
	if len(i.AddressNotIn) > 0 {
		predicates = append(predicates, customer.AddressNotIn(i.AddressNotIn...))
	}
	if i.AddressGT != nil {
		predicates = append(predicates, customer.AddressGT(*i.AddressGT))
	}
	if i.AddressGTE != nil {
		predicates = append(predicates, customer.AddressGTE(*i.AddressGTE))
	}
	if i.AddressLT != nil {
		predicates = append(predicates, customer.AddressLT(*i.AddressLT))
	}
	if i.AddressLTE != nil {
		predicates = append(predicates, customer.AddressLTE(*i.AddressLTE))
	}
	if i.AddressContains != nil {
		predicates = append(predicates, customer.AddressContains(*i.AddressContains))
	}
	if i.AddressHasPrefix != nil {
		predicates = append(predicates, customer.AddressHasPrefix(*i.AddressHasPrefix))
	}
	if i.AddressHasSuffix != nil {
		predicates = append(predicates, customer.AddressHasSuffix(*i.AddressHasSuffix))
	}
	if i.AddressEqualFold != nil {
		predicates = append(predicates, customer.AddressEqualFold(*i.AddressEqualFold))
	}
	if i.AddressContainsFold != nil {
		predicates = append(predicates, customer.AddressContainsFold(*i.AddressContainsFold))
	}
	if i.City != nil {
		predicates = append(predicates, customer.CityEQ(*i.City))
	}
	if i.CityNEQ != nil {
		predicates = append(predicates, customer.CityNEQ(*i.CityNEQ))
	}
	if len(i.CityIn) > 0 {
		predicates = append(predicates, customer.CityIn(i.CityIn...))
	}
	if len(i.CityNotIn) > 0 {
		predicates = append(predicates, customer.CityNotIn(i.CityNotIn...))
	}
	if i.CityGT != nil {
		predicates = append(predicates, customer.CityGT(*i.CityGT))
	}
	if i.CityGTE != nil {
		predicates = append(predicates, customer.CityGTE(*i.CityGTE))
	}
	if i.CityLT != nil {
		predicates = append(predicates, customer.CityLT(*i.CityLT))
	}
	if i.CityLTE != nil {
		predicates = append(predicates, customer.CityLTE(*i.CityLTE))
	}
	if i.CityContains != nil {
		predicates = append(predicates, customer.CityContains(*i.CityContains))
	}
	if i.CityHasPrefix != nil {
		predicates = append(predicates, customer.CityHasPrefix(*i.CityHasPrefix))
	}
	if i.CityHasSuffix != nil {
		predicates = append(predicates, customer.CityHasSuffix(*i.CityHasSuffix))
	}
	if i.CityEqualFold != nil {
		predicates = append(predicates, customer.CityEqualFold(*i.CityEqualFold))
	}
	if i.CityContainsFold != nil {
		predicates = append(predicates, customer.CityContainsFold(*i.CityContainsFold))
	}
	if i.Country != nil {
		predicates = append(predicates, customer.CountryEQ(*i.Country))
	}
	if i.CountryNEQ != nil {
		predicates = append(predicates, customer.CountryNEQ(*i.CountryNEQ))
	}
	if len(i.CountryIn) > 0 {
		predicates = append(predicates, customer.CountryIn(i.CountryIn...))
	}
	if len(i.CountryNotIn) > 0 {
		predicates = append(predicates, customer.CountryNotIn(i.CountryNotIn...))
	}
	if i.CountryGT != nil {
		predicates = append(predicates, customer.CountryGT(*i.CountryGT))
	}
	if i.CountryGTE != nil {
		predicates = append(predicates, customer.CountryGTE(*i.CountryGTE))
	}
	if i.CountryLT != nil {
		predicates = append(predicates, customer.CountryLT(*i.CountryLT))
	}
	if i.CountryLTE != nil {
		predicates = append(predicates, customer.CountryLTE(*i.CountryLTE))
	}
	if i.CountryContains != nil {
		predicates = append(predicates, customer.CountryContains(*i.CountryContains))
	}
	if i.CountryHasPrefix != nil {
		predicates = append(predicates, customer.CountryHasPrefix(*i.CountryHasPrefix))
	}
	if i.CountryHasSuffix != nil {
		predicates = append(predicates, customer.CountryHasSuffix(*i.CountryHasSuffix))
	}
	if i.CountryEqualFold != nil {
		predicates = append(predicates, customer.CountryEqualFold(*i.CountryEqualFold))
	}
	if i.CountryContainsFold != nil {
		predicates = append(predicates, customer.CountryContainsFold(*i.CountryContainsFold))
	}
	if i.Description != nil {
		predicates = append(predicates, customer.DescriptionEQ(*i.Description))
	}
	if i.DescriptionNEQ != nil {
		predicates = append(predicates, customer.DescriptionNEQ(*i.DescriptionNEQ))
	}
	if len(i.DescriptionIn) > 0 {
		predicates = append(predicates, customer.DescriptionIn(i.DescriptionIn...))
	}
	if len(i.DescriptionNotIn) > 0 {
		predicates = append(predicates, customer.DescriptionNotIn(i.DescriptionNotIn...))
	}
	if i.DescriptionGT != nil {
		predicates = append(predicates, customer.DescriptionGT(*i.DescriptionGT))
	}
	if i.DescriptionGTE != nil {
		predicates = append(predicates, customer.DescriptionGTE(*i.DescriptionGTE))
	}
	if i.DescriptionLT != nil {
		predicates = append(predicates, customer.DescriptionLT(*i.DescriptionLT))
	}
	if i.DescriptionLTE != nil {
		predicates = append(predicates, customer.DescriptionLTE(*i.DescriptionLTE))
	}
	if i.DescriptionContains != nil {
		predicates = append(predicates, customer.DescriptionContains(*i.DescriptionContains))
	}
	if i.DescriptionHasPrefix != nil {
		predicates = append(predicates, customer.DescriptionHasPrefix(*i.DescriptionHasPrefix))
	}
	if i.DescriptionHasSuffix != nil {
		predicates = append(predicates, customer.DescriptionHasSuffix(*i.DescriptionHasSuffix))
	}
	if i.DescriptionIsNil {
		predicates = append(predicates, customer.DescriptionIsNil())
	}
	if i.DescriptionNotNil {
		predicates = append(predicates, customer.DescriptionNotNil())
	}
	if i.DescriptionEqualFold != nil {
		predicates = append(predicates, customer.DescriptionEqualFold(*i.DescriptionEqualFold))
	}
	if i.DescriptionContainsFold != nil {
		predicates = append(predicates, customer.DescriptionContainsFold(*i.DescriptionContainsFold))
	}
	if i.Email != nil {
		predicates = append(predicates, customer.EmailEQ(*i.Email))
	}
	if i.EmailNEQ != nil {
		predicates = append(predicates, customer.EmailNEQ(*i.EmailNEQ))
	}
	if len(i.EmailIn) > 0 {
		predicates = append(predicates, customer.EmailIn(i.EmailIn...))
	}
	if len(i.EmailNotIn) > 0 {
		predicates = append(predicates, customer.EmailNotIn(i.EmailNotIn...))
	}
	if i.EmailGT != nil {
		predicates = append(predicates, customer.EmailGT(*i.EmailGT))
	}
	if i.EmailGTE != nil {
		predicates = append(predicates, customer.EmailGTE(*i.EmailGTE))
	}
	if i.EmailLT != nil {
		predicates = append(predicates, customer.EmailLT(*i.EmailLT))
	}
	if i.EmailLTE != nil {
		predicates = append(predicates, customer.EmailLTE(*i.EmailLTE))
	}
	if i.EmailContains != nil {
		predicates = append(predicates, customer.EmailContains(*i.EmailContains))
	}
	if i.EmailHasPrefix != nil {
		predicates = append(predicates, customer.EmailHasPrefix(*i.EmailHasPrefix))
	}
	if i.EmailHasSuffix != nil {
		predicates = append(predicates, customer.EmailHasSuffix(*i.EmailHasSuffix))
	}
	if i.EmailIsNil {
		predicates = append(predicates, customer.EmailIsNil())
	}
	if i.EmailNotNil {
		predicates = append(predicates, customer.EmailNotNil())
	}
	if i.EmailEqualFold != nil {
		predicates = append(predicates, customer.EmailEqualFold(*i.EmailEqualFold))
	}
	if i.EmailContainsFold != nil {
		predicates = append(predicates, customer.EmailContainsFold(*i.EmailContainsFold))
	}
	if i.IsDefault != nil {
		predicates = append(predicates, customer.IsDefaultEQ(*i.IsDefault))
	}
	if i.IsDefaultNEQ != nil {
		predicates = append(predicates, customer.IsDefaultNEQ(*i.IsDefaultNEQ))
	}
	if i.IsDefaultIsNil {
		predicates = append(predicates, customer.IsDefaultIsNil())
	}
	if i.IsDefaultNotNil {
		predicates = append(predicates, customer.IsDefaultNotNil())
	}
	if i.Name != nil {
		predicates = append(predicates, customer.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, customer.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, customer.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, customer.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, customer.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, customer.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, customer.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, customer.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, customer.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, customer.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, customer.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, customer.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, customer.NameContainsFold(*i.NameContainsFold))
	}
	if i.Phone != nil {
		predicates = append(predicates, customer.PhoneEQ(*i.Phone))
	}
	if i.PhoneNEQ != nil {
		predicates = append(predicates, customer.PhoneNEQ(*i.PhoneNEQ))
	}
	if len(i.PhoneIn) > 0 {
		predicates = append(predicates, customer.PhoneIn(i.PhoneIn...))
	}
	if len(i.PhoneNotIn) > 0 {
		predicates = append(predicates, customer.PhoneNotIn(i.PhoneNotIn...))
	}
	if i.PhoneGT != nil {
		predicates = append(predicates, customer.PhoneGT(*i.PhoneGT))
	}
	if i.PhoneGTE != nil {
		predicates = append(predicates, customer.PhoneGTE(*i.PhoneGTE))
	}
	if i.PhoneLT != nil {
		predicates = append(predicates, customer.PhoneLT(*i.PhoneLT))
	}
	if i.PhoneLTE != nil {
		predicates = append(predicates, customer.PhoneLTE(*i.PhoneLTE))
	}
	if i.PhoneContains != nil {
		predicates = append(predicates, customer.PhoneContains(*i.PhoneContains))
	}
	if i.PhoneHasPrefix != nil {
		predicates = append(predicates, customer.PhoneHasPrefix(*i.PhoneHasPrefix))
	}
	if i.PhoneHasSuffix != nil {
		predicates = append(predicates, customer.PhoneHasSuffix(*i.PhoneHasSuffix))
	}
	if i.PhoneEqualFold != nil {
		predicates = append(predicates, customer.PhoneEqualFold(*i.PhoneEqualFold))
	}
	if i.PhoneContainsFold != nil {
		predicates = append(predicates, customer.PhoneContainsFold(*i.PhoneContainsFold))
	}
	if i.TaxId != nil {
		predicates = append(predicates, customer.TaxIdEQ(*i.TaxId))
	}
	if i.TaxIdNEQ != nil {
		predicates = append(predicates, customer.TaxIdNEQ(*i.TaxIdNEQ))
	}
	if len(i.TaxIdIn) > 0 {
		predicates = append(predicates, customer.TaxIdIn(i.TaxIdIn...))
	}
	if len(i.TaxIdNotIn) > 0 {
		predicates = append(predicates, customer.TaxIdNotIn(i.TaxIdNotIn...))
	}
	if i.TaxIdGT != nil {
		predicates = append(predicates, customer.TaxIdGT(*i.TaxIdGT))
	}
	if i.TaxIdGTE != nil {
		predicates = append(predicates, customer.TaxIdGTE(*i.TaxIdGTE))
	}
	if i.TaxIdLT != nil {
		predicates = append(predicates, customer.TaxIdLT(*i.TaxIdLT))
	}
	if i.TaxIdLTE != nil {
		predicates = append(predicates, customer.TaxIdLTE(*i.TaxIdLTE))
	}
	if i.TaxIdContains != nil {
		predicates = append(predicates, customer.TaxIdContains(*i.TaxIdContains))
	}
	if i.TaxIdHasPrefix != nil {
		predicates = append(predicates, customer.TaxIdHasPrefix(*i.TaxIdHasPrefix))
	}
	if i.TaxIdHasSuffix != nil {
		predicates = append(predicates, customer.TaxIdHasSuffix(*i.TaxIdHasSuffix))
	}
	if i.TaxIdEqualFold != nil {
		predicates = append(predicates, customer.TaxIdEqualFold(*i.TaxIdEqualFold))
	}
	if i.TaxIdContainsFold != nil {
		predicates = append(predicates, customer.TaxIdContainsFold(*i.TaxIdContainsFold))
	}

	if i.HasCompany != nil {
		p := customer.HasCompany()
		if !*i.HasCompany {
			p = customer.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasCompanyWith) > 0 {
		with := make([]predicate.Company, 0, len(i.HasCompanyWith))
		for _, w := range i.HasCompanyWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasCompanyWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, customer.HasCompanyWith(with...))
	}
	if i.HasReceivables != nil {
		p := customer.HasReceivables()
		if !*i.HasReceivables {
			p = customer.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasReceivablesWith) > 0 {
		with := make([]predicate.Receivable, 0, len(i.HasReceivablesWith))
		for _, w := range i.HasReceivablesWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasReceivablesWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, customer.HasReceivablesWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyCustomerWhereInput
	case 1:
		return predicates[0], nil
	default:
		return customer.And(predicates...), nil
	}
}

// EmployeeWhereInput represents a where input for filtering Employee queries.
type EmployeeWhereInput struct {
	Predicates []predicate.Employee  `json:"-"`
	Not        *EmployeeWhereInput   `json:"not,omitempty"`
	Or         []*EmployeeWhereInput `json:"or,omitempty"`
	And        []*EmployeeWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "createdAt" field predicates.
	CreatedAt      *time.Time  `json:"createdat,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdatNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdatIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdatNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdatGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdatGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdatLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdatLTE,omitempty"`

	// "updatedAt" field predicates.
	UpdatedAt      *time.Time  `json:"updatedat,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedatNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedatIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedatNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedatGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedatGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedatLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedatLTE,omitempty"`

	// "deletedAt" field predicates.
	DeletedAt       *time.Time  `json:"deletedat,omitempty"`
	DeletedAtNEQ    *time.Time  `json:"deletedatNEQ,omitempty"`
	DeletedAtIn     []time.Time `json:"deletedatIn,omitempty"`
	DeletedAtNotIn  []time.Time `json:"deletedatNotIn,omitempty"`
	DeletedAtGT     *time.Time  `json:"deletedatGT,omitempty"`
	DeletedAtGTE    *time.Time  `json:"deletedatGTE,omitempty"`
	DeletedAtLT     *time.Time  `json:"deletedatLT,omitempty"`
	DeletedAtLTE    *time.Time  `json:"deletedatLTE,omitempty"`
	DeletedAtIsNil  bool        `json:"deletedatIsNil,omitempty"`
	DeletedAtNotNil bool        `json:"deletedatNotNil,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "gender" field predicates.
	Gender      *employee.Gender  `json:"gender,omitempty"`
	GenderNEQ   *employee.Gender  `json:"genderNEQ,omitempty"`
	GenderIn    []employee.Gender `json:"genderIn,omitempty"`
	GenderNotIn []employee.Gender `json:"genderNotIn,omitempty"`

	// "position" field predicates.
	Position             *string  `json:"position,omitempty"`
	PositionNEQ          *string  `json:"positionNEQ,omitempty"`
	PositionIn           []string `json:"positionIn,omitempty"`
	PositionNotIn        []string `json:"positionNotIn,omitempty"`
	PositionGT           *string  `json:"positionGT,omitempty"`
	PositionGTE          *string  `json:"positionGTE,omitempty"`
	PositionLT           *string  `json:"positionLT,omitempty"`
	PositionLTE          *string  `json:"positionLTE,omitempty"`
	PositionContains     *string  `json:"positionContains,omitempty"`
	PositionHasPrefix    *string  `json:"positionHasPrefix,omitempty"`
	PositionHasSuffix    *string  `json:"positionHasSuffix,omitempty"`
	PositionIsNil        bool     `json:"positionIsNil,omitempty"`
	PositionNotNil       bool     `json:"positionNotNil,omitempty"`
	PositionEqualFold    *string  `json:"positionEqualFold,omitempty"`
	PositionContainsFold *string  `json:"positionContainsFold,omitempty"`

	// "email" field predicates.
	Email             *string  `json:"email,omitempty"`
	EmailNEQ          *string  `json:"emailNEQ,omitempty"`
	EmailIn           []string `json:"emailIn,omitempty"`
	EmailNotIn        []string `json:"emailNotIn,omitempty"`
	EmailGT           *string  `json:"emailGT,omitempty"`
	EmailGTE          *string  `json:"emailGTE,omitempty"`
	EmailLT           *string  `json:"emailLT,omitempty"`
	EmailLTE          *string  `json:"emailLTE,omitempty"`
	EmailContains     *string  `json:"emailContains,omitempty"`
	EmailHasPrefix    *string  `json:"emailHasPrefix,omitempty"`
	EmailHasSuffix    *string  `json:"emailHasSuffix,omitempty"`
	EmailIsNil        bool     `json:"emailIsNil,omitempty"`
	EmailNotNil       bool     `json:"emailNotNil,omitempty"`
	EmailEqualFold    *string  `json:"emailEqualFold,omitempty"`
	EmailContainsFold *string  `json:"emailContainsFold,omitempty"`

	// "phone" field predicates.
	Phone             *string  `json:"phone,omitempty"`
	PhoneNEQ          *string  `json:"phoneNEQ,omitempty"`
	PhoneIn           []string `json:"phoneIn,omitempty"`
	PhoneNotIn        []string `json:"phoneNotIn,omitempty"`
	PhoneGT           *string  `json:"phoneGT,omitempty"`
	PhoneGTE          *string  `json:"phoneGTE,omitempty"`
	PhoneLT           *string  `json:"phoneLT,omitempty"`
	PhoneLTE          *string  `json:"phoneLTE,omitempty"`
	PhoneContains     *string  `json:"phoneContains,omitempty"`
	PhoneHasPrefix    *string  `json:"phoneHasPrefix,omitempty"`
	PhoneHasSuffix    *string  `json:"phoneHasSuffix,omitempty"`
	PhoneEqualFold    *string  `json:"phoneEqualFold,omitempty"`
	PhoneContainsFold *string  `json:"phoneContainsFold,omitempty"`

	// "company" edge predicates.
	HasCompany     *bool                `json:"hasCompany,omitempty"`
	HasCompanyWith []*CompanyWhereInput `json:"hasCompanyWith,omitempty"`

	// "user" edge predicates.
	HasUser     *bool             `json:"hasUser,omitempty"`
	HasUserWith []*UserWhereInput `json:"hasUserWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *EmployeeWhereInput) AddPredicates(predicates ...predicate.Employee) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the EmployeeWhereInput filter on the EmployeeQuery builder.
func (i *EmployeeWhereInput) Filter(q *EmployeeQuery) (*EmployeeQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyEmployeeWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyEmployeeWhereInput is returned in case the EmployeeWhereInput is empty.
var ErrEmptyEmployeeWhereInput = errors.New("generated: empty predicate EmployeeWhereInput")

// P returns a predicate for filtering employees.
// An error is returned if the input is empty or invalid.
func (i *EmployeeWhereInput) P() (predicate.Employee, error) {
	var predicates []predicate.Employee
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, employee.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Employee, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, employee.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Employee, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, employee.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, employee.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, employee.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, employee.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, employee.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, employee.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, employee.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, employee.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, employee.IDLTE(*i.IDLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, employee.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, employee.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, employee.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, employee.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, employee.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, employee.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, employee.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, employee.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, employee.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, employee.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, employee.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, employee.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, employee.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, employee.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, employee.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, employee.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.DeletedAt != nil {
		predicates = append(predicates, employee.DeletedAtEQ(*i.DeletedAt))
	}
	if i.DeletedAtNEQ != nil {
		predicates = append(predicates, employee.DeletedAtNEQ(*i.DeletedAtNEQ))
	}
	if len(i.DeletedAtIn) > 0 {
		predicates = append(predicates, employee.DeletedAtIn(i.DeletedAtIn...))
	}
	if len(i.DeletedAtNotIn) > 0 {
		predicates = append(predicates, employee.DeletedAtNotIn(i.DeletedAtNotIn...))
	}
	if i.DeletedAtGT != nil {
		predicates = append(predicates, employee.DeletedAtGT(*i.DeletedAtGT))
	}
	if i.DeletedAtGTE != nil {
		predicates = append(predicates, employee.DeletedAtGTE(*i.DeletedAtGTE))
	}
	if i.DeletedAtLT != nil {
		predicates = append(predicates, employee.DeletedAtLT(*i.DeletedAtLT))
	}
	if i.DeletedAtLTE != nil {
		predicates = append(predicates, employee.DeletedAtLTE(*i.DeletedAtLTE))
	}
	if i.DeletedAtIsNil {
		predicates = append(predicates, employee.DeletedAtIsNil())
	}
	if i.DeletedAtNotNil {
		predicates = append(predicates, employee.DeletedAtNotNil())
	}
	if i.Name != nil {
		predicates = append(predicates, employee.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, employee.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, employee.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, employee.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, employee.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, employee.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, employee.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, employee.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, employee.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, employee.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, employee.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, employee.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, employee.NameContainsFold(*i.NameContainsFold))
	}
	if i.Gender != nil {
		predicates = append(predicates, employee.GenderEQ(*i.Gender))
	}
	if i.GenderNEQ != nil {
		predicates = append(predicates, employee.GenderNEQ(*i.GenderNEQ))
	}
	if len(i.GenderIn) > 0 {
		predicates = append(predicates, employee.GenderIn(i.GenderIn...))
	}
	if len(i.GenderNotIn) > 0 {
		predicates = append(predicates, employee.GenderNotIn(i.GenderNotIn...))
	}
	if i.Position != nil {
		predicates = append(predicates, employee.PositionEQ(*i.Position))
	}
	if i.PositionNEQ != nil {
		predicates = append(predicates, employee.PositionNEQ(*i.PositionNEQ))
	}
	if len(i.PositionIn) > 0 {
		predicates = append(predicates, employee.PositionIn(i.PositionIn...))
	}
	if len(i.PositionNotIn) > 0 {
		predicates = append(predicates, employee.PositionNotIn(i.PositionNotIn...))
	}
	if i.PositionGT != nil {
		predicates = append(predicates, employee.PositionGT(*i.PositionGT))
	}
	if i.PositionGTE != nil {
		predicates = append(predicates, employee.PositionGTE(*i.PositionGTE))
	}
	if i.PositionLT != nil {
		predicates = append(predicates, employee.PositionLT(*i.PositionLT))
	}
	if i.PositionLTE != nil {
		predicates = append(predicates, employee.PositionLTE(*i.PositionLTE))
	}
	if i.PositionContains != nil {
		predicates = append(predicates, employee.PositionContains(*i.PositionContains))
	}
	if i.PositionHasPrefix != nil {
		predicates = append(predicates, employee.PositionHasPrefix(*i.PositionHasPrefix))
	}
	if i.PositionHasSuffix != nil {
		predicates = append(predicates, employee.PositionHasSuffix(*i.PositionHasSuffix))
	}
	if i.PositionIsNil {
		predicates = append(predicates, employee.PositionIsNil())
	}
	if i.PositionNotNil {
		predicates = append(predicates, employee.PositionNotNil())
	}
	if i.PositionEqualFold != nil {
		predicates = append(predicates, employee.PositionEqualFold(*i.PositionEqualFold))
	}
	if i.PositionContainsFold != nil {
		predicates = append(predicates, employee.PositionContainsFold(*i.PositionContainsFold))
	}
	if i.Email != nil {
		predicates = append(predicates, employee.EmailEQ(*i.Email))
	}
	if i.EmailNEQ != nil {
		predicates = append(predicates, employee.EmailNEQ(*i.EmailNEQ))
	}
	if len(i.EmailIn) > 0 {
		predicates = append(predicates, employee.EmailIn(i.EmailIn...))
	}
	if len(i.EmailNotIn) > 0 {
		predicates = append(predicates, employee.EmailNotIn(i.EmailNotIn...))
	}
	if i.EmailGT != nil {
		predicates = append(predicates, employee.EmailGT(*i.EmailGT))
	}
	if i.EmailGTE != nil {
		predicates = append(predicates, employee.EmailGTE(*i.EmailGTE))
	}
	if i.EmailLT != nil {
		predicates = append(predicates, employee.EmailLT(*i.EmailLT))
	}
	if i.EmailLTE != nil {
		predicates = append(predicates, employee.EmailLTE(*i.EmailLTE))
	}
	if i.EmailContains != nil {
		predicates = append(predicates, employee.EmailContains(*i.EmailContains))
	}
	if i.EmailHasPrefix != nil {
		predicates = append(predicates, employee.EmailHasPrefix(*i.EmailHasPrefix))
	}
	if i.EmailHasSuffix != nil {
		predicates = append(predicates, employee.EmailHasSuffix(*i.EmailHasSuffix))
	}
	if i.EmailIsNil {
		predicates = append(predicates, employee.EmailIsNil())
	}
	if i.EmailNotNil {
		predicates = append(predicates, employee.EmailNotNil())
	}
	if i.EmailEqualFold != nil {
		predicates = append(predicates, employee.EmailEqualFold(*i.EmailEqualFold))
	}
	if i.EmailContainsFold != nil {
		predicates = append(predicates, employee.EmailContainsFold(*i.EmailContainsFold))
	}
	if i.Phone != nil {
		predicates = append(predicates, employee.PhoneEQ(*i.Phone))
	}
	if i.PhoneNEQ != nil {
		predicates = append(predicates, employee.PhoneNEQ(*i.PhoneNEQ))
	}
	if len(i.PhoneIn) > 0 {
		predicates = append(predicates, employee.PhoneIn(i.PhoneIn...))
	}
	if len(i.PhoneNotIn) > 0 {
		predicates = append(predicates, employee.PhoneNotIn(i.PhoneNotIn...))
	}
	if i.PhoneGT != nil {
		predicates = append(predicates, employee.PhoneGT(*i.PhoneGT))
	}
	if i.PhoneGTE != nil {
		predicates = append(predicates, employee.PhoneGTE(*i.PhoneGTE))
	}
	if i.PhoneLT != nil {
		predicates = append(predicates, employee.PhoneLT(*i.PhoneLT))
	}
	if i.PhoneLTE != nil {
		predicates = append(predicates, employee.PhoneLTE(*i.PhoneLTE))
	}
	if i.PhoneContains != nil {
		predicates = append(predicates, employee.PhoneContains(*i.PhoneContains))
	}
	if i.PhoneHasPrefix != nil {
		predicates = append(predicates, employee.PhoneHasPrefix(*i.PhoneHasPrefix))
	}
	if i.PhoneHasSuffix != nil {
		predicates = append(predicates, employee.PhoneHasSuffix(*i.PhoneHasSuffix))
	}
	if i.PhoneEqualFold != nil {
		predicates = append(predicates, employee.PhoneEqualFold(*i.PhoneEqualFold))
	}
	if i.PhoneContainsFold != nil {
		predicates = append(predicates, employee.PhoneContainsFold(*i.PhoneContainsFold))
	}

	if i.HasCompany != nil {
		p := employee.HasCompany()
		if !*i.HasCompany {
			p = employee.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasCompanyWith) > 0 {
		with := make([]predicate.Company, 0, len(i.HasCompanyWith))
		for _, w := range i.HasCompanyWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasCompanyWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, employee.HasCompanyWith(with...))
	}
	if i.HasUser != nil {
		p := employee.HasUser()
		if !*i.HasUser {
			p = employee.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasUserWith) > 0 {
		with := make([]predicate.User, 0, len(i.HasUserWith))
		for _, w := range i.HasUserWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasUserWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, employee.HasUserWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyEmployeeWhereInput
	case 1:
		return predicates[0], nil
	default:
		return employee.And(predicates...), nil
	}
}

// FileWhereInput represents a where input for filtering File queries.
type FileWhereInput struct {
	Predicates []predicate.File  `json:"-"`
	Not        *FileWhereInput   `json:"not,omitempty"`
	Or         []*FileWhereInput `json:"or,omitempty"`
	And        []*FileWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "createdAt" field predicates.
	CreatedAt      *time.Time  `json:"createdat,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdatNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdatIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdatNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdatGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdatGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdatLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdatLTE,omitempty"`

	// "updatedAt" field predicates.
	UpdatedAt      *time.Time  `json:"updatedat,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedatNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedatIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedatNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedatGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedatGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedatLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedatLTE,omitempty"`

	// "deletedAt" field predicates.
	DeletedAt       *time.Time  `json:"deletedat,omitempty"`
	DeletedAtNEQ    *time.Time  `json:"deletedatNEQ,omitempty"`
	DeletedAtIn     []time.Time `json:"deletedatIn,omitempty"`
	DeletedAtNotIn  []time.Time `json:"deletedatNotIn,omitempty"`
	DeletedAtGT     *time.Time  `json:"deletedatGT,omitempty"`
	DeletedAtGTE    *time.Time  `json:"deletedatGTE,omitempty"`
	DeletedAtLT     *time.Time  `json:"deletedatLT,omitempty"`
	DeletedAtLTE    *time.Time  `json:"deletedatLTE,omitempty"`
	DeletedAtIsNil  bool        `json:"deletedatIsNil,omitempty"`
	DeletedAtNotNil bool        `json:"deletedatNotNil,omitempty"`

	// "category" field predicates.
	Category      *file.Category  `json:"category,omitempty"`
	CategoryNEQ   *file.Category  `json:"categoryNEQ,omitempty"`
	CategoryIn    []file.Category `json:"categoryIn,omitempty"`
	CategoryNotIn []file.Category `json:"categoryNotIn,omitempty"`

	// "extension" field predicates.
	Extension             *string  `json:"extension,omitempty"`
	ExtensionNEQ          *string  `json:"extensionNEQ,omitempty"`
	ExtensionIn           []string `json:"extensionIn,omitempty"`
	ExtensionNotIn        []string `json:"extensionNotIn,omitempty"`
	ExtensionGT           *string  `json:"extensionGT,omitempty"`
	ExtensionGTE          *string  `json:"extensionGTE,omitempty"`
	ExtensionLT           *string  `json:"extensionLT,omitempty"`
	ExtensionLTE          *string  `json:"extensionLTE,omitempty"`
	ExtensionContains     *string  `json:"extensionContains,omitempty"`
	ExtensionHasPrefix    *string  `json:"extensionHasPrefix,omitempty"`
	ExtensionHasSuffix    *string  `json:"extensionHasSuffix,omitempty"`
	ExtensionEqualFold    *string  `json:"extensionEqualFold,omitempty"`
	ExtensionContainsFold *string  `json:"extensionContainsFold,omitempty"`

	// "size" field predicates.
	Size             *string  `json:"size,omitempty"`
	SizeNEQ          *string  `json:"sizeNEQ,omitempty"`
	SizeIn           []string `json:"sizeIn,omitempty"`
	SizeNotIn        []string `json:"sizeNotIn,omitempty"`
	SizeGT           *string  `json:"sizeGT,omitempty"`
	SizeGTE          *string  `json:"sizeGTE,omitempty"`
	SizeLT           *string  `json:"sizeLT,omitempty"`
	SizeLTE          *string  `json:"sizeLTE,omitempty"`
	SizeContains     *string  `json:"sizeContains,omitempty"`
	SizeHasPrefix    *string  `json:"sizeHasPrefix,omitempty"`
	SizeHasSuffix    *string  `json:"sizeHasSuffix,omitempty"`
	SizeEqualFold    *string  `json:"sizeEqualFold,omitempty"`
	SizeContainsFold *string  `json:"sizeContainsFold,omitempty"`

	// "uri" field predicates.
	URI             *string  `json:"uri,omitempty"`
	URINEQ          *string  `json:"uriNEQ,omitempty"`
	URIIn           []string `json:"uriIn,omitempty"`
	URINotIn        []string `json:"uriNotIn,omitempty"`
	URIGT           *string  `json:"uriGT,omitempty"`
	URIGTE          *string  `json:"uriGTE,omitempty"`
	URILT           *string  `json:"uriLT,omitempty"`
	URILTE          *string  `json:"uriLTE,omitempty"`
	URIContains     *string  `json:"uriContains,omitempty"`
	URIHasPrefix    *string  `json:"uriHasPrefix,omitempty"`
	URIHasSuffix    *string  `json:"uriHasSuffix,omitempty"`
	URIEqualFold    *string  `json:"uriEqualFold,omitempty"`
	URIContainsFold *string  `json:"uriContainsFold,omitempty"`

	// "url" field predicates.
	URL             *string  `json:"url,omitempty"`
	URLNEQ          *string  `json:"urlNEQ,omitempty"`
	URLIn           []string `json:"urlIn,omitempty"`
	URLNotIn        []string `json:"urlNotIn,omitempty"`
	URLGT           *string  `json:"urlGT,omitempty"`
	URLGTE          *string  `json:"urlGTE,omitempty"`
	URLLT           *string  `json:"urlLT,omitempty"`
	URLLTE          *string  `json:"urlLTE,omitempty"`
	URLContains     *string  `json:"urlContains,omitempty"`
	URLHasPrefix    *string  `json:"urlHasPrefix,omitempty"`
	URLHasSuffix    *string  `json:"urlHasSuffix,omitempty"`
	URLEqualFold    *string  `json:"urlEqualFold,omitempty"`
	URLContainsFold *string  `json:"urlContainsFold,omitempty"`

	// "description" field predicates.
	Description             *string  `json:"description,omitempty"`
	DescriptionNEQ          *string  `json:"descriptionNEQ,omitempty"`
	DescriptionIn           []string `json:"descriptionIn,omitempty"`
	DescriptionNotIn        []string `json:"descriptionNotIn,omitempty"`
	DescriptionGT           *string  `json:"descriptionGT,omitempty"`
	DescriptionGTE          *string  `json:"descriptionGTE,omitempty"`
	DescriptionLT           *string  `json:"descriptionLT,omitempty"`
	DescriptionLTE          *string  `json:"descriptionLTE,omitempty"`
	DescriptionContains     *string  `json:"descriptionContains,omitempty"`
	DescriptionHasPrefix    *string  `json:"descriptionHasPrefix,omitempty"`
	DescriptionHasSuffix    *string  `json:"descriptionHasSuffix,omitempty"`
	DescriptionEqualFold    *string  `json:"descriptionEqualFold,omitempty"`
	DescriptionContainsFold *string  `json:"descriptionContainsFold,omitempty"`

	// "company" edge predicates.
	HasCompany     *bool                `json:"hasCompany,omitempty"`
	HasCompanyWith []*CompanyWhereInput `json:"hasCompanyWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *FileWhereInput) AddPredicates(predicates ...predicate.File) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the FileWhereInput filter on the FileQuery builder.
func (i *FileWhereInput) Filter(q *FileQuery) (*FileQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyFileWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyFileWhereInput is returned in case the FileWhereInput is empty.
var ErrEmptyFileWhereInput = errors.New("generated: empty predicate FileWhereInput")

// P returns a predicate for filtering files.
// An error is returned if the input is empty or invalid.
func (i *FileWhereInput) P() (predicate.File, error) {
	var predicates []predicate.File
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, file.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.File, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, file.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.File, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, file.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, file.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, file.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, file.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, file.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, file.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, file.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, file.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, file.IDLTE(*i.IDLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, file.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, file.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, file.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, file.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, file.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, file.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, file.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, file.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, file.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, file.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, file.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, file.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, file.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, file.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, file.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, file.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.DeletedAt != nil {
		predicates = append(predicates, file.DeletedAtEQ(*i.DeletedAt))
	}
	if i.DeletedAtNEQ != nil {
		predicates = append(predicates, file.DeletedAtNEQ(*i.DeletedAtNEQ))
	}
	if len(i.DeletedAtIn) > 0 {
		predicates = append(predicates, file.DeletedAtIn(i.DeletedAtIn...))
	}
	if len(i.DeletedAtNotIn) > 0 {
		predicates = append(predicates, file.DeletedAtNotIn(i.DeletedAtNotIn...))
	}
	if i.DeletedAtGT != nil {
		predicates = append(predicates, file.DeletedAtGT(*i.DeletedAtGT))
	}
	if i.DeletedAtGTE != nil {
		predicates = append(predicates, file.DeletedAtGTE(*i.DeletedAtGTE))
	}
	if i.DeletedAtLT != nil {
		predicates = append(predicates, file.DeletedAtLT(*i.DeletedAtLT))
	}
	if i.DeletedAtLTE != nil {
		predicates = append(predicates, file.DeletedAtLTE(*i.DeletedAtLTE))
	}
	if i.DeletedAtIsNil {
		predicates = append(predicates, file.DeletedAtIsNil())
	}
	if i.DeletedAtNotNil {
		predicates = append(predicates, file.DeletedAtNotNil())
	}
	if i.Category != nil {
		predicates = append(predicates, file.CategoryEQ(*i.Category))
	}
	if i.CategoryNEQ != nil {
		predicates = append(predicates, file.CategoryNEQ(*i.CategoryNEQ))
	}
	if len(i.CategoryIn) > 0 {
		predicates = append(predicates, file.CategoryIn(i.CategoryIn...))
	}
	if len(i.CategoryNotIn) > 0 {
		predicates = append(predicates, file.CategoryNotIn(i.CategoryNotIn...))
	}
	if i.Extension != nil {
		predicates = append(predicates, file.ExtensionEQ(*i.Extension))
	}
	if i.ExtensionNEQ != nil {
		predicates = append(predicates, file.ExtensionNEQ(*i.ExtensionNEQ))
	}
	if len(i.ExtensionIn) > 0 {
		predicates = append(predicates, file.ExtensionIn(i.ExtensionIn...))
	}
	if len(i.ExtensionNotIn) > 0 {
		predicates = append(predicates, file.ExtensionNotIn(i.ExtensionNotIn...))
	}
	if i.ExtensionGT != nil {
		predicates = append(predicates, file.ExtensionGT(*i.ExtensionGT))
	}
	if i.ExtensionGTE != nil {
		predicates = append(predicates, file.ExtensionGTE(*i.ExtensionGTE))
	}
	if i.ExtensionLT != nil {
		predicates = append(predicates, file.ExtensionLT(*i.ExtensionLT))
	}
	if i.ExtensionLTE != nil {
		predicates = append(predicates, file.ExtensionLTE(*i.ExtensionLTE))
	}
	if i.ExtensionContains != nil {
		predicates = append(predicates, file.ExtensionContains(*i.ExtensionContains))
	}
	if i.ExtensionHasPrefix != nil {
		predicates = append(predicates, file.ExtensionHasPrefix(*i.ExtensionHasPrefix))
	}
	if i.ExtensionHasSuffix != nil {
		predicates = append(predicates, file.ExtensionHasSuffix(*i.ExtensionHasSuffix))
	}
	if i.ExtensionEqualFold != nil {
		predicates = append(predicates, file.ExtensionEqualFold(*i.ExtensionEqualFold))
	}
	if i.ExtensionContainsFold != nil {
		predicates = append(predicates, file.ExtensionContainsFold(*i.ExtensionContainsFold))
	}
	if i.Size != nil {
		predicates = append(predicates, file.SizeEQ(*i.Size))
	}
	if i.SizeNEQ != nil {
		predicates = append(predicates, file.SizeNEQ(*i.SizeNEQ))
	}
	if len(i.SizeIn) > 0 {
		predicates = append(predicates, file.SizeIn(i.SizeIn...))
	}
	if len(i.SizeNotIn) > 0 {
		predicates = append(predicates, file.SizeNotIn(i.SizeNotIn...))
	}
	if i.SizeGT != nil {
		predicates = append(predicates, file.SizeGT(*i.SizeGT))
	}
	if i.SizeGTE != nil {
		predicates = append(predicates, file.SizeGTE(*i.SizeGTE))
	}
	if i.SizeLT != nil {
		predicates = append(predicates, file.SizeLT(*i.SizeLT))
	}
	if i.SizeLTE != nil {
		predicates = append(predicates, file.SizeLTE(*i.SizeLTE))
	}
	if i.SizeContains != nil {
		predicates = append(predicates, file.SizeContains(*i.SizeContains))
	}
	if i.SizeHasPrefix != nil {
		predicates = append(predicates, file.SizeHasPrefix(*i.SizeHasPrefix))
	}
	if i.SizeHasSuffix != nil {
		predicates = append(predicates, file.SizeHasSuffix(*i.SizeHasSuffix))
	}
	if i.SizeEqualFold != nil {
		predicates = append(predicates, file.SizeEqualFold(*i.SizeEqualFold))
	}
	if i.SizeContainsFold != nil {
		predicates = append(predicates, file.SizeContainsFold(*i.SizeContainsFold))
	}
	if i.URI != nil {
		predicates = append(predicates, file.URIEQ(*i.URI))
	}
	if i.URINEQ != nil {
		predicates = append(predicates, file.URINEQ(*i.URINEQ))
	}
	if len(i.URIIn) > 0 {
		predicates = append(predicates, file.URIIn(i.URIIn...))
	}
	if len(i.URINotIn) > 0 {
		predicates = append(predicates, file.URINotIn(i.URINotIn...))
	}
	if i.URIGT != nil {
		predicates = append(predicates, file.URIGT(*i.URIGT))
	}
	if i.URIGTE != nil {
		predicates = append(predicates, file.URIGTE(*i.URIGTE))
	}
	if i.URILT != nil {
		predicates = append(predicates, file.URILT(*i.URILT))
	}
	if i.URILTE != nil {
		predicates = append(predicates, file.URILTE(*i.URILTE))
	}
	if i.URIContains != nil {
		predicates = append(predicates, file.URIContains(*i.URIContains))
	}
	if i.URIHasPrefix != nil {
		predicates = append(predicates, file.URIHasPrefix(*i.URIHasPrefix))
	}
	if i.URIHasSuffix != nil {
		predicates = append(predicates, file.URIHasSuffix(*i.URIHasSuffix))
	}
	if i.URIEqualFold != nil {
		predicates = append(predicates, file.URIEqualFold(*i.URIEqualFold))
	}
	if i.URIContainsFold != nil {
		predicates = append(predicates, file.URIContainsFold(*i.URIContainsFold))
	}
	if i.URL != nil {
		predicates = append(predicates, file.URLEQ(*i.URL))
	}
	if i.URLNEQ != nil {
		predicates = append(predicates, file.URLNEQ(*i.URLNEQ))
	}
	if len(i.URLIn) > 0 {
		predicates = append(predicates, file.URLIn(i.URLIn...))
	}
	if len(i.URLNotIn) > 0 {
		predicates = append(predicates, file.URLNotIn(i.URLNotIn...))
	}
	if i.URLGT != nil {
		predicates = append(predicates, file.URLGT(*i.URLGT))
	}
	if i.URLGTE != nil {
		predicates = append(predicates, file.URLGTE(*i.URLGTE))
	}
	if i.URLLT != nil {
		predicates = append(predicates, file.URLLT(*i.URLLT))
	}
	if i.URLLTE != nil {
		predicates = append(predicates, file.URLLTE(*i.URLLTE))
	}
	if i.URLContains != nil {
		predicates = append(predicates, file.URLContains(*i.URLContains))
	}
	if i.URLHasPrefix != nil {
		predicates = append(predicates, file.URLHasPrefix(*i.URLHasPrefix))
	}
	if i.URLHasSuffix != nil {
		predicates = append(predicates, file.URLHasSuffix(*i.URLHasSuffix))
	}
	if i.URLEqualFold != nil {
		predicates = append(predicates, file.URLEqualFold(*i.URLEqualFold))
	}
	if i.URLContainsFold != nil {
		predicates = append(predicates, file.URLContainsFold(*i.URLContainsFold))
	}
	if i.Description != nil {
		predicates = append(predicates, file.DescriptionEQ(*i.Description))
	}
	if i.DescriptionNEQ != nil {
		predicates = append(predicates, file.DescriptionNEQ(*i.DescriptionNEQ))
	}
	if len(i.DescriptionIn) > 0 {
		predicates = append(predicates, file.DescriptionIn(i.DescriptionIn...))
	}
	if len(i.DescriptionNotIn) > 0 {
		predicates = append(predicates, file.DescriptionNotIn(i.DescriptionNotIn...))
	}
	if i.DescriptionGT != nil {
		predicates = append(predicates, file.DescriptionGT(*i.DescriptionGT))
	}
	if i.DescriptionGTE != nil {
		predicates = append(predicates, file.DescriptionGTE(*i.DescriptionGTE))
	}
	if i.DescriptionLT != nil {
		predicates = append(predicates, file.DescriptionLT(*i.DescriptionLT))
	}
	if i.DescriptionLTE != nil {
		predicates = append(predicates, file.DescriptionLTE(*i.DescriptionLTE))
	}
	if i.DescriptionContains != nil {
		predicates = append(predicates, file.DescriptionContains(*i.DescriptionContains))
	}
	if i.DescriptionHasPrefix != nil {
		predicates = append(predicates, file.DescriptionHasPrefix(*i.DescriptionHasPrefix))
	}
	if i.DescriptionHasSuffix != nil {
		predicates = append(predicates, file.DescriptionHasSuffix(*i.DescriptionHasSuffix))
	}
	if i.DescriptionEqualFold != nil {
		predicates = append(predicates, file.DescriptionEqualFold(*i.DescriptionEqualFold))
	}
	if i.DescriptionContainsFold != nil {
		predicates = append(predicates, file.DescriptionContainsFold(*i.DescriptionContainsFold))
	}

	if i.HasCompany != nil {
		p := file.HasCompany()
		if !*i.HasCompany {
			p = file.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasCompanyWith) > 0 {
		with := make([]predicate.Company, 0, len(i.HasCompanyWith))
		for _, w := range i.HasCompanyWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasCompanyWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, file.HasCompanyWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyFileWhereInput
	case 1:
		return predicates[0], nil
	default:
		return file.And(predicates...), nil
	}
}

// MemberSignupTokenWhereInput represents a where input for filtering MemberSignupToken queries.
type MemberSignupTokenWhereInput struct {
	Predicates []predicate.MemberSignupToken  `json:"-"`
	Not        *MemberSignupTokenWhereInput   `json:"not,omitempty"`
	Or         []*MemberSignupTokenWhereInput `json:"or,omitempty"`
	And        []*MemberSignupTokenWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "createdAt" field predicates.
	CreatedAt      *time.Time  `json:"createdat,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdatNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdatIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdatNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdatGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdatGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdatLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdatLTE,omitempty"`

	// "updatedAt" field predicates.
	UpdatedAt      *time.Time  `json:"updatedat,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedatNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedatIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedatNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedatGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedatGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedatLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedatLTE,omitempty"`

	// "deletedAt" field predicates.
	DeletedAt       *time.Time  `json:"deletedat,omitempty"`
	DeletedAtNEQ    *time.Time  `json:"deletedatNEQ,omitempty"`
	DeletedAtIn     []time.Time `json:"deletedatIn,omitempty"`
	DeletedAtNotIn  []time.Time `json:"deletedatNotIn,omitempty"`
	DeletedAtGT     *time.Time  `json:"deletedatGT,omitempty"`
	DeletedAtGTE    *time.Time  `json:"deletedatGTE,omitempty"`
	DeletedAtLT     *time.Time  `json:"deletedatLT,omitempty"`
	DeletedAtLTE    *time.Time  `json:"deletedatLTE,omitempty"`
	DeletedAtIsNil  bool        `json:"deletedatIsNil,omitempty"`
	DeletedAtNotNil bool        `json:"deletedatNotNil,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "email" field predicates.
	Email             *string  `json:"email,omitempty"`
	EmailNEQ          *string  `json:"emailNEQ,omitempty"`
	EmailIn           []string `json:"emailIn,omitempty"`
	EmailNotIn        []string `json:"emailNotIn,omitempty"`
	EmailGT           *string  `json:"emailGT,omitempty"`
	EmailGTE          *string  `json:"emailGTE,omitempty"`
	EmailLT           *string  `json:"emailLT,omitempty"`
	EmailLTE          *string  `json:"emailLTE,omitempty"`
	EmailContains     *string  `json:"emailContains,omitempty"`
	EmailHasPrefix    *string  `json:"emailHasPrefix,omitempty"`
	EmailHasSuffix    *string  `json:"emailHasSuffix,omitempty"`
	EmailIsNil        bool     `json:"emailIsNil,omitempty"`
	EmailNotNil       bool     `json:"emailNotNil,omitempty"`
	EmailEqualFold    *string  `json:"emailEqualFold,omitempty"`
	EmailContainsFold *string  `json:"emailContainsFold,omitempty"`

	// "token" field predicates.
	Token             *string  `json:"token,omitempty"`
	TokenNEQ          *string  `json:"tokenNEQ,omitempty"`
	TokenIn           []string `json:"tokenIn,omitempty"`
	TokenNotIn        []string `json:"tokenNotIn,omitempty"`
	TokenGT           *string  `json:"tokenGT,omitempty"`
	TokenGTE          *string  `json:"tokenGTE,omitempty"`
	TokenLT           *string  `json:"tokenLT,omitempty"`
	TokenLTE          *string  `json:"tokenLTE,omitempty"`
	TokenContains     *string  `json:"tokenContains,omitempty"`
	TokenHasPrefix    *string  `json:"tokenHasPrefix,omitempty"`
	TokenHasSuffix    *string  `json:"tokenHasSuffix,omitempty"`
	TokenEqualFold    *string  `json:"tokenEqualFold,omitempty"`
	TokenContainsFold *string  `json:"tokenContainsFold,omitempty"`

	// "avatar" field predicates.
	Avatar             *string  `json:"avatar,omitempty"`
	AvatarNEQ          *string  `json:"avatarNEQ,omitempty"`
	AvatarIn           []string `json:"avatarIn,omitempty"`
	AvatarNotIn        []string `json:"avatarNotIn,omitempty"`
	AvatarGT           *string  `json:"avatarGT,omitempty"`
	AvatarGTE          *string  `json:"avatarGTE,omitempty"`
	AvatarLT           *string  `json:"avatarLT,omitempty"`
	AvatarLTE          *string  `json:"avatarLTE,omitempty"`
	AvatarContains     *string  `json:"avatarContains,omitempty"`
	AvatarHasPrefix    *string  `json:"avatarHasPrefix,omitempty"`
	AvatarHasSuffix    *string  `json:"avatarHasSuffix,omitempty"`
	AvatarEqualFold    *string  `json:"avatarEqualFold,omitempty"`
	AvatarContainsFold *string  `json:"avatarContainsFold,omitempty"`

	// "role" field predicates.
	Role      *membersignuptoken.Role  `json:"role,omitempty"`
	RoleNEQ   *membersignuptoken.Role  `json:"roleNEQ,omitempty"`
	RoleIn    []membersignuptoken.Role `json:"roleIn,omitempty"`
	RoleNotIn []membersignuptoken.Role `json:"roleNotIn,omitempty"`

	// "note" field predicates.
	Note             *string  `json:"note,omitempty"`
	NoteNEQ          *string  `json:"noteNEQ,omitempty"`
	NoteIn           []string `json:"noteIn,omitempty"`
	NoteNotIn        []string `json:"noteNotIn,omitempty"`
	NoteGT           *string  `json:"noteGT,omitempty"`
	NoteGTE          *string  `json:"noteGTE,omitempty"`
	NoteLT           *string  `json:"noteLT,omitempty"`
	NoteLTE          *string  `json:"noteLTE,omitempty"`
	NoteContains     *string  `json:"noteContains,omitempty"`
	NoteHasPrefix    *string  `json:"noteHasPrefix,omitempty"`
	NoteHasSuffix    *string  `json:"noteHasSuffix,omitempty"`
	NoteEqualFold    *string  `json:"noteEqualFold,omitempty"`
	NoteContainsFold *string  `json:"noteContainsFold,omitempty"`

	// "numberAccessed" field predicates.
	NumberAccessed      *int  `json:"numberaccessed,omitempty"`
	NumberAccessedNEQ   *int  `json:"numberaccessedNEQ,omitempty"`
	NumberAccessedIn    []int `json:"numberaccessedIn,omitempty"`
	NumberAccessedNotIn []int `json:"numberaccessedNotIn,omitempty"`
	NumberAccessedGT    *int  `json:"numberaccessedGT,omitempty"`
	NumberAccessedGTE   *int  `json:"numberaccessedGTE,omitempty"`
	NumberAccessedLT    *int  `json:"numberaccessedLT,omitempty"`
	NumberAccessedLTE   *int  `json:"numberaccessedLTE,omitempty"`

	// "expiresAt" field predicates.
	ExpiresAt      *time.Time  `json:"expiresat,omitempty"`
	ExpiresAtNEQ   *time.Time  `json:"expiresatNEQ,omitempty"`
	ExpiresAtIn    []time.Time `json:"expiresatIn,omitempty"`
	ExpiresAtNotIn []time.Time `json:"expiresatNotIn,omitempty"`
	ExpiresAtGT    *time.Time  `json:"expiresatGT,omitempty"`
	ExpiresAtGTE   *time.Time  `json:"expiresatGTE,omitempty"`
	ExpiresAtLT    *time.Time  `json:"expiresatLT,omitempty"`
	ExpiresAtLTE   *time.Time  `json:"expiresatLTE,omitempty"`

	// "alreadyUsed" field predicates.
	AlreadyUsed    *bool `json:"alreadyused,omitempty"`
	AlreadyUsedNEQ *bool `json:"alreadyusedNEQ,omitempty"`

	// "company" edge predicates.
	HasCompany     *bool                `json:"hasCompany,omitempty"`
	HasCompanyWith []*CompanyWhereInput `json:"hasCompanyWith,omitempty"`

	// "createdBy" edge predicates.
	HasCreatedBy     *bool             `json:"hasCreatedBy,omitempty"`
	HasCreatedByWith []*UserWhereInput `json:"hasCreatedByWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *MemberSignupTokenWhereInput) AddPredicates(predicates ...predicate.MemberSignupToken) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the MemberSignupTokenWhereInput filter on the MemberSignupTokenQuery builder.
func (i *MemberSignupTokenWhereInput) Filter(q *MemberSignupTokenQuery) (*MemberSignupTokenQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyMemberSignupTokenWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyMemberSignupTokenWhereInput is returned in case the MemberSignupTokenWhereInput is empty.
var ErrEmptyMemberSignupTokenWhereInput = errors.New("generated: empty predicate MemberSignupTokenWhereInput")

// P returns a predicate for filtering membersignuptokens.
// An error is returned if the input is empty or invalid.
func (i *MemberSignupTokenWhereInput) P() (predicate.MemberSignupToken, error) {
	var predicates []predicate.MemberSignupToken
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, membersignuptoken.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.MemberSignupToken, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, membersignuptoken.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.MemberSignupToken, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, membersignuptoken.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, membersignuptoken.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, membersignuptoken.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, membersignuptoken.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, membersignuptoken.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, membersignuptoken.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, membersignuptoken.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, membersignuptoken.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, membersignuptoken.IDLTE(*i.IDLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, membersignuptoken.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, membersignuptoken.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, membersignuptoken.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, membersignuptoken.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, membersignuptoken.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, membersignuptoken.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, membersignuptoken.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, membersignuptoken.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, membersignuptoken.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, membersignuptoken.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, membersignuptoken.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, membersignuptoken.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, membersignuptoken.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, membersignuptoken.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, membersignuptoken.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, membersignuptoken.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.DeletedAt != nil {
		predicates = append(predicates, membersignuptoken.DeletedAtEQ(*i.DeletedAt))
	}
	if i.DeletedAtNEQ != nil {
		predicates = append(predicates, membersignuptoken.DeletedAtNEQ(*i.DeletedAtNEQ))
	}
	if len(i.DeletedAtIn) > 0 {
		predicates = append(predicates, membersignuptoken.DeletedAtIn(i.DeletedAtIn...))
	}
	if len(i.DeletedAtNotIn) > 0 {
		predicates = append(predicates, membersignuptoken.DeletedAtNotIn(i.DeletedAtNotIn...))
	}
	if i.DeletedAtGT != nil {
		predicates = append(predicates, membersignuptoken.DeletedAtGT(*i.DeletedAtGT))
	}
	if i.DeletedAtGTE != nil {
		predicates = append(predicates, membersignuptoken.DeletedAtGTE(*i.DeletedAtGTE))
	}
	if i.DeletedAtLT != nil {
		predicates = append(predicates, membersignuptoken.DeletedAtLT(*i.DeletedAtLT))
	}
	if i.DeletedAtLTE != nil {
		predicates = append(predicates, membersignuptoken.DeletedAtLTE(*i.DeletedAtLTE))
	}
	if i.DeletedAtIsNil {
		predicates = append(predicates, membersignuptoken.DeletedAtIsNil())
	}
	if i.DeletedAtNotNil {
		predicates = append(predicates, membersignuptoken.DeletedAtNotNil())
	}
	if i.Name != nil {
		predicates = append(predicates, membersignuptoken.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, membersignuptoken.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, membersignuptoken.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, membersignuptoken.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, membersignuptoken.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, membersignuptoken.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, membersignuptoken.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, membersignuptoken.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, membersignuptoken.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, membersignuptoken.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, membersignuptoken.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, membersignuptoken.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, membersignuptoken.NameContainsFold(*i.NameContainsFold))
	}
	if i.Email != nil {
		predicates = append(predicates, membersignuptoken.EmailEQ(*i.Email))
	}
	if i.EmailNEQ != nil {
		predicates = append(predicates, membersignuptoken.EmailNEQ(*i.EmailNEQ))
	}
	if len(i.EmailIn) > 0 {
		predicates = append(predicates, membersignuptoken.EmailIn(i.EmailIn...))
	}
	if len(i.EmailNotIn) > 0 {
		predicates = append(predicates, membersignuptoken.EmailNotIn(i.EmailNotIn...))
	}
	if i.EmailGT != nil {
		predicates = append(predicates, membersignuptoken.EmailGT(*i.EmailGT))
	}
	if i.EmailGTE != nil {
		predicates = append(predicates, membersignuptoken.EmailGTE(*i.EmailGTE))
	}
	if i.EmailLT != nil {
		predicates = append(predicates, membersignuptoken.EmailLT(*i.EmailLT))
	}
	if i.EmailLTE != nil {
		predicates = append(predicates, membersignuptoken.EmailLTE(*i.EmailLTE))
	}
	if i.EmailContains != nil {
		predicates = append(predicates, membersignuptoken.EmailContains(*i.EmailContains))
	}
	if i.EmailHasPrefix != nil {
		predicates = append(predicates, membersignuptoken.EmailHasPrefix(*i.EmailHasPrefix))
	}
	if i.EmailHasSuffix != nil {
		predicates = append(predicates, membersignuptoken.EmailHasSuffix(*i.EmailHasSuffix))
	}
	if i.EmailIsNil {
		predicates = append(predicates, membersignuptoken.EmailIsNil())
	}
	if i.EmailNotNil {
		predicates = append(predicates, membersignuptoken.EmailNotNil())
	}
	if i.EmailEqualFold != nil {
		predicates = append(predicates, membersignuptoken.EmailEqualFold(*i.EmailEqualFold))
	}
	if i.EmailContainsFold != nil {
		predicates = append(predicates, membersignuptoken.EmailContainsFold(*i.EmailContainsFold))
	}
	if i.Token != nil {
		predicates = append(predicates, membersignuptoken.TokenEQ(*i.Token))
	}
	if i.TokenNEQ != nil {
		predicates = append(predicates, membersignuptoken.TokenNEQ(*i.TokenNEQ))
	}
	if len(i.TokenIn) > 0 {
		predicates = append(predicates, membersignuptoken.TokenIn(i.TokenIn...))
	}
	if len(i.TokenNotIn) > 0 {
		predicates = append(predicates, membersignuptoken.TokenNotIn(i.TokenNotIn...))
	}
	if i.TokenGT != nil {
		predicates = append(predicates, membersignuptoken.TokenGT(*i.TokenGT))
	}
	if i.TokenGTE != nil {
		predicates = append(predicates, membersignuptoken.TokenGTE(*i.TokenGTE))
	}
	if i.TokenLT != nil {
		predicates = append(predicates, membersignuptoken.TokenLT(*i.TokenLT))
	}
	if i.TokenLTE != nil {
		predicates = append(predicates, membersignuptoken.TokenLTE(*i.TokenLTE))
	}
	if i.TokenContains != nil {
		predicates = append(predicates, membersignuptoken.TokenContains(*i.TokenContains))
	}
	if i.TokenHasPrefix != nil {
		predicates = append(predicates, membersignuptoken.TokenHasPrefix(*i.TokenHasPrefix))
	}
	if i.TokenHasSuffix != nil {
		predicates = append(predicates, membersignuptoken.TokenHasSuffix(*i.TokenHasSuffix))
	}
	if i.TokenEqualFold != nil {
		predicates = append(predicates, membersignuptoken.TokenEqualFold(*i.TokenEqualFold))
	}
	if i.TokenContainsFold != nil {
		predicates = append(predicates, membersignuptoken.TokenContainsFold(*i.TokenContainsFold))
	}
	if i.Avatar != nil {
		predicates = append(predicates, membersignuptoken.AvatarEQ(*i.Avatar))
	}
	if i.AvatarNEQ != nil {
		predicates = append(predicates, membersignuptoken.AvatarNEQ(*i.AvatarNEQ))
	}
	if len(i.AvatarIn) > 0 {
		predicates = append(predicates, membersignuptoken.AvatarIn(i.AvatarIn...))
	}
	if len(i.AvatarNotIn) > 0 {
		predicates = append(predicates, membersignuptoken.AvatarNotIn(i.AvatarNotIn...))
	}
	if i.AvatarGT != nil {
		predicates = append(predicates, membersignuptoken.AvatarGT(*i.AvatarGT))
	}
	if i.AvatarGTE != nil {
		predicates = append(predicates, membersignuptoken.AvatarGTE(*i.AvatarGTE))
	}
	if i.AvatarLT != nil {
		predicates = append(predicates, membersignuptoken.AvatarLT(*i.AvatarLT))
	}
	if i.AvatarLTE != nil {
		predicates = append(predicates, membersignuptoken.AvatarLTE(*i.AvatarLTE))
	}
	if i.AvatarContains != nil {
		predicates = append(predicates, membersignuptoken.AvatarContains(*i.AvatarContains))
	}
	if i.AvatarHasPrefix != nil {
		predicates = append(predicates, membersignuptoken.AvatarHasPrefix(*i.AvatarHasPrefix))
	}
	if i.AvatarHasSuffix != nil {
		predicates = append(predicates, membersignuptoken.AvatarHasSuffix(*i.AvatarHasSuffix))
	}
	if i.AvatarEqualFold != nil {
		predicates = append(predicates, membersignuptoken.AvatarEqualFold(*i.AvatarEqualFold))
	}
	if i.AvatarContainsFold != nil {
		predicates = append(predicates, membersignuptoken.AvatarContainsFold(*i.AvatarContainsFold))
	}
	if i.Role != nil {
		predicates = append(predicates, membersignuptoken.RoleEQ(*i.Role))
	}
	if i.RoleNEQ != nil {
		predicates = append(predicates, membersignuptoken.RoleNEQ(*i.RoleNEQ))
	}
	if len(i.RoleIn) > 0 {
		predicates = append(predicates, membersignuptoken.RoleIn(i.RoleIn...))
	}
	if len(i.RoleNotIn) > 0 {
		predicates = append(predicates, membersignuptoken.RoleNotIn(i.RoleNotIn...))
	}
	if i.Note != nil {
		predicates = append(predicates, membersignuptoken.NoteEQ(*i.Note))
	}
	if i.NoteNEQ != nil {
		predicates = append(predicates, membersignuptoken.NoteNEQ(*i.NoteNEQ))
	}
	if len(i.NoteIn) > 0 {
		predicates = append(predicates, membersignuptoken.NoteIn(i.NoteIn...))
	}
	if len(i.NoteNotIn) > 0 {
		predicates = append(predicates, membersignuptoken.NoteNotIn(i.NoteNotIn...))
	}
	if i.NoteGT != nil {
		predicates = append(predicates, membersignuptoken.NoteGT(*i.NoteGT))
	}
	if i.NoteGTE != nil {
		predicates = append(predicates, membersignuptoken.NoteGTE(*i.NoteGTE))
	}
	if i.NoteLT != nil {
		predicates = append(predicates, membersignuptoken.NoteLT(*i.NoteLT))
	}
	if i.NoteLTE != nil {
		predicates = append(predicates, membersignuptoken.NoteLTE(*i.NoteLTE))
	}
	if i.NoteContains != nil {
		predicates = append(predicates, membersignuptoken.NoteContains(*i.NoteContains))
	}
	if i.NoteHasPrefix != nil {
		predicates = append(predicates, membersignuptoken.NoteHasPrefix(*i.NoteHasPrefix))
	}
	if i.NoteHasSuffix != nil {
		predicates = append(predicates, membersignuptoken.NoteHasSuffix(*i.NoteHasSuffix))
	}
	if i.NoteEqualFold != nil {
		predicates = append(predicates, membersignuptoken.NoteEqualFold(*i.NoteEqualFold))
	}
	if i.NoteContainsFold != nil {
		predicates = append(predicates, membersignuptoken.NoteContainsFold(*i.NoteContainsFold))
	}
	if i.NumberAccessed != nil {
		predicates = append(predicates, membersignuptoken.NumberAccessedEQ(*i.NumberAccessed))
	}
	if i.NumberAccessedNEQ != nil {
		predicates = append(predicates, membersignuptoken.NumberAccessedNEQ(*i.NumberAccessedNEQ))
	}
	if len(i.NumberAccessedIn) > 0 {
		predicates = append(predicates, membersignuptoken.NumberAccessedIn(i.NumberAccessedIn...))
	}
	if len(i.NumberAccessedNotIn) > 0 {
		predicates = append(predicates, membersignuptoken.NumberAccessedNotIn(i.NumberAccessedNotIn...))
	}
	if i.NumberAccessedGT != nil {
		predicates = append(predicates, membersignuptoken.NumberAccessedGT(*i.NumberAccessedGT))
	}
	if i.NumberAccessedGTE != nil {
		predicates = append(predicates, membersignuptoken.NumberAccessedGTE(*i.NumberAccessedGTE))
	}
	if i.NumberAccessedLT != nil {
		predicates = append(predicates, membersignuptoken.NumberAccessedLT(*i.NumberAccessedLT))
	}
	if i.NumberAccessedLTE != nil {
		predicates = append(predicates, membersignuptoken.NumberAccessedLTE(*i.NumberAccessedLTE))
	}
	if i.ExpiresAt != nil {
		predicates = append(predicates, membersignuptoken.ExpiresAtEQ(*i.ExpiresAt))
	}
	if i.ExpiresAtNEQ != nil {
		predicates = append(predicates, membersignuptoken.ExpiresAtNEQ(*i.ExpiresAtNEQ))
	}
	if len(i.ExpiresAtIn) > 0 {
		predicates = append(predicates, membersignuptoken.ExpiresAtIn(i.ExpiresAtIn...))
	}
	if len(i.ExpiresAtNotIn) > 0 {
		predicates = append(predicates, membersignuptoken.ExpiresAtNotIn(i.ExpiresAtNotIn...))
	}
	if i.ExpiresAtGT != nil {
		predicates = append(predicates, membersignuptoken.ExpiresAtGT(*i.ExpiresAtGT))
	}
	if i.ExpiresAtGTE != nil {
		predicates = append(predicates, membersignuptoken.ExpiresAtGTE(*i.ExpiresAtGTE))
	}
	if i.ExpiresAtLT != nil {
		predicates = append(predicates, membersignuptoken.ExpiresAtLT(*i.ExpiresAtLT))
	}
	if i.ExpiresAtLTE != nil {
		predicates = append(predicates, membersignuptoken.ExpiresAtLTE(*i.ExpiresAtLTE))
	}
	if i.AlreadyUsed != nil {
		predicates = append(predicates, membersignuptoken.AlreadyUsedEQ(*i.AlreadyUsed))
	}
	if i.AlreadyUsedNEQ != nil {
		predicates = append(predicates, membersignuptoken.AlreadyUsedNEQ(*i.AlreadyUsedNEQ))
	}

	if i.HasCompany != nil {
		p := membersignuptoken.HasCompany()
		if !*i.HasCompany {
			p = membersignuptoken.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasCompanyWith) > 0 {
		with := make([]predicate.Company, 0, len(i.HasCompanyWith))
		for _, w := range i.HasCompanyWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasCompanyWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, membersignuptoken.HasCompanyWith(with...))
	}
	if i.HasCreatedBy != nil {
		p := membersignuptoken.HasCreatedBy()
		if !*i.HasCreatedBy {
			p = membersignuptoken.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasCreatedByWith) > 0 {
		with := make([]predicate.User, 0, len(i.HasCreatedByWith))
		for _, w := range i.HasCreatedByWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasCreatedByWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, membersignuptoken.HasCreatedByWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyMemberSignupTokenWhereInput
	case 1:
		return predicates[0], nil
	default:
		return membersignuptoken.And(predicates...), nil
	}
}

// PayableWhereInput represents a where input for filtering Payable queries.
type PayableWhereInput struct {
	Predicates []predicate.Payable  `json:"-"`
	Not        *PayableWhereInput   `json:"not,omitempty"`
	Or         []*PayableWhereInput `json:"or,omitempty"`
	And        []*PayableWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "createdAt" field predicates.
	CreatedAt      *time.Time  `json:"createdat,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdatNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdatIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdatNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdatGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdatGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdatLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdatLTE,omitempty"`

	// "updatedAt" field predicates.
	UpdatedAt      *time.Time  `json:"updatedat,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedatNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedatIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedatNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedatGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedatGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedatLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedatLTE,omitempty"`

	// "deletedAt" field predicates.
	DeletedAt       *time.Time  `json:"deletedat,omitempty"`
	DeletedAtNEQ    *time.Time  `json:"deletedatNEQ,omitempty"`
	DeletedAtIn     []time.Time `json:"deletedatIn,omitempty"`
	DeletedAtNotIn  []time.Time `json:"deletedatNotIn,omitempty"`
	DeletedAtGT     *time.Time  `json:"deletedatGT,omitempty"`
	DeletedAtGTE    *time.Time  `json:"deletedatGTE,omitempty"`
	DeletedAtLT     *time.Time  `json:"deletedatLT,omitempty"`
	DeletedAtLTE    *time.Time  `json:"deletedatLTE,omitempty"`
	DeletedAtIsNil  bool        `json:"deletedatIsNil,omitempty"`
	DeletedAtNotNil bool        `json:"deletedatNotNil,omitempty"`

	// "entryGroup" field predicates.
	EntryGroup      *int  `json:"entrygroup,omitempty"`
	EntryGroupNEQ   *int  `json:"entrygroupNEQ,omitempty"`
	EntryGroupIn    []int `json:"entrygroupIn,omitempty"`
	EntryGroupNotIn []int `json:"entrygroupNotIn,omitempty"`
	EntryGroupGT    *int  `json:"entrygroupGT,omitempty"`
	EntryGroupGTE   *int  `json:"entrygroupGTE,omitempty"`
	EntryGroupLT    *int  `json:"entrygroupLT,omitempty"`
	EntryGroupLTE   *int  `json:"entrygroupLTE,omitempty"`

	// "date" field predicates.
	Date      *time.Time  `json:"date,omitempty"`
	DateNEQ   *time.Time  `json:"dateNEQ,omitempty"`
	DateIn    []time.Time `json:"dateIn,omitempty"`
	DateNotIn []time.Time `json:"dateNotIn,omitempty"`
	DateGT    *time.Time  `json:"dateGT,omitempty"`
	DateGTE   *time.Time  `json:"dateGTE,omitempty"`
	DateLT    *time.Time  `json:"dateLT,omitempty"`
	DateLTE   *time.Time  `json:"dateLTE,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "outstandingBalance" field predicates.
	OutstandingBalance      *float64  `json:"outstandingbalance,omitempty"`
	OutstandingBalanceNEQ   *float64  `json:"outstandingbalanceNEQ,omitempty"`
	OutstandingBalanceIn    []float64 `json:"outstandingbalanceIn,omitempty"`
	OutstandingBalanceNotIn []float64 `json:"outstandingbalanceNotIn,omitempty"`
	OutstandingBalanceGT    *float64  `json:"outstandingbalanceGT,omitempty"`
	OutstandingBalanceGTE   *float64  `json:"outstandingbalanceGTE,omitempty"`
	OutstandingBalanceLT    *float64  `json:"outstandingbalanceLT,omitempty"`
	OutstandingBalanceLTE   *float64  `json:"outstandingbalanceLTE,omitempty"`

	// "totalTransaction" field predicates.
	TotalTransaction      *float64  `json:"totaltransaction,omitempty"`
	TotalTransactionNEQ   *float64  `json:"totaltransactionNEQ,omitempty"`
	TotalTransactionIn    []float64 `json:"totaltransactionIn,omitempty"`
	TotalTransactionNotIn []float64 `json:"totaltransactionNotIn,omitempty"`
	TotalTransactionGT    *float64  `json:"totaltransactionGT,omitempty"`
	TotalTransactionGTE   *float64  `json:"totaltransactionGTE,omitempty"`
	TotalTransactionLT    *float64  `json:"totaltransactionLT,omitempty"`
	TotalTransactionLTE   *float64  `json:"totaltransactionLTE,omitempty"`

	// "dueDate" field predicates.
	DueDate      *time.Time  `json:"duedate,omitempty"`
	DueDateNEQ   *time.Time  `json:"duedateNEQ,omitempty"`
	DueDateIn    []time.Time `json:"duedateIn,omitempty"`
	DueDateNotIn []time.Time `json:"duedateNotIn,omitempty"`
	DueDateGT    *time.Time  `json:"duedateGT,omitempty"`
	DueDateGTE   *time.Time  `json:"duedateGTE,omitempty"`
	DueDateLT    *time.Time  `json:"duedateLT,omitempty"`
	DueDateLTE   *time.Time  `json:"duedateLTE,omitempty"`

	// "status" field predicates.
	Status      *payable.Status  `json:"status,omitempty"`
	StatusNEQ   *payable.Status  `json:"statusNEQ,omitempty"`
	StatusIn    []payable.Status `json:"statusIn,omitempty"`
	StatusNotIn []payable.Status `json:"statusNotIn,omitempty"`

	// "company" edge predicates.
	HasCompany     *bool                `json:"hasCompany,omitempty"`
	HasCompanyWith []*CompanyWhereInput `json:"hasCompanyWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *PayableWhereInput) AddPredicates(predicates ...predicate.Payable) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the PayableWhereInput filter on the PayableQuery builder.
func (i *PayableWhereInput) Filter(q *PayableQuery) (*PayableQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyPayableWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyPayableWhereInput is returned in case the PayableWhereInput is empty.
var ErrEmptyPayableWhereInput = errors.New("generated: empty predicate PayableWhereInput")

// P returns a predicate for filtering payables.
// An error is returned if the input is empty or invalid.
func (i *PayableWhereInput) P() (predicate.Payable, error) {
	var predicates []predicate.Payable
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, payable.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Payable, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, payable.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Payable, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, payable.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, payable.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, payable.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, payable.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, payable.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, payable.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, payable.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, payable.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, payable.IDLTE(*i.IDLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, payable.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, payable.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, payable.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, payable.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, payable.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, payable.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, payable.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, payable.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, payable.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, payable.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, payable.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, payable.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, payable.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, payable.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, payable.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, payable.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.DeletedAt != nil {
		predicates = append(predicates, payable.DeletedAtEQ(*i.DeletedAt))
	}
	if i.DeletedAtNEQ != nil {
		predicates = append(predicates, payable.DeletedAtNEQ(*i.DeletedAtNEQ))
	}
	if len(i.DeletedAtIn) > 0 {
		predicates = append(predicates, payable.DeletedAtIn(i.DeletedAtIn...))
	}
	if len(i.DeletedAtNotIn) > 0 {
		predicates = append(predicates, payable.DeletedAtNotIn(i.DeletedAtNotIn...))
	}
	if i.DeletedAtGT != nil {
		predicates = append(predicates, payable.DeletedAtGT(*i.DeletedAtGT))
	}
	if i.DeletedAtGTE != nil {
		predicates = append(predicates, payable.DeletedAtGTE(*i.DeletedAtGTE))
	}
	if i.DeletedAtLT != nil {
		predicates = append(predicates, payable.DeletedAtLT(*i.DeletedAtLT))
	}
	if i.DeletedAtLTE != nil {
		predicates = append(predicates, payable.DeletedAtLTE(*i.DeletedAtLTE))
	}
	if i.DeletedAtIsNil {
		predicates = append(predicates, payable.DeletedAtIsNil())
	}
	if i.DeletedAtNotNil {
		predicates = append(predicates, payable.DeletedAtNotNil())
	}
	if i.EntryGroup != nil {
		predicates = append(predicates, payable.EntryGroupEQ(*i.EntryGroup))
	}
	if i.EntryGroupNEQ != nil {
		predicates = append(predicates, payable.EntryGroupNEQ(*i.EntryGroupNEQ))
	}
	if len(i.EntryGroupIn) > 0 {
		predicates = append(predicates, payable.EntryGroupIn(i.EntryGroupIn...))
	}
	if len(i.EntryGroupNotIn) > 0 {
		predicates = append(predicates, payable.EntryGroupNotIn(i.EntryGroupNotIn...))
	}
	if i.EntryGroupGT != nil {
		predicates = append(predicates, payable.EntryGroupGT(*i.EntryGroupGT))
	}
	if i.EntryGroupGTE != nil {
		predicates = append(predicates, payable.EntryGroupGTE(*i.EntryGroupGTE))
	}
	if i.EntryGroupLT != nil {
		predicates = append(predicates, payable.EntryGroupLT(*i.EntryGroupLT))
	}
	if i.EntryGroupLTE != nil {
		predicates = append(predicates, payable.EntryGroupLTE(*i.EntryGroupLTE))
	}
	if i.Date != nil {
		predicates = append(predicates, payable.DateEQ(*i.Date))
	}
	if i.DateNEQ != nil {
		predicates = append(predicates, payable.DateNEQ(*i.DateNEQ))
	}
	if len(i.DateIn) > 0 {
		predicates = append(predicates, payable.DateIn(i.DateIn...))
	}
	if len(i.DateNotIn) > 0 {
		predicates = append(predicates, payable.DateNotIn(i.DateNotIn...))
	}
	if i.DateGT != nil {
		predicates = append(predicates, payable.DateGT(*i.DateGT))
	}
	if i.DateGTE != nil {
		predicates = append(predicates, payable.DateGTE(*i.DateGTE))
	}
	if i.DateLT != nil {
		predicates = append(predicates, payable.DateLT(*i.DateLT))
	}
	if i.DateLTE != nil {
		predicates = append(predicates, payable.DateLTE(*i.DateLTE))
	}
	if i.Name != nil {
		predicates = append(predicates, payable.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, payable.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, payable.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, payable.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, payable.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, payable.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, payable.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, payable.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, payable.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, payable.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, payable.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, payable.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, payable.NameContainsFold(*i.NameContainsFold))
	}
	if i.OutstandingBalance != nil {
		predicates = append(predicates, payable.OutstandingBalanceEQ(*i.OutstandingBalance))
	}
	if i.OutstandingBalanceNEQ != nil {
		predicates = append(predicates, payable.OutstandingBalanceNEQ(*i.OutstandingBalanceNEQ))
	}
	if len(i.OutstandingBalanceIn) > 0 {
		predicates = append(predicates, payable.OutstandingBalanceIn(i.OutstandingBalanceIn...))
	}
	if len(i.OutstandingBalanceNotIn) > 0 {
		predicates = append(predicates, payable.OutstandingBalanceNotIn(i.OutstandingBalanceNotIn...))
	}
	if i.OutstandingBalanceGT != nil {
		predicates = append(predicates, payable.OutstandingBalanceGT(*i.OutstandingBalanceGT))
	}
	if i.OutstandingBalanceGTE != nil {
		predicates = append(predicates, payable.OutstandingBalanceGTE(*i.OutstandingBalanceGTE))
	}
	if i.OutstandingBalanceLT != nil {
		predicates = append(predicates, payable.OutstandingBalanceLT(*i.OutstandingBalanceLT))
	}
	if i.OutstandingBalanceLTE != nil {
		predicates = append(predicates, payable.OutstandingBalanceLTE(*i.OutstandingBalanceLTE))
	}
	if i.TotalTransaction != nil {
		predicates = append(predicates, payable.TotalTransactionEQ(*i.TotalTransaction))
	}
	if i.TotalTransactionNEQ != nil {
		predicates = append(predicates, payable.TotalTransactionNEQ(*i.TotalTransactionNEQ))
	}
	if len(i.TotalTransactionIn) > 0 {
		predicates = append(predicates, payable.TotalTransactionIn(i.TotalTransactionIn...))
	}
	if len(i.TotalTransactionNotIn) > 0 {
		predicates = append(predicates, payable.TotalTransactionNotIn(i.TotalTransactionNotIn...))
	}
	if i.TotalTransactionGT != nil {
		predicates = append(predicates, payable.TotalTransactionGT(*i.TotalTransactionGT))
	}
	if i.TotalTransactionGTE != nil {
		predicates = append(predicates, payable.TotalTransactionGTE(*i.TotalTransactionGTE))
	}
	if i.TotalTransactionLT != nil {
		predicates = append(predicates, payable.TotalTransactionLT(*i.TotalTransactionLT))
	}
	if i.TotalTransactionLTE != nil {
		predicates = append(predicates, payable.TotalTransactionLTE(*i.TotalTransactionLTE))
	}
	if i.DueDate != nil {
		predicates = append(predicates, payable.DueDateEQ(*i.DueDate))
	}
	if i.DueDateNEQ != nil {
		predicates = append(predicates, payable.DueDateNEQ(*i.DueDateNEQ))
	}
	if len(i.DueDateIn) > 0 {
		predicates = append(predicates, payable.DueDateIn(i.DueDateIn...))
	}
	if len(i.DueDateNotIn) > 0 {
		predicates = append(predicates, payable.DueDateNotIn(i.DueDateNotIn...))
	}
	if i.DueDateGT != nil {
		predicates = append(predicates, payable.DueDateGT(*i.DueDateGT))
	}
	if i.DueDateGTE != nil {
		predicates = append(predicates, payable.DueDateGTE(*i.DueDateGTE))
	}
	if i.DueDateLT != nil {
		predicates = append(predicates, payable.DueDateLT(*i.DueDateLT))
	}
	if i.DueDateLTE != nil {
		predicates = append(predicates, payable.DueDateLTE(*i.DueDateLTE))
	}
	if i.Status != nil {
		predicates = append(predicates, payable.StatusEQ(*i.Status))
	}
	if i.StatusNEQ != nil {
		predicates = append(predicates, payable.StatusNEQ(*i.StatusNEQ))
	}
	if len(i.StatusIn) > 0 {
		predicates = append(predicates, payable.StatusIn(i.StatusIn...))
	}
	if len(i.StatusNotIn) > 0 {
		predicates = append(predicates, payable.StatusNotIn(i.StatusNotIn...))
	}

	if i.HasCompany != nil {
		p := payable.HasCompany()
		if !*i.HasCompany {
			p = payable.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasCompanyWith) > 0 {
		with := make([]predicate.Company, 0, len(i.HasCompanyWith))
		for _, w := range i.HasCompanyWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasCompanyWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, payable.HasCompanyWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyPayableWhereInput
	case 1:
		return predicates[0], nil
	default:
		return payable.And(predicates...), nil
	}
}

// ProductWhereInput represents a where input for filtering Product queries.
type ProductWhereInput struct {
	Predicates []predicate.Product  `json:"-"`
	Not        *ProductWhereInput   `json:"not,omitempty"`
	Or         []*ProductWhereInput `json:"or,omitempty"`
	And        []*ProductWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "createdAt" field predicates.
	CreatedAt      *time.Time  `json:"createdat,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdatNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdatIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdatNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdatGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdatGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdatLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdatLTE,omitempty"`

	// "updatedAt" field predicates.
	UpdatedAt      *time.Time  `json:"updatedat,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedatNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedatIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedatNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedatGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedatGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedatLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedatLTE,omitempty"`

	// "deletedAt" field predicates.
	DeletedAt       *time.Time  `json:"deletedat,omitempty"`
	DeletedAtNEQ    *time.Time  `json:"deletedatNEQ,omitempty"`
	DeletedAtIn     []time.Time `json:"deletedatIn,omitempty"`
	DeletedAtNotIn  []time.Time `json:"deletedatNotIn,omitempty"`
	DeletedAtGT     *time.Time  `json:"deletedatGT,omitempty"`
	DeletedAtGTE    *time.Time  `json:"deletedatGTE,omitempty"`
	DeletedAtLT     *time.Time  `json:"deletedatLT,omitempty"`
	DeletedAtLTE    *time.Time  `json:"deletedatLTE,omitempty"`
	DeletedAtIsNil  bool        `json:"deletedatIsNil,omitempty"`
	DeletedAtNotNil bool        `json:"deletedatNotNil,omitempty"`

	// "stock" field predicates.
	Stock      *int  `json:"stock,omitempty"`
	StockNEQ   *int  `json:"stockNEQ,omitempty"`
	StockIn    []int `json:"stockIn,omitempty"`
	StockNotIn []int `json:"stockNotIn,omitempty"`
	StockGT    *int  `json:"stockGT,omitempty"`
	StockGTE   *int  `json:"stockGTE,omitempty"`
	StockLT    *int  `json:"stockLT,omitempty"`
	StockLTE   *int  `json:"stockLTE,omitempty"`

	// "company" edge predicates.
	HasCompany     *bool                `json:"hasCompany,omitempty"`
	HasCompanyWith []*CompanyWhereInput `json:"hasCompanyWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *ProductWhereInput) AddPredicates(predicates ...predicate.Product) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the ProductWhereInput filter on the ProductQuery builder.
func (i *ProductWhereInput) Filter(q *ProductQuery) (*ProductQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyProductWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyProductWhereInput is returned in case the ProductWhereInput is empty.
var ErrEmptyProductWhereInput = errors.New("generated: empty predicate ProductWhereInput")

// P returns a predicate for filtering products.
// An error is returned if the input is empty or invalid.
func (i *ProductWhereInput) P() (predicate.Product, error) {
	var predicates []predicate.Product
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, product.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Product, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, product.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Product, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, product.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, product.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, product.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, product.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, product.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, product.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, product.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, product.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, product.IDLTE(*i.IDLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, product.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, product.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, product.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, product.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, product.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, product.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, product.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, product.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, product.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, product.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, product.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, product.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, product.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, product.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, product.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, product.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.DeletedAt != nil {
		predicates = append(predicates, product.DeletedAtEQ(*i.DeletedAt))
	}
	if i.DeletedAtNEQ != nil {
		predicates = append(predicates, product.DeletedAtNEQ(*i.DeletedAtNEQ))
	}
	if len(i.DeletedAtIn) > 0 {
		predicates = append(predicates, product.DeletedAtIn(i.DeletedAtIn...))
	}
	if len(i.DeletedAtNotIn) > 0 {
		predicates = append(predicates, product.DeletedAtNotIn(i.DeletedAtNotIn...))
	}
	if i.DeletedAtGT != nil {
		predicates = append(predicates, product.DeletedAtGT(*i.DeletedAtGT))
	}
	if i.DeletedAtGTE != nil {
		predicates = append(predicates, product.DeletedAtGTE(*i.DeletedAtGTE))
	}
	if i.DeletedAtLT != nil {
		predicates = append(predicates, product.DeletedAtLT(*i.DeletedAtLT))
	}
	if i.DeletedAtLTE != nil {
		predicates = append(predicates, product.DeletedAtLTE(*i.DeletedAtLTE))
	}
	if i.DeletedAtIsNil {
		predicates = append(predicates, product.DeletedAtIsNil())
	}
	if i.DeletedAtNotNil {
		predicates = append(predicates, product.DeletedAtNotNil())
	}
	if i.Stock != nil {
		predicates = append(predicates, product.StockEQ(*i.Stock))
	}
	if i.StockNEQ != nil {
		predicates = append(predicates, product.StockNEQ(*i.StockNEQ))
	}
	if len(i.StockIn) > 0 {
		predicates = append(predicates, product.StockIn(i.StockIn...))
	}
	if len(i.StockNotIn) > 0 {
		predicates = append(predicates, product.StockNotIn(i.StockNotIn...))
	}
	if i.StockGT != nil {
		predicates = append(predicates, product.StockGT(*i.StockGT))
	}
	if i.StockGTE != nil {
		predicates = append(predicates, product.StockGTE(*i.StockGTE))
	}
	if i.StockLT != nil {
		predicates = append(predicates, product.StockLT(*i.StockLT))
	}
	if i.StockLTE != nil {
		predicates = append(predicates, product.StockLTE(*i.StockLTE))
	}

	if i.HasCompany != nil {
		p := product.HasCompany()
		if !*i.HasCompany {
			p = product.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasCompanyWith) > 0 {
		with := make([]predicate.Company, 0, len(i.HasCompanyWith))
		for _, w := range i.HasCompanyWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasCompanyWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, product.HasCompanyWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyProductWhereInput
	case 1:
		return predicates[0], nil
	default:
		return product.And(predicates...), nil
	}
}

// ProjectWhereInput represents a where input for filtering Project queries.
type ProjectWhereInput struct {
	Predicates []predicate.Project  `json:"-"`
	Not        *ProjectWhereInput   `json:"not,omitempty"`
	Or         []*ProjectWhereInput `json:"or,omitempty"`
	And        []*ProjectWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "createdAt" field predicates.
	CreatedAt      *time.Time  `json:"createdat,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdatNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdatIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdatNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdatGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdatGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdatLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdatLTE,omitempty"`

	// "updatedAt" field predicates.
	UpdatedAt      *time.Time  `json:"updatedat,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedatNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedatIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedatNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedatGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedatGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedatLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedatLTE,omitempty"`

	// "deletedAt" field predicates.
	DeletedAt       *time.Time  `json:"deletedat,omitempty"`
	DeletedAtNEQ    *time.Time  `json:"deletedatNEQ,omitempty"`
	DeletedAtIn     []time.Time `json:"deletedatIn,omitempty"`
	DeletedAtNotIn  []time.Time `json:"deletedatNotIn,omitempty"`
	DeletedAtGT     *time.Time  `json:"deletedatGT,omitempty"`
	DeletedAtGTE    *time.Time  `json:"deletedatGTE,omitempty"`
	DeletedAtLT     *time.Time  `json:"deletedatLT,omitempty"`
	DeletedAtLTE    *time.Time  `json:"deletedatLTE,omitempty"`
	DeletedAtIsNil  bool        `json:"deletedatIsNil,omitempty"`
	DeletedAtNotNil bool        `json:"deletedatNotNil,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "description" field predicates.
	Description             *string  `json:"description,omitempty"`
	DescriptionNEQ          *string  `json:"descriptionNEQ,omitempty"`
	DescriptionIn           []string `json:"descriptionIn,omitempty"`
	DescriptionNotIn        []string `json:"descriptionNotIn,omitempty"`
	DescriptionGT           *string  `json:"descriptionGT,omitempty"`
	DescriptionGTE          *string  `json:"descriptionGTE,omitempty"`
	DescriptionLT           *string  `json:"descriptionLT,omitempty"`
	DescriptionLTE          *string  `json:"descriptionLTE,omitempty"`
	DescriptionContains     *string  `json:"descriptionContains,omitempty"`
	DescriptionHasPrefix    *string  `json:"descriptionHasPrefix,omitempty"`
	DescriptionHasSuffix    *string  `json:"descriptionHasSuffix,omitempty"`
	DescriptionEqualFold    *string  `json:"descriptionEqualFold,omitempty"`
	DescriptionContainsFold *string  `json:"descriptionContainsFold,omitempty"`

	// "startDate" field predicates.
	StartDate      *time.Time  `json:"startdate,omitempty"`
	StartDateNEQ   *time.Time  `json:"startdateNEQ,omitempty"`
	StartDateIn    []time.Time `json:"startdateIn,omitempty"`
	StartDateNotIn []time.Time `json:"startdateNotIn,omitempty"`
	StartDateGT    *time.Time  `json:"startdateGT,omitempty"`
	StartDateGTE   *time.Time  `json:"startdateGTE,omitempty"`
	StartDateLT    *time.Time  `json:"startdateLT,omitempty"`
	StartDateLTE   *time.Time  `json:"startdateLTE,omitempty"`

	// "endDate" field predicates.
	EndDate      *time.Time  `json:"enddate,omitempty"`
	EndDateNEQ   *time.Time  `json:"enddateNEQ,omitempty"`
	EndDateIn    []time.Time `json:"enddateIn,omitempty"`
	EndDateNotIn []time.Time `json:"enddateNotIn,omitempty"`
	EndDateGT    *time.Time  `json:"enddateGT,omitempty"`
	EndDateGTE   *time.Time  `json:"enddateGTE,omitempty"`
	EndDateLT    *time.Time  `json:"enddateLT,omitempty"`
	EndDateLTE   *time.Time  `json:"enddateLTE,omitempty"`

	// "progress" field predicates.
	Progress      *float64  `json:"progress,omitempty"`
	ProgressNEQ   *float64  `json:"progressNEQ,omitempty"`
	ProgressIn    []float64 `json:"progressIn,omitempty"`
	ProgressNotIn []float64 `json:"progressNotIn,omitempty"`
	ProgressGT    *float64  `json:"progressGT,omitempty"`
	ProgressGTE   *float64  `json:"progressGTE,omitempty"`
	ProgressLT    *float64  `json:"progressLT,omitempty"`
	ProgressLTE   *float64  `json:"progressLTE,omitempty"`

	// "status" field predicates.
	Status      *project.Status  `json:"status,omitempty"`
	StatusNEQ   *project.Status  `json:"statusNEQ,omitempty"`
	StatusIn    []project.Status `json:"statusIn,omitempty"`
	StatusNotIn []project.Status `json:"statusNotIn,omitempty"`

	// "company" edge predicates.
	HasCompany     *bool                `json:"hasCompany,omitempty"`
	HasCompanyWith []*CompanyWhereInput `json:"hasCompanyWith,omitempty"`

	// "createdBy" edge predicates.
	HasCreatedBy     *bool             `json:"hasCreatedBy,omitempty"`
	HasCreatedByWith []*UserWhereInput `json:"hasCreatedByWith,omitempty"`

	// "leader" edge predicates.
	HasLeader     *bool             `json:"hasLeader,omitempty"`
	HasLeaderWith []*UserWhereInput `json:"hasLeaderWith,omitempty"`

	// "tasks" edge predicates.
	HasTasks     *bool                    `json:"hasTasks,omitempty"`
	HasTasksWith []*ProjectTaskWhereInput `json:"hasTasksWith,omitempty"`

	// "milestones" edge predicates.
	HasMilestones     *bool                         `json:"hasMilestones,omitempty"`
	HasMilestonesWith []*ProjectMilestoneWhereInput `json:"hasMilestonesWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *ProjectWhereInput) AddPredicates(predicates ...predicate.Project) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the ProjectWhereInput filter on the ProjectQuery builder.
func (i *ProjectWhereInput) Filter(q *ProjectQuery) (*ProjectQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyProjectWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyProjectWhereInput is returned in case the ProjectWhereInput is empty.
var ErrEmptyProjectWhereInput = errors.New("generated: empty predicate ProjectWhereInput")

// P returns a predicate for filtering projects.
// An error is returned if the input is empty or invalid.
func (i *ProjectWhereInput) P() (predicate.Project, error) {
	var predicates []predicate.Project
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, project.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Project, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, project.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Project, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, project.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, project.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, project.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, project.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, project.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, project.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, project.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, project.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, project.IDLTE(*i.IDLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, project.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, project.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, project.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, project.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, project.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, project.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, project.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, project.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, project.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, project.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, project.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, project.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, project.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, project.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, project.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, project.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.DeletedAt != nil {
		predicates = append(predicates, project.DeletedAtEQ(*i.DeletedAt))
	}
	if i.DeletedAtNEQ != nil {
		predicates = append(predicates, project.DeletedAtNEQ(*i.DeletedAtNEQ))
	}
	if len(i.DeletedAtIn) > 0 {
		predicates = append(predicates, project.DeletedAtIn(i.DeletedAtIn...))
	}
	if len(i.DeletedAtNotIn) > 0 {
		predicates = append(predicates, project.DeletedAtNotIn(i.DeletedAtNotIn...))
	}
	if i.DeletedAtGT != nil {
		predicates = append(predicates, project.DeletedAtGT(*i.DeletedAtGT))
	}
	if i.DeletedAtGTE != nil {
		predicates = append(predicates, project.DeletedAtGTE(*i.DeletedAtGTE))
	}
	if i.DeletedAtLT != nil {
		predicates = append(predicates, project.DeletedAtLT(*i.DeletedAtLT))
	}
	if i.DeletedAtLTE != nil {
		predicates = append(predicates, project.DeletedAtLTE(*i.DeletedAtLTE))
	}
	if i.DeletedAtIsNil {
		predicates = append(predicates, project.DeletedAtIsNil())
	}
	if i.DeletedAtNotNil {
		predicates = append(predicates, project.DeletedAtNotNil())
	}
	if i.Name != nil {
		predicates = append(predicates, project.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, project.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, project.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, project.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, project.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, project.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, project.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, project.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, project.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, project.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, project.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, project.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, project.NameContainsFold(*i.NameContainsFold))
	}
	if i.Description != nil {
		predicates = append(predicates, project.DescriptionEQ(*i.Description))
	}
	if i.DescriptionNEQ != nil {
		predicates = append(predicates, project.DescriptionNEQ(*i.DescriptionNEQ))
	}
	if len(i.DescriptionIn) > 0 {
		predicates = append(predicates, project.DescriptionIn(i.DescriptionIn...))
	}
	if len(i.DescriptionNotIn) > 0 {
		predicates = append(predicates, project.DescriptionNotIn(i.DescriptionNotIn...))
	}
	if i.DescriptionGT != nil {
		predicates = append(predicates, project.DescriptionGT(*i.DescriptionGT))
	}
	if i.DescriptionGTE != nil {
		predicates = append(predicates, project.DescriptionGTE(*i.DescriptionGTE))
	}
	if i.DescriptionLT != nil {
		predicates = append(predicates, project.DescriptionLT(*i.DescriptionLT))
	}
	if i.DescriptionLTE != nil {
		predicates = append(predicates, project.DescriptionLTE(*i.DescriptionLTE))
	}
	if i.DescriptionContains != nil {
		predicates = append(predicates, project.DescriptionContains(*i.DescriptionContains))
	}
	if i.DescriptionHasPrefix != nil {
		predicates = append(predicates, project.DescriptionHasPrefix(*i.DescriptionHasPrefix))
	}
	if i.DescriptionHasSuffix != nil {
		predicates = append(predicates, project.DescriptionHasSuffix(*i.DescriptionHasSuffix))
	}
	if i.DescriptionEqualFold != nil {
		predicates = append(predicates, project.DescriptionEqualFold(*i.DescriptionEqualFold))
	}
	if i.DescriptionContainsFold != nil {
		predicates = append(predicates, project.DescriptionContainsFold(*i.DescriptionContainsFold))
	}
	if i.StartDate != nil {
		predicates = append(predicates, project.StartDateEQ(*i.StartDate))
	}
	if i.StartDateNEQ != nil {
		predicates = append(predicates, project.StartDateNEQ(*i.StartDateNEQ))
	}
	if len(i.StartDateIn) > 0 {
		predicates = append(predicates, project.StartDateIn(i.StartDateIn...))
	}
	if len(i.StartDateNotIn) > 0 {
		predicates = append(predicates, project.StartDateNotIn(i.StartDateNotIn...))
	}
	if i.StartDateGT != nil {
		predicates = append(predicates, project.StartDateGT(*i.StartDateGT))
	}
	if i.StartDateGTE != nil {
		predicates = append(predicates, project.StartDateGTE(*i.StartDateGTE))
	}
	if i.StartDateLT != nil {
		predicates = append(predicates, project.StartDateLT(*i.StartDateLT))
	}
	if i.StartDateLTE != nil {
		predicates = append(predicates, project.StartDateLTE(*i.StartDateLTE))
	}
	if i.EndDate != nil {
		predicates = append(predicates, project.EndDateEQ(*i.EndDate))
	}
	if i.EndDateNEQ != nil {
		predicates = append(predicates, project.EndDateNEQ(*i.EndDateNEQ))
	}
	if len(i.EndDateIn) > 0 {
		predicates = append(predicates, project.EndDateIn(i.EndDateIn...))
	}
	if len(i.EndDateNotIn) > 0 {
		predicates = append(predicates, project.EndDateNotIn(i.EndDateNotIn...))
	}
	if i.EndDateGT != nil {
		predicates = append(predicates, project.EndDateGT(*i.EndDateGT))
	}
	if i.EndDateGTE != nil {
		predicates = append(predicates, project.EndDateGTE(*i.EndDateGTE))
	}
	if i.EndDateLT != nil {
		predicates = append(predicates, project.EndDateLT(*i.EndDateLT))
	}
	if i.EndDateLTE != nil {
		predicates = append(predicates, project.EndDateLTE(*i.EndDateLTE))
	}
	if i.Progress != nil {
		predicates = append(predicates, project.ProgressEQ(*i.Progress))
	}
	if i.ProgressNEQ != nil {
		predicates = append(predicates, project.ProgressNEQ(*i.ProgressNEQ))
	}
	if len(i.ProgressIn) > 0 {
		predicates = append(predicates, project.ProgressIn(i.ProgressIn...))
	}
	if len(i.ProgressNotIn) > 0 {
		predicates = append(predicates, project.ProgressNotIn(i.ProgressNotIn...))
	}
	if i.ProgressGT != nil {
		predicates = append(predicates, project.ProgressGT(*i.ProgressGT))
	}
	if i.ProgressGTE != nil {
		predicates = append(predicates, project.ProgressGTE(*i.ProgressGTE))
	}
	if i.ProgressLT != nil {
		predicates = append(predicates, project.ProgressLT(*i.ProgressLT))
	}
	if i.ProgressLTE != nil {
		predicates = append(predicates, project.ProgressLTE(*i.ProgressLTE))
	}
	if i.Status != nil {
		predicates = append(predicates, project.StatusEQ(*i.Status))
	}
	if i.StatusNEQ != nil {
		predicates = append(predicates, project.StatusNEQ(*i.StatusNEQ))
	}
	if len(i.StatusIn) > 0 {
		predicates = append(predicates, project.StatusIn(i.StatusIn...))
	}
	if len(i.StatusNotIn) > 0 {
		predicates = append(predicates, project.StatusNotIn(i.StatusNotIn...))
	}

	if i.HasCompany != nil {
		p := project.HasCompany()
		if !*i.HasCompany {
			p = project.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasCompanyWith) > 0 {
		with := make([]predicate.Company, 0, len(i.HasCompanyWith))
		for _, w := range i.HasCompanyWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasCompanyWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, project.HasCompanyWith(with...))
	}
	if i.HasCreatedBy != nil {
		p := project.HasCreatedBy()
		if !*i.HasCreatedBy {
			p = project.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasCreatedByWith) > 0 {
		with := make([]predicate.User, 0, len(i.HasCreatedByWith))
		for _, w := range i.HasCreatedByWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasCreatedByWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, project.HasCreatedByWith(with...))
	}
	if i.HasLeader != nil {
		p := project.HasLeader()
		if !*i.HasLeader {
			p = project.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasLeaderWith) > 0 {
		with := make([]predicate.User, 0, len(i.HasLeaderWith))
		for _, w := range i.HasLeaderWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasLeaderWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, project.HasLeaderWith(with...))
	}
	if i.HasTasks != nil {
		p := project.HasTasks()
		if !*i.HasTasks {
			p = project.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasTasksWith) > 0 {
		with := make([]predicate.ProjectTask, 0, len(i.HasTasksWith))
		for _, w := range i.HasTasksWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasTasksWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, project.HasTasksWith(with...))
	}
	if i.HasMilestones != nil {
		p := project.HasMilestones()
		if !*i.HasMilestones {
			p = project.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasMilestonesWith) > 0 {
		with := make([]predicate.ProjectMilestone, 0, len(i.HasMilestonesWith))
		for _, w := range i.HasMilestonesWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasMilestonesWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, project.HasMilestonesWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyProjectWhereInput
	case 1:
		return predicates[0], nil
	default:
		return project.And(predicates...), nil
	}
}

// ProjectMilestoneWhereInput represents a where input for filtering ProjectMilestone queries.
type ProjectMilestoneWhereInput struct {
	Predicates []predicate.ProjectMilestone  `json:"-"`
	Not        *ProjectMilestoneWhereInput   `json:"not,omitempty"`
	Or         []*ProjectMilestoneWhereInput `json:"or,omitempty"`
	And        []*ProjectMilestoneWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "dueDate" field predicates.
	DueDate      *time.Time  `json:"duedate,omitempty"`
	DueDateNEQ   *time.Time  `json:"duedateNEQ,omitempty"`
	DueDateIn    []time.Time `json:"duedateIn,omitempty"`
	DueDateNotIn []time.Time `json:"duedateNotIn,omitempty"`
	DueDateGT    *time.Time  `json:"duedateGT,omitempty"`
	DueDateGTE   *time.Time  `json:"duedateGTE,omitempty"`
	DueDateLT    *time.Time  `json:"duedateLT,omitempty"`
	DueDateLTE   *time.Time  `json:"duedateLTE,omitempty"`

	// "project" edge predicates.
	HasProject     *bool                `json:"hasProject,omitempty"`
	HasProjectWith []*ProjectWhereInput `json:"hasProjectWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *ProjectMilestoneWhereInput) AddPredicates(predicates ...predicate.ProjectMilestone) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the ProjectMilestoneWhereInput filter on the ProjectMilestoneQuery builder.
func (i *ProjectMilestoneWhereInput) Filter(q *ProjectMilestoneQuery) (*ProjectMilestoneQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyProjectMilestoneWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyProjectMilestoneWhereInput is returned in case the ProjectMilestoneWhereInput is empty.
var ErrEmptyProjectMilestoneWhereInput = errors.New("generated: empty predicate ProjectMilestoneWhereInput")

// P returns a predicate for filtering projectmilestones.
// An error is returned if the input is empty or invalid.
func (i *ProjectMilestoneWhereInput) P() (predicate.ProjectMilestone, error) {
	var predicates []predicate.ProjectMilestone
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, projectmilestone.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.ProjectMilestone, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, projectmilestone.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.ProjectMilestone, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, projectmilestone.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, projectmilestone.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, projectmilestone.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, projectmilestone.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, projectmilestone.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, projectmilestone.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, projectmilestone.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, projectmilestone.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, projectmilestone.IDLTE(*i.IDLTE))
	}
	if i.Name != nil {
		predicates = append(predicates, projectmilestone.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, projectmilestone.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, projectmilestone.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, projectmilestone.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, projectmilestone.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, projectmilestone.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, projectmilestone.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, projectmilestone.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, projectmilestone.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, projectmilestone.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, projectmilestone.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, projectmilestone.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, projectmilestone.NameContainsFold(*i.NameContainsFold))
	}
	if i.DueDate != nil {
		predicates = append(predicates, projectmilestone.DueDateEQ(*i.DueDate))
	}
	if i.DueDateNEQ != nil {
		predicates = append(predicates, projectmilestone.DueDateNEQ(*i.DueDateNEQ))
	}
	if len(i.DueDateIn) > 0 {
		predicates = append(predicates, projectmilestone.DueDateIn(i.DueDateIn...))
	}
	if len(i.DueDateNotIn) > 0 {
		predicates = append(predicates, projectmilestone.DueDateNotIn(i.DueDateNotIn...))
	}
	if i.DueDateGT != nil {
		predicates = append(predicates, projectmilestone.DueDateGT(*i.DueDateGT))
	}
	if i.DueDateGTE != nil {
		predicates = append(predicates, projectmilestone.DueDateGTE(*i.DueDateGTE))
	}
	if i.DueDateLT != nil {
		predicates = append(predicates, projectmilestone.DueDateLT(*i.DueDateLT))
	}
	if i.DueDateLTE != nil {
		predicates = append(predicates, projectmilestone.DueDateLTE(*i.DueDateLTE))
	}

	if i.HasProject != nil {
		p := projectmilestone.HasProject()
		if !*i.HasProject {
			p = projectmilestone.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasProjectWith) > 0 {
		with := make([]predicate.Project, 0, len(i.HasProjectWith))
		for _, w := range i.HasProjectWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasProjectWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, projectmilestone.HasProjectWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyProjectMilestoneWhereInput
	case 1:
		return predicates[0], nil
	default:
		return projectmilestone.And(predicates...), nil
	}
}

// ProjectTaskWhereInput represents a where input for filtering ProjectTask queries.
type ProjectTaskWhereInput struct {
	Predicates []predicate.ProjectTask  `json:"-"`
	Not        *ProjectTaskWhereInput   `json:"not,omitempty"`
	Or         []*ProjectTaskWhereInput `json:"or,omitempty"`
	And        []*ProjectTaskWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "createdAt" field predicates.
	CreatedAt       *time.Time  `json:"createdat,omitempty"`
	CreatedAtNEQ    *time.Time  `json:"createdatNEQ,omitempty"`
	CreatedAtIn     []time.Time `json:"createdatIn,omitempty"`
	CreatedAtNotIn  []time.Time `json:"createdatNotIn,omitempty"`
	CreatedAtGT     *time.Time  `json:"createdatGT,omitempty"`
	CreatedAtGTE    *time.Time  `json:"createdatGTE,omitempty"`
	CreatedAtLT     *time.Time  `json:"createdatLT,omitempty"`
	CreatedAtLTE    *time.Time  `json:"createdatLTE,omitempty"`
	CreatedAtIsNil  bool        `json:"createdatIsNil,omitempty"`
	CreatedAtNotNil bool        `json:"createdatNotNil,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "assigneeName" field predicates.
	AssigneeName             *string  `json:"assigneename,omitempty"`
	AssigneeNameNEQ          *string  `json:"assigneenameNEQ,omitempty"`
	AssigneeNameIn           []string `json:"assigneenameIn,omitempty"`
	AssigneeNameNotIn        []string `json:"assigneenameNotIn,omitempty"`
	AssigneeNameGT           *string  `json:"assigneenameGT,omitempty"`
	AssigneeNameGTE          *string  `json:"assigneenameGTE,omitempty"`
	AssigneeNameLT           *string  `json:"assigneenameLT,omitempty"`
	AssigneeNameLTE          *string  `json:"assigneenameLTE,omitempty"`
	AssigneeNameContains     *string  `json:"assigneenameContains,omitempty"`
	AssigneeNameHasPrefix    *string  `json:"assigneenameHasPrefix,omitempty"`
	AssigneeNameHasSuffix    *string  `json:"assigneenameHasSuffix,omitempty"`
	AssigneeNameEqualFold    *string  `json:"assigneenameEqualFold,omitempty"`
	AssigneeNameContainsFold *string  `json:"assigneenameContainsFold,omitempty"`

	// "location" field predicates.
	Location             *string  `json:"location,omitempty"`
	LocationNEQ          *string  `json:"locationNEQ,omitempty"`
	LocationIn           []string `json:"locationIn,omitempty"`
	LocationNotIn        []string `json:"locationNotIn,omitempty"`
	LocationGT           *string  `json:"locationGT,omitempty"`
	LocationGTE          *string  `json:"locationGTE,omitempty"`
	LocationLT           *string  `json:"locationLT,omitempty"`
	LocationLTE          *string  `json:"locationLTE,omitempty"`
	LocationContains     *string  `json:"locationContains,omitempty"`
	LocationHasPrefix    *string  `json:"locationHasPrefix,omitempty"`
	LocationHasSuffix    *string  `json:"locationHasSuffix,omitempty"`
	LocationIsNil        bool     `json:"locationIsNil,omitempty"`
	LocationNotNil       bool     `json:"locationNotNil,omitempty"`
	LocationEqualFold    *string  `json:"locationEqualFold,omitempty"`
	LocationContainsFold *string  `json:"locationContainsFold,omitempty"`

	// "dueDate" field predicates.
	DueDate      *time.Time  `json:"duedate,omitempty"`
	DueDateNEQ   *time.Time  `json:"duedateNEQ,omitempty"`
	DueDateIn    []time.Time `json:"duedateIn,omitempty"`
	DueDateNotIn []time.Time `json:"duedateNotIn,omitempty"`
	DueDateGT    *time.Time  `json:"duedateGT,omitempty"`
	DueDateGTE   *time.Time  `json:"duedateGTE,omitempty"`
	DueDateLT    *time.Time  `json:"duedateLT,omitempty"`
	DueDateLTE   *time.Time  `json:"duedateLTE,omitempty"`

	// "startDate" field predicates.
	StartDate      *time.Time  `json:"startdate,omitempty"`
	StartDateNEQ   *time.Time  `json:"startdateNEQ,omitempty"`
	StartDateIn    []time.Time `json:"startdateIn,omitempty"`
	StartDateNotIn []time.Time `json:"startdateNotIn,omitempty"`
	StartDateGT    *time.Time  `json:"startdateGT,omitempty"`
	StartDateGTE   *time.Time  `json:"startdateGTE,omitempty"`
	StartDateLT    *time.Time  `json:"startdateLT,omitempty"`
	StartDateLTE   *time.Time  `json:"startdateLTE,omitempty"`

	// "endDate" field predicates.
	EndDate      *time.Time  `json:"enddate,omitempty"`
	EndDateNEQ   *time.Time  `json:"enddateNEQ,omitempty"`
	EndDateIn    []time.Time `json:"enddateIn,omitempty"`
	EndDateNotIn []time.Time `json:"enddateNotIn,omitempty"`
	EndDateGT    *time.Time  `json:"enddateGT,omitempty"`
	EndDateGTE   *time.Time  `json:"enddateGTE,omitempty"`
	EndDateLT    *time.Time  `json:"enddateLT,omitempty"`
	EndDateLTE   *time.Time  `json:"enddateLTE,omitempty"`

	// "description" field predicates.
	Description             *string  `json:"description,omitempty"`
	DescriptionNEQ          *string  `json:"descriptionNEQ,omitempty"`
	DescriptionIn           []string `json:"descriptionIn,omitempty"`
	DescriptionNotIn        []string `json:"descriptionNotIn,omitempty"`
	DescriptionGT           *string  `json:"descriptionGT,omitempty"`
	DescriptionGTE          *string  `json:"descriptionGTE,omitempty"`
	DescriptionLT           *string  `json:"descriptionLT,omitempty"`
	DescriptionLTE          *string  `json:"descriptionLTE,omitempty"`
	DescriptionContains     *string  `json:"descriptionContains,omitempty"`
	DescriptionHasPrefix    *string  `json:"descriptionHasPrefix,omitempty"`
	DescriptionHasSuffix    *string  `json:"descriptionHasSuffix,omitempty"`
	DescriptionIsNil        bool     `json:"descriptionIsNil,omitempty"`
	DescriptionNotNil       bool     `json:"descriptionNotNil,omitempty"`
	DescriptionEqualFold    *string  `json:"descriptionEqualFold,omitempty"`
	DescriptionContainsFold *string  `json:"descriptionContainsFold,omitempty"`

	// "status" field predicates.
	Status      *projecttask.Status  `json:"status,omitempty"`
	StatusNEQ   *projecttask.Status  `json:"statusNEQ,omitempty"`
	StatusIn    []projecttask.Status `json:"statusIn,omitempty"`
	StatusNotIn []projecttask.Status `json:"statusNotIn,omitempty"`

	// "project" edge predicates.
	HasProject     *bool                `json:"hasProject,omitempty"`
	HasProjectWith []*ProjectWhereInput `json:"hasProjectWith,omitempty"`

	// "assignee" edge predicates.
	HasAssignee     *bool             `json:"hasAssignee,omitempty"`
	HasAssigneeWith []*UserWhereInput `json:"hasAssigneeWith,omitempty"`

	// "participants" edge predicates.
	HasParticipants     *bool             `json:"hasParticipants,omitempty"`
	HasParticipantsWith []*UserWhereInput `json:"hasParticipantsWith,omitempty"`

	// "createdBy" edge predicates.
	HasCreatedBy     *bool             `json:"hasCreatedBy,omitempty"`
	HasCreatedByWith []*UserWhereInput `json:"hasCreatedByWith,omitempty"`

	// "workShifts" edge predicates.
	HasWorkShifts     *bool                  `json:"hasWorkShifts,omitempty"`
	HasWorkShiftsWith []*WorkshiftWhereInput `json:"hasWorkShiftsWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *ProjectTaskWhereInput) AddPredicates(predicates ...predicate.ProjectTask) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the ProjectTaskWhereInput filter on the ProjectTaskQuery builder.
func (i *ProjectTaskWhereInput) Filter(q *ProjectTaskQuery) (*ProjectTaskQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyProjectTaskWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyProjectTaskWhereInput is returned in case the ProjectTaskWhereInput is empty.
var ErrEmptyProjectTaskWhereInput = errors.New("generated: empty predicate ProjectTaskWhereInput")

// P returns a predicate for filtering projecttasks.
// An error is returned if the input is empty or invalid.
func (i *ProjectTaskWhereInput) P() (predicate.ProjectTask, error) {
	var predicates []predicate.ProjectTask
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, projecttask.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.ProjectTask, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, projecttask.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.ProjectTask, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, projecttask.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, projecttask.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, projecttask.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, projecttask.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, projecttask.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, projecttask.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, projecttask.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, projecttask.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, projecttask.IDLTE(*i.IDLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, projecttask.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, projecttask.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, projecttask.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, projecttask.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, projecttask.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, projecttask.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, projecttask.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, projecttask.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.CreatedAtIsNil {
		predicates = append(predicates, projecttask.CreatedAtIsNil())
	}
	if i.CreatedAtNotNil {
		predicates = append(predicates, projecttask.CreatedAtNotNil())
	}
	if i.Name != nil {
		predicates = append(predicates, projecttask.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, projecttask.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, projecttask.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, projecttask.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, projecttask.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, projecttask.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, projecttask.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, projecttask.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, projecttask.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, projecttask.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, projecttask.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, projecttask.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, projecttask.NameContainsFold(*i.NameContainsFold))
	}
	if i.AssigneeName != nil {
		predicates = append(predicates, projecttask.AssigneeNameEQ(*i.AssigneeName))
	}
	if i.AssigneeNameNEQ != nil {
		predicates = append(predicates, projecttask.AssigneeNameNEQ(*i.AssigneeNameNEQ))
	}
	if len(i.AssigneeNameIn) > 0 {
		predicates = append(predicates, projecttask.AssigneeNameIn(i.AssigneeNameIn...))
	}
	if len(i.AssigneeNameNotIn) > 0 {
		predicates = append(predicates, projecttask.AssigneeNameNotIn(i.AssigneeNameNotIn...))
	}
	if i.AssigneeNameGT != nil {
		predicates = append(predicates, projecttask.AssigneeNameGT(*i.AssigneeNameGT))
	}
	if i.AssigneeNameGTE != nil {
		predicates = append(predicates, projecttask.AssigneeNameGTE(*i.AssigneeNameGTE))
	}
	if i.AssigneeNameLT != nil {
		predicates = append(predicates, projecttask.AssigneeNameLT(*i.AssigneeNameLT))
	}
	if i.AssigneeNameLTE != nil {
		predicates = append(predicates, projecttask.AssigneeNameLTE(*i.AssigneeNameLTE))
	}
	if i.AssigneeNameContains != nil {
		predicates = append(predicates, projecttask.AssigneeNameContains(*i.AssigneeNameContains))
	}
	if i.AssigneeNameHasPrefix != nil {
		predicates = append(predicates, projecttask.AssigneeNameHasPrefix(*i.AssigneeNameHasPrefix))
	}
	if i.AssigneeNameHasSuffix != nil {
		predicates = append(predicates, projecttask.AssigneeNameHasSuffix(*i.AssigneeNameHasSuffix))
	}
	if i.AssigneeNameEqualFold != nil {
		predicates = append(predicates, projecttask.AssigneeNameEqualFold(*i.AssigneeNameEqualFold))
	}
	if i.AssigneeNameContainsFold != nil {
		predicates = append(predicates, projecttask.AssigneeNameContainsFold(*i.AssigneeNameContainsFold))
	}
	if i.Location != nil {
		predicates = append(predicates, projecttask.LocationEQ(*i.Location))
	}
	if i.LocationNEQ != nil {
		predicates = append(predicates, projecttask.LocationNEQ(*i.LocationNEQ))
	}
	if len(i.LocationIn) > 0 {
		predicates = append(predicates, projecttask.LocationIn(i.LocationIn...))
	}
	if len(i.LocationNotIn) > 0 {
		predicates = append(predicates, projecttask.LocationNotIn(i.LocationNotIn...))
	}
	if i.LocationGT != nil {
		predicates = append(predicates, projecttask.LocationGT(*i.LocationGT))
	}
	if i.LocationGTE != nil {
		predicates = append(predicates, projecttask.LocationGTE(*i.LocationGTE))
	}
	if i.LocationLT != nil {
		predicates = append(predicates, projecttask.LocationLT(*i.LocationLT))
	}
	if i.LocationLTE != nil {
		predicates = append(predicates, projecttask.LocationLTE(*i.LocationLTE))
	}
	if i.LocationContains != nil {
		predicates = append(predicates, projecttask.LocationContains(*i.LocationContains))
	}
	if i.LocationHasPrefix != nil {
		predicates = append(predicates, projecttask.LocationHasPrefix(*i.LocationHasPrefix))
	}
	if i.LocationHasSuffix != nil {
		predicates = append(predicates, projecttask.LocationHasSuffix(*i.LocationHasSuffix))
	}
	if i.LocationIsNil {
		predicates = append(predicates, projecttask.LocationIsNil())
	}
	if i.LocationNotNil {
		predicates = append(predicates, projecttask.LocationNotNil())
	}
	if i.LocationEqualFold != nil {
		predicates = append(predicates, projecttask.LocationEqualFold(*i.LocationEqualFold))
	}
	if i.LocationContainsFold != nil {
		predicates = append(predicates, projecttask.LocationContainsFold(*i.LocationContainsFold))
	}
	if i.DueDate != nil {
		predicates = append(predicates, projecttask.DueDateEQ(*i.DueDate))
	}
	if i.DueDateNEQ != nil {
		predicates = append(predicates, projecttask.DueDateNEQ(*i.DueDateNEQ))
	}
	if len(i.DueDateIn) > 0 {
		predicates = append(predicates, projecttask.DueDateIn(i.DueDateIn...))
	}
	if len(i.DueDateNotIn) > 0 {
		predicates = append(predicates, projecttask.DueDateNotIn(i.DueDateNotIn...))
	}
	if i.DueDateGT != nil {
		predicates = append(predicates, projecttask.DueDateGT(*i.DueDateGT))
	}
	if i.DueDateGTE != nil {
		predicates = append(predicates, projecttask.DueDateGTE(*i.DueDateGTE))
	}
	if i.DueDateLT != nil {
		predicates = append(predicates, projecttask.DueDateLT(*i.DueDateLT))
	}
	if i.DueDateLTE != nil {
		predicates = append(predicates, projecttask.DueDateLTE(*i.DueDateLTE))
	}
	if i.StartDate != nil {
		predicates = append(predicates, projecttask.StartDateEQ(*i.StartDate))
	}
	if i.StartDateNEQ != nil {
		predicates = append(predicates, projecttask.StartDateNEQ(*i.StartDateNEQ))
	}
	if len(i.StartDateIn) > 0 {
		predicates = append(predicates, projecttask.StartDateIn(i.StartDateIn...))
	}
	if len(i.StartDateNotIn) > 0 {
		predicates = append(predicates, projecttask.StartDateNotIn(i.StartDateNotIn...))
	}
	if i.StartDateGT != nil {
		predicates = append(predicates, projecttask.StartDateGT(*i.StartDateGT))
	}
	if i.StartDateGTE != nil {
		predicates = append(predicates, projecttask.StartDateGTE(*i.StartDateGTE))
	}
	if i.StartDateLT != nil {
		predicates = append(predicates, projecttask.StartDateLT(*i.StartDateLT))
	}
	if i.StartDateLTE != nil {
		predicates = append(predicates, projecttask.StartDateLTE(*i.StartDateLTE))
	}
	if i.EndDate != nil {
		predicates = append(predicates, projecttask.EndDateEQ(*i.EndDate))
	}
	if i.EndDateNEQ != nil {
		predicates = append(predicates, projecttask.EndDateNEQ(*i.EndDateNEQ))
	}
	if len(i.EndDateIn) > 0 {
		predicates = append(predicates, projecttask.EndDateIn(i.EndDateIn...))
	}
	if len(i.EndDateNotIn) > 0 {
		predicates = append(predicates, projecttask.EndDateNotIn(i.EndDateNotIn...))
	}
	if i.EndDateGT != nil {
		predicates = append(predicates, projecttask.EndDateGT(*i.EndDateGT))
	}
	if i.EndDateGTE != nil {
		predicates = append(predicates, projecttask.EndDateGTE(*i.EndDateGTE))
	}
	if i.EndDateLT != nil {
		predicates = append(predicates, projecttask.EndDateLT(*i.EndDateLT))
	}
	if i.EndDateLTE != nil {
		predicates = append(predicates, projecttask.EndDateLTE(*i.EndDateLTE))
	}
	if i.Description != nil {
		predicates = append(predicates, projecttask.DescriptionEQ(*i.Description))
	}
	if i.DescriptionNEQ != nil {
		predicates = append(predicates, projecttask.DescriptionNEQ(*i.DescriptionNEQ))
	}
	if len(i.DescriptionIn) > 0 {
		predicates = append(predicates, projecttask.DescriptionIn(i.DescriptionIn...))
	}
	if len(i.DescriptionNotIn) > 0 {
		predicates = append(predicates, projecttask.DescriptionNotIn(i.DescriptionNotIn...))
	}
	if i.DescriptionGT != nil {
		predicates = append(predicates, projecttask.DescriptionGT(*i.DescriptionGT))
	}
	if i.DescriptionGTE != nil {
		predicates = append(predicates, projecttask.DescriptionGTE(*i.DescriptionGTE))
	}
	if i.DescriptionLT != nil {
		predicates = append(predicates, projecttask.DescriptionLT(*i.DescriptionLT))
	}
	if i.DescriptionLTE != nil {
		predicates = append(predicates, projecttask.DescriptionLTE(*i.DescriptionLTE))
	}
	if i.DescriptionContains != nil {
		predicates = append(predicates, projecttask.DescriptionContains(*i.DescriptionContains))
	}
	if i.DescriptionHasPrefix != nil {
		predicates = append(predicates, projecttask.DescriptionHasPrefix(*i.DescriptionHasPrefix))
	}
	if i.DescriptionHasSuffix != nil {
		predicates = append(predicates, projecttask.DescriptionHasSuffix(*i.DescriptionHasSuffix))
	}
	if i.DescriptionIsNil {
		predicates = append(predicates, projecttask.DescriptionIsNil())
	}
	if i.DescriptionNotNil {
		predicates = append(predicates, projecttask.DescriptionNotNil())
	}
	if i.DescriptionEqualFold != nil {
		predicates = append(predicates, projecttask.DescriptionEqualFold(*i.DescriptionEqualFold))
	}
	if i.DescriptionContainsFold != nil {
		predicates = append(predicates, projecttask.DescriptionContainsFold(*i.DescriptionContainsFold))
	}
	if i.Status != nil {
		predicates = append(predicates, projecttask.StatusEQ(*i.Status))
	}
	if i.StatusNEQ != nil {
		predicates = append(predicates, projecttask.StatusNEQ(*i.StatusNEQ))
	}
	if len(i.StatusIn) > 0 {
		predicates = append(predicates, projecttask.StatusIn(i.StatusIn...))
	}
	if len(i.StatusNotIn) > 0 {
		predicates = append(predicates, projecttask.StatusNotIn(i.StatusNotIn...))
	}

	if i.HasProject != nil {
		p := projecttask.HasProject()
		if !*i.HasProject {
			p = projecttask.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasProjectWith) > 0 {
		with := make([]predicate.Project, 0, len(i.HasProjectWith))
		for _, w := range i.HasProjectWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasProjectWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, projecttask.HasProjectWith(with...))
	}
	if i.HasAssignee != nil {
		p := projecttask.HasAssignee()
		if !*i.HasAssignee {
			p = projecttask.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasAssigneeWith) > 0 {
		with := make([]predicate.User, 0, len(i.HasAssigneeWith))
		for _, w := range i.HasAssigneeWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasAssigneeWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, projecttask.HasAssigneeWith(with...))
	}
	if i.HasParticipants != nil {
		p := projecttask.HasParticipants()
		if !*i.HasParticipants {
			p = projecttask.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasParticipantsWith) > 0 {
		with := make([]predicate.User, 0, len(i.HasParticipantsWith))
		for _, w := range i.HasParticipantsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasParticipantsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, projecttask.HasParticipantsWith(with...))
	}
	if i.HasCreatedBy != nil {
		p := projecttask.HasCreatedBy()
		if !*i.HasCreatedBy {
			p = projecttask.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasCreatedByWith) > 0 {
		with := make([]predicate.User, 0, len(i.HasCreatedByWith))
		for _, w := range i.HasCreatedByWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasCreatedByWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, projecttask.HasCreatedByWith(with...))
	}
	if i.HasWorkShifts != nil {
		p := projecttask.HasWorkShifts()
		if !*i.HasWorkShifts {
			p = projecttask.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasWorkShiftsWith) > 0 {
		with := make([]predicate.Workshift, 0, len(i.HasWorkShiftsWith))
		for _, w := range i.HasWorkShiftsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasWorkShiftsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, projecttask.HasWorkShiftsWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyProjectTaskWhereInput
	case 1:
		return predicates[0], nil
	default:
		return projecttask.And(predicates...), nil
	}
}

// ReceivableWhereInput represents a where input for filtering Receivable queries.
type ReceivableWhereInput struct {
	Predicates []predicate.Receivable  `json:"-"`
	Not        *ReceivableWhereInput   `json:"not,omitempty"`
	Or         []*ReceivableWhereInput `json:"or,omitempty"`
	And        []*ReceivableWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "createdAt" field predicates.
	CreatedAt      *time.Time  `json:"createdat,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdatNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdatIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdatNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdatGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdatGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdatLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdatLTE,omitempty"`

	// "updatedAt" field predicates.
	UpdatedAt      *time.Time  `json:"updatedat,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedatNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedatIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedatNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedatGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedatGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedatLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedatLTE,omitempty"`

	// "deletedAt" field predicates.
	DeletedAt       *time.Time  `json:"deletedat,omitempty"`
	DeletedAtNEQ    *time.Time  `json:"deletedatNEQ,omitempty"`
	DeletedAtIn     []time.Time `json:"deletedatIn,omitempty"`
	DeletedAtNotIn  []time.Time `json:"deletedatNotIn,omitempty"`
	DeletedAtGT     *time.Time  `json:"deletedatGT,omitempty"`
	DeletedAtGTE    *time.Time  `json:"deletedatGTE,omitempty"`
	DeletedAtLT     *time.Time  `json:"deletedatLT,omitempty"`
	DeletedAtLTE    *time.Time  `json:"deletedatLTE,omitempty"`
	DeletedAtIsNil  bool        `json:"deletedatIsNil,omitempty"`
	DeletedAtNotNil bool        `json:"deletedatNotNil,omitempty"`

	// "entryGroup" field predicates.
	EntryGroup      *int  `json:"entrygroup,omitempty"`
	EntryGroupNEQ   *int  `json:"entrygroupNEQ,omitempty"`
	EntryGroupIn    []int `json:"entrygroupIn,omitempty"`
	EntryGroupNotIn []int `json:"entrygroupNotIn,omitempty"`
	EntryGroupGT    *int  `json:"entrygroupGT,omitempty"`
	EntryGroupGTE   *int  `json:"entrygroupGTE,omitempty"`
	EntryGroupLT    *int  `json:"entrygroupLT,omitempty"`
	EntryGroupLTE   *int  `json:"entrygroupLTE,omitempty"`

	// "date" field predicates.
	Date      *time.Time  `json:"date,omitempty"`
	DateNEQ   *time.Time  `json:"dateNEQ,omitempty"`
	DateIn    []time.Time `json:"dateIn,omitempty"`
	DateNotIn []time.Time `json:"dateNotIn,omitempty"`
	DateGT    *time.Time  `json:"dateGT,omitempty"`
	DateGTE   *time.Time  `json:"dateGTE,omitempty"`
	DateLT    *time.Time  `json:"dateLT,omitempty"`
	DateLTE   *time.Time  `json:"dateLTE,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "outstandingBalance" field predicates.
	OutstandingBalance      *float64  `json:"outstandingbalance,omitempty"`
	OutstandingBalanceNEQ   *float64  `json:"outstandingbalanceNEQ,omitempty"`
	OutstandingBalanceIn    []float64 `json:"outstandingbalanceIn,omitempty"`
	OutstandingBalanceNotIn []float64 `json:"outstandingbalanceNotIn,omitempty"`
	OutstandingBalanceGT    *float64  `json:"outstandingbalanceGT,omitempty"`
	OutstandingBalanceGTE   *float64  `json:"outstandingbalanceGTE,omitempty"`
	OutstandingBalanceLT    *float64  `json:"outstandingbalanceLT,omitempty"`
	OutstandingBalanceLTE   *float64  `json:"outstandingbalanceLTE,omitempty"`

	// "totalTransaction" field predicates.
	TotalTransaction      *float64  `json:"totaltransaction,omitempty"`
	TotalTransactionNEQ   *float64  `json:"totaltransactionNEQ,omitempty"`
	TotalTransactionIn    []float64 `json:"totaltransactionIn,omitempty"`
	TotalTransactionNotIn []float64 `json:"totaltransactionNotIn,omitempty"`
	TotalTransactionGT    *float64  `json:"totaltransactionGT,omitempty"`
	TotalTransactionGTE   *float64  `json:"totaltransactionGTE,omitempty"`
	TotalTransactionLT    *float64  `json:"totaltransactionLT,omitempty"`
	TotalTransactionLTE   *float64  `json:"totaltransactionLTE,omitempty"`

	// "dueDate" field predicates.
	DueDate      *time.Time  `json:"duedate,omitempty"`
	DueDateNEQ   *time.Time  `json:"duedateNEQ,omitempty"`
	DueDateIn    []time.Time `json:"duedateIn,omitempty"`
	DueDateNotIn []time.Time `json:"duedateNotIn,omitempty"`
	DueDateGT    *time.Time  `json:"duedateGT,omitempty"`
	DueDateGTE   *time.Time  `json:"duedateGTE,omitempty"`
	DueDateLT    *time.Time  `json:"duedateLT,omitempty"`
	DueDateLTE   *time.Time  `json:"duedateLTE,omitempty"`

	// "status" field predicates.
	Status      *receivable.Status  `json:"status,omitempty"`
	StatusNEQ   *receivable.Status  `json:"statusNEQ,omitempty"`
	StatusIn    []receivable.Status `json:"statusIn,omitempty"`
	StatusNotIn []receivable.Status `json:"statusNotIn,omitempty"`

	// "company" edge predicates.
	HasCompany     *bool                `json:"hasCompany,omitempty"`
	HasCompanyWith []*CompanyWhereInput `json:"hasCompanyWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *ReceivableWhereInput) AddPredicates(predicates ...predicate.Receivable) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the ReceivableWhereInput filter on the ReceivableQuery builder.
func (i *ReceivableWhereInput) Filter(q *ReceivableQuery) (*ReceivableQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyReceivableWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyReceivableWhereInput is returned in case the ReceivableWhereInput is empty.
var ErrEmptyReceivableWhereInput = errors.New("generated: empty predicate ReceivableWhereInput")

// P returns a predicate for filtering receivables.
// An error is returned if the input is empty or invalid.
func (i *ReceivableWhereInput) P() (predicate.Receivable, error) {
	var predicates []predicate.Receivable
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, receivable.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Receivable, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, receivable.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Receivable, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, receivable.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, receivable.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, receivable.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, receivable.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, receivable.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, receivable.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, receivable.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, receivable.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, receivable.IDLTE(*i.IDLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, receivable.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, receivable.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, receivable.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, receivable.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, receivable.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, receivable.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, receivable.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, receivable.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, receivable.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, receivable.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, receivable.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, receivable.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, receivable.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, receivable.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, receivable.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, receivable.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.DeletedAt != nil {
		predicates = append(predicates, receivable.DeletedAtEQ(*i.DeletedAt))
	}
	if i.DeletedAtNEQ != nil {
		predicates = append(predicates, receivable.DeletedAtNEQ(*i.DeletedAtNEQ))
	}
	if len(i.DeletedAtIn) > 0 {
		predicates = append(predicates, receivable.DeletedAtIn(i.DeletedAtIn...))
	}
	if len(i.DeletedAtNotIn) > 0 {
		predicates = append(predicates, receivable.DeletedAtNotIn(i.DeletedAtNotIn...))
	}
	if i.DeletedAtGT != nil {
		predicates = append(predicates, receivable.DeletedAtGT(*i.DeletedAtGT))
	}
	if i.DeletedAtGTE != nil {
		predicates = append(predicates, receivable.DeletedAtGTE(*i.DeletedAtGTE))
	}
	if i.DeletedAtLT != nil {
		predicates = append(predicates, receivable.DeletedAtLT(*i.DeletedAtLT))
	}
	if i.DeletedAtLTE != nil {
		predicates = append(predicates, receivable.DeletedAtLTE(*i.DeletedAtLTE))
	}
	if i.DeletedAtIsNil {
		predicates = append(predicates, receivable.DeletedAtIsNil())
	}
	if i.DeletedAtNotNil {
		predicates = append(predicates, receivable.DeletedAtNotNil())
	}
	if i.EntryGroup != nil {
		predicates = append(predicates, receivable.EntryGroupEQ(*i.EntryGroup))
	}
	if i.EntryGroupNEQ != nil {
		predicates = append(predicates, receivable.EntryGroupNEQ(*i.EntryGroupNEQ))
	}
	if len(i.EntryGroupIn) > 0 {
		predicates = append(predicates, receivable.EntryGroupIn(i.EntryGroupIn...))
	}
	if len(i.EntryGroupNotIn) > 0 {
		predicates = append(predicates, receivable.EntryGroupNotIn(i.EntryGroupNotIn...))
	}
	if i.EntryGroupGT != nil {
		predicates = append(predicates, receivable.EntryGroupGT(*i.EntryGroupGT))
	}
	if i.EntryGroupGTE != nil {
		predicates = append(predicates, receivable.EntryGroupGTE(*i.EntryGroupGTE))
	}
	if i.EntryGroupLT != nil {
		predicates = append(predicates, receivable.EntryGroupLT(*i.EntryGroupLT))
	}
	if i.EntryGroupLTE != nil {
		predicates = append(predicates, receivable.EntryGroupLTE(*i.EntryGroupLTE))
	}
	if i.Date != nil {
		predicates = append(predicates, receivable.DateEQ(*i.Date))
	}
	if i.DateNEQ != nil {
		predicates = append(predicates, receivable.DateNEQ(*i.DateNEQ))
	}
	if len(i.DateIn) > 0 {
		predicates = append(predicates, receivable.DateIn(i.DateIn...))
	}
	if len(i.DateNotIn) > 0 {
		predicates = append(predicates, receivable.DateNotIn(i.DateNotIn...))
	}
	if i.DateGT != nil {
		predicates = append(predicates, receivable.DateGT(*i.DateGT))
	}
	if i.DateGTE != nil {
		predicates = append(predicates, receivable.DateGTE(*i.DateGTE))
	}
	if i.DateLT != nil {
		predicates = append(predicates, receivable.DateLT(*i.DateLT))
	}
	if i.DateLTE != nil {
		predicates = append(predicates, receivable.DateLTE(*i.DateLTE))
	}
	if i.Name != nil {
		predicates = append(predicates, receivable.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, receivable.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, receivable.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, receivable.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, receivable.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, receivable.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, receivable.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, receivable.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, receivable.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, receivable.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, receivable.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, receivable.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, receivable.NameContainsFold(*i.NameContainsFold))
	}
	if i.OutstandingBalance != nil {
		predicates = append(predicates, receivable.OutstandingBalanceEQ(*i.OutstandingBalance))
	}
	if i.OutstandingBalanceNEQ != nil {
		predicates = append(predicates, receivable.OutstandingBalanceNEQ(*i.OutstandingBalanceNEQ))
	}
	if len(i.OutstandingBalanceIn) > 0 {
		predicates = append(predicates, receivable.OutstandingBalanceIn(i.OutstandingBalanceIn...))
	}
	if len(i.OutstandingBalanceNotIn) > 0 {
		predicates = append(predicates, receivable.OutstandingBalanceNotIn(i.OutstandingBalanceNotIn...))
	}
	if i.OutstandingBalanceGT != nil {
		predicates = append(predicates, receivable.OutstandingBalanceGT(*i.OutstandingBalanceGT))
	}
	if i.OutstandingBalanceGTE != nil {
		predicates = append(predicates, receivable.OutstandingBalanceGTE(*i.OutstandingBalanceGTE))
	}
	if i.OutstandingBalanceLT != nil {
		predicates = append(predicates, receivable.OutstandingBalanceLT(*i.OutstandingBalanceLT))
	}
	if i.OutstandingBalanceLTE != nil {
		predicates = append(predicates, receivable.OutstandingBalanceLTE(*i.OutstandingBalanceLTE))
	}
	if i.TotalTransaction != nil {
		predicates = append(predicates, receivable.TotalTransactionEQ(*i.TotalTransaction))
	}
	if i.TotalTransactionNEQ != nil {
		predicates = append(predicates, receivable.TotalTransactionNEQ(*i.TotalTransactionNEQ))
	}
	if len(i.TotalTransactionIn) > 0 {
		predicates = append(predicates, receivable.TotalTransactionIn(i.TotalTransactionIn...))
	}
	if len(i.TotalTransactionNotIn) > 0 {
		predicates = append(predicates, receivable.TotalTransactionNotIn(i.TotalTransactionNotIn...))
	}
	if i.TotalTransactionGT != nil {
		predicates = append(predicates, receivable.TotalTransactionGT(*i.TotalTransactionGT))
	}
	if i.TotalTransactionGTE != nil {
		predicates = append(predicates, receivable.TotalTransactionGTE(*i.TotalTransactionGTE))
	}
	if i.TotalTransactionLT != nil {
		predicates = append(predicates, receivable.TotalTransactionLT(*i.TotalTransactionLT))
	}
	if i.TotalTransactionLTE != nil {
		predicates = append(predicates, receivable.TotalTransactionLTE(*i.TotalTransactionLTE))
	}
	if i.DueDate != nil {
		predicates = append(predicates, receivable.DueDateEQ(*i.DueDate))
	}
	if i.DueDateNEQ != nil {
		predicates = append(predicates, receivable.DueDateNEQ(*i.DueDateNEQ))
	}
	if len(i.DueDateIn) > 0 {
		predicates = append(predicates, receivable.DueDateIn(i.DueDateIn...))
	}
	if len(i.DueDateNotIn) > 0 {
		predicates = append(predicates, receivable.DueDateNotIn(i.DueDateNotIn...))
	}
	if i.DueDateGT != nil {
		predicates = append(predicates, receivable.DueDateGT(*i.DueDateGT))
	}
	if i.DueDateGTE != nil {
		predicates = append(predicates, receivable.DueDateGTE(*i.DueDateGTE))
	}
	if i.DueDateLT != nil {
		predicates = append(predicates, receivable.DueDateLT(*i.DueDateLT))
	}
	if i.DueDateLTE != nil {
		predicates = append(predicates, receivable.DueDateLTE(*i.DueDateLTE))
	}
	if i.Status != nil {
		predicates = append(predicates, receivable.StatusEQ(*i.Status))
	}
	if i.StatusNEQ != nil {
		predicates = append(predicates, receivable.StatusNEQ(*i.StatusNEQ))
	}
	if len(i.StatusIn) > 0 {
		predicates = append(predicates, receivable.StatusIn(i.StatusIn...))
	}
	if len(i.StatusNotIn) > 0 {
		predicates = append(predicates, receivable.StatusNotIn(i.StatusNotIn...))
	}

	if i.HasCompany != nil {
		p := receivable.HasCompany()
		if !*i.HasCompany {
			p = receivable.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasCompanyWith) > 0 {
		with := make([]predicate.Company, 0, len(i.HasCompanyWith))
		for _, w := range i.HasCompanyWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasCompanyWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, receivable.HasCompanyWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyReceivableWhereInput
	case 1:
		return predicates[0], nil
	default:
		return receivable.And(predicates...), nil
	}
}

// SupplierWhereInput represents a where input for filtering Supplier queries.
type SupplierWhereInput struct {
	Predicates []predicate.Supplier  `json:"-"`
	Not        *SupplierWhereInput   `json:"not,omitempty"`
	Or         []*SupplierWhereInput `json:"or,omitempty"`
	And        []*SupplierWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "createdAt" field predicates.
	CreatedAt      *time.Time  `json:"createdat,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdatNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdatIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdatNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdatGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdatGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdatLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdatLTE,omitempty"`

	// "updatedAt" field predicates.
	UpdatedAt      *time.Time  `json:"updatedat,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedatNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedatIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedatNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedatGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedatGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedatLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedatLTE,omitempty"`

	// "deletedAt" field predicates.
	DeletedAt       *time.Time  `json:"deletedat,omitempty"`
	DeletedAtNEQ    *time.Time  `json:"deletedatNEQ,omitempty"`
	DeletedAtIn     []time.Time `json:"deletedatIn,omitempty"`
	DeletedAtNotIn  []time.Time `json:"deletedatNotIn,omitempty"`
	DeletedAtGT     *time.Time  `json:"deletedatGT,omitempty"`
	DeletedAtGTE    *time.Time  `json:"deletedatGTE,omitempty"`
	DeletedAtLT     *time.Time  `json:"deletedatLT,omitempty"`
	DeletedAtLTE    *time.Time  `json:"deletedatLTE,omitempty"`
	DeletedAtIsNil  bool        `json:"deletedatIsNil,omitempty"`
	DeletedAtNotNil bool        `json:"deletedatNotNil,omitempty"`

	// "address" field predicates.
	Address             *string  `json:"address,omitempty"`
	AddressNEQ          *string  `json:"addressNEQ,omitempty"`
	AddressIn           []string `json:"addressIn,omitempty"`
	AddressNotIn        []string `json:"addressNotIn,omitempty"`
	AddressGT           *string  `json:"addressGT,omitempty"`
	AddressGTE          *string  `json:"addressGTE,omitempty"`
	AddressLT           *string  `json:"addressLT,omitempty"`
	AddressLTE          *string  `json:"addressLTE,omitempty"`
	AddressContains     *string  `json:"addressContains,omitempty"`
	AddressHasPrefix    *string  `json:"addressHasPrefix,omitempty"`
	AddressHasSuffix    *string  `json:"addressHasSuffix,omitempty"`
	AddressEqualFold    *string  `json:"addressEqualFold,omitempty"`
	AddressContainsFold *string  `json:"addressContainsFold,omitempty"`

	// "city" field predicates.
	City             *string  `json:"city,omitempty"`
	CityNEQ          *string  `json:"cityNEQ,omitempty"`
	CityIn           []string `json:"cityIn,omitempty"`
	CityNotIn        []string `json:"cityNotIn,omitempty"`
	CityGT           *string  `json:"cityGT,omitempty"`
	CityGTE          *string  `json:"cityGTE,omitempty"`
	CityLT           *string  `json:"cityLT,omitempty"`
	CityLTE          *string  `json:"cityLTE,omitempty"`
	CityContains     *string  `json:"cityContains,omitempty"`
	CityHasPrefix    *string  `json:"cityHasPrefix,omitempty"`
	CityHasSuffix    *string  `json:"cityHasSuffix,omitempty"`
	CityEqualFold    *string  `json:"cityEqualFold,omitempty"`
	CityContainsFold *string  `json:"cityContainsFold,omitempty"`

	// "country" field predicates.
	Country             *string  `json:"country,omitempty"`
	CountryNEQ          *string  `json:"countryNEQ,omitempty"`
	CountryIn           []string `json:"countryIn,omitempty"`
	CountryNotIn        []string `json:"countryNotIn,omitempty"`
	CountryGT           *string  `json:"countryGT,omitempty"`
	CountryGTE          *string  `json:"countryGTE,omitempty"`
	CountryLT           *string  `json:"countryLT,omitempty"`
	CountryLTE          *string  `json:"countryLTE,omitempty"`
	CountryContains     *string  `json:"countryContains,omitempty"`
	CountryHasPrefix    *string  `json:"countryHasPrefix,omitempty"`
	CountryHasSuffix    *string  `json:"countryHasSuffix,omitempty"`
	CountryEqualFold    *string  `json:"countryEqualFold,omitempty"`
	CountryContainsFold *string  `json:"countryContainsFold,omitempty"`

	// "description" field predicates.
	Description             *string  `json:"description,omitempty"`
	DescriptionNEQ          *string  `json:"descriptionNEQ,omitempty"`
	DescriptionIn           []string `json:"descriptionIn,omitempty"`
	DescriptionNotIn        []string `json:"descriptionNotIn,omitempty"`
	DescriptionGT           *string  `json:"descriptionGT,omitempty"`
	DescriptionGTE          *string  `json:"descriptionGTE,omitempty"`
	DescriptionLT           *string  `json:"descriptionLT,omitempty"`
	DescriptionLTE          *string  `json:"descriptionLTE,omitempty"`
	DescriptionContains     *string  `json:"descriptionContains,omitempty"`
	DescriptionHasPrefix    *string  `json:"descriptionHasPrefix,omitempty"`
	DescriptionHasSuffix    *string  `json:"descriptionHasSuffix,omitempty"`
	DescriptionEqualFold    *string  `json:"descriptionEqualFold,omitempty"`
	DescriptionContainsFold *string  `json:"descriptionContainsFold,omitempty"`

	// "email" field predicates.
	Email             *string  `json:"email,omitempty"`
	EmailNEQ          *string  `json:"emailNEQ,omitempty"`
	EmailIn           []string `json:"emailIn,omitempty"`
	EmailNotIn        []string `json:"emailNotIn,omitempty"`
	EmailGT           *string  `json:"emailGT,omitempty"`
	EmailGTE          *string  `json:"emailGTE,omitempty"`
	EmailLT           *string  `json:"emailLT,omitempty"`
	EmailLTE          *string  `json:"emailLTE,omitempty"`
	EmailContains     *string  `json:"emailContains,omitempty"`
	EmailHasPrefix    *string  `json:"emailHasPrefix,omitempty"`
	EmailHasSuffix    *string  `json:"emailHasSuffix,omitempty"`
	EmailEqualFold    *string  `json:"emailEqualFold,omitempty"`
	EmailContainsFold *string  `json:"emailContainsFold,omitempty"`

	// "isDefault" field predicates.
	IsDefault       *bool `json:"isdefault,omitempty"`
	IsDefaultNEQ    *bool `json:"isdefaultNEQ,omitempty"`
	IsDefaultIsNil  bool  `json:"isdefaultIsNil,omitempty"`
	IsDefaultNotNil bool  `json:"isdefaultNotNil,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "phone" field predicates.
	Phone             *string  `json:"phone,omitempty"`
	PhoneNEQ          *string  `json:"phoneNEQ,omitempty"`
	PhoneIn           []string `json:"phoneIn,omitempty"`
	PhoneNotIn        []string `json:"phoneNotIn,omitempty"`
	PhoneGT           *string  `json:"phoneGT,omitempty"`
	PhoneGTE          *string  `json:"phoneGTE,omitempty"`
	PhoneLT           *string  `json:"phoneLT,omitempty"`
	PhoneLTE          *string  `json:"phoneLTE,omitempty"`
	PhoneContains     *string  `json:"phoneContains,omitempty"`
	PhoneHasPrefix    *string  `json:"phoneHasPrefix,omitempty"`
	PhoneHasSuffix    *string  `json:"phoneHasSuffix,omitempty"`
	PhoneEqualFold    *string  `json:"phoneEqualFold,omitempty"`
	PhoneContainsFold *string  `json:"phoneContainsFold,omitempty"`

	// "taxId" field predicates.
	TaxId             *string  `json:"taxid,omitempty"`
	TaxIdNEQ          *string  `json:"taxidNEQ,omitempty"`
	TaxIdIn           []string `json:"taxidIn,omitempty"`
	TaxIdNotIn        []string `json:"taxidNotIn,omitempty"`
	TaxIdGT           *string  `json:"taxidGT,omitempty"`
	TaxIdGTE          *string  `json:"taxidGTE,omitempty"`
	TaxIdLT           *string  `json:"taxidLT,omitempty"`
	TaxIdLTE          *string  `json:"taxidLTE,omitempty"`
	TaxIdContains     *string  `json:"taxidContains,omitempty"`
	TaxIdHasPrefix    *string  `json:"taxidHasPrefix,omitempty"`
	TaxIdHasSuffix    *string  `json:"taxidHasSuffix,omitempty"`
	TaxIdEqualFold    *string  `json:"taxidEqualFold,omitempty"`
	TaxIdContainsFold *string  `json:"taxidContainsFold,omitempty"`

	// "company" edge predicates.
	HasCompany     *bool                `json:"hasCompany,omitempty"`
	HasCompanyWith []*CompanyWhereInput `json:"hasCompanyWith,omitempty"`

	// "payables" edge predicates.
	HasPayables     *bool                `json:"hasPayables,omitempty"`
	HasPayablesWith []*PayableWhereInput `json:"hasPayablesWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *SupplierWhereInput) AddPredicates(predicates ...predicate.Supplier) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the SupplierWhereInput filter on the SupplierQuery builder.
func (i *SupplierWhereInput) Filter(q *SupplierQuery) (*SupplierQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptySupplierWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptySupplierWhereInput is returned in case the SupplierWhereInput is empty.
var ErrEmptySupplierWhereInput = errors.New("generated: empty predicate SupplierWhereInput")

// P returns a predicate for filtering suppliers.
// An error is returned if the input is empty or invalid.
func (i *SupplierWhereInput) P() (predicate.Supplier, error) {
	var predicates []predicate.Supplier
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, supplier.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Supplier, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, supplier.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Supplier, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, supplier.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, supplier.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, supplier.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, supplier.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, supplier.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, supplier.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, supplier.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, supplier.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, supplier.IDLTE(*i.IDLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, supplier.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, supplier.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, supplier.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, supplier.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, supplier.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, supplier.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, supplier.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, supplier.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, supplier.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, supplier.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, supplier.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, supplier.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, supplier.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, supplier.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, supplier.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, supplier.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.DeletedAt != nil {
		predicates = append(predicates, supplier.DeletedAtEQ(*i.DeletedAt))
	}
	if i.DeletedAtNEQ != nil {
		predicates = append(predicates, supplier.DeletedAtNEQ(*i.DeletedAtNEQ))
	}
	if len(i.DeletedAtIn) > 0 {
		predicates = append(predicates, supplier.DeletedAtIn(i.DeletedAtIn...))
	}
	if len(i.DeletedAtNotIn) > 0 {
		predicates = append(predicates, supplier.DeletedAtNotIn(i.DeletedAtNotIn...))
	}
	if i.DeletedAtGT != nil {
		predicates = append(predicates, supplier.DeletedAtGT(*i.DeletedAtGT))
	}
	if i.DeletedAtGTE != nil {
		predicates = append(predicates, supplier.DeletedAtGTE(*i.DeletedAtGTE))
	}
	if i.DeletedAtLT != nil {
		predicates = append(predicates, supplier.DeletedAtLT(*i.DeletedAtLT))
	}
	if i.DeletedAtLTE != nil {
		predicates = append(predicates, supplier.DeletedAtLTE(*i.DeletedAtLTE))
	}
	if i.DeletedAtIsNil {
		predicates = append(predicates, supplier.DeletedAtIsNil())
	}
	if i.DeletedAtNotNil {
		predicates = append(predicates, supplier.DeletedAtNotNil())
	}
	if i.Address != nil {
		predicates = append(predicates, supplier.AddressEQ(*i.Address))
	}
	if i.AddressNEQ != nil {
		predicates = append(predicates, supplier.AddressNEQ(*i.AddressNEQ))
	}
	if len(i.AddressIn) > 0 {
		predicates = append(predicates, supplier.AddressIn(i.AddressIn...))
	}
	if len(i.AddressNotIn) > 0 {
		predicates = append(predicates, supplier.AddressNotIn(i.AddressNotIn...))
	}
	if i.AddressGT != nil {
		predicates = append(predicates, supplier.AddressGT(*i.AddressGT))
	}
	if i.AddressGTE != nil {
		predicates = append(predicates, supplier.AddressGTE(*i.AddressGTE))
	}
	if i.AddressLT != nil {
		predicates = append(predicates, supplier.AddressLT(*i.AddressLT))
	}
	if i.AddressLTE != nil {
		predicates = append(predicates, supplier.AddressLTE(*i.AddressLTE))
	}
	if i.AddressContains != nil {
		predicates = append(predicates, supplier.AddressContains(*i.AddressContains))
	}
	if i.AddressHasPrefix != nil {
		predicates = append(predicates, supplier.AddressHasPrefix(*i.AddressHasPrefix))
	}
	if i.AddressHasSuffix != nil {
		predicates = append(predicates, supplier.AddressHasSuffix(*i.AddressHasSuffix))
	}
	if i.AddressEqualFold != nil {
		predicates = append(predicates, supplier.AddressEqualFold(*i.AddressEqualFold))
	}
	if i.AddressContainsFold != nil {
		predicates = append(predicates, supplier.AddressContainsFold(*i.AddressContainsFold))
	}
	if i.City != nil {
		predicates = append(predicates, supplier.CityEQ(*i.City))
	}
	if i.CityNEQ != nil {
		predicates = append(predicates, supplier.CityNEQ(*i.CityNEQ))
	}
	if len(i.CityIn) > 0 {
		predicates = append(predicates, supplier.CityIn(i.CityIn...))
	}
	if len(i.CityNotIn) > 0 {
		predicates = append(predicates, supplier.CityNotIn(i.CityNotIn...))
	}
	if i.CityGT != nil {
		predicates = append(predicates, supplier.CityGT(*i.CityGT))
	}
	if i.CityGTE != nil {
		predicates = append(predicates, supplier.CityGTE(*i.CityGTE))
	}
	if i.CityLT != nil {
		predicates = append(predicates, supplier.CityLT(*i.CityLT))
	}
	if i.CityLTE != nil {
		predicates = append(predicates, supplier.CityLTE(*i.CityLTE))
	}
	if i.CityContains != nil {
		predicates = append(predicates, supplier.CityContains(*i.CityContains))
	}
	if i.CityHasPrefix != nil {
		predicates = append(predicates, supplier.CityHasPrefix(*i.CityHasPrefix))
	}
	if i.CityHasSuffix != nil {
		predicates = append(predicates, supplier.CityHasSuffix(*i.CityHasSuffix))
	}
	if i.CityEqualFold != nil {
		predicates = append(predicates, supplier.CityEqualFold(*i.CityEqualFold))
	}
	if i.CityContainsFold != nil {
		predicates = append(predicates, supplier.CityContainsFold(*i.CityContainsFold))
	}
	if i.Country != nil {
		predicates = append(predicates, supplier.CountryEQ(*i.Country))
	}
	if i.CountryNEQ != nil {
		predicates = append(predicates, supplier.CountryNEQ(*i.CountryNEQ))
	}
	if len(i.CountryIn) > 0 {
		predicates = append(predicates, supplier.CountryIn(i.CountryIn...))
	}
	if len(i.CountryNotIn) > 0 {
		predicates = append(predicates, supplier.CountryNotIn(i.CountryNotIn...))
	}
	if i.CountryGT != nil {
		predicates = append(predicates, supplier.CountryGT(*i.CountryGT))
	}
	if i.CountryGTE != nil {
		predicates = append(predicates, supplier.CountryGTE(*i.CountryGTE))
	}
	if i.CountryLT != nil {
		predicates = append(predicates, supplier.CountryLT(*i.CountryLT))
	}
	if i.CountryLTE != nil {
		predicates = append(predicates, supplier.CountryLTE(*i.CountryLTE))
	}
	if i.CountryContains != nil {
		predicates = append(predicates, supplier.CountryContains(*i.CountryContains))
	}
	if i.CountryHasPrefix != nil {
		predicates = append(predicates, supplier.CountryHasPrefix(*i.CountryHasPrefix))
	}
	if i.CountryHasSuffix != nil {
		predicates = append(predicates, supplier.CountryHasSuffix(*i.CountryHasSuffix))
	}
	if i.CountryEqualFold != nil {
		predicates = append(predicates, supplier.CountryEqualFold(*i.CountryEqualFold))
	}
	if i.CountryContainsFold != nil {
		predicates = append(predicates, supplier.CountryContainsFold(*i.CountryContainsFold))
	}
	if i.Description != nil {
		predicates = append(predicates, supplier.DescriptionEQ(*i.Description))
	}
	if i.DescriptionNEQ != nil {
		predicates = append(predicates, supplier.DescriptionNEQ(*i.DescriptionNEQ))
	}
	if len(i.DescriptionIn) > 0 {
		predicates = append(predicates, supplier.DescriptionIn(i.DescriptionIn...))
	}
	if len(i.DescriptionNotIn) > 0 {
		predicates = append(predicates, supplier.DescriptionNotIn(i.DescriptionNotIn...))
	}
	if i.DescriptionGT != nil {
		predicates = append(predicates, supplier.DescriptionGT(*i.DescriptionGT))
	}
	if i.DescriptionGTE != nil {
		predicates = append(predicates, supplier.DescriptionGTE(*i.DescriptionGTE))
	}
	if i.DescriptionLT != nil {
		predicates = append(predicates, supplier.DescriptionLT(*i.DescriptionLT))
	}
	if i.DescriptionLTE != nil {
		predicates = append(predicates, supplier.DescriptionLTE(*i.DescriptionLTE))
	}
	if i.DescriptionContains != nil {
		predicates = append(predicates, supplier.DescriptionContains(*i.DescriptionContains))
	}
	if i.DescriptionHasPrefix != nil {
		predicates = append(predicates, supplier.DescriptionHasPrefix(*i.DescriptionHasPrefix))
	}
	if i.DescriptionHasSuffix != nil {
		predicates = append(predicates, supplier.DescriptionHasSuffix(*i.DescriptionHasSuffix))
	}
	if i.DescriptionEqualFold != nil {
		predicates = append(predicates, supplier.DescriptionEqualFold(*i.DescriptionEqualFold))
	}
	if i.DescriptionContainsFold != nil {
		predicates = append(predicates, supplier.DescriptionContainsFold(*i.DescriptionContainsFold))
	}
	if i.Email != nil {
		predicates = append(predicates, supplier.EmailEQ(*i.Email))
	}
	if i.EmailNEQ != nil {
		predicates = append(predicates, supplier.EmailNEQ(*i.EmailNEQ))
	}
	if len(i.EmailIn) > 0 {
		predicates = append(predicates, supplier.EmailIn(i.EmailIn...))
	}
	if len(i.EmailNotIn) > 0 {
		predicates = append(predicates, supplier.EmailNotIn(i.EmailNotIn...))
	}
	if i.EmailGT != nil {
		predicates = append(predicates, supplier.EmailGT(*i.EmailGT))
	}
	if i.EmailGTE != nil {
		predicates = append(predicates, supplier.EmailGTE(*i.EmailGTE))
	}
	if i.EmailLT != nil {
		predicates = append(predicates, supplier.EmailLT(*i.EmailLT))
	}
	if i.EmailLTE != nil {
		predicates = append(predicates, supplier.EmailLTE(*i.EmailLTE))
	}
	if i.EmailContains != nil {
		predicates = append(predicates, supplier.EmailContains(*i.EmailContains))
	}
	if i.EmailHasPrefix != nil {
		predicates = append(predicates, supplier.EmailHasPrefix(*i.EmailHasPrefix))
	}
	if i.EmailHasSuffix != nil {
		predicates = append(predicates, supplier.EmailHasSuffix(*i.EmailHasSuffix))
	}
	if i.EmailEqualFold != nil {
		predicates = append(predicates, supplier.EmailEqualFold(*i.EmailEqualFold))
	}
	if i.EmailContainsFold != nil {
		predicates = append(predicates, supplier.EmailContainsFold(*i.EmailContainsFold))
	}
	if i.IsDefault != nil {
		predicates = append(predicates, supplier.IsDefaultEQ(*i.IsDefault))
	}
	if i.IsDefaultNEQ != nil {
		predicates = append(predicates, supplier.IsDefaultNEQ(*i.IsDefaultNEQ))
	}
	if i.IsDefaultIsNil {
		predicates = append(predicates, supplier.IsDefaultIsNil())
	}
	if i.IsDefaultNotNil {
		predicates = append(predicates, supplier.IsDefaultNotNil())
	}
	if i.Name != nil {
		predicates = append(predicates, supplier.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, supplier.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, supplier.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, supplier.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, supplier.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, supplier.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, supplier.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, supplier.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, supplier.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, supplier.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, supplier.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, supplier.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, supplier.NameContainsFold(*i.NameContainsFold))
	}
	if i.Phone != nil {
		predicates = append(predicates, supplier.PhoneEQ(*i.Phone))
	}
	if i.PhoneNEQ != nil {
		predicates = append(predicates, supplier.PhoneNEQ(*i.PhoneNEQ))
	}
	if len(i.PhoneIn) > 0 {
		predicates = append(predicates, supplier.PhoneIn(i.PhoneIn...))
	}
	if len(i.PhoneNotIn) > 0 {
		predicates = append(predicates, supplier.PhoneNotIn(i.PhoneNotIn...))
	}
	if i.PhoneGT != nil {
		predicates = append(predicates, supplier.PhoneGT(*i.PhoneGT))
	}
	if i.PhoneGTE != nil {
		predicates = append(predicates, supplier.PhoneGTE(*i.PhoneGTE))
	}
	if i.PhoneLT != nil {
		predicates = append(predicates, supplier.PhoneLT(*i.PhoneLT))
	}
	if i.PhoneLTE != nil {
		predicates = append(predicates, supplier.PhoneLTE(*i.PhoneLTE))
	}
	if i.PhoneContains != nil {
		predicates = append(predicates, supplier.PhoneContains(*i.PhoneContains))
	}
	if i.PhoneHasPrefix != nil {
		predicates = append(predicates, supplier.PhoneHasPrefix(*i.PhoneHasPrefix))
	}
	if i.PhoneHasSuffix != nil {
		predicates = append(predicates, supplier.PhoneHasSuffix(*i.PhoneHasSuffix))
	}
	if i.PhoneEqualFold != nil {
		predicates = append(predicates, supplier.PhoneEqualFold(*i.PhoneEqualFold))
	}
	if i.PhoneContainsFold != nil {
		predicates = append(predicates, supplier.PhoneContainsFold(*i.PhoneContainsFold))
	}
	if i.TaxId != nil {
		predicates = append(predicates, supplier.TaxIdEQ(*i.TaxId))
	}
	if i.TaxIdNEQ != nil {
		predicates = append(predicates, supplier.TaxIdNEQ(*i.TaxIdNEQ))
	}
	if len(i.TaxIdIn) > 0 {
		predicates = append(predicates, supplier.TaxIdIn(i.TaxIdIn...))
	}
	if len(i.TaxIdNotIn) > 0 {
		predicates = append(predicates, supplier.TaxIdNotIn(i.TaxIdNotIn...))
	}
	if i.TaxIdGT != nil {
		predicates = append(predicates, supplier.TaxIdGT(*i.TaxIdGT))
	}
	if i.TaxIdGTE != nil {
		predicates = append(predicates, supplier.TaxIdGTE(*i.TaxIdGTE))
	}
	if i.TaxIdLT != nil {
		predicates = append(predicates, supplier.TaxIdLT(*i.TaxIdLT))
	}
	if i.TaxIdLTE != nil {
		predicates = append(predicates, supplier.TaxIdLTE(*i.TaxIdLTE))
	}
	if i.TaxIdContains != nil {
		predicates = append(predicates, supplier.TaxIdContains(*i.TaxIdContains))
	}
	if i.TaxIdHasPrefix != nil {
		predicates = append(predicates, supplier.TaxIdHasPrefix(*i.TaxIdHasPrefix))
	}
	if i.TaxIdHasSuffix != nil {
		predicates = append(predicates, supplier.TaxIdHasSuffix(*i.TaxIdHasSuffix))
	}
	if i.TaxIdEqualFold != nil {
		predicates = append(predicates, supplier.TaxIdEqualFold(*i.TaxIdEqualFold))
	}
	if i.TaxIdContainsFold != nil {
		predicates = append(predicates, supplier.TaxIdContainsFold(*i.TaxIdContainsFold))
	}

	if i.HasCompany != nil {
		p := supplier.HasCompany()
		if !*i.HasCompany {
			p = supplier.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasCompanyWith) > 0 {
		with := make([]predicate.Company, 0, len(i.HasCompanyWith))
		for _, w := range i.HasCompanyWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasCompanyWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, supplier.HasCompanyWith(with...))
	}
	if i.HasPayables != nil {
		p := supplier.HasPayables()
		if !*i.HasPayables {
			p = supplier.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasPayablesWith) > 0 {
		with := make([]predicate.Payable, 0, len(i.HasPayablesWith))
		for _, w := range i.HasPayablesWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasPayablesWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, supplier.HasPayablesWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptySupplierWhereInput
	case 1:
		return predicates[0], nil
	default:
		return supplier.And(predicates...), nil
	}
}

// TokenWhereInput represents a where input for filtering Token queries.
type TokenWhereInput struct {
	Predicates []predicate.Token  `json:"-"`
	Not        *TokenWhereInput   `json:"not,omitempty"`
	Or         []*TokenWhereInput `json:"or,omitempty"`
	And        []*TokenWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "expiry" field predicates.
	Expiry      *time.Time  `json:"expiry,omitempty"`
	ExpiryNEQ   *time.Time  `json:"expiryNEQ,omitempty"`
	ExpiryIn    []time.Time `json:"expiryIn,omitempty"`
	ExpiryNotIn []time.Time `json:"expiryNotIn,omitempty"`
	ExpiryGT    *time.Time  `json:"expiryGT,omitempty"`
	ExpiryGTE   *time.Time  `json:"expiryGTE,omitempty"`
	ExpiryLT    *time.Time  `json:"expiryLT,omitempty"`
	ExpiryLTE   *time.Time  `json:"expiryLTE,omitempty"`

	// "category" field predicates.
	Category      *token.Category  `json:"category,omitempty"`
	CategoryNEQ   *token.Category  `json:"categoryNEQ,omitempty"`
	CategoryIn    []token.Category `json:"categoryIn,omitempty"`
	CategoryNotIn []token.Category `json:"categoryNotIn,omitempty"`

	// "token" field predicates.
	Token             *string  `json:"token,omitempty"`
	TokenNEQ          *string  `json:"tokenNEQ,omitempty"`
	TokenIn           []string `json:"tokenIn,omitempty"`
	TokenNotIn        []string `json:"tokenNotIn,omitempty"`
	TokenGT           *string  `json:"tokenGT,omitempty"`
	TokenGTE          *string  `json:"tokenGTE,omitempty"`
	TokenLT           *string  `json:"tokenLT,omitempty"`
	TokenLTE          *string  `json:"tokenLTE,omitempty"`
	TokenContains     *string  `json:"tokenContains,omitempty"`
	TokenHasPrefix    *string  `json:"tokenHasPrefix,omitempty"`
	TokenHasSuffix    *string  `json:"tokenHasSuffix,omitempty"`
	TokenEqualFold    *string  `json:"tokenEqualFold,omitempty"`
	TokenContainsFold *string  `json:"tokenContainsFold,omitempty"`

	// "company" edge predicates.
	HasCompany     *bool                `json:"hasCompany,omitempty"`
	HasCompanyWith []*CompanyWhereInput `json:"hasCompanyWith,omitempty"`

	// "user" edge predicates.
	HasUser     *bool             `json:"hasUser,omitempty"`
	HasUserWith []*UserWhereInput `json:"hasUserWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *TokenWhereInput) AddPredicates(predicates ...predicate.Token) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the TokenWhereInput filter on the TokenQuery builder.
func (i *TokenWhereInput) Filter(q *TokenQuery) (*TokenQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyTokenWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyTokenWhereInput is returned in case the TokenWhereInput is empty.
var ErrEmptyTokenWhereInput = errors.New("generated: empty predicate TokenWhereInput")

// P returns a predicate for filtering tokens.
// An error is returned if the input is empty or invalid.
func (i *TokenWhereInput) P() (predicate.Token, error) {
	var predicates []predicate.Token
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, token.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Token, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, token.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Token, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, token.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, token.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, token.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, token.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, token.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, token.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, token.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, token.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, token.IDLTE(*i.IDLTE))
	}
	if i.Expiry != nil {
		predicates = append(predicates, token.ExpiryEQ(*i.Expiry))
	}
	if i.ExpiryNEQ != nil {
		predicates = append(predicates, token.ExpiryNEQ(*i.ExpiryNEQ))
	}
	if len(i.ExpiryIn) > 0 {
		predicates = append(predicates, token.ExpiryIn(i.ExpiryIn...))
	}
	if len(i.ExpiryNotIn) > 0 {
		predicates = append(predicates, token.ExpiryNotIn(i.ExpiryNotIn...))
	}
	if i.ExpiryGT != nil {
		predicates = append(predicates, token.ExpiryGT(*i.ExpiryGT))
	}
	if i.ExpiryGTE != nil {
		predicates = append(predicates, token.ExpiryGTE(*i.ExpiryGTE))
	}
	if i.ExpiryLT != nil {
		predicates = append(predicates, token.ExpiryLT(*i.ExpiryLT))
	}
	if i.ExpiryLTE != nil {
		predicates = append(predicates, token.ExpiryLTE(*i.ExpiryLTE))
	}
	if i.Category != nil {
		predicates = append(predicates, token.CategoryEQ(*i.Category))
	}
	if i.CategoryNEQ != nil {
		predicates = append(predicates, token.CategoryNEQ(*i.CategoryNEQ))
	}
	if len(i.CategoryIn) > 0 {
		predicates = append(predicates, token.CategoryIn(i.CategoryIn...))
	}
	if len(i.CategoryNotIn) > 0 {
		predicates = append(predicates, token.CategoryNotIn(i.CategoryNotIn...))
	}
	if i.Token != nil {
		predicates = append(predicates, token.TokenEQ(*i.Token))
	}
	if i.TokenNEQ != nil {
		predicates = append(predicates, token.TokenNEQ(*i.TokenNEQ))
	}
	if len(i.TokenIn) > 0 {
		predicates = append(predicates, token.TokenIn(i.TokenIn...))
	}
	if len(i.TokenNotIn) > 0 {
		predicates = append(predicates, token.TokenNotIn(i.TokenNotIn...))
	}
	if i.TokenGT != nil {
		predicates = append(predicates, token.TokenGT(*i.TokenGT))
	}
	if i.TokenGTE != nil {
		predicates = append(predicates, token.TokenGTE(*i.TokenGTE))
	}
	if i.TokenLT != nil {
		predicates = append(predicates, token.TokenLT(*i.TokenLT))
	}
	if i.TokenLTE != nil {
		predicates = append(predicates, token.TokenLTE(*i.TokenLTE))
	}
	if i.TokenContains != nil {
		predicates = append(predicates, token.TokenContains(*i.TokenContains))
	}
	if i.TokenHasPrefix != nil {
		predicates = append(predicates, token.TokenHasPrefix(*i.TokenHasPrefix))
	}
	if i.TokenHasSuffix != nil {
		predicates = append(predicates, token.TokenHasSuffix(*i.TokenHasSuffix))
	}
	if i.TokenEqualFold != nil {
		predicates = append(predicates, token.TokenEqualFold(*i.TokenEqualFold))
	}
	if i.TokenContainsFold != nil {
		predicates = append(predicates, token.TokenContainsFold(*i.TokenContainsFold))
	}

	if i.HasCompany != nil {
		p := token.HasCompany()
		if !*i.HasCompany {
			p = token.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasCompanyWith) > 0 {
		with := make([]predicate.Company, 0, len(i.HasCompanyWith))
		for _, w := range i.HasCompanyWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasCompanyWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, token.HasCompanyWith(with...))
	}
	if i.HasUser != nil {
		p := token.HasUser()
		if !*i.HasUser {
			p = token.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasUserWith) > 0 {
		with := make([]predicate.User, 0, len(i.HasUserWith))
		for _, w := range i.HasUserWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasUserWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, token.HasUserWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyTokenWhereInput
	case 1:
		return predicates[0], nil
	default:
		return token.And(predicates...), nil
	}
}

// TreasuryWhereInput represents a where input for filtering Treasury queries.
type TreasuryWhereInput struct {
	Predicates []predicate.Treasury  `json:"-"`
	Not        *TreasuryWhereInput   `json:"not,omitempty"`
	Or         []*TreasuryWhereInput `json:"or,omitempty"`
	And        []*TreasuryWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "createdAt" field predicates.
	CreatedAt      *time.Time  `json:"createdat,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdatNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdatIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdatNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdatGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdatGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdatLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdatLTE,omitempty"`

	// "updatedAt" field predicates.
	UpdatedAt      *time.Time  `json:"updatedat,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedatNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedatIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedatNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedatGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedatGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedatLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedatLTE,omitempty"`

	// "deletedAt" field predicates.
	DeletedAt       *time.Time  `json:"deletedat,omitempty"`
	DeletedAtNEQ    *time.Time  `json:"deletedatNEQ,omitempty"`
	DeletedAtIn     []time.Time `json:"deletedatIn,omitempty"`
	DeletedAtNotIn  []time.Time `json:"deletedatNotIn,omitempty"`
	DeletedAtGT     *time.Time  `json:"deletedatGT,omitempty"`
	DeletedAtGTE    *time.Time  `json:"deletedatGTE,omitempty"`
	DeletedAtLT     *time.Time  `json:"deletedatLT,omitempty"`
	DeletedAtLTE    *time.Time  `json:"deletedatLTE,omitempty"`
	DeletedAtIsNil  bool        `json:"deletedatIsNil,omitempty"`
	DeletedAtNotNil bool        `json:"deletedatNotNil,omitempty"`

	// "balance" field predicates.
	Balance      *float64  `json:"balance,omitempty"`
	BalanceNEQ   *float64  `json:"balanceNEQ,omitempty"`
	BalanceIn    []float64 `json:"balanceIn,omitempty"`
	BalanceNotIn []float64 `json:"balanceNotIn,omitempty"`
	BalanceGT    *float64  `json:"balanceGT,omitempty"`
	BalanceGTE   *float64  `json:"balanceGTE,omitempty"`
	BalanceLT    *float64  `json:"balanceLT,omitempty"`
	BalanceLTE   *float64  `json:"balanceLTE,omitempty"`

	// "company" edge predicates.
	HasCompany     *bool                `json:"hasCompany,omitempty"`
	HasCompanyWith []*CompanyWhereInput `json:"hasCompanyWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *TreasuryWhereInput) AddPredicates(predicates ...predicate.Treasury) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the TreasuryWhereInput filter on the TreasuryQuery builder.
func (i *TreasuryWhereInput) Filter(q *TreasuryQuery) (*TreasuryQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyTreasuryWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyTreasuryWhereInput is returned in case the TreasuryWhereInput is empty.
var ErrEmptyTreasuryWhereInput = errors.New("generated: empty predicate TreasuryWhereInput")

// P returns a predicate for filtering treasuries.
// An error is returned if the input is empty or invalid.
func (i *TreasuryWhereInput) P() (predicate.Treasury, error) {
	var predicates []predicate.Treasury
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, treasury.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Treasury, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, treasury.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Treasury, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, treasury.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, treasury.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, treasury.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, treasury.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, treasury.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, treasury.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, treasury.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, treasury.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, treasury.IDLTE(*i.IDLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, treasury.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, treasury.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, treasury.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, treasury.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, treasury.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, treasury.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, treasury.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, treasury.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, treasury.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, treasury.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, treasury.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, treasury.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, treasury.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, treasury.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, treasury.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, treasury.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.DeletedAt != nil {
		predicates = append(predicates, treasury.DeletedAtEQ(*i.DeletedAt))
	}
	if i.DeletedAtNEQ != nil {
		predicates = append(predicates, treasury.DeletedAtNEQ(*i.DeletedAtNEQ))
	}
	if len(i.DeletedAtIn) > 0 {
		predicates = append(predicates, treasury.DeletedAtIn(i.DeletedAtIn...))
	}
	if len(i.DeletedAtNotIn) > 0 {
		predicates = append(predicates, treasury.DeletedAtNotIn(i.DeletedAtNotIn...))
	}
	if i.DeletedAtGT != nil {
		predicates = append(predicates, treasury.DeletedAtGT(*i.DeletedAtGT))
	}
	if i.DeletedAtGTE != nil {
		predicates = append(predicates, treasury.DeletedAtGTE(*i.DeletedAtGTE))
	}
	if i.DeletedAtLT != nil {
		predicates = append(predicates, treasury.DeletedAtLT(*i.DeletedAtLT))
	}
	if i.DeletedAtLTE != nil {
		predicates = append(predicates, treasury.DeletedAtLTE(*i.DeletedAtLTE))
	}
	if i.DeletedAtIsNil {
		predicates = append(predicates, treasury.DeletedAtIsNil())
	}
	if i.DeletedAtNotNil {
		predicates = append(predicates, treasury.DeletedAtNotNil())
	}
	if i.Balance != nil {
		predicates = append(predicates, treasury.BalanceEQ(*i.Balance))
	}
	if i.BalanceNEQ != nil {
		predicates = append(predicates, treasury.BalanceNEQ(*i.BalanceNEQ))
	}
	if len(i.BalanceIn) > 0 {
		predicates = append(predicates, treasury.BalanceIn(i.BalanceIn...))
	}
	if len(i.BalanceNotIn) > 0 {
		predicates = append(predicates, treasury.BalanceNotIn(i.BalanceNotIn...))
	}
	if i.BalanceGT != nil {
		predicates = append(predicates, treasury.BalanceGT(*i.BalanceGT))
	}
	if i.BalanceGTE != nil {
		predicates = append(predicates, treasury.BalanceGTE(*i.BalanceGTE))
	}
	if i.BalanceLT != nil {
		predicates = append(predicates, treasury.BalanceLT(*i.BalanceLT))
	}
	if i.BalanceLTE != nil {
		predicates = append(predicates, treasury.BalanceLTE(*i.BalanceLTE))
	}

	if i.HasCompany != nil {
		p := treasury.HasCompany()
		if !*i.HasCompany {
			p = treasury.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasCompanyWith) > 0 {
		with := make([]predicate.Company, 0, len(i.HasCompanyWith))
		for _, w := range i.HasCompanyWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasCompanyWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, treasury.HasCompanyWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyTreasuryWhereInput
	case 1:
		return predicates[0], nil
	default:
		return treasury.And(predicates...), nil
	}
}

// UserWhereInput represents a where input for filtering User queries.
type UserWhereInput struct {
	Predicates []predicate.User  `json:"-"`
	Not        *UserWhereInput   `json:"not,omitempty"`
	Or         []*UserWhereInput `json:"or,omitempty"`
	And        []*UserWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "createdAt" field predicates.
	CreatedAt      *time.Time  `json:"createdat,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdatNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdatIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdatNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdatGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdatGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdatLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdatLTE,omitempty"`

	// "updatedAt" field predicates.
	UpdatedAt      *time.Time  `json:"updatedat,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedatNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedatIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedatNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedatGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedatGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedatLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedatLTE,omitempty"`

	// "deletedAt" field predicates.
	DeletedAt       *time.Time  `json:"deletedat,omitempty"`
	DeletedAtNEQ    *time.Time  `json:"deletedatNEQ,omitempty"`
	DeletedAtIn     []time.Time `json:"deletedatIn,omitempty"`
	DeletedAtNotIn  []time.Time `json:"deletedatNotIn,omitempty"`
	DeletedAtGT     *time.Time  `json:"deletedatGT,omitempty"`
	DeletedAtGTE    *time.Time  `json:"deletedatGTE,omitempty"`
	DeletedAtLT     *time.Time  `json:"deletedatLT,omitempty"`
	DeletedAtLTE    *time.Time  `json:"deletedatLTE,omitempty"`
	DeletedAtIsNil  bool        `json:"deletedatIsNil,omitempty"`
	DeletedAtNotNil bool        `json:"deletedatNotNil,omitempty"`

	// "firebaseUID" field predicates.
	FirebaseUID             *string  `json:"firebaseuid,omitempty"`
	FirebaseUIDNEQ          *string  `json:"firebaseuidNEQ,omitempty"`
	FirebaseUIDIn           []string `json:"firebaseuidIn,omitempty"`
	FirebaseUIDNotIn        []string `json:"firebaseuidNotIn,omitempty"`
	FirebaseUIDGT           *string  `json:"firebaseuidGT,omitempty"`
	FirebaseUIDGTE          *string  `json:"firebaseuidGTE,omitempty"`
	FirebaseUIDLT           *string  `json:"firebaseuidLT,omitempty"`
	FirebaseUIDLTE          *string  `json:"firebaseuidLTE,omitempty"`
	FirebaseUIDContains     *string  `json:"firebaseuidContains,omitempty"`
	FirebaseUIDHasPrefix    *string  `json:"firebaseuidHasPrefix,omitempty"`
	FirebaseUIDHasSuffix    *string  `json:"firebaseuidHasSuffix,omitempty"`
	FirebaseUIDEqualFold    *string  `json:"firebaseuidEqualFold,omitempty"`
	FirebaseUIDContainsFold *string  `json:"firebaseuidContainsFold,omitempty"`

	// "fcmToken" field predicates.
	FcmToken             *string  `json:"fcmtoken,omitempty"`
	FcmTokenNEQ          *string  `json:"fcmtokenNEQ,omitempty"`
	FcmTokenIn           []string `json:"fcmtokenIn,omitempty"`
	FcmTokenNotIn        []string `json:"fcmtokenNotIn,omitempty"`
	FcmTokenGT           *string  `json:"fcmtokenGT,omitempty"`
	FcmTokenGTE          *string  `json:"fcmtokenGTE,omitempty"`
	FcmTokenLT           *string  `json:"fcmtokenLT,omitempty"`
	FcmTokenLTE          *string  `json:"fcmtokenLTE,omitempty"`
	FcmTokenContains     *string  `json:"fcmtokenContains,omitempty"`
	FcmTokenHasPrefix    *string  `json:"fcmtokenHasPrefix,omitempty"`
	FcmTokenHasSuffix    *string  `json:"fcmtokenHasSuffix,omitempty"`
	FcmTokenIsNil        bool     `json:"fcmtokenIsNil,omitempty"`
	FcmTokenNotNil       bool     `json:"fcmtokenNotNil,omitempty"`
	FcmTokenEqualFold    *string  `json:"fcmtokenEqualFold,omitempty"`
	FcmTokenContainsFold *string  `json:"fcmtokenContainsFold,omitempty"`

	// "email" field predicates.
	Email             *string  `json:"email,omitempty"`
	EmailNEQ          *string  `json:"emailNEQ,omitempty"`
	EmailIn           []string `json:"emailIn,omitempty"`
	EmailNotIn        []string `json:"emailNotIn,omitempty"`
	EmailGT           *string  `json:"emailGT,omitempty"`
	EmailGTE          *string  `json:"emailGTE,omitempty"`
	EmailLT           *string  `json:"emailLT,omitempty"`
	EmailLTE          *string  `json:"emailLTE,omitempty"`
	EmailContains     *string  `json:"emailContains,omitempty"`
	EmailHasPrefix    *string  `json:"emailHasPrefix,omitempty"`
	EmailHasSuffix    *string  `json:"emailHasSuffix,omitempty"`
	EmailEqualFold    *string  `json:"emailEqualFold,omitempty"`
	EmailContainsFold *string  `json:"emailContainsFold,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "address" field predicates.
	Address             *string  `json:"address,omitempty"`
	AddressNEQ          *string  `json:"addressNEQ,omitempty"`
	AddressIn           []string `json:"addressIn,omitempty"`
	AddressNotIn        []string `json:"addressNotIn,omitempty"`
	AddressGT           *string  `json:"addressGT,omitempty"`
	AddressGTE          *string  `json:"addressGTE,omitempty"`
	AddressLT           *string  `json:"addressLT,omitempty"`
	AddressLTE          *string  `json:"addressLTE,omitempty"`
	AddressContains     *string  `json:"addressContains,omitempty"`
	AddressHasPrefix    *string  `json:"addressHasPrefix,omitempty"`
	AddressHasSuffix    *string  `json:"addressHasSuffix,omitempty"`
	AddressIsNil        bool     `json:"addressIsNil,omitempty"`
	AddressNotNil       bool     `json:"addressNotNil,omitempty"`
	AddressEqualFold    *string  `json:"addressEqualFold,omitempty"`
	AddressContainsFold *string  `json:"addressContainsFold,omitempty"`

	// "avatar" field predicates.
	Avatar             *string  `json:"avatar,omitempty"`
	AvatarNEQ          *string  `json:"avatarNEQ,omitempty"`
	AvatarIn           []string `json:"avatarIn,omitempty"`
	AvatarNotIn        []string `json:"avatarNotIn,omitempty"`
	AvatarGT           *string  `json:"avatarGT,omitempty"`
	AvatarGTE          *string  `json:"avatarGTE,omitempty"`
	AvatarLT           *string  `json:"avatarLT,omitempty"`
	AvatarLTE          *string  `json:"avatarLTE,omitempty"`
	AvatarContains     *string  `json:"avatarContains,omitempty"`
	AvatarHasPrefix    *string  `json:"avatarHasPrefix,omitempty"`
	AvatarHasSuffix    *string  `json:"avatarHasSuffix,omitempty"`
	AvatarIsNil        bool     `json:"avatarIsNil,omitempty"`
	AvatarNotNil       bool     `json:"avatarNotNil,omitempty"`
	AvatarEqualFold    *string  `json:"avatarEqualFold,omitempty"`
	AvatarContainsFold *string  `json:"avatarContainsFold,omitempty"`

	// "photoURL" field predicates.
	PhotoURL             *string  `json:"photourl,omitempty"`
	PhotoURLNEQ          *string  `json:"photourlNEQ,omitempty"`
	PhotoURLIn           []string `json:"photourlIn,omitempty"`
	PhotoURLNotIn        []string `json:"photourlNotIn,omitempty"`
	PhotoURLGT           *string  `json:"photourlGT,omitempty"`
	PhotoURLGTE          *string  `json:"photourlGTE,omitempty"`
	PhotoURLLT           *string  `json:"photourlLT,omitempty"`
	PhotoURLLTE          *string  `json:"photourlLTE,omitempty"`
	PhotoURLContains     *string  `json:"photourlContains,omitempty"`
	PhotoURLHasPrefix    *string  `json:"photourlHasPrefix,omitempty"`
	PhotoURLHasSuffix    *string  `json:"photourlHasSuffix,omitempty"`
	PhotoURLIsNil        bool     `json:"photourlIsNil,omitempty"`
	PhotoURLNotNil       bool     `json:"photourlNotNil,omitempty"`
	PhotoURLEqualFold    *string  `json:"photourlEqualFold,omitempty"`
	PhotoURLContainsFold *string  `json:"photourlContainsFold,omitempty"`

	// "department" field predicates.
	Department             *string  `json:"department,omitempty"`
	DepartmentNEQ          *string  `json:"departmentNEQ,omitempty"`
	DepartmentIn           []string `json:"departmentIn,omitempty"`
	DepartmentNotIn        []string `json:"departmentNotIn,omitempty"`
	DepartmentGT           *string  `json:"departmentGT,omitempty"`
	DepartmentGTE          *string  `json:"departmentGTE,omitempty"`
	DepartmentLT           *string  `json:"departmentLT,omitempty"`
	DepartmentLTE          *string  `json:"departmentLTE,omitempty"`
	DepartmentContains     *string  `json:"departmentContains,omitempty"`
	DepartmentHasPrefix    *string  `json:"departmentHasPrefix,omitempty"`
	DepartmentHasSuffix    *string  `json:"departmentHasSuffix,omitempty"`
	DepartmentIsNil        bool     `json:"departmentIsNil,omitempty"`
	DepartmentNotNil       bool     `json:"departmentNotNil,omitempty"`
	DepartmentEqualFold    *string  `json:"departmentEqualFold,omitempty"`
	DepartmentContainsFold *string  `json:"departmentContainsFold,omitempty"`

	// "phone" field predicates.
	Phone             *string  `json:"phone,omitempty"`
	PhoneNEQ          *string  `json:"phoneNEQ,omitempty"`
	PhoneIn           []string `json:"phoneIn,omitempty"`
	PhoneNotIn        []string `json:"phoneNotIn,omitempty"`
	PhoneGT           *string  `json:"phoneGT,omitempty"`
	PhoneGTE          *string  `json:"phoneGTE,omitempty"`
	PhoneLT           *string  `json:"phoneLT,omitempty"`
	PhoneLTE          *string  `json:"phoneLTE,omitempty"`
	PhoneContains     *string  `json:"phoneContains,omitempty"`
	PhoneHasPrefix    *string  `json:"phoneHasPrefix,omitempty"`
	PhoneHasSuffix    *string  `json:"phoneHasSuffix,omitempty"`
	PhoneIsNil        bool     `json:"phoneIsNil,omitempty"`
	PhoneNotNil       bool     `json:"phoneNotNil,omitempty"`
	PhoneEqualFold    *string  `json:"phoneEqualFold,omitempty"`
	PhoneContainsFold *string  `json:"phoneContainsFold,omitempty"`

	// "birthdate" field predicates.
	Birthdate       *time.Time  `json:"birthdate,omitempty"`
	BirthdateNEQ    *time.Time  `json:"birthdateNEQ,omitempty"`
	BirthdateIn     []time.Time `json:"birthdateIn,omitempty"`
	BirthdateNotIn  []time.Time `json:"birthdateNotIn,omitempty"`
	BirthdateGT     *time.Time  `json:"birthdateGT,omitempty"`
	BirthdateGTE    *time.Time  `json:"birthdateGTE,omitempty"`
	BirthdateLT     *time.Time  `json:"birthdateLT,omitempty"`
	BirthdateLTE    *time.Time  `json:"birthdateLTE,omitempty"`
	BirthdateIsNil  bool        `json:"birthdateIsNil,omitempty"`
	BirthdateNotNil bool        `json:"birthdateNotNil,omitempty"`

	// "lastLogin" field predicates.
	LastLogin       *time.Time  `json:"lastlogin,omitempty"`
	LastLoginNEQ    *time.Time  `json:"lastloginNEQ,omitempty"`
	LastLoginIn     []time.Time `json:"lastloginIn,omitempty"`
	LastLoginNotIn  []time.Time `json:"lastloginNotIn,omitempty"`
	LastLoginGT     *time.Time  `json:"lastloginGT,omitempty"`
	LastLoginGTE    *time.Time  `json:"lastloginGTE,omitempty"`
	LastLoginLT     *time.Time  `json:"lastloginLT,omitempty"`
	LastLoginLTE    *time.Time  `json:"lastloginLTE,omitempty"`
	LastLoginIsNil  bool        `json:"lastloginIsNil,omitempty"`
	LastLoginNotNil bool        `json:"lastloginNotNil,omitempty"`

	// "gender" field predicates.
	Gender      *user.Gender  `json:"gender,omitempty"`
	GenderNEQ   *user.Gender  `json:"genderNEQ,omitempty"`
	GenderIn    []user.Gender `json:"genderIn,omitempty"`
	GenderNotIn []user.Gender `json:"genderNotIn,omitempty"`

	// "active" field predicates.
	Active    *bool `json:"active,omitempty"`
	ActiveNEQ *bool `json:"activeNEQ,omitempty"`

	// "accountingEntries" edge predicates.
	HasAccountingEntries     *bool                        `json:"hasAccountingEntries,omitempty"`
	HasAccountingEntriesWith []*AccountingEntryWhereInput `json:"hasAccountingEntriesWith,omitempty"`

	// "company" edge predicates.
	HasCompany     *bool                `json:"hasCompany,omitempty"`
	HasCompanyWith []*CompanyWhereInput `json:"hasCompanyWith,omitempty"`

	// "assignedRoles" edge predicates.
	HasAssignedRoles     *bool                 `json:"hasAssignedRoles,omitempty"`
	HasAssignedRolesWith []*UserRoleWhereInput `json:"hasAssignedRolesWith,omitempty"`

	// "subordinates" edge predicates.
	HasSubordinates     *bool             `json:"hasSubordinates,omitempty"`
	HasSubordinatesWith []*UserWhereInput `json:"hasSubordinatesWith,omitempty"`

	// "leader" edge predicates.
	HasLeader     *bool             `json:"hasLeader,omitempty"`
	HasLeaderWith []*UserWhereInput `json:"hasLeaderWith,omitempty"`

	// "createdMemberSignupTokens" edge predicates.
	HasCreatedMemberSignupTokens     *bool                          `json:"hasCreatedMemberSignupTokens,omitempty"`
	HasCreatedMemberSignupTokensWith []*MemberSignupTokenWhereInput `json:"hasCreatedMemberSignupTokensWith,omitempty"`

	// "employee" edge predicates.
	HasEmployee     *bool                 `json:"hasEmployee,omitempty"`
	HasEmployeeWith []*EmployeeWhereInput `json:"hasEmployeeWith,omitempty"`

	// "createdProjects" edge predicates.
	HasCreatedProjects     *bool                `json:"hasCreatedProjects,omitempty"`
	HasCreatedProjectsWith []*ProjectWhereInput `json:"hasCreatedProjectsWith,omitempty"`

	// "leaderedProjects" edge predicates.
	HasLeaderedProjects     *bool                `json:"hasLeaderedProjects,omitempty"`
	HasLeaderedProjectsWith []*ProjectWhereInput `json:"hasLeaderedProjectsWith,omitempty"`

	// "assignedProjectTasks" edge predicates.
	HasAssignedProjectTasks     *bool                    `json:"hasAssignedProjectTasks,omitempty"`
	HasAssignedProjectTasksWith []*ProjectTaskWhereInput `json:"hasAssignedProjectTasksWith,omitempty"`

	// "participatedProjectTasks" edge predicates.
	HasParticipatedProjectTasks     *bool                    `json:"hasParticipatedProjectTasks,omitempty"`
	HasParticipatedProjectTasksWith []*ProjectTaskWhereInput `json:"hasParticipatedProjectTasksWith,omitempty"`

	// "createdTasks" edge predicates.
	HasCreatedTasks     *bool                    `json:"hasCreatedTasks,omitempty"`
	HasCreatedTasksWith []*ProjectTaskWhereInput `json:"hasCreatedTasksWith,omitempty"`

	// "tokens" edge predicates.
	HasTokens     *bool              `json:"hasTokens,omitempty"`
	HasTokensWith []*TokenWhereInput `json:"hasTokensWith,omitempty"`

	// "approvedWorkShifts" edge predicates.
	HasApprovedWorkShifts     *bool                  `json:"hasApprovedWorkShifts,omitempty"`
	HasApprovedWorkShiftsWith []*WorkshiftWhereInput `json:"hasApprovedWorkShiftsWith,omitempty"`

	// "workShifts" edge predicates.
	HasWorkShifts     *bool                  `json:"hasWorkShifts,omitempty"`
	HasWorkShiftsWith []*WorkshiftWhereInput `json:"hasWorkShiftsWith,omitempty"`

	// "uploadedDocuments" edge predicates.
	HasUploadedDocuments     *bool                        `json:"hasUploadedDocuments,omitempty"`
	HasUploadedDocumentsWith []*CompanyDocumentWhereInput `json:"hasUploadedDocumentsWith,omitempty"`

	// "approvedDocuments" edge predicates.
	HasApprovedDocuments     *bool                        `json:"hasApprovedDocuments,omitempty"`
	HasApprovedDocumentsWith []*CompanyDocumentWhereInput `json:"hasApprovedDocumentsWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *UserWhereInput) AddPredicates(predicates ...predicate.User) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the UserWhereInput filter on the UserQuery builder.
func (i *UserWhereInput) Filter(q *UserQuery) (*UserQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyUserWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyUserWhereInput is returned in case the UserWhereInput is empty.
var ErrEmptyUserWhereInput = errors.New("generated: empty predicate UserWhereInput")

// P returns a predicate for filtering users.
// An error is returned if the input is empty or invalid.
func (i *UserWhereInput) P() (predicate.User, error) {
	var predicates []predicate.User
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, user.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.User, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, user.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.User, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, user.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, user.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, user.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, user.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, user.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, user.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, user.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, user.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, user.IDLTE(*i.IDLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, user.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, user.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, user.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, user.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, user.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, user.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, user.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, user.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, user.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, user.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, user.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, user.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, user.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, user.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, user.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, user.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.DeletedAt != nil {
		predicates = append(predicates, user.DeletedAtEQ(*i.DeletedAt))
	}
	if i.DeletedAtNEQ != nil {
		predicates = append(predicates, user.DeletedAtNEQ(*i.DeletedAtNEQ))
	}
	if len(i.DeletedAtIn) > 0 {
		predicates = append(predicates, user.DeletedAtIn(i.DeletedAtIn...))
	}
	if len(i.DeletedAtNotIn) > 0 {
		predicates = append(predicates, user.DeletedAtNotIn(i.DeletedAtNotIn...))
	}
	if i.DeletedAtGT != nil {
		predicates = append(predicates, user.DeletedAtGT(*i.DeletedAtGT))
	}
	if i.DeletedAtGTE != nil {
		predicates = append(predicates, user.DeletedAtGTE(*i.DeletedAtGTE))
	}
	if i.DeletedAtLT != nil {
		predicates = append(predicates, user.DeletedAtLT(*i.DeletedAtLT))
	}
	if i.DeletedAtLTE != nil {
		predicates = append(predicates, user.DeletedAtLTE(*i.DeletedAtLTE))
	}
	if i.DeletedAtIsNil {
		predicates = append(predicates, user.DeletedAtIsNil())
	}
	if i.DeletedAtNotNil {
		predicates = append(predicates, user.DeletedAtNotNil())
	}
	if i.FirebaseUID != nil {
		predicates = append(predicates, user.FirebaseUIDEQ(*i.FirebaseUID))
	}
	if i.FirebaseUIDNEQ != nil {
		predicates = append(predicates, user.FirebaseUIDNEQ(*i.FirebaseUIDNEQ))
	}
	if len(i.FirebaseUIDIn) > 0 {
		predicates = append(predicates, user.FirebaseUIDIn(i.FirebaseUIDIn...))
	}
	if len(i.FirebaseUIDNotIn) > 0 {
		predicates = append(predicates, user.FirebaseUIDNotIn(i.FirebaseUIDNotIn...))
	}
	if i.FirebaseUIDGT != nil {
		predicates = append(predicates, user.FirebaseUIDGT(*i.FirebaseUIDGT))
	}
	if i.FirebaseUIDGTE != nil {
		predicates = append(predicates, user.FirebaseUIDGTE(*i.FirebaseUIDGTE))
	}
	if i.FirebaseUIDLT != nil {
		predicates = append(predicates, user.FirebaseUIDLT(*i.FirebaseUIDLT))
	}
	if i.FirebaseUIDLTE != nil {
		predicates = append(predicates, user.FirebaseUIDLTE(*i.FirebaseUIDLTE))
	}
	if i.FirebaseUIDContains != nil {
		predicates = append(predicates, user.FirebaseUIDContains(*i.FirebaseUIDContains))
	}
	if i.FirebaseUIDHasPrefix != nil {
		predicates = append(predicates, user.FirebaseUIDHasPrefix(*i.FirebaseUIDHasPrefix))
	}
	if i.FirebaseUIDHasSuffix != nil {
		predicates = append(predicates, user.FirebaseUIDHasSuffix(*i.FirebaseUIDHasSuffix))
	}
	if i.FirebaseUIDEqualFold != nil {
		predicates = append(predicates, user.FirebaseUIDEqualFold(*i.FirebaseUIDEqualFold))
	}
	if i.FirebaseUIDContainsFold != nil {
		predicates = append(predicates, user.FirebaseUIDContainsFold(*i.FirebaseUIDContainsFold))
	}
	if i.FcmToken != nil {
		predicates = append(predicates, user.FcmTokenEQ(*i.FcmToken))
	}
	if i.FcmTokenNEQ != nil {
		predicates = append(predicates, user.FcmTokenNEQ(*i.FcmTokenNEQ))
	}
	if len(i.FcmTokenIn) > 0 {
		predicates = append(predicates, user.FcmTokenIn(i.FcmTokenIn...))
	}
	if len(i.FcmTokenNotIn) > 0 {
		predicates = append(predicates, user.FcmTokenNotIn(i.FcmTokenNotIn...))
	}
	if i.FcmTokenGT != nil {
		predicates = append(predicates, user.FcmTokenGT(*i.FcmTokenGT))
	}
	if i.FcmTokenGTE != nil {
		predicates = append(predicates, user.FcmTokenGTE(*i.FcmTokenGTE))
	}
	if i.FcmTokenLT != nil {
		predicates = append(predicates, user.FcmTokenLT(*i.FcmTokenLT))
	}
	if i.FcmTokenLTE != nil {
		predicates = append(predicates, user.FcmTokenLTE(*i.FcmTokenLTE))
	}
	if i.FcmTokenContains != nil {
		predicates = append(predicates, user.FcmTokenContains(*i.FcmTokenContains))
	}
	if i.FcmTokenHasPrefix != nil {
		predicates = append(predicates, user.FcmTokenHasPrefix(*i.FcmTokenHasPrefix))
	}
	if i.FcmTokenHasSuffix != nil {
		predicates = append(predicates, user.FcmTokenHasSuffix(*i.FcmTokenHasSuffix))
	}
	if i.FcmTokenIsNil {
		predicates = append(predicates, user.FcmTokenIsNil())
	}
	if i.FcmTokenNotNil {
		predicates = append(predicates, user.FcmTokenNotNil())
	}
	if i.FcmTokenEqualFold != nil {
		predicates = append(predicates, user.FcmTokenEqualFold(*i.FcmTokenEqualFold))
	}
	if i.FcmTokenContainsFold != nil {
		predicates = append(predicates, user.FcmTokenContainsFold(*i.FcmTokenContainsFold))
	}
	if i.Email != nil {
		predicates = append(predicates, user.EmailEQ(*i.Email))
	}
	if i.EmailNEQ != nil {
		predicates = append(predicates, user.EmailNEQ(*i.EmailNEQ))
	}
	if len(i.EmailIn) > 0 {
		predicates = append(predicates, user.EmailIn(i.EmailIn...))
	}
	if len(i.EmailNotIn) > 0 {
		predicates = append(predicates, user.EmailNotIn(i.EmailNotIn...))
	}
	if i.EmailGT != nil {
		predicates = append(predicates, user.EmailGT(*i.EmailGT))
	}
	if i.EmailGTE != nil {
		predicates = append(predicates, user.EmailGTE(*i.EmailGTE))
	}
	if i.EmailLT != nil {
		predicates = append(predicates, user.EmailLT(*i.EmailLT))
	}
	if i.EmailLTE != nil {
		predicates = append(predicates, user.EmailLTE(*i.EmailLTE))
	}
	if i.EmailContains != nil {
		predicates = append(predicates, user.EmailContains(*i.EmailContains))
	}
	if i.EmailHasPrefix != nil {
		predicates = append(predicates, user.EmailHasPrefix(*i.EmailHasPrefix))
	}
	if i.EmailHasSuffix != nil {
		predicates = append(predicates, user.EmailHasSuffix(*i.EmailHasSuffix))
	}
	if i.EmailEqualFold != nil {
		predicates = append(predicates, user.EmailEqualFold(*i.EmailEqualFold))
	}
	if i.EmailContainsFold != nil {
		predicates = append(predicates, user.EmailContainsFold(*i.EmailContainsFold))
	}
	if i.Name != nil {
		predicates = append(predicates, user.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, user.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, user.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, user.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, user.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, user.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, user.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, user.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, user.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, user.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, user.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, user.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, user.NameContainsFold(*i.NameContainsFold))
	}
	if i.Address != nil {
		predicates = append(predicates, user.AddressEQ(*i.Address))
	}
	if i.AddressNEQ != nil {
		predicates = append(predicates, user.AddressNEQ(*i.AddressNEQ))
	}
	if len(i.AddressIn) > 0 {
		predicates = append(predicates, user.AddressIn(i.AddressIn...))
	}
	if len(i.AddressNotIn) > 0 {
		predicates = append(predicates, user.AddressNotIn(i.AddressNotIn...))
	}
	if i.AddressGT != nil {
		predicates = append(predicates, user.AddressGT(*i.AddressGT))
	}
	if i.AddressGTE != nil {
		predicates = append(predicates, user.AddressGTE(*i.AddressGTE))
	}
	if i.AddressLT != nil {
		predicates = append(predicates, user.AddressLT(*i.AddressLT))
	}
	if i.AddressLTE != nil {
		predicates = append(predicates, user.AddressLTE(*i.AddressLTE))
	}
	if i.AddressContains != nil {
		predicates = append(predicates, user.AddressContains(*i.AddressContains))
	}
	if i.AddressHasPrefix != nil {
		predicates = append(predicates, user.AddressHasPrefix(*i.AddressHasPrefix))
	}
	if i.AddressHasSuffix != nil {
		predicates = append(predicates, user.AddressHasSuffix(*i.AddressHasSuffix))
	}
	if i.AddressIsNil {
		predicates = append(predicates, user.AddressIsNil())
	}
	if i.AddressNotNil {
		predicates = append(predicates, user.AddressNotNil())
	}
	if i.AddressEqualFold != nil {
		predicates = append(predicates, user.AddressEqualFold(*i.AddressEqualFold))
	}
	if i.AddressContainsFold != nil {
		predicates = append(predicates, user.AddressContainsFold(*i.AddressContainsFold))
	}
	if i.Avatar != nil {
		predicates = append(predicates, user.AvatarEQ(*i.Avatar))
	}
	if i.AvatarNEQ != nil {
		predicates = append(predicates, user.AvatarNEQ(*i.AvatarNEQ))
	}
	if len(i.AvatarIn) > 0 {
		predicates = append(predicates, user.AvatarIn(i.AvatarIn...))
	}
	if len(i.AvatarNotIn) > 0 {
		predicates = append(predicates, user.AvatarNotIn(i.AvatarNotIn...))
	}
	if i.AvatarGT != nil {
		predicates = append(predicates, user.AvatarGT(*i.AvatarGT))
	}
	if i.AvatarGTE != nil {
		predicates = append(predicates, user.AvatarGTE(*i.AvatarGTE))
	}
	if i.AvatarLT != nil {
		predicates = append(predicates, user.AvatarLT(*i.AvatarLT))
	}
	if i.AvatarLTE != nil {
		predicates = append(predicates, user.AvatarLTE(*i.AvatarLTE))
	}
	if i.AvatarContains != nil {
		predicates = append(predicates, user.AvatarContains(*i.AvatarContains))
	}
	if i.AvatarHasPrefix != nil {
		predicates = append(predicates, user.AvatarHasPrefix(*i.AvatarHasPrefix))
	}
	if i.AvatarHasSuffix != nil {
		predicates = append(predicates, user.AvatarHasSuffix(*i.AvatarHasSuffix))
	}
	if i.AvatarIsNil {
		predicates = append(predicates, user.AvatarIsNil())
	}
	if i.AvatarNotNil {
		predicates = append(predicates, user.AvatarNotNil())
	}
	if i.AvatarEqualFold != nil {
		predicates = append(predicates, user.AvatarEqualFold(*i.AvatarEqualFold))
	}
	if i.AvatarContainsFold != nil {
		predicates = append(predicates, user.AvatarContainsFold(*i.AvatarContainsFold))
	}
	if i.PhotoURL != nil {
		predicates = append(predicates, user.PhotoURLEQ(*i.PhotoURL))
	}
	if i.PhotoURLNEQ != nil {
		predicates = append(predicates, user.PhotoURLNEQ(*i.PhotoURLNEQ))
	}
	if len(i.PhotoURLIn) > 0 {
		predicates = append(predicates, user.PhotoURLIn(i.PhotoURLIn...))
	}
	if len(i.PhotoURLNotIn) > 0 {
		predicates = append(predicates, user.PhotoURLNotIn(i.PhotoURLNotIn...))
	}
	if i.PhotoURLGT != nil {
		predicates = append(predicates, user.PhotoURLGT(*i.PhotoURLGT))
	}
	if i.PhotoURLGTE != nil {
		predicates = append(predicates, user.PhotoURLGTE(*i.PhotoURLGTE))
	}
	if i.PhotoURLLT != nil {
		predicates = append(predicates, user.PhotoURLLT(*i.PhotoURLLT))
	}
	if i.PhotoURLLTE != nil {
		predicates = append(predicates, user.PhotoURLLTE(*i.PhotoURLLTE))
	}
	if i.PhotoURLContains != nil {
		predicates = append(predicates, user.PhotoURLContains(*i.PhotoURLContains))
	}
	if i.PhotoURLHasPrefix != nil {
		predicates = append(predicates, user.PhotoURLHasPrefix(*i.PhotoURLHasPrefix))
	}
	if i.PhotoURLHasSuffix != nil {
		predicates = append(predicates, user.PhotoURLHasSuffix(*i.PhotoURLHasSuffix))
	}
	if i.PhotoURLIsNil {
		predicates = append(predicates, user.PhotoURLIsNil())
	}
	if i.PhotoURLNotNil {
		predicates = append(predicates, user.PhotoURLNotNil())
	}
	if i.PhotoURLEqualFold != nil {
		predicates = append(predicates, user.PhotoURLEqualFold(*i.PhotoURLEqualFold))
	}
	if i.PhotoURLContainsFold != nil {
		predicates = append(predicates, user.PhotoURLContainsFold(*i.PhotoURLContainsFold))
	}
	if i.Department != nil {
		predicates = append(predicates, user.DepartmentEQ(*i.Department))
	}
	if i.DepartmentNEQ != nil {
		predicates = append(predicates, user.DepartmentNEQ(*i.DepartmentNEQ))
	}
	if len(i.DepartmentIn) > 0 {
		predicates = append(predicates, user.DepartmentIn(i.DepartmentIn...))
	}
	if len(i.DepartmentNotIn) > 0 {
		predicates = append(predicates, user.DepartmentNotIn(i.DepartmentNotIn...))
	}
	if i.DepartmentGT != nil {
		predicates = append(predicates, user.DepartmentGT(*i.DepartmentGT))
	}
	if i.DepartmentGTE != nil {
		predicates = append(predicates, user.DepartmentGTE(*i.DepartmentGTE))
	}
	if i.DepartmentLT != nil {
		predicates = append(predicates, user.DepartmentLT(*i.DepartmentLT))
	}
	if i.DepartmentLTE != nil {
		predicates = append(predicates, user.DepartmentLTE(*i.DepartmentLTE))
	}
	if i.DepartmentContains != nil {
		predicates = append(predicates, user.DepartmentContains(*i.DepartmentContains))
	}
	if i.DepartmentHasPrefix != nil {
		predicates = append(predicates, user.DepartmentHasPrefix(*i.DepartmentHasPrefix))
	}
	if i.DepartmentHasSuffix != nil {
		predicates = append(predicates, user.DepartmentHasSuffix(*i.DepartmentHasSuffix))
	}
	if i.DepartmentIsNil {
		predicates = append(predicates, user.DepartmentIsNil())
	}
	if i.DepartmentNotNil {
		predicates = append(predicates, user.DepartmentNotNil())
	}
	if i.DepartmentEqualFold != nil {
		predicates = append(predicates, user.DepartmentEqualFold(*i.DepartmentEqualFold))
	}
	if i.DepartmentContainsFold != nil {
		predicates = append(predicates, user.DepartmentContainsFold(*i.DepartmentContainsFold))
	}
	if i.Phone != nil {
		predicates = append(predicates, user.PhoneEQ(*i.Phone))
	}
	if i.PhoneNEQ != nil {
		predicates = append(predicates, user.PhoneNEQ(*i.PhoneNEQ))
	}
	if len(i.PhoneIn) > 0 {
		predicates = append(predicates, user.PhoneIn(i.PhoneIn...))
	}
	if len(i.PhoneNotIn) > 0 {
		predicates = append(predicates, user.PhoneNotIn(i.PhoneNotIn...))
	}
	if i.PhoneGT != nil {
		predicates = append(predicates, user.PhoneGT(*i.PhoneGT))
	}
	if i.PhoneGTE != nil {
		predicates = append(predicates, user.PhoneGTE(*i.PhoneGTE))
	}
	if i.PhoneLT != nil {
		predicates = append(predicates, user.PhoneLT(*i.PhoneLT))
	}
	if i.PhoneLTE != nil {
		predicates = append(predicates, user.PhoneLTE(*i.PhoneLTE))
	}
	if i.PhoneContains != nil {
		predicates = append(predicates, user.PhoneContains(*i.PhoneContains))
	}
	if i.PhoneHasPrefix != nil {
		predicates = append(predicates, user.PhoneHasPrefix(*i.PhoneHasPrefix))
	}
	if i.PhoneHasSuffix != nil {
		predicates = append(predicates, user.PhoneHasSuffix(*i.PhoneHasSuffix))
	}
	if i.PhoneIsNil {
		predicates = append(predicates, user.PhoneIsNil())
	}
	if i.PhoneNotNil {
		predicates = append(predicates, user.PhoneNotNil())
	}
	if i.PhoneEqualFold != nil {
		predicates = append(predicates, user.PhoneEqualFold(*i.PhoneEqualFold))
	}
	if i.PhoneContainsFold != nil {
		predicates = append(predicates, user.PhoneContainsFold(*i.PhoneContainsFold))
	}
	if i.Birthdate != nil {
		predicates = append(predicates, user.BirthdateEQ(*i.Birthdate))
	}
	if i.BirthdateNEQ != nil {
		predicates = append(predicates, user.BirthdateNEQ(*i.BirthdateNEQ))
	}
	if len(i.BirthdateIn) > 0 {
		predicates = append(predicates, user.BirthdateIn(i.BirthdateIn...))
	}
	if len(i.BirthdateNotIn) > 0 {
		predicates = append(predicates, user.BirthdateNotIn(i.BirthdateNotIn...))
	}
	if i.BirthdateGT != nil {
		predicates = append(predicates, user.BirthdateGT(*i.BirthdateGT))
	}
	if i.BirthdateGTE != nil {
		predicates = append(predicates, user.BirthdateGTE(*i.BirthdateGTE))
	}
	if i.BirthdateLT != nil {
		predicates = append(predicates, user.BirthdateLT(*i.BirthdateLT))
	}
	if i.BirthdateLTE != nil {
		predicates = append(predicates, user.BirthdateLTE(*i.BirthdateLTE))
	}
	if i.BirthdateIsNil {
		predicates = append(predicates, user.BirthdateIsNil())
	}
	if i.BirthdateNotNil {
		predicates = append(predicates, user.BirthdateNotNil())
	}
	if i.LastLogin != nil {
		predicates = append(predicates, user.LastLoginEQ(*i.LastLogin))
	}
	if i.LastLoginNEQ != nil {
		predicates = append(predicates, user.LastLoginNEQ(*i.LastLoginNEQ))
	}
	if len(i.LastLoginIn) > 0 {
		predicates = append(predicates, user.LastLoginIn(i.LastLoginIn...))
	}
	if len(i.LastLoginNotIn) > 0 {
		predicates = append(predicates, user.LastLoginNotIn(i.LastLoginNotIn...))
	}
	if i.LastLoginGT != nil {
		predicates = append(predicates, user.LastLoginGT(*i.LastLoginGT))
	}
	if i.LastLoginGTE != nil {
		predicates = append(predicates, user.LastLoginGTE(*i.LastLoginGTE))
	}
	if i.LastLoginLT != nil {
		predicates = append(predicates, user.LastLoginLT(*i.LastLoginLT))
	}
	if i.LastLoginLTE != nil {
		predicates = append(predicates, user.LastLoginLTE(*i.LastLoginLTE))
	}
	if i.LastLoginIsNil {
		predicates = append(predicates, user.LastLoginIsNil())
	}
	if i.LastLoginNotNil {
		predicates = append(predicates, user.LastLoginNotNil())
	}
	if i.Gender != nil {
		predicates = append(predicates, user.GenderEQ(*i.Gender))
	}
	if i.GenderNEQ != nil {
		predicates = append(predicates, user.GenderNEQ(*i.GenderNEQ))
	}
	if len(i.GenderIn) > 0 {
		predicates = append(predicates, user.GenderIn(i.GenderIn...))
	}
	if len(i.GenderNotIn) > 0 {
		predicates = append(predicates, user.GenderNotIn(i.GenderNotIn...))
	}
	if i.Active != nil {
		predicates = append(predicates, user.ActiveEQ(*i.Active))
	}
	if i.ActiveNEQ != nil {
		predicates = append(predicates, user.ActiveNEQ(*i.ActiveNEQ))
	}

	if i.HasAccountingEntries != nil {
		p := user.HasAccountingEntries()
		if !*i.HasAccountingEntries {
			p = user.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasAccountingEntriesWith) > 0 {
		with := make([]predicate.AccountingEntry, 0, len(i.HasAccountingEntriesWith))
		for _, w := range i.HasAccountingEntriesWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasAccountingEntriesWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, user.HasAccountingEntriesWith(with...))
	}
	if i.HasCompany != nil {
		p := user.HasCompany()
		if !*i.HasCompany {
			p = user.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasCompanyWith) > 0 {
		with := make([]predicate.Company, 0, len(i.HasCompanyWith))
		for _, w := range i.HasCompanyWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasCompanyWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, user.HasCompanyWith(with...))
	}
	if i.HasAssignedRoles != nil {
		p := user.HasAssignedRoles()
		if !*i.HasAssignedRoles {
			p = user.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasAssignedRolesWith) > 0 {
		with := make([]predicate.UserRole, 0, len(i.HasAssignedRolesWith))
		for _, w := range i.HasAssignedRolesWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasAssignedRolesWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, user.HasAssignedRolesWith(with...))
	}
	if i.HasSubordinates != nil {
		p := user.HasSubordinates()
		if !*i.HasSubordinates {
			p = user.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasSubordinatesWith) > 0 {
		with := make([]predicate.User, 0, len(i.HasSubordinatesWith))
		for _, w := range i.HasSubordinatesWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasSubordinatesWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, user.HasSubordinatesWith(with...))
	}
	if i.HasLeader != nil {
		p := user.HasLeader()
		if !*i.HasLeader {
			p = user.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasLeaderWith) > 0 {
		with := make([]predicate.User, 0, len(i.HasLeaderWith))
		for _, w := range i.HasLeaderWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasLeaderWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, user.HasLeaderWith(with...))
	}
	if i.HasCreatedMemberSignupTokens != nil {
		p := user.HasCreatedMemberSignupTokens()
		if !*i.HasCreatedMemberSignupTokens {
			p = user.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasCreatedMemberSignupTokensWith) > 0 {
		with := make([]predicate.MemberSignupToken, 0, len(i.HasCreatedMemberSignupTokensWith))
		for _, w := range i.HasCreatedMemberSignupTokensWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasCreatedMemberSignupTokensWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, user.HasCreatedMemberSignupTokensWith(with...))
	}
	if i.HasEmployee != nil {
		p := user.HasEmployee()
		if !*i.HasEmployee {
			p = user.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasEmployeeWith) > 0 {
		with := make([]predicate.Employee, 0, len(i.HasEmployeeWith))
		for _, w := range i.HasEmployeeWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasEmployeeWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, user.HasEmployeeWith(with...))
	}
	if i.HasCreatedProjects != nil {
		p := user.HasCreatedProjects()
		if !*i.HasCreatedProjects {
			p = user.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasCreatedProjectsWith) > 0 {
		with := make([]predicate.Project, 0, len(i.HasCreatedProjectsWith))
		for _, w := range i.HasCreatedProjectsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasCreatedProjectsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, user.HasCreatedProjectsWith(with...))
	}
	if i.HasLeaderedProjects != nil {
		p := user.HasLeaderedProjects()
		if !*i.HasLeaderedProjects {
			p = user.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasLeaderedProjectsWith) > 0 {
		with := make([]predicate.Project, 0, len(i.HasLeaderedProjectsWith))
		for _, w := range i.HasLeaderedProjectsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasLeaderedProjectsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, user.HasLeaderedProjectsWith(with...))
	}
	if i.HasAssignedProjectTasks != nil {
		p := user.HasAssignedProjectTasks()
		if !*i.HasAssignedProjectTasks {
			p = user.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasAssignedProjectTasksWith) > 0 {
		with := make([]predicate.ProjectTask, 0, len(i.HasAssignedProjectTasksWith))
		for _, w := range i.HasAssignedProjectTasksWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasAssignedProjectTasksWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, user.HasAssignedProjectTasksWith(with...))
	}
	if i.HasParticipatedProjectTasks != nil {
		p := user.HasParticipatedProjectTasks()
		if !*i.HasParticipatedProjectTasks {
			p = user.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasParticipatedProjectTasksWith) > 0 {
		with := make([]predicate.ProjectTask, 0, len(i.HasParticipatedProjectTasksWith))
		for _, w := range i.HasParticipatedProjectTasksWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasParticipatedProjectTasksWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, user.HasParticipatedProjectTasksWith(with...))
	}
	if i.HasCreatedTasks != nil {
		p := user.HasCreatedTasks()
		if !*i.HasCreatedTasks {
			p = user.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasCreatedTasksWith) > 0 {
		with := make([]predicate.ProjectTask, 0, len(i.HasCreatedTasksWith))
		for _, w := range i.HasCreatedTasksWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasCreatedTasksWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, user.HasCreatedTasksWith(with...))
	}
	if i.HasTokens != nil {
		p := user.HasTokens()
		if !*i.HasTokens {
			p = user.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasTokensWith) > 0 {
		with := make([]predicate.Token, 0, len(i.HasTokensWith))
		for _, w := range i.HasTokensWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasTokensWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, user.HasTokensWith(with...))
	}
	if i.HasApprovedWorkShifts != nil {
		p := user.HasApprovedWorkShifts()
		if !*i.HasApprovedWorkShifts {
			p = user.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasApprovedWorkShiftsWith) > 0 {
		with := make([]predicate.Workshift, 0, len(i.HasApprovedWorkShiftsWith))
		for _, w := range i.HasApprovedWorkShiftsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasApprovedWorkShiftsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, user.HasApprovedWorkShiftsWith(with...))
	}
	if i.HasWorkShifts != nil {
		p := user.HasWorkShifts()
		if !*i.HasWorkShifts {
			p = user.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasWorkShiftsWith) > 0 {
		with := make([]predicate.Workshift, 0, len(i.HasWorkShiftsWith))
		for _, w := range i.HasWorkShiftsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasWorkShiftsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, user.HasWorkShiftsWith(with...))
	}
	if i.HasUploadedDocuments != nil {
		p := user.HasUploadedDocuments()
		if !*i.HasUploadedDocuments {
			p = user.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasUploadedDocumentsWith) > 0 {
		with := make([]predicate.CompanyDocument, 0, len(i.HasUploadedDocumentsWith))
		for _, w := range i.HasUploadedDocumentsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasUploadedDocumentsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, user.HasUploadedDocumentsWith(with...))
	}
	if i.HasApprovedDocuments != nil {
		p := user.HasApprovedDocuments()
		if !*i.HasApprovedDocuments {
			p = user.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasApprovedDocumentsWith) > 0 {
		with := make([]predicate.CompanyDocument, 0, len(i.HasApprovedDocumentsWith))
		for _, w := range i.HasApprovedDocumentsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasApprovedDocumentsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, user.HasApprovedDocumentsWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyUserWhereInput
	case 1:
		return predicates[0], nil
	default:
		return user.And(predicates...), nil
	}
}

// UserRoleWhereInput represents a where input for filtering UserRole queries.
type UserRoleWhereInput struct {
	Predicates []predicate.UserRole  `json:"-"`
	Not        *UserRoleWhereInput   `json:"not,omitempty"`
	Or         []*UserRoleWhereInput `json:"or,omitempty"`
	And        []*UserRoleWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "role" field predicates.
	Role      *userrole.Role  `json:"role,omitempty"`
	RoleNEQ   *userrole.Role  `json:"roleNEQ,omitempty"`
	RoleIn    []userrole.Role `json:"roleIn,omitempty"`
	RoleNotIn []userrole.Role `json:"roleNotIn,omitempty"`

	// "notes" field predicates.
	Notes             *string  `json:"notes,omitempty"`
	NotesNEQ          *string  `json:"notesNEQ,omitempty"`
	NotesIn           []string `json:"notesIn,omitempty"`
	NotesNotIn        []string `json:"notesNotIn,omitempty"`
	NotesGT           *string  `json:"notesGT,omitempty"`
	NotesGTE          *string  `json:"notesGTE,omitempty"`
	NotesLT           *string  `json:"notesLT,omitempty"`
	NotesLTE          *string  `json:"notesLTE,omitempty"`
	NotesContains     *string  `json:"notesContains,omitempty"`
	NotesHasPrefix    *string  `json:"notesHasPrefix,omitempty"`
	NotesHasSuffix    *string  `json:"notesHasSuffix,omitempty"`
	NotesEqualFold    *string  `json:"notesEqualFold,omitempty"`
	NotesContainsFold *string  `json:"notesContainsFold,omitempty"`

	// "company" edge predicates.
	HasCompany     *bool                `json:"hasCompany,omitempty"`
	HasCompanyWith []*CompanyWhereInput `json:"hasCompanyWith,omitempty"`

	// "user" edge predicates.
	HasUser     *bool             `json:"hasUser,omitempty"`
	HasUserWith []*UserWhereInput `json:"hasUserWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *UserRoleWhereInput) AddPredicates(predicates ...predicate.UserRole) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the UserRoleWhereInput filter on the UserRoleQuery builder.
func (i *UserRoleWhereInput) Filter(q *UserRoleQuery) (*UserRoleQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyUserRoleWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyUserRoleWhereInput is returned in case the UserRoleWhereInput is empty.
var ErrEmptyUserRoleWhereInput = errors.New("generated: empty predicate UserRoleWhereInput")

// P returns a predicate for filtering userroles.
// An error is returned if the input is empty or invalid.
func (i *UserRoleWhereInput) P() (predicate.UserRole, error) {
	var predicates []predicate.UserRole
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, userrole.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.UserRole, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, userrole.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.UserRole, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, userrole.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, userrole.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, userrole.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, userrole.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, userrole.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, userrole.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, userrole.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, userrole.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, userrole.IDLTE(*i.IDLTE))
	}
	if i.Role != nil {
		predicates = append(predicates, userrole.RoleEQ(*i.Role))
	}
	if i.RoleNEQ != nil {
		predicates = append(predicates, userrole.RoleNEQ(*i.RoleNEQ))
	}
	if len(i.RoleIn) > 0 {
		predicates = append(predicates, userrole.RoleIn(i.RoleIn...))
	}
	if len(i.RoleNotIn) > 0 {
		predicates = append(predicates, userrole.RoleNotIn(i.RoleNotIn...))
	}
	if i.Notes != nil {
		predicates = append(predicates, userrole.NotesEQ(*i.Notes))
	}
	if i.NotesNEQ != nil {
		predicates = append(predicates, userrole.NotesNEQ(*i.NotesNEQ))
	}
	if len(i.NotesIn) > 0 {
		predicates = append(predicates, userrole.NotesIn(i.NotesIn...))
	}
	if len(i.NotesNotIn) > 0 {
		predicates = append(predicates, userrole.NotesNotIn(i.NotesNotIn...))
	}
	if i.NotesGT != nil {
		predicates = append(predicates, userrole.NotesGT(*i.NotesGT))
	}
	if i.NotesGTE != nil {
		predicates = append(predicates, userrole.NotesGTE(*i.NotesGTE))
	}
	if i.NotesLT != nil {
		predicates = append(predicates, userrole.NotesLT(*i.NotesLT))
	}
	if i.NotesLTE != nil {
		predicates = append(predicates, userrole.NotesLTE(*i.NotesLTE))
	}
	if i.NotesContains != nil {
		predicates = append(predicates, userrole.NotesContains(*i.NotesContains))
	}
	if i.NotesHasPrefix != nil {
		predicates = append(predicates, userrole.NotesHasPrefix(*i.NotesHasPrefix))
	}
	if i.NotesHasSuffix != nil {
		predicates = append(predicates, userrole.NotesHasSuffix(*i.NotesHasSuffix))
	}
	if i.NotesEqualFold != nil {
		predicates = append(predicates, userrole.NotesEqualFold(*i.NotesEqualFold))
	}
	if i.NotesContainsFold != nil {
		predicates = append(predicates, userrole.NotesContainsFold(*i.NotesContainsFold))
	}

	if i.HasCompany != nil {
		p := userrole.HasCompany()
		if !*i.HasCompany {
			p = userrole.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasCompanyWith) > 0 {
		with := make([]predicate.Company, 0, len(i.HasCompanyWith))
		for _, w := range i.HasCompanyWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasCompanyWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, userrole.HasCompanyWith(with...))
	}
	if i.HasUser != nil {
		p := userrole.HasUser()
		if !*i.HasUser {
			p = userrole.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasUserWith) > 0 {
		with := make([]predicate.User, 0, len(i.HasUserWith))
		for _, w := range i.HasUserWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasUserWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, userrole.HasUserWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyUserRoleWhereInput
	case 1:
		return predicates[0], nil
	default:
		return userrole.And(predicates...), nil
	}
}

// WorkshiftWhereInput represents a where input for filtering Workshift queries.
type WorkshiftWhereInput struct {
	Predicates []predicate.Workshift  `json:"-"`
	Not        *WorkshiftWhereInput   `json:"not,omitempty"`
	Or         []*WorkshiftWhereInput `json:"or,omitempty"`
	And        []*WorkshiftWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "createdAt" field predicates.
	CreatedAt      *time.Time  `json:"createdat,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdatNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdatIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdatNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdatGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdatGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdatLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdatLTE,omitempty"`

	// "updatedAt" field predicates.
	UpdatedAt      *time.Time  `json:"updatedat,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedatNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedatIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedatNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedatGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedatGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedatLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedatLTE,omitempty"`

	// "deletedAt" field predicates.
	DeletedAt       *time.Time  `json:"deletedat,omitempty"`
	DeletedAtNEQ    *time.Time  `json:"deletedatNEQ,omitempty"`
	DeletedAtIn     []time.Time `json:"deletedatIn,omitempty"`
	DeletedAtNotIn  []time.Time `json:"deletedatNotIn,omitempty"`
	DeletedAtGT     *time.Time  `json:"deletedatGT,omitempty"`
	DeletedAtGTE    *time.Time  `json:"deletedatGTE,omitempty"`
	DeletedAtLT     *time.Time  `json:"deletedatLT,omitempty"`
	DeletedAtLTE    *time.Time  `json:"deletedatLTE,omitempty"`
	DeletedAtIsNil  bool        `json:"deletedatIsNil,omitempty"`
	DeletedAtNotNil bool        `json:"deletedatNotNil,omitempty"`

	// "approvedAt" field predicates.
	ApprovedAt       *time.Time  `json:"approvedat,omitempty"`
	ApprovedAtNEQ    *time.Time  `json:"approvedatNEQ,omitempty"`
	ApprovedAtIn     []time.Time `json:"approvedatIn,omitempty"`
	ApprovedAtNotIn  []time.Time `json:"approvedatNotIn,omitempty"`
	ApprovedAtGT     *time.Time  `json:"approvedatGT,omitempty"`
	ApprovedAtGTE    *time.Time  `json:"approvedatGTE,omitempty"`
	ApprovedAtLT     *time.Time  `json:"approvedatLT,omitempty"`
	ApprovedAtLTE    *time.Time  `json:"approvedatLTE,omitempty"`
	ApprovedAtIsNil  bool        `json:"approvedatIsNil,omitempty"`
	ApprovedAtNotNil bool        `json:"approvedatNotNil,omitempty"`

	// "clockIn" field predicates.
	ClockIn      *time.Time  `json:"clockin,omitempty"`
	ClockInNEQ   *time.Time  `json:"clockinNEQ,omitempty"`
	ClockInIn    []time.Time `json:"clockinIn,omitempty"`
	ClockInNotIn []time.Time `json:"clockinNotIn,omitempty"`
	ClockInGT    *time.Time  `json:"clockinGT,omitempty"`
	ClockInGTE   *time.Time  `json:"clockinGTE,omitempty"`
	ClockInLT    *time.Time  `json:"clockinLT,omitempty"`
	ClockInLTE   *time.Time  `json:"clockinLTE,omitempty"`

	// "clockOut" field predicates.
	ClockOut       *time.Time  `json:"clockout,omitempty"`
	ClockOutNEQ    *time.Time  `json:"clockoutNEQ,omitempty"`
	ClockOutIn     []time.Time `json:"clockoutIn,omitempty"`
	ClockOutNotIn  []time.Time `json:"clockoutNotIn,omitempty"`
	ClockOutGT     *time.Time  `json:"clockoutGT,omitempty"`
	ClockOutGTE    *time.Time  `json:"clockoutGTE,omitempty"`
	ClockOutLT     *time.Time  `json:"clockoutLT,omitempty"`
	ClockOutLTE    *time.Time  `json:"clockoutLTE,omitempty"`
	ClockOutIsNil  bool        `json:"clockoutIsNil,omitempty"`
	ClockOutNotNil bool        `json:"clockoutNotNil,omitempty"`

	// "clockInLocation" field predicates.
	ClockInLocation             *string  `json:"clockinlocation,omitempty"`
	ClockInLocationNEQ          *string  `json:"clockinlocationNEQ,omitempty"`
	ClockInLocationIn           []string `json:"clockinlocationIn,omitempty"`
	ClockInLocationNotIn        []string `json:"clockinlocationNotIn,omitempty"`
	ClockInLocationGT           *string  `json:"clockinlocationGT,omitempty"`
	ClockInLocationGTE          *string  `json:"clockinlocationGTE,omitempty"`
	ClockInLocationLT           *string  `json:"clockinlocationLT,omitempty"`
	ClockInLocationLTE          *string  `json:"clockinlocationLTE,omitempty"`
	ClockInLocationContains     *string  `json:"clockinlocationContains,omitempty"`
	ClockInLocationHasPrefix    *string  `json:"clockinlocationHasPrefix,omitempty"`
	ClockInLocationHasSuffix    *string  `json:"clockinlocationHasSuffix,omitempty"`
	ClockInLocationEqualFold    *string  `json:"clockinlocationEqualFold,omitempty"`
	ClockInLocationContainsFold *string  `json:"clockinlocationContainsFold,omitempty"`

	// "clockOutLocation" field predicates.
	ClockOutLocation             *string  `json:"clockoutlocation,omitempty"`
	ClockOutLocationNEQ          *string  `json:"clockoutlocationNEQ,omitempty"`
	ClockOutLocationIn           []string `json:"clockoutlocationIn,omitempty"`
	ClockOutLocationNotIn        []string `json:"clockoutlocationNotIn,omitempty"`
	ClockOutLocationGT           *string  `json:"clockoutlocationGT,omitempty"`
	ClockOutLocationGTE          *string  `json:"clockoutlocationGTE,omitempty"`
	ClockOutLocationLT           *string  `json:"clockoutlocationLT,omitempty"`
	ClockOutLocationLTE          *string  `json:"clockoutlocationLTE,omitempty"`
	ClockOutLocationContains     *string  `json:"clockoutlocationContains,omitempty"`
	ClockOutLocationHasPrefix    *string  `json:"clockoutlocationHasPrefix,omitempty"`
	ClockOutLocationHasSuffix    *string  `json:"clockoutlocationHasSuffix,omitempty"`
	ClockOutLocationIsNil        bool     `json:"clockoutlocationIsNil,omitempty"`
	ClockOutLocationNotNil       bool     `json:"clockoutlocationNotNil,omitempty"`
	ClockOutLocationEqualFold    *string  `json:"clockoutlocationEqualFold,omitempty"`
	ClockOutLocationContainsFold *string  `json:"clockoutlocationContainsFold,omitempty"`

	// "description" field predicates.
	Description             *string  `json:"description,omitempty"`
	DescriptionNEQ          *string  `json:"descriptionNEQ,omitempty"`
	DescriptionIn           []string `json:"descriptionIn,omitempty"`
	DescriptionNotIn        []string `json:"descriptionNotIn,omitempty"`
	DescriptionGT           *string  `json:"descriptionGT,omitempty"`
	DescriptionGTE          *string  `json:"descriptionGTE,omitempty"`
	DescriptionLT           *string  `json:"descriptionLT,omitempty"`
	DescriptionLTE          *string  `json:"descriptionLTE,omitempty"`
	DescriptionContains     *string  `json:"descriptionContains,omitempty"`
	DescriptionHasPrefix    *string  `json:"descriptionHasPrefix,omitempty"`
	DescriptionHasSuffix    *string  `json:"descriptionHasSuffix,omitempty"`
	DescriptionIsNil        bool     `json:"descriptionIsNil,omitempty"`
	DescriptionNotNil       bool     `json:"descriptionNotNil,omitempty"`
	DescriptionEqualFold    *string  `json:"descriptionEqualFold,omitempty"`
	DescriptionContainsFold *string  `json:"descriptionContainsFold,omitempty"`

	// "note" field predicates.
	Note             *string  `json:"note,omitempty"`
	NoteNEQ          *string  `json:"noteNEQ,omitempty"`
	NoteIn           []string `json:"noteIn,omitempty"`
	NoteNotIn        []string `json:"noteNotIn,omitempty"`
	NoteGT           *string  `json:"noteGT,omitempty"`
	NoteGTE          *string  `json:"noteGTE,omitempty"`
	NoteLT           *string  `json:"noteLT,omitempty"`
	NoteLTE          *string  `json:"noteLTE,omitempty"`
	NoteContains     *string  `json:"noteContains,omitempty"`
	NoteHasPrefix    *string  `json:"noteHasPrefix,omitempty"`
	NoteHasSuffix    *string  `json:"noteHasSuffix,omitempty"`
	NoteIsNil        bool     `json:"noteIsNil,omitempty"`
	NoteNotNil       bool     `json:"noteNotNil,omitempty"`
	NoteEqualFold    *string  `json:"noteEqualFold,omitempty"`
	NoteContainsFold *string  `json:"noteContainsFold,omitempty"`

	// "status" field predicates.
	Status      *workshift.Status  `json:"status,omitempty"`
	StatusNEQ   *workshift.Status  `json:"statusNEQ,omitempty"`
	StatusIn    []workshift.Status `json:"statusIn,omitempty"`
	StatusNotIn []workshift.Status `json:"statusNotIn,omitempty"`

	// "company" edge predicates.
	HasCompany     *bool                `json:"hasCompany,omitempty"`
	HasCompanyWith []*CompanyWhereInput `json:"hasCompanyWith,omitempty"`

	// "user" edge predicates.
	HasUser     *bool             `json:"hasUser,omitempty"`
	HasUserWith []*UserWhereInput `json:"hasUserWith,omitempty"`

	// "approvedBy" edge predicates.
	HasApprovedBy     *bool             `json:"hasApprovedBy,omitempty"`
	HasApprovedByWith []*UserWhereInput `json:"hasApprovedByWith,omitempty"`

	// "task" edge predicates.
	HasTask     *bool                    `json:"hasTask,omitempty"`
	HasTaskWith []*ProjectTaskWhereInput `json:"hasTaskWith,omitempty"`

	// "editRequest" edge predicates.
	HasEditRequest     *bool                  `json:"hasEditRequest,omitempty"`
	HasEditRequestWith []*WorkshiftWhereInput `json:"hasEditRequestWith,omitempty"`

	// "workShift" edge predicates.
	HasWorkShift     *bool                  `json:"hasWorkShift,omitempty"`
	HasWorkShiftWith []*WorkshiftWhereInput `json:"hasWorkShiftWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *WorkshiftWhereInput) AddPredicates(predicates ...predicate.Workshift) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the WorkshiftWhereInput filter on the WorkshiftQuery builder.
func (i *WorkshiftWhereInput) Filter(q *WorkshiftQuery) (*WorkshiftQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyWorkshiftWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyWorkshiftWhereInput is returned in case the WorkshiftWhereInput is empty.
var ErrEmptyWorkshiftWhereInput = errors.New("generated: empty predicate WorkshiftWhereInput")

// P returns a predicate for filtering workshifts.
// An error is returned if the input is empty or invalid.
func (i *WorkshiftWhereInput) P() (predicate.Workshift, error) {
	var predicates []predicate.Workshift
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, workshift.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Workshift, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, workshift.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Workshift, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, workshift.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, workshift.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, workshift.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, workshift.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, workshift.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, workshift.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, workshift.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, workshift.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, workshift.IDLTE(*i.IDLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, workshift.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, workshift.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, workshift.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, workshift.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, workshift.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, workshift.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, workshift.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, workshift.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, workshift.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, workshift.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, workshift.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, workshift.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, workshift.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, workshift.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, workshift.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, workshift.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.DeletedAt != nil {
		predicates = append(predicates, workshift.DeletedAtEQ(*i.DeletedAt))
	}
	if i.DeletedAtNEQ != nil {
		predicates = append(predicates, workshift.DeletedAtNEQ(*i.DeletedAtNEQ))
	}
	if len(i.DeletedAtIn) > 0 {
		predicates = append(predicates, workshift.DeletedAtIn(i.DeletedAtIn...))
	}
	if len(i.DeletedAtNotIn) > 0 {
		predicates = append(predicates, workshift.DeletedAtNotIn(i.DeletedAtNotIn...))
	}
	if i.DeletedAtGT != nil {
		predicates = append(predicates, workshift.DeletedAtGT(*i.DeletedAtGT))
	}
	if i.DeletedAtGTE != nil {
		predicates = append(predicates, workshift.DeletedAtGTE(*i.DeletedAtGTE))
	}
	if i.DeletedAtLT != nil {
		predicates = append(predicates, workshift.DeletedAtLT(*i.DeletedAtLT))
	}
	if i.DeletedAtLTE != nil {
		predicates = append(predicates, workshift.DeletedAtLTE(*i.DeletedAtLTE))
	}
	if i.DeletedAtIsNil {
		predicates = append(predicates, workshift.DeletedAtIsNil())
	}
	if i.DeletedAtNotNil {
		predicates = append(predicates, workshift.DeletedAtNotNil())
	}
	if i.ApprovedAt != nil {
		predicates = append(predicates, workshift.ApprovedAtEQ(*i.ApprovedAt))
	}
	if i.ApprovedAtNEQ != nil {
		predicates = append(predicates, workshift.ApprovedAtNEQ(*i.ApprovedAtNEQ))
	}
	if len(i.ApprovedAtIn) > 0 {
		predicates = append(predicates, workshift.ApprovedAtIn(i.ApprovedAtIn...))
	}
	if len(i.ApprovedAtNotIn) > 0 {
		predicates = append(predicates, workshift.ApprovedAtNotIn(i.ApprovedAtNotIn...))
	}
	if i.ApprovedAtGT != nil {
		predicates = append(predicates, workshift.ApprovedAtGT(*i.ApprovedAtGT))
	}
	if i.ApprovedAtGTE != nil {
		predicates = append(predicates, workshift.ApprovedAtGTE(*i.ApprovedAtGTE))
	}
	if i.ApprovedAtLT != nil {
		predicates = append(predicates, workshift.ApprovedAtLT(*i.ApprovedAtLT))
	}
	if i.ApprovedAtLTE != nil {
		predicates = append(predicates, workshift.ApprovedAtLTE(*i.ApprovedAtLTE))
	}
	if i.ApprovedAtIsNil {
		predicates = append(predicates, workshift.ApprovedAtIsNil())
	}
	if i.ApprovedAtNotNil {
		predicates = append(predicates, workshift.ApprovedAtNotNil())
	}
	if i.ClockIn != nil {
		predicates = append(predicates, workshift.ClockInEQ(*i.ClockIn))
	}
	if i.ClockInNEQ != nil {
		predicates = append(predicates, workshift.ClockInNEQ(*i.ClockInNEQ))
	}
	if len(i.ClockInIn) > 0 {
		predicates = append(predicates, workshift.ClockInIn(i.ClockInIn...))
	}
	if len(i.ClockInNotIn) > 0 {
		predicates = append(predicates, workshift.ClockInNotIn(i.ClockInNotIn...))
	}
	if i.ClockInGT != nil {
		predicates = append(predicates, workshift.ClockInGT(*i.ClockInGT))
	}
	if i.ClockInGTE != nil {
		predicates = append(predicates, workshift.ClockInGTE(*i.ClockInGTE))
	}
	if i.ClockInLT != nil {
		predicates = append(predicates, workshift.ClockInLT(*i.ClockInLT))
	}
	if i.ClockInLTE != nil {
		predicates = append(predicates, workshift.ClockInLTE(*i.ClockInLTE))
	}
	if i.ClockOut != nil {
		predicates = append(predicates, workshift.ClockOutEQ(*i.ClockOut))
	}
	if i.ClockOutNEQ != nil {
		predicates = append(predicates, workshift.ClockOutNEQ(*i.ClockOutNEQ))
	}
	if len(i.ClockOutIn) > 0 {
		predicates = append(predicates, workshift.ClockOutIn(i.ClockOutIn...))
	}
	if len(i.ClockOutNotIn) > 0 {
		predicates = append(predicates, workshift.ClockOutNotIn(i.ClockOutNotIn...))
	}
	if i.ClockOutGT != nil {
		predicates = append(predicates, workshift.ClockOutGT(*i.ClockOutGT))
	}
	if i.ClockOutGTE != nil {
		predicates = append(predicates, workshift.ClockOutGTE(*i.ClockOutGTE))
	}
	if i.ClockOutLT != nil {
		predicates = append(predicates, workshift.ClockOutLT(*i.ClockOutLT))
	}
	if i.ClockOutLTE != nil {
		predicates = append(predicates, workshift.ClockOutLTE(*i.ClockOutLTE))
	}
	if i.ClockOutIsNil {
		predicates = append(predicates, workshift.ClockOutIsNil())
	}
	if i.ClockOutNotNil {
		predicates = append(predicates, workshift.ClockOutNotNil())
	}
	if i.ClockInLocation != nil {
		predicates = append(predicates, workshift.ClockInLocationEQ(*i.ClockInLocation))
	}
	if i.ClockInLocationNEQ != nil {
		predicates = append(predicates, workshift.ClockInLocationNEQ(*i.ClockInLocationNEQ))
	}
	if len(i.ClockInLocationIn) > 0 {
		predicates = append(predicates, workshift.ClockInLocationIn(i.ClockInLocationIn...))
	}
	if len(i.ClockInLocationNotIn) > 0 {
		predicates = append(predicates, workshift.ClockInLocationNotIn(i.ClockInLocationNotIn...))
	}
	if i.ClockInLocationGT != nil {
		predicates = append(predicates, workshift.ClockInLocationGT(*i.ClockInLocationGT))
	}
	if i.ClockInLocationGTE != nil {
		predicates = append(predicates, workshift.ClockInLocationGTE(*i.ClockInLocationGTE))
	}
	if i.ClockInLocationLT != nil {
		predicates = append(predicates, workshift.ClockInLocationLT(*i.ClockInLocationLT))
	}
	if i.ClockInLocationLTE != nil {
		predicates = append(predicates, workshift.ClockInLocationLTE(*i.ClockInLocationLTE))
	}
	if i.ClockInLocationContains != nil {
		predicates = append(predicates, workshift.ClockInLocationContains(*i.ClockInLocationContains))
	}
	if i.ClockInLocationHasPrefix != nil {
		predicates = append(predicates, workshift.ClockInLocationHasPrefix(*i.ClockInLocationHasPrefix))
	}
	if i.ClockInLocationHasSuffix != nil {
		predicates = append(predicates, workshift.ClockInLocationHasSuffix(*i.ClockInLocationHasSuffix))
	}
	if i.ClockInLocationEqualFold != nil {
		predicates = append(predicates, workshift.ClockInLocationEqualFold(*i.ClockInLocationEqualFold))
	}
	if i.ClockInLocationContainsFold != nil {
		predicates = append(predicates, workshift.ClockInLocationContainsFold(*i.ClockInLocationContainsFold))
	}
	if i.ClockOutLocation != nil {
		predicates = append(predicates, workshift.ClockOutLocationEQ(*i.ClockOutLocation))
	}
	if i.ClockOutLocationNEQ != nil {
		predicates = append(predicates, workshift.ClockOutLocationNEQ(*i.ClockOutLocationNEQ))
	}
	if len(i.ClockOutLocationIn) > 0 {
		predicates = append(predicates, workshift.ClockOutLocationIn(i.ClockOutLocationIn...))
	}
	if len(i.ClockOutLocationNotIn) > 0 {
		predicates = append(predicates, workshift.ClockOutLocationNotIn(i.ClockOutLocationNotIn...))
	}
	if i.ClockOutLocationGT != nil {
		predicates = append(predicates, workshift.ClockOutLocationGT(*i.ClockOutLocationGT))
	}
	if i.ClockOutLocationGTE != nil {
		predicates = append(predicates, workshift.ClockOutLocationGTE(*i.ClockOutLocationGTE))
	}
	if i.ClockOutLocationLT != nil {
		predicates = append(predicates, workshift.ClockOutLocationLT(*i.ClockOutLocationLT))
	}
	if i.ClockOutLocationLTE != nil {
		predicates = append(predicates, workshift.ClockOutLocationLTE(*i.ClockOutLocationLTE))
	}
	if i.ClockOutLocationContains != nil {
		predicates = append(predicates, workshift.ClockOutLocationContains(*i.ClockOutLocationContains))
	}
	if i.ClockOutLocationHasPrefix != nil {
		predicates = append(predicates, workshift.ClockOutLocationHasPrefix(*i.ClockOutLocationHasPrefix))
	}
	if i.ClockOutLocationHasSuffix != nil {
		predicates = append(predicates, workshift.ClockOutLocationHasSuffix(*i.ClockOutLocationHasSuffix))
	}
	if i.ClockOutLocationIsNil {
		predicates = append(predicates, workshift.ClockOutLocationIsNil())
	}
	if i.ClockOutLocationNotNil {
		predicates = append(predicates, workshift.ClockOutLocationNotNil())
	}
	if i.ClockOutLocationEqualFold != nil {
		predicates = append(predicates, workshift.ClockOutLocationEqualFold(*i.ClockOutLocationEqualFold))
	}
	if i.ClockOutLocationContainsFold != nil {
		predicates = append(predicates, workshift.ClockOutLocationContainsFold(*i.ClockOutLocationContainsFold))
	}
	if i.Description != nil {
		predicates = append(predicates, workshift.DescriptionEQ(*i.Description))
	}
	if i.DescriptionNEQ != nil {
		predicates = append(predicates, workshift.DescriptionNEQ(*i.DescriptionNEQ))
	}
	if len(i.DescriptionIn) > 0 {
		predicates = append(predicates, workshift.DescriptionIn(i.DescriptionIn...))
	}
	if len(i.DescriptionNotIn) > 0 {
		predicates = append(predicates, workshift.DescriptionNotIn(i.DescriptionNotIn...))
	}
	if i.DescriptionGT != nil {
		predicates = append(predicates, workshift.DescriptionGT(*i.DescriptionGT))
	}
	if i.DescriptionGTE != nil {
		predicates = append(predicates, workshift.DescriptionGTE(*i.DescriptionGTE))
	}
	if i.DescriptionLT != nil {
		predicates = append(predicates, workshift.DescriptionLT(*i.DescriptionLT))
	}
	if i.DescriptionLTE != nil {
		predicates = append(predicates, workshift.DescriptionLTE(*i.DescriptionLTE))
	}
	if i.DescriptionContains != nil {
		predicates = append(predicates, workshift.DescriptionContains(*i.DescriptionContains))
	}
	if i.DescriptionHasPrefix != nil {
		predicates = append(predicates, workshift.DescriptionHasPrefix(*i.DescriptionHasPrefix))
	}
	if i.DescriptionHasSuffix != nil {
		predicates = append(predicates, workshift.DescriptionHasSuffix(*i.DescriptionHasSuffix))
	}
	if i.DescriptionIsNil {
		predicates = append(predicates, workshift.DescriptionIsNil())
	}
	if i.DescriptionNotNil {
		predicates = append(predicates, workshift.DescriptionNotNil())
	}
	if i.DescriptionEqualFold != nil {
		predicates = append(predicates, workshift.DescriptionEqualFold(*i.DescriptionEqualFold))
	}
	if i.DescriptionContainsFold != nil {
		predicates = append(predicates, workshift.DescriptionContainsFold(*i.DescriptionContainsFold))
	}
	if i.Note != nil {
		predicates = append(predicates, workshift.NoteEQ(*i.Note))
	}
	if i.NoteNEQ != nil {
		predicates = append(predicates, workshift.NoteNEQ(*i.NoteNEQ))
	}
	if len(i.NoteIn) > 0 {
		predicates = append(predicates, workshift.NoteIn(i.NoteIn...))
	}
	if len(i.NoteNotIn) > 0 {
		predicates = append(predicates, workshift.NoteNotIn(i.NoteNotIn...))
	}
	if i.NoteGT != nil {
		predicates = append(predicates, workshift.NoteGT(*i.NoteGT))
	}
	if i.NoteGTE != nil {
		predicates = append(predicates, workshift.NoteGTE(*i.NoteGTE))
	}
	if i.NoteLT != nil {
		predicates = append(predicates, workshift.NoteLT(*i.NoteLT))
	}
	if i.NoteLTE != nil {
		predicates = append(predicates, workshift.NoteLTE(*i.NoteLTE))
	}
	if i.NoteContains != nil {
		predicates = append(predicates, workshift.NoteContains(*i.NoteContains))
	}
	if i.NoteHasPrefix != nil {
		predicates = append(predicates, workshift.NoteHasPrefix(*i.NoteHasPrefix))
	}
	if i.NoteHasSuffix != nil {
		predicates = append(predicates, workshift.NoteHasSuffix(*i.NoteHasSuffix))
	}
	if i.NoteIsNil {
		predicates = append(predicates, workshift.NoteIsNil())
	}
	if i.NoteNotNil {
		predicates = append(predicates, workshift.NoteNotNil())
	}
	if i.NoteEqualFold != nil {
		predicates = append(predicates, workshift.NoteEqualFold(*i.NoteEqualFold))
	}
	if i.NoteContainsFold != nil {
		predicates = append(predicates, workshift.NoteContainsFold(*i.NoteContainsFold))
	}
	if i.Status != nil {
		predicates = append(predicates, workshift.StatusEQ(*i.Status))
	}
	if i.StatusNEQ != nil {
		predicates = append(predicates, workshift.StatusNEQ(*i.StatusNEQ))
	}
	if len(i.StatusIn) > 0 {
		predicates = append(predicates, workshift.StatusIn(i.StatusIn...))
	}
	if len(i.StatusNotIn) > 0 {
		predicates = append(predicates, workshift.StatusNotIn(i.StatusNotIn...))
	}

	if i.HasCompany != nil {
		p := workshift.HasCompany()
		if !*i.HasCompany {
			p = workshift.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasCompanyWith) > 0 {
		with := make([]predicate.Company, 0, len(i.HasCompanyWith))
		for _, w := range i.HasCompanyWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasCompanyWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, workshift.HasCompanyWith(with...))
	}
	if i.HasUser != nil {
		p := workshift.HasUser()
		if !*i.HasUser {
			p = workshift.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasUserWith) > 0 {
		with := make([]predicate.User, 0, len(i.HasUserWith))
		for _, w := range i.HasUserWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasUserWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, workshift.HasUserWith(with...))
	}
	if i.HasApprovedBy != nil {
		p := workshift.HasApprovedBy()
		if !*i.HasApprovedBy {
			p = workshift.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasApprovedByWith) > 0 {
		with := make([]predicate.User, 0, len(i.HasApprovedByWith))
		for _, w := range i.HasApprovedByWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasApprovedByWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, workshift.HasApprovedByWith(with...))
	}
	if i.HasTask != nil {
		p := workshift.HasTask()
		if !*i.HasTask {
			p = workshift.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasTaskWith) > 0 {
		with := make([]predicate.ProjectTask, 0, len(i.HasTaskWith))
		for _, w := range i.HasTaskWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasTaskWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, workshift.HasTaskWith(with...))
	}
	if i.HasEditRequest != nil {
		p := workshift.HasEditRequest()
		if !*i.HasEditRequest {
			p = workshift.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasEditRequestWith) > 0 {
		with := make([]predicate.Workshift, 0, len(i.HasEditRequestWith))
		for _, w := range i.HasEditRequestWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasEditRequestWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, workshift.HasEditRequestWith(with...))
	}
	if i.HasWorkShift != nil {
		p := workshift.HasWorkShift()
		if !*i.HasWorkShift {
			p = workshift.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasWorkShiftWith) > 0 {
		with := make([]predicate.Workshift, 0, len(i.HasWorkShiftWith))
		for _, w := range i.HasWorkShiftWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasWorkShiftWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, workshift.HasWorkShiftWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyWorkshiftWhereInput
	case 1:
		return predicates[0], nil
	default:
		return workshift.And(predicates...), nil
	}
}
