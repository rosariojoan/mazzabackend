// Code generated by ent, DO NOT EDIT.

package generated

import (
	"errors"
	"fmt"
	"mazza/ent/generated/accountingentry"
	"mazza/ent/generated/company"
	"mazza/ent/generated/companydocument"
	"mazza/ent/generated/customer"
	"mazza/ent/generated/employee"
	"mazza/ent/generated/file"
	"mazza/ent/generated/inventory"
	"mazza/ent/generated/inventorymovement"
	"mazza/ent/generated/invoice"
	"mazza/ent/generated/loan"
	"mazza/ent/generated/membersignuptoken"
	"mazza/ent/generated/payable"
	"mazza/ent/generated/predicate"
	"mazza/ent/generated/product"
	"mazza/ent/generated/project"
	"mazza/ent/generated/projectmilestone"
	"mazza/ent/generated/projecttask"
	"mazza/ent/generated/receivable"
	"mazza/ent/generated/supplier"
	"mazza/ent/generated/token"
	"mazza/ent/generated/treasury"
	"mazza/ent/generated/user"
	"mazza/ent/generated/userrole"
	"mazza/ent/generated/workshift"
	"time"
)

// AccountingEntryWhereInput represents a where input for filtering AccountingEntry queries.
type AccountingEntryWhereInput struct {
	Predicates []predicate.AccountingEntry  `json:"-"`
	Not        *AccountingEntryWhereInput   `json:"not,omitempty"`
	Or         []*AccountingEntryWhereInput `json:"or,omitempty"`
	And        []*AccountingEntryWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "createdAt" field predicates.
	CreatedAt      *time.Time  `json:"createdat,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdatNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdatIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdatNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdatGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdatGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdatLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdatLTE,omitempty"`

	// "updatedAt" field predicates.
	UpdatedAt      *time.Time  `json:"updatedat,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedatNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedatIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedatNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedatGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedatGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedatLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedatLTE,omitempty"`

	// "deletedAt" field predicates.
	DeletedAt       *time.Time  `json:"deletedat,omitempty"`
	DeletedAtNEQ    *time.Time  `json:"deletedatNEQ,omitempty"`
	DeletedAtIn     []time.Time `json:"deletedatIn,omitempty"`
	DeletedAtNotIn  []time.Time `json:"deletedatNotIn,omitempty"`
	DeletedAtGT     *time.Time  `json:"deletedatGT,omitempty"`
	DeletedAtGTE    *time.Time  `json:"deletedatGTE,omitempty"`
	DeletedAtLT     *time.Time  `json:"deletedatLT,omitempty"`
	DeletedAtLTE    *time.Time  `json:"deletedatLTE,omitempty"`
	DeletedAtIsNil  bool        `json:"deletedatIsNil,omitempty"`
	DeletedAtNotNil bool        `json:"deletedatNotNil,omitempty"`

	// "number" field predicates.
	Number      *int  `json:"number,omitempty"`
	NumberNEQ   *int  `json:"numberNEQ,omitempty"`
	NumberIn    []int `json:"numberIn,omitempty"`
	NumberNotIn []int `json:"numberNotIn,omitempty"`
	NumberGT    *int  `json:"numberGT,omitempty"`
	NumberGTE   *int  `json:"numberGTE,omitempty"`
	NumberLT    *int  `json:"numberLT,omitempty"`
	NumberLTE   *int  `json:"numberLTE,omitempty"`

	// "group" field predicates.
	Group      *int  `json:"group,omitempty"`
	GroupNEQ   *int  `json:"groupNEQ,omitempty"`
	GroupIn    []int `json:"groupIn,omitempty"`
	GroupNotIn []int `json:"groupNotIn,omitempty"`
	GroupGT    *int  `json:"groupGT,omitempty"`
	GroupGTE   *int  `json:"groupGTE,omitempty"`
	GroupLT    *int  `json:"groupLT,omitempty"`
	GroupLTE   *int  `json:"groupLTE,omitempty"`

	// "date" field predicates.
	Date      *time.Time  `json:"date,omitempty"`
	DateNEQ   *time.Time  `json:"dateNEQ,omitempty"`
	DateIn    []time.Time `json:"dateIn,omitempty"`
	DateNotIn []time.Time `json:"dateNotIn,omitempty"`
	DateGT    *time.Time  `json:"dateGT,omitempty"`
	DateGTE   *time.Time  `json:"dateGTE,omitempty"`
	DateLT    *time.Time  `json:"dateLT,omitempty"`
	DateLTE   *time.Time  `json:"dateLTE,omitempty"`

	// "account" field predicates.
	Account             *string  `json:"account,omitempty"`
	AccountNEQ          *string  `json:"accountNEQ,omitempty"`
	AccountIn           []string `json:"accountIn,omitempty"`
	AccountNotIn        []string `json:"accountNotIn,omitempty"`
	AccountGT           *string  `json:"accountGT,omitempty"`
	AccountGTE          *string  `json:"accountGTE,omitempty"`
	AccountLT           *string  `json:"accountLT,omitempty"`
	AccountLTE          *string  `json:"accountLTE,omitempty"`
	AccountContains     *string  `json:"accountContains,omitempty"`
	AccountHasPrefix    *string  `json:"accountHasPrefix,omitempty"`
	AccountHasSuffix    *string  `json:"accountHasSuffix,omitempty"`
	AccountEqualFold    *string  `json:"accountEqualFold,omitempty"`
	AccountContainsFold *string  `json:"accountContainsFold,omitempty"`

	// "label" field predicates.
	Label             *string  `json:"label,omitempty"`
	LabelNEQ          *string  `json:"labelNEQ,omitempty"`
	LabelIn           []string `json:"labelIn,omitempty"`
	LabelNotIn        []string `json:"labelNotIn,omitempty"`
	LabelGT           *string  `json:"labelGT,omitempty"`
	LabelGTE          *string  `json:"labelGTE,omitempty"`
	LabelLT           *string  `json:"labelLT,omitempty"`
	LabelLTE          *string  `json:"labelLTE,omitempty"`
	LabelContains     *string  `json:"labelContains,omitempty"`
	LabelHasPrefix    *string  `json:"labelHasPrefix,omitempty"`
	LabelHasSuffix    *string  `json:"labelHasSuffix,omitempty"`
	LabelEqualFold    *string  `json:"labelEqualFold,omitempty"`
	LabelContainsFold *string  `json:"labelContainsFold,omitempty"`

	// "amount" field predicates.
	Amount      *float64  `json:"amount,omitempty"`
	AmountNEQ   *float64  `json:"amountNEQ,omitempty"`
	AmountIn    []float64 `json:"amountIn,omitempty"`
	AmountNotIn []float64 `json:"amountNotIn,omitempty"`
	AmountGT    *float64  `json:"amountGT,omitempty"`
	AmountGTE   *float64  `json:"amountGTE,omitempty"`
	AmountLT    *float64  `json:"amountLT,omitempty"`
	AmountLTE   *float64  `json:"amountLTE,omitempty"`

	// "description" field predicates.
	Description             *string  `json:"description,omitempty"`
	DescriptionNEQ          *string  `json:"descriptionNEQ,omitempty"`
	DescriptionIn           []string `json:"descriptionIn,omitempty"`
	DescriptionNotIn        []string `json:"descriptionNotIn,omitempty"`
	DescriptionGT           *string  `json:"descriptionGT,omitempty"`
	DescriptionGTE          *string  `json:"descriptionGTE,omitempty"`
	DescriptionLT           *string  `json:"descriptionLT,omitempty"`
	DescriptionLTE          *string  `json:"descriptionLTE,omitempty"`
	DescriptionContains     *string  `json:"descriptionContains,omitempty"`
	DescriptionHasPrefix    *string  `json:"descriptionHasPrefix,omitempty"`
	DescriptionHasSuffix    *string  `json:"descriptionHasSuffix,omitempty"`
	DescriptionEqualFold    *string  `json:"descriptionEqualFold,omitempty"`
	DescriptionContainsFold *string  `json:"descriptionContainsFold,omitempty"`

	// "accountType" field predicates.
	AccountType      *accountingentry.AccountType  `json:"accounttype,omitempty"`
	AccountTypeNEQ   *accountingentry.AccountType  `json:"accounttypeNEQ,omitempty"`
	AccountTypeIn    []accountingentry.AccountType `json:"accounttypeIn,omitempty"`
	AccountTypeNotIn []accountingentry.AccountType `json:"accounttypeNotIn,omitempty"`

	// "category" field predicates.
	Category             *string  `json:"category,omitempty"`
	CategoryNEQ          *string  `json:"categoryNEQ,omitempty"`
	CategoryIn           []string `json:"categoryIn,omitempty"`
	CategoryNotIn        []string `json:"categoryNotIn,omitempty"`
	CategoryGT           *string  `json:"categoryGT,omitempty"`
	CategoryGTE          *string  `json:"categoryGTE,omitempty"`
	CategoryLT           *string  `json:"categoryLT,omitempty"`
	CategoryLTE          *string  `json:"categoryLTE,omitempty"`
	CategoryContains     *string  `json:"categoryContains,omitempty"`
	CategoryHasPrefix    *string  `json:"categoryHasPrefix,omitempty"`
	CategoryHasSuffix    *string  `json:"categoryHasSuffix,omitempty"`
	CategoryEqualFold    *string  `json:"categoryEqualFold,omitempty"`
	CategoryContainsFold *string  `json:"categoryContainsFold,omitempty"`

	// "isDebit" field predicates.
	IsDebit    *bool `json:"isdebit,omitempty"`
	IsDebitNEQ *bool `json:"isdebitNEQ,omitempty"`

	// "isReversal" field predicates.
	IsReversal    *bool `json:"isreversal,omitempty"`
	IsReversalNEQ *bool `json:"isreversalNEQ,omitempty"`

	// "reversed" field predicates.
	Reversed    *bool `json:"reversed,omitempty"`
	ReversedNEQ *bool `json:"reversedNEQ,omitempty"`

	// "company" edge predicates.
	HasCompany     *bool                `json:"hasCompany,omitempty"`
	HasCompanyWith []*CompanyWhereInput `json:"hasCompanyWith,omitempty"`

	// "user" edge predicates.
	HasUser     *bool             `json:"hasUser,omitempty"`
	HasUserWith []*UserWhereInput `json:"hasUserWith,omitempty"`

	// "loan" edge predicates.
	HasLoan     *bool             `json:"hasLoan,omitempty"`
	HasLoanWith []*LoanWhereInput `json:"hasLoanWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *AccountingEntryWhereInput) AddPredicates(predicates ...predicate.AccountingEntry) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the AccountingEntryWhereInput filter on the AccountingEntryQuery builder.
func (i *AccountingEntryWhereInput) Filter(q *AccountingEntryQuery) (*AccountingEntryQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyAccountingEntryWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyAccountingEntryWhereInput is returned in case the AccountingEntryWhereInput is empty.
var ErrEmptyAccountingEntryWhereInput = errors.New("generated: empty predicate AccountingEntryWhereInput")

// P returns a predicate for filtering accountingentries.
// An error is returned if the input is empty or invalid.
func (i *AccountingEntryWhereInput) P() (predicate.AccountingEntry, error) {
	var predicates []predicate.AccountingEntry
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, accountingentry.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.AccountingEntry, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, accountingentry.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.AccountingEntry, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, accountingentry.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, accountingentry.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, accountingentry.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, accountingentry.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, accountingentry.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, accountingentry.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, accountingentry.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, accountingentry.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, accountingentry.IDLTE(*i.IDLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, accountingentry.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, accountingentry.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, accountingentry.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, accountingentry.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, accountingentry.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, accountingentry.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, accountingentry.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, accountingentry.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, accountingentry.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, accountingentry.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, accountingentry.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, accountingentry.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, accountingentry.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, accountingentry.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, accountingentry.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, accountingentry.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.DeletedAt != nil {
		predicates = append(predicates, accountingentry.DeletedAtEQ(*i.DeletedAt))
	}
	if i.DeletedAtNEQ != nil {
		predicates = append(predicates, accountingentry.DeletedAtNEQ(*i.DeletedAtNEQ))
	}
	if len(i.DeletedAtIn) > 0 {
		predicates = append(predicates, accountingentry.DeletedAtIn(i.DeletedAtIn...))
	}
	if len(i.DeletedAtNotIn) > 0 {
		predicates = append(predicates, accountingentry.DeletedAtNotIn(i.DeletedAtNotIn...))
	}
	if i.DeletedAtGT != nil {
		predicates = append(predicates, accountingentry.DeletedAtGT(*i.DeletedAtGT))
	}
	if i.DeletedAtGTE != nil {
		predicates = append(predicates, accountingentry.DeletedAtGTE(*i.DeletedAtGTE))
	}
	if i.DeletedAtLT != nil {
		predicates = append(predicates, accountingentry.DeletedAtLT(*i.DeletedAtLT))
	}
	if i.DeletedAtLTE != nil {
		predicates = append(predicates, accountingentry.DeletedAtLTE(*i.DeletedAtLTE))
	}
	if i.DeletedAtIsNil {
		predicates = append(predicates, accountingentry.DeletedAtIsNil())
	}
	if i.DeletedAtNotNil {
		predicates = append(predicates, accountingentry.DeletedAtNotNil())
	}
	if i.Number != nil {
		predicates = append(predicates, accountingentry.NumberEQ(*i.Number))
	}
	if i.NumberNEQ != nil {
		predicates = append(predicates, accountingentry.NumberNEQ(*i.NumberNEQ))
	}
	if len(i.NumberIn) > 0 {
		predicates = append(predicates, accountingentry.NumberIn(i.NumberIn...))
	}
	if len(i.NumberNotIn) > 0 {
		predicates = append(predicates, accountingentry.NumberNotIn(i.NumberNotIn...))
	}
	if i.NumberGT != nil {
		predicates = append(predicates, accountingentry.NumberGT(*i.NumberGT))
	}
	if i.NumberGTE != nil {
		predicates = append(predicates, accountingentry.NumberGTE(*i.NumberGTE))
	}
	if i.NumberLT != nil {
		predicates = append(predicates, accountingentry.NumberLT(*i.NumberLT))
	}
	if i.NumberLTE != nil {
		predicates = append(predicates, accountingentry.NumberLTE(*i.NumberLTE))
	}
	if i.Group != nil {
		predicates = append(predicates, accountingentry.GroupEQ(*i.Group))
	}
	if i.GroupNEQ != nil {
		predicates = append(predicates, accountingentry.GroupNEQ(*i.GroupNEQ))
	}
	if len(i.GroupIn) > 0 {
		predicates = append(predicates, accountingentry.GroupIn(i.GroupIn...))
	}
	if len(i.GroupNotIn) > 0 {
		predicates = append(predicates, accountingentry.GroupNotIn(i.GroupNotIn...))
	}
	if i.GroupGT != nil {
		predicates = append(predicates, accountingentry.GroupGT(*i.GroupGT))
	}
	if i.GroupGTE != nil {
		predicates = append(predicates, accountingentry.GroupGTE(*i.GroupGTE))
	}
	if i.GroupLT != nil {
		predicates = append(predicates, accountingentry.GroupLT(*i.GroupLT))
	}
	if i.GroupLTE != nil {
		predicates = append(predicates, accountingentry.GroupLTE(*i.GroupLTE))
	}
	if i.Date != nil {
		predicates = append(predicates, accountingentry.DateEQ(*i.Date))
	}
	if i.DateNEQ != nil {
		predicates = append(predicates, accountingentry.DateNEQ(*i.DateNEQ))
	}
	if len(i.DateIn) > 0 {
		predicates = append(predicates, accountingentry.DateIn(i.DateIn...))
	}
	if len(i.DateNotIn) > 0 {
		predicates = append(predicates, accountingentry.DateNotIn(i.DateNotIn...))
	}
	if i.DateGT != nil {
		predicates = append(predicates, accountingentry.DateGT(*i.DateGT))
	}
	if i.DateGTE != nil {
		predicates = append(predicates, accountingentry.DateGTE(*i.DateGTE))
	}
	if i.DateLT != nil {
		predicates = append(predicates, accountingentry.DateLT(*i.DateLT))
	}
	if i.DateLTE != nil {
		predicates = append(predicates, accountingentry.DateLTE(*i.DateLTE))
	}
	if i.Account != nil {
		predicates = append(predicates, accountingentry.AccountEQ(*i.Account))
	}
	if i.AccountNEQ != nil {
		predicates = append(predicates, accountingentry.AccountNEQ(*i.AccountNEQ))
	}
	if len(i.AccountIn) > 0 {
		predicates = append(predicates, accountingentry.AccountIn(i.AccountIn...))
	}
	if len(i.AccountNotIn) > 0 {
		predicates = append(predicates, accountingentry.AccountNotIn(i.AccountNotIn...))
	}
	if i.AccountGT != nil {
		predicates = append(predicates, accountingentry.AccountGT(*i.AccountGT))
	}
	if i.AccountGTE != nil {
		predicates = append(predicates, accountingentry.AccountGTE(*i.AccountGTE))
	}
	if i.AccountLT != nil {
		predicates = append(predicates, accountingentry.AccountLT(*i.AccountLT))
	}
	if i.AccountLTE != nil {
		predicates = append(predicates, accountingentry.AccountLTE(*i.AccountLTE))
	}
	if i.AccountContains != nil {
		predicates = append(predicates, accountingentry.AccountContains(*i.AccountContains))
	}
	if i.AccountHasPrefix != nil {
		predicates = append(predicates, accountingentry.AccountHasPrefix(*i.AccountHasPrefix))
	}
	if i.AccountHasSuffix != nil {
		predicates = append(predicates, accountingentry.AccountHasSuffix(*i.AccountHasSuffix))
	}
	if i.AccountEqualFold != nil {
		predicates = append(predicates, accountingentry.AccountEqualFold(*i.AccountEqualFold))
	}
	if i.AccountContainsFold != nil {
		predicates = append(predicates, accountingentry.AccountContainsFold(*i.AccountContainsFold))
	}
	if i.Label != nil {
		predicates = append(predicates, accountingentry.LabelEQ(*i.Label))
	}
	if i.LabelNEQ != nil {
		predicates = append(predicates, accountingentry.LabelNEQ(*i.LabelNEQ))
	}
	if len(i.LabelIn) > 0 {
		predicates = append(predicates, accountingentry.LabelIn(i.LabelIn...))
	}
	if len(i.LabelNotIn) > 0 {
		predicates = append(predicates, accountingentry.LabelNotIn(i.LabelNotIn...))
	}
	if i.LabelGT != nil {
		predicates = append(predicates, accountingentry.LabelGT(*i.LabelGT))
	}
	if i.LabelGTE != nil {
		predicates = append(predicates, accountingentry.LabelGTE(*i.LabelGTE))
	}
	if i.LabelLT != nil {
		predicates = append(predicates, accountingentry.LabelLT(*i.LabelLT))
	}
	if i.LabelLTE != nil {
		predicates = append(predicates, accountingentry.LabelLTE(*i.LabelLTE))
	}
	if i.LabelContains != nil {
		predicates = append(predicates, accountingentry.LabelContains(*i.LabelContains))
	}
	if i.LabelHasPrefix != nil {
		predicates = append(predicates, accountingentry.LabelHasPrefix(*i.LabelHasPrefix))
	}
	if i.LabelHasSuffix != nil {
		predicates = append(predicates, accountingentry.LabelHasSuffix(*i.LabelHasSuffix))
	}
	if i.LabelEqualFold != nil {
		predicates = append(predicates, accountingentry.LabelEqualFold(*i.LabelEqualFold))
	}
	if i.LabelContainsFold != nil {
		predicates = append(predicates, accountingentry.LabelContainsFold(*i.LabelContainsFold))
	}
	if i.Amount != nil {
		predicates = append(predicates, accountingentry.AmountEQ(*i.Amount))
	}
	if i.AmountNEQ != nil {
		predicates = append(predicates, accountingentry.AmountNEQ(*i.AmountNEQ))
	}
	if len(i.AmountIn) > 0 {
		predicates = append(predicates, accountingentry.AmountIn(i.AmountIn...))
	}
	if len(i.AmountNotIn) > 0 {
		predicates = append(predicates, accountingentry.AmountNotIn(i.AmountNotIn...))
	}
	if i.AmountGT != nil {
		predicates = append(predicates, accountingentry.AmountGT(*i.AmountGT))
	}
	if i.AmountGTE != nil {
		predicates = append(predicates, accountingentry.AmountGTE(*i.AmountGTE))
	}
	if i.AmountLT != nil {
		predicates = append(predicates, accountingentry.AmountLT(*i.AmountLT))
	}
	if i.AmountLTE != nil {
		predicates = append(predicates, accountingentry.AmountLTE(*i.AmountLTE))
	}
	if i.Description != nil {
		predicates = append(predicates, accountingentry.DescriptionEQ(*i.Description))
	}
	if i.DescriptionNEQ != nil {
		predicates = append(predicates, accountingentry.DescriptionNEQ(*i.DescriptionNEQ))
	}
	if len(i.DescriptionIn) > 0 {
		predicates = append(predicates, accountingentry.DescriptionIn(i.DescriptionIn...))
	}
	if len(i.DescriptionNotIn) > 0 {
		predicates = append(predicates, accountingentry.DescriptionNotIn(i.DescriptionNotIn...))
	}
	if i.DescriptionGT != nil {
		predicates = append(predicates, accountingentry.DescriptionGT(*i.DescriptionGT))
	}
	if i.DescriptionGTE != nil {
		predicates = append(predicates, accountingentry.DescriptionGTE(*i.DescriptionGTE))
	}
	if i.DescriptionLT != nil {
		predicates = append(predicates, accountingentry.DescriptionLT(*i.DescriptionLT))
	}
	if i.DescriptionLTE != nil {
		predicates = append(predicates, accountingentry.DescriptionLTE(*i.DescriptionLTE))
	}
	if i.DescriptionContains != nil {
		predicates = append(predicates, accountingentry.DescriptionContains(*i.DescriptionContains))
	}
	if i.DescriptionHasPrefix != nil {
		predicates = append(predicates, accountingentry.DescriptionHasPrefix(*i.DescriptionHasPrefix))
	}
	if i.DescriptionHasSuffix != nil {
		predicates = append(predicates, accountingentry.DescriptionHasSuffix(*i.DescriptionHasSuffix))
	}
	if i.DescriptionEqualFold != nil {
		predicates = append(predicates, accountingentry.DescriptionEqualFold(*i.DescriptionEqualFold))
	}
	if i.DescriptionContainsFold != nil {
		predicates = append(predicates, accountingentry.DescriptionContainsFold(*i.DescriptionContainsFold))
	}
	if i.AccountType != nil {
		predicates = append(predicates, accountingentry.AccountTypeEQ(*i.AccountType))
	}
	if i.AccountTypeNEQ != nil {
		predicates = append(predicates, accountingentry.AccountTypeNEQ(*i.AccountTypeNEQ))
	}
	if len(i.AccountTypeIn) > 0 {
		predicates = append(predicates, accountingentry.AccountTypeIn(i.AccountTypeIn...))
	}
	if len(i.AccountTypeNotIn) > 0 {
		predicates = append(predicates, accountingentry.AccountTypeNotIn(i.AccountTypeNotIn...))
	}
	if i.Category != nil {
		predicates = append(predicates, accountingentry.CategoryEQ(*i.Category))
	}
	if i.CategoryNEQ != nil {
		predicates = append(predicates, accountingentry.CategoryNEQ(*i.CategoryNEQ))
	}
	if len(i.CategoryIn) > 0 {
		predicates = append(predicates, accountingentry.CategoryIn(i.CategoryIn...))
	}
	if len(i.CategoryNotIn) > 0 {
		predicates = append(predicates, accountingentry.CategoryNotIn(i.CategoryNotIn...))
	}
	if i.CategoryGT != nil {
		predicates = append(predicates, accountingentry.CategoryGT(*i.CategoryGT))
	}
	if i.CategoryGTE != nil {
		predicates = append(predicates, accountingentry.CategoryGTE(*i.CategoryGTE))
	}
	if i.CategoryLT != nil {
		predicates = append(predicates, accountingentry.CategoryLT(*i.CategoryLT))
	}
	if i.CategoryLTE != nil {
		predicates = append(predicates, accountingentry.CategoryLTE(*i.CategoryLTE))
	}
	if i.CategoryContains != nil {
		predicates = append(predicates, accountingentry.CategoryContains(*i.CategoryContains))
	}
	if i.CategoryHasPrefix != nil {
		predicates = append(predicates, accountingentry.CategoryHasPrefix(*i.CategoryHasPrefix))
	}
	if i.CategoryHasSuffix != nil {
		predicates = append(predicates, accountingentry.CategoryHasSuffix(*i.CategoryHasSuffix))
	}
	if i.CategoryEqualFold != nil {
		predicates = append(predicates, accountingentry.CategoryEqualFold(*i.CategoryEqualFold))
	}
	if i.CategoryContainsFold != nil {
		predicates = append(predicates, accountingentry.CategoryContainsFold(*i.CategoryContainsFold))
	}
	if i.IsDebit != nil {
		predicates = append(predicates, accountingentry.IsDebitEQ(*i.IsDebit))
	}
	if i.IsDebitNEQ != nil {
		predicates = append(predicates, accountingentry.IsDebitNEQ(*i.IsDebitNEQ))
	}
	if i.IsReversal != nil {
		predicates = append(predicates, accountingentry.IsReversalEQ(*i.IsReversal))
	}
	if i.IsReversalNEQ != nil {
		predicates = append(predicates, accountingentry.IsReversalNEQ(*i.IsReversalNEQ))
	}
	if i.Reversed != nil {
		predicates = append(predicates, accountingentry.ReversedEQ(*i.Reversed))
	}
	if i.ReversedNEQ != nil {
		predicates = append(predicates, accountingentry.ReversedNEQ(*i.ReversedNEQ))
	}

	if i.HasCompany != nil {
		p := accountingentry.HasCompany()
		if !*i.HasCompany {
			p = accountingentry.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasCompanyWith) > 0 {
		with := make([]predicate.Company, 0, len(i.HasCompanyWith))
		for _, w := range i.HasCompanyWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasCompanyWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, accountingentry.HasCompanyWith(with...))
	}
	if i.HasUser != nil {
		p := accountingentry.HasUser()
		if !*i.HasUser {
			p = accountingentry.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasUserWith) > 0 {
		with := make([]predicate.User, 0, len(i.HasUserWith))
		for _, w := range i.HasUserWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasUserWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, accountingentry.HasUserWith(with...))
	}
	if i.HasLoan != nil {
		p := accountingentry.HasLoan()
		if !*i.HasLoan {
			p = accountingentry.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasLoanWith) > 0 {
		with := make([]predicate.Loan, 0, len(i.HasLoanWith))
		for _, w := range i.HasLoanWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasLoanWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, accountingentry.HasLoanWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyAccountingEntryWhereInput
	case 1:
		return predicates[0], nil
	default:
		return accountingentry.And(predicates...), nil
	}
}

// CompanyWhereInput represents a where input for filtering Company queries.
type CompanyWhereInput struct {
	Predicates []predicate.Company  `json:"-"`
	Not        *CompanyWhereInput   `json:"not,omitempty"`
	Or         []*CompanyWhereInput `json:"or,omitempty"`
	And        []*CompanyWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "createdAt" field predicates.
	CreatedAt      *time.Time  `json:"createdat,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdatNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdatIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdatNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdatGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdatGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdatLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdatLTE,omitempty"`

	// "updatedAt" field predicates.
	UpdatedAt      *time.Time  `json:"updatedat,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedatNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedatIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedatNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedatGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedatGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedatLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedatLTE,omitempty"`

	// "deletedAt" field predicates.
	DeletedAt       *time.Time  `json:"deletedat,omitempty"`
	DeletedAtNEQ    *time.Time  `json:"deletedatNEQ,omitempty"`
	DeletedAtIn     []time.Time `json:"deletedatIn,omitempty"`
	DeletedAtNotIn  []time.Time `json:"deletedatNotIn,omitempty"`
	DeletedAtGT     *time.Time  `json:"deletedatGT,omitempty"`
	DeletedAtGTE    *time.Time  `json:"deletedatGTE,omitempty"`
	DeletedAtLT     *time.Time  `json:"deletedatLT,omitempty"`
	DeletedAtLTE    *time.Time  `json:"deletedatLTE,omitempty"`
	DeletedAtIsNil  bool        `json:"deletedatIsNil,omitempty"`
	DeletedAtNotNil bool        `json:"deletedatNotNil,omitempty"`

	// "address" field predicates.
	Address             *string  `json:"address,omitempty"`
	AddressNEQ          *string  `json:"addressNEQ,omitempty"`
	AddressIn           []string `json:"addressIn,omitempty"`
	AddressNotIn        []string `json:"addressNotIn,omitempty"`
	AddressGT           *string  `json:"addressGT,omitempty"`
	AddressGTE          *string  `json:"addressGTE,omitempty"`
	AddressLT           *string  `json:"addressLT,omitempty"`
	AddressLTE          *string  `json:"addressLTE,omitempty"`
	AddressContains     *string  `json:"addressContains,omitempty"`
	AddressHasPrefix    *string  `json:"addressHasPrefix,omitempty"`
	AddressHasSuffix    *string  `json:"addressHasSuffix,omitempty"`
	AddressIsNil        bool     `json:"addressIsNil,omitempty"`
	AddressNotNil       bool     `json:"addressNotNil,omitempty"`
	AddressEqualFold    *string  `json:"addressEqualFold,omitempty"`
	AddressContainsFold *string  `json:"addressContainsFold,omitempty"`

	// "baseCurrency" field predicates.
	BaseCurrency             *string  `json:"basecurrency,omitempty"`
	BaseCurrencyNEQ          *string  `json:"basecurrencyNEQ,omitempty"`
	BaseCurrencyIn           []string `json:"basecurrencyIn,omitempty"`
	BaseCurrencyNotIn        []string `json:"basecurrencyNotIn,omitempty"`
	BaseCurrencyGT           *string  `json:"basecurrencyGT,omitempty"`
	BaseCurrencyGTE          *string  `json:"basecurrencyGTE,omitempty"`
	BaseCurrencyLT           *string  `json:"basecurrencyLT,omitempty"`
	BaseCurrencyLTE          *string  `json:"basecurrencyLTE,omitempty"`
	BaseCurrencyContains     *string  `json:"basecurrencyContains,omitempty"`
	BaseCurrencyHasPrefix    *string  `json:"basecurrencyHasPrefix,omitempty"`
	BaseCurrencyHasSuffix    *string  `json:"basecurrencyHasSuffix,omitempty"`
	BaseCurrencyEqualFold    *string  `json:"basecurrencyEqualFold,omitempty"`
	BaseCurrencyContainsFold *string  `json:"basecurrencyContainsFold,omitempty"`

	// "ceoName" field predicates.
	CeoName             *string  `json:"ceoname,omitempty"`
	CeoNameNEQ          *string  `json:"ceonameNEQ,omitempty"`
	CeoNameIn           []string `json:"ceonameIn,omitempty"`
	CeoNameNotIn        []string `json:"ceonameNotIn,omitempty"`
	CeoNameGT           *string  `json:"ceonameGT,omitempty"`
	CeoNameGTE          *string  `json:"ceonameGTE,omitempty"`
	CeoNameLT           *string  `json:"ceonameLT,omitempty"`
	CeoNameLTE          *string  `json:"ceonameLTE,omitempty"`
	CeoNameContains     *string  `json:"ceonameContains,omitempty"`
	CeoNameHasPrefix    *string  `json:"ceonameHasPrefix,omitempty"`
	CeoNameHasSuffix    *string  `json:"ceonameHasSuffix,omitempty"`
	CeoNameIsNil        bool     `json:"ceonameIsNil,omitempty"`
	CeoNameNotNil       bool     `json:"ceonameNotNil,omitempty"`
	CeoNameEqualFold    *string  `json:"ceonameEqualFold,omitempty"`
	CeoNameContainsFold *string  `json:"ceonameContainsFold,omitempty"`

	// "city" field predicates.
	City             *string  `json:"city,omitempty"`
	CityNEQ          *string  `json:"cityNEQ,omitempty"`
	CityIn           []string `json:"cityIn,omitempty"`
	CityNotIn        []string `json:"cityNotIn,omitempty"`
	CityGT           *string  `json:"cityGT,omitempty"`
	CityGTE          *string  `json:"cityGTE,omitempty"`
	CityLT           *string  `json:"cityLT,omitempty"`
	CityLTE          *string  `json:"cityLTE,omitempty"`
	CityContains     *string  `json:"cityContains,omitempty"`
	CityHasPrefix    *string  `json:"cityHasPrefix,omitempty"`
	CityHasSuffix    *string  `json:"cityHasSuffix,omitempty"`
	CityEqualFold    *string  `json:"cityEqualFold,omitempty"`
	CityContainsFold *string  `json:"cityContainsFold,omitempty"`

	// "country" field predicates.
	Country             *string  `json:"country,omitempty"`
	CountryNEQ          *string  `json:"countryNEQ,omitempty"`
	CountryIn           []string `json:"countryIn,omitempty"`
	CountryNotIn        []string `json:"countryNotIn,omitempty"`
	CountryGT           *string  `json:"countryGT,omitempty"`
	CountryGTE          *string  `json:"countryGTE,omitempty"`
	CountryLT           *string  `json:"countryLT,omitempty"`
	CountryLTE          *string  `json:"countryLTE,omitempty"`
	CountryContains     *string  `json:"countryContains,omitempty"`
	CountryHasPrefix    *string  `json:"countryHasPrefix,omitempty"`
	CountryHasSuffix    *string  `json:"countryHasSuffix,omitempty"`
	CountryEqualFold    *string  `json:"countryEqualFold,omitempty"`
	CountryContainsFold *string  `json:"countryContainsFold,omitempty"`

	// "establishedAt" field predicates.
	EstablishedAt      *time.Time  `json:"establishedat,omitempty"`
	EstablishedAtNEQ   *time.Time  `json:"establishedatNEQ,omitempty"`
	EstablishedAtIn    []time.Time `json:"establishedatIn,omitempty"`
	EstablishedAtNotIn []time.Time `json:"establishedatNotIn,omitempty"`
	EstablishedAtGT    *time.Time  `json:"establishedatGT,omitempty"`
	EstablishedAtGTE   *time.Time  `json:"establishedatGTE,omitempty"`
	EstablishedAtLT    *time.Time  `json:"establishedatLT,omitempty"`
	EstablishedAtLTE   *time.Time  `json:"establishedatLTE,omitempty"`

	// "description" field predicates.
	Description             *string  `json:"description,omitempty"`
	DescriptionNEQ          *string  `json:"descriptionNEQ,omitempty"`
	DescriptionIn           []string `json:"descriptionIn,omitempty"`
	DescriptionNotIn        []string `json:"descriptionNotIn,omitempty"`
	DescriptionGT           *string  `json:"descriptionGT,omitempty"`
	DescriptionGTE          *string  `json:"descriptionGTE,omitempty"`
	DescriptionLT           *string  `json:"descriptionLT,omitempty"`
	DescriptionLTE          *string  `json:"descriptionLTE,omitempty"`
	DescriptionContains     *string  `json:"descriptionContains,omitempty"`
	DescriptionHasPrefix    *string  `json:"descriptionHasPrefix,omitempty"`
	DescriptionHasSuffix    *string  `json:"descriptionHasSuffix,omitempty"`
	DescriptionIsNil        bool     `json:"descriptionIsNil,omitempty"`
	DescriptionNotNil       bool     `json:"descriptionNotNil,omitempty"`
	DescriptionEqualFold    *string  `json:"descriptionEqualFold,omitempty"`
	DescriptionContainsFold *string  `json:"descriptionContainsFold,omitempty"`

	// "email" field predicates.
	Email             *string  `json:"email,omitempty"`
	EmailNEQ          *string  `json:"emailNEQ,omitempty"`
	EmailIn           []string `json:"emailIn,omitempty"`
	EmailNotIn        []string `json:"emailNotIn,omitempty"`
	EmailGT           *string  `json:"emailGT,omitempty"`
	EmailGTE          *string  `json:"emailGTE,omitempty"`
	EmailLT           *string  `json:"emailLT,omitempty"`
	EmailLTE          *string  `json:"emailLTE,omitempty"`
	EmailContains     *string  `json:"emailContains,omitempty"`
	EmailHasPrefix    *string  `json:"emailHasPrefix,omitempty"`
	EmailHasSuffix    *string  `json:"emailHasSuffix,omitempty"`
	EmailIsNil        bool     `json:"emailIsNil,omitempty"`
	EmailNotNil       bool     `json:"emailNotNil,omitempty"`
	EmailEqualFold    *string  `json:"emailEqualFold,omitempty"`
	EmailContainsFold *string  `json:"emailContainsFold,omitempty"`

	// "industry" field predicates.
	Industry             *string  `json:"industry,omitempty"`
	IndustryNEQ          *string  `json:"industryNEQ,omitempty"`
	IndustryIn           []string `json:"industryIn,omitempty"`
	IndustryNotIn        []string `json:"industryNotIn,omitempty"`
	IndustryGT           *string  `json:"industryGT,omitempty"`
	IndustryGTE          *string  `json:"industryGTE,omitempty"`
	IndustryLT           *string  `json:"industryLT,omitempty"`
	IndustryLTE          *string  `json:"industryLTE,omitempty"`
	IndustryContains     *string  `json:"industryContains,omitempty"`
	IndustryHasPrefix    *string  `json:"industryHasPrefix,omitempty"`
	IndustryHasSuffix    *string  `json:"industryHasSuffix,omitempty"`
	IndustryIsNil        bool     `json:"industryIsNil,omitempty"`
	IndustryNotNil       bool     `json:"industryNotNil,omitempty"`
	IndustryEqualFold    *string  `json:"industryEqualFold,omitempty"`
	IndustryContainsFold *string  `json:"industryContainsFold,omitempty"`

	// "lastEntryDate" field predicates.
	LastEntryDate      *time.Time  `json:"lastentrydate,omitempty"`
	LastEntryDateNEQ   *time.Time  `json:"lastentrydateNEQ,omitempty"`
	LastEntryDateIn    []time.Time `json:"lastentrydateIn,omitempty"`
	LastEntryDateNotIn []time.Time `json:"lastentrydateNotIn,omitempty"`
	LastEntryDateGT    *time.Time  `json:"lastentrydateGT,omitempty"`
	LastEntryDateGTE   *time.Time  `json:"lastentrydateGTE,omitempty"`
	LastEntryDateLT    *time.Time  `json:"lastentrydateLT,omitempty"`
	LastEntryDateLTE   *time.Time  `json:"lastentrydateLTE,omitempty"`

	// "lastInvoiceNumber" field predicates.
	LastInvoiceNumber       *int32  `json:"lastinvoicenumber,omitempty"`
	LastInvoiceNumberNEQ    *int32  `json:"lastinvoicenumberNEQ,omitempty"`
	LastInvoiceNumberIn     []int32 `json:"lastinvoicenumberIn,omitempty"`
	LastInvoiceNumberNotIn  []int32 `json:"lastinvoicenumberNotIn,omitempty"`
	LastInvoiceNumberGT     *int32  `json:"lastinvoicenumberGT,omitempty"`
	LastInvoiceNumberGTE    *int32  `json:"lastinvoicenumberGTE,omitempty"`
	LastInvoiceNumberLT     *int32  `json:"lastinvoicenumberLT,omitempty"`
	LastInvoiceNumberLTE    *int32  `json:"lastinvoicenumberLTE,omitempty"`
	LastInvoiceNumberIsNil  bool    `json:"lastinvoicenumberIsNil,omitempty"`
	LastInvoiceNumberNotNil bool    `json:"lastinvoicenumberNotNil,omitempty"`

	// "logoURL" field predicates.
	LogoURL             *string  `json:"logourl,omitempty"`
	LogoURLNEQ          *string  `json:"logourlNEQ,omitempty"`
	LogoURLIn           []string `json:"logourlIn,omitempty"`
	LogoURLNotIn        []string `json:"logourlNotIn,omitempty"`
	LogoURLGT           *string  `json:"logourlGT,omitempty"`
	LogoURLGTE          *string  `json:"logourlGTE,omitempty"`
	LogoURLLT           *string  `json:"logourlLT,omitempty"`
	LogoURLLTE          *string  `json:"logourlLTE,omitempty"`
	LogoURLContains     *string  `json:"logourlContains,omitempty"`
	LogoURLHasPrefix    *string  `json:"logourlHasPrefix,omitempty"`
	LogoURLHasSuffix    *string  `json:"logourlHasSuffix,omitempty"`
	LogoURLIsNil        bool     `json:"logourlIsNil,omitempty"`
	LogoURLNotNil       bool     `json:"logourlNotNil,omitempty"`
	LogoURLEqualFold    *string  `json:"logourlEqualFold,omitempty"`
	LogoURLContainsFold *string  `json:"logourlContainsFold,omitempty"`

	// "logoStorageURI" field predicates.
	LogoStorageURI             *string  `json:"logostorageuri,omitempty"`
	LogoStorageURINEQ          *string  `json:"logostorageuriNEQ,omitempty"`
	LogoStorageURIIn           []string `json:"logostorageuriIn,omitempty"`
	LogoStorageURINotIn        []string `json:"logostorageuriNotIn,omitempty"`
	LogoStorageURIGT           *string  `json:"logostorageuriGT,omitempty"`
	LogoStorageURIGTE          *string  `json:"logostorageuriGTE,omitempty"`
	LogoStorageURILT           *string  `json:"logostorageuriLT,omitempty"`
	LogoStorageURILTE          *string  `json:"logostorageuriLTE,omitempty"`
	LogoStorageURIContains     *string  `json:"logostorageuriContains,omitempty"`
	LogoStorageURIHasPrefix    *string  `json:"logostorageuriHasPrefix,omitempty"`
	LogoStorageURIHasSuffix    *string  `json:"logostorageuriHasSuffix,omitempty"`
	LogoStorageURIIsNil        bool     `json:"logostorageuriIsNil,omitempty"`
	LogoStorageURINotNil       bool     `json:"logostorageuriNotNil,omitempty"`
	LogoStorageURIEqualFold    *string  `json:"logostorageuriEqualFold,omitempty"`
	LogoStorageURIContainsFold *string  `json:"logostorageuriContainsFold,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "numberOfEmployees" field predicates.
	NumberOfEmployees      *int32  `json:"numberofemployees,omitempty"`
	NumberOfEmployeesNEQ   *int32  `json:"numberofemployeesNEQ,omitempty"`
	NumberOfEmployeesIn    []int32 `json:"numberofemployeesIn,omitempty"`
	NumberOfEmployeesNotIn []int32 `json:"numberofemployeesNotIn,omitempty"`
	NumberOfEmployeesGT    *int32  `json:"numberofemployeesGT,omitempty"`
	NumberOfEmployeesGTE   *int32  `json:"numberofemployeesGTE,omitempty"`
	NumberOfEmployeesLT    *int32  `json:"numberofemployeesLT,omitempty"`
	NumberOfEmployeesLTE   *int32  `json:"numberofemployeesLTE,omitempty"`

	// "phone" field predicates.
	Phone             *string  `json:"phone,omitempty"`
	PhoneNEQ          *string  `json:"phoneNEQ,omitempty"`
	PhoneIn           []string `json:"phoneIn,omitempty"`
	PhoneNotIn        []string `json:"phoneNotIn,omitempty"`
	PhoneGT           *string  `json:"phoneGT,omitempty"`
	PhoneGTE          *string  `json:"phoneGTE,omitempty"`
	PhoneLT           *string  `json:"phoneLT,omitempty"`
	PhoneLTE          *string  `json:"phoneLTE,omitempty"`
	PhoneContains     *string  `json:"phoneContains,omitempty"`
	PhoneHasPrefix    *string  `json:"phoneHasPrefix,omitempty"`
	PhoneHasSuffix    *string  `json:"phoneHasSuffix,omitempty"`
	PhoneIsNil        bool     `json:"phoneIsNil,omitempty"`
	PhoneNotNil       bool     `json:"phoneNotNil,omitempty"`
	PhoneEqualFold    *string  `json:"phoneEqualFold,omitempty"`
	PhoneContainsFold *string  `json:"phoneContainsFold,omitempty"`

	// "taxId" field predicates.
	TaxId             *string  `json:"taxid,omitempty"`
	TaxIdNEQ          *string  `json:"taxidNEQ,omitempty"`
	TaxIdIn           []string `json:"taxidIn,omitempty"`
	TaxIdNotIn        []string `json:"taxidNotIn,omitempty"`
	TaxIdGT           *string  `json:"taxidGT,omitempty"`
	TaxIdGTE          *string  `json:"taxidGTE,omitempty"`
	TaxIdLT           *string  `json:"taxidLT,omitempty"`
	TaxIdLTE          *string  `json:"taxidLTE,omitempty"`
	TaxIdContains     *string  `json:"taxidContains,omitempty"`
	TaxIdHasPrefix    *string  `json:"taxidHasPrefix,omitempty"`
	TaxIdHasSuffix    *string  `json:"taxidHasSuffix,omitempty"`
	TaxIdEqualFold    *string  `json:"taxidEqualFold,omitempty"`
	TaxIdContainsFold *string  `json:"taxidContainsFold,omitempty"`

	// "vatRate" field predicates.
	VatRate      *float64  `json:"vatrate,omitempty"`
	VatRateNEQ   *float64  `json:"vatrateNEQ,omitempty"`
	VatRateIn    []float64 `json:"vatrateIn,omitempty"`
	VatRateNotIn []float64 `json:"vatrateNotIn,omitempty"`
	VatRateGT    *float64  `json:"vatrateGT,omitempty"`
	VatRateGTE   *float64  `json:"vatrateGTE,omitempty"`
	VatRateLT    *float64  `json:"vatrateLT,omitempty"`
	VatRateLTE   *float64  `json:"vatrateLTE,omitempty"`

	// "website" field predicates.
	Website             *string  `json:"website,omitempty"`
	WebsiteNEQ          *string  `json:"websiteNEQ,omitempty"`
	WebsiteIn           []string `json:"websiteIn,omitempty"`
	WebsiteNotIn        []string `json:"websiteNotIn,omitempty"`
	WebsiteGT           *string  `json:"websiteGT,omitempty"`
	WebsiteGTE          *string  `json:"websiteGTE,omitempty"`
	WebsiteLT           *string  `json:"websiteLT,omitempty"`
	WebsiteLTE          *string  `json:"websiteLTE,omitempty"`
	WebsiteContains     *string  `json:"websiteContains,omitempty"`
	WebsiteHasPrefix    *string  `json:"websiteHasPrefix,omitempty"`
	WebsiteHasSuffix    *string  `json:"websiteHasSuffix,omitempty"`
	WebsiteIsNil        bool     `json:"websiteIsNil,omitempty"`
	WebsiteNotNil       bool     `json:"websiteNotNil,omitempty"`
	WebsiteEqualFold    *string  `json:"websiteEqualFold,omitempty"`
	WebsiteContainsFold *string  `json:"websiteContainsFold,omitempty"`

	// "incompleteSetup" field predicates.
	IncompleteSetup       *bool `json:"incompletesetup,omitempty"`
	IncompleteSetupNEQ    *bool `json:"incompletesetupNEQ,omitempty"`
	IncompleteSetupIsNil  bool  `json:"incompletesetupIsNil,omitempty"`
	IncompleteSetupNotNil bool  `json:"incompletesetupNotNil,omitempty"`

	// "availableRoles" edge predicates.
	HasAvailableRoles     *bool                 `json:"hasAvailableRoles,omitempty"`
	HasAvailableRolesWith []*UserRoleWhereInput `json:"hasAvailableRolesWith,omitempty"`

	// "accountingEntries" edge predicates.
	HasAccountingEntries     *bool                        `json:"hasAccountingEntries,omitempty"`
	HasAccountingEntriesWith []*AccountingEntryWhereInput `json:"hasAccountingEntriesWith,omitempty"`

	// "customers" edge predicates.
	HasCustomers     *bool                 `json:"hasCustomers,omitempty"`
	HasCustomersWith []*CustomerWhereInput `json:"hasCustomersWith,omitempty"`

	// "documents" edge predicates.
	HasDocuments     *bool                        `json:"hasDocuments,omitempty"`
	HasDocumentsWith []*CompanyDocumentWhereInput `json:"hasDocumentsWith,omitempty"`

	// "employees" edge predicates.
	HasEmployees     *bool                 `json:"hasEmployees,omitempty"`
	HasEmployeesWith []*EmployeeWhereInput `json:"hasEmployeesWith,omitempty"`

	// "files" edge predicates.
	HasFiles     *bool             `json:"hasFiles,omitempty"`
	HasFilesWith []*FileWhereInput `json:"hasFilesWith,omitempty"`

	// "inventory" edge predicates.
	HasInventory     *bool                  `json:"hasInventory,omitempty"`
	HasInventoryWith []*InventoryWhereInput `json:"hasInventoryWith,omitempty"`

	// "inventoryMovements" edge predicates.
	HasInventoryMovements     *bool                          `json:"hasInventoryMovements,omitempty"`
	HasInventoryMovementsWith []*InventoryMovementWhereInput `json:"hasInventoryMovementsWith,omitempty"`

	// "invoices" edge predicates.
	HasInvoices     *bool                `json:"hasInvoices,omitempty"`
	HasInvoicesWith []*InvoiceWhereInput `json:"hasInvoicesWith,omitempty"`

	// "loans" edge predicates.
	HasLoans     *bool             `json:"hasLoans,omitempty"`
	HasLoansWith []*LoanWhereInput `json:"hasLoansWith,omitempty"`

	// "memberSignupTokens" edge predicates.
	HasMemberSignupTokens     *bool                          `json:"hasMemberSignupTokens,omitempty"`
	HasMemberSignupTokensWith []*MemberSignupTokenWhereInput `json:"hasMemberSignupTokensWith,omitempty"`

	// "products" edge predicates.
	HasProducts     *bool                `json:"hasProducts,omitempty"`
	HasProductsWith []*ProductWhereInput `json:"hasProductsWith,omitempty"`

	// "projects" edge predicates.
	HasProjects     *bool                `json:"hasProjects,omitempty"`
	HasProjectsWith []*ProjectWhereInput `json:"hasProjectsWith,omitempty"`

	// "payables" edge predicates.
	HasPayables     *bool                `json:"hasPayables,omitempty"`
	HasPayablesWith []*PayableWhereInput `json:"hasPayablesWith,omitempty"`

	// "receivables" edge predicates.
	HasReceivables     *bool                   `json:"hasReceivables,omitempty"`
	HasReceivablesWith []*ReceivableWhereInput `json:"hasReceivablesWith,omitempty"`

	// "suppliers" edge predicates.
	HasSuppliers     *bool                 `json:"hasSuppliers,omitempty"`
	HasSuppliersWith []*SupplierWhereInput `json:"hasSuppliersWith,omitempty"`

	// "tokens" edge predicates.
	HasTokens     *bool              `json:"hasTokens,omitempty"`
	HasTokensWith []*TokenWhereInput `json:"hasTokensWith,omitempty"`

	// "treasuries" edge predicates.
	HasTreasuries     *bool                 `json:"hasTreasuries,omitempty"`
	HasTreasuriesWith []*TreasuryWhereInput `json:"hasTreasuriesWith,omitempty"`

	// "workShifts" edge predicates.
	HasWorkShifts     *bool                  `json:"hasWorkShifts,omitempty"`
	HasWorkShiftsWith []*WorkshiftWhereInput `json:"hasWorkShiftsWith,omitempty"`

	// "users" edge predicates.
	HasUsers     *bool             `json:"hasUsers,omitempty"`
	HasUsersWith []*UserWhereInput `json:"hasUsersWith,omitempty"`

	// "daughterCompanies" edge predicates.
	HasDaughterCompanies     *bool                `json:"hasDaughterCompanies,omitempty"`
	HasDaughterCompaniesWith []*CompanyWhereInput `json:"hasDaughterCompaniesWith,omitempty"`

	// "parentCompany" edge predicates.
	HasParentCompany     *bool                `json:"hasParentCompany,omitempty"`
	HasParentCompanyWith []*CompanyWhereInput `json:"hasParentCompanyWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *CompanyWhereInput) AddPredicates(predicates ...predicate.Company) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the CompanyWhereInput filter on the CompanyQuery builder.
func (i *CompanyWhereInput) Filter(q *CompanyQuery) (*CompanyQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyCompanyWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyCompanyWhereInput is returned in case the CompanyWhereInput is empty.
var ErrEmptyCompanyWhereInput = errors.New("generated: empty predicate CompanyWhereInput")

// P returns a predicate for filtering companies.
// An error is returned if the input is empty or invalid.
func (i *CompanyWhereInput) P() (predicate.Company, error) {
	var predicates []predicate.Company
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, company.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Company, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, company.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Company, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, company.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, company.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, company.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, company.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, company.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, company.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, company.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, company.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, company.IDLTE(*i.IDLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, company.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, company.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, company.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, company.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, company.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, company.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, company.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, company.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, company.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, company.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, company.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, company.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, company.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, company.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, company.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, company.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.DeletedAt != nil {
		predicates = append(predicates, company.DeletedAtEQ(*i.DeletedAt))
	}
	if i.DeletedAtNEQ != nil {
		predicates = append(predicates, company.DeletedAtNEQ(*i.DeletedAtNEQ))
	}
	if len(i.DeletedAtIn) > 0 {
		predicates = append(predicates, company.DeletedAtIn(i.DeletedAtIn...))
	}
	if len(i.DeletedAtNotIn) > 0 {
		predicates = append(predicates, company.DeletedAtNotIn(i.DeletedAtNotIn...))
	}
	if i.DeletedAtGT != nil {
		predicates = append(predicates, company.DeletedAtGT(*i.DeletedAtGT))
	}
	if i.DeletedAtGTE != nil {
		predicates = append(predicates, company.DeletedAtGTE(*i.DeletedAtGTE))
	}
	if i.DeletedAtLT != nil {
		predicates = append(predicates, company.DeletedAtLT(*i.DeletedAtLT))
	}
	if i.DeletedAtLTE != nil {
		predicates = append(predicates, company.DeletedAtLTE(*i.DeletedAtLTE))
	}
	if i.DeletedAtIsNil {
		predicates = append(predicates, company.DeletedAtIsNil())
	}
	if i.DeletedAtNotNil {
		predicates = append(predicates, company.DeletedAtNotNil())
	}
	if i.Address != nil {
		predicates = append(predicates, company.AddressEQ(*i.Address))
	}
	if i.AddressNEQ != nil {
		predicates = append(predicates, company.AddressNEQ(*i.AddressNEQ))
	}
	if len(i.AddressIn) > 0 {
		predicates = append(predicates, company.AddressIn(i.AddressIn...))
	}
	if len(i.AddressNotIn) > 0 {
		predicates = append(predicates, company.AddressNotIn(i.AddressNotIn...))
	}
	if i.AddressGT != nil {
		predicates = append(predicates, company.AddressGT(*i.AddressGT))
	}
	if i.AddressGTE != nil {
		predicates = append(predicates, company.AddressGTE(*i.AddressGTE))
	}
	if i.AddressLT != nil {
		predicates = append(predicates, company.AddressLT(*i.AddressLT))
	}
	if i.AddressLTE != nil {
		predicates = append(predicates, company.AddressLTE(*i.AddressLTE))
	}
	if i.AddressContains != nil {
		predicates = append(predicates, company.AddressContains(*i.AddressContains))
	}
	if i.AddressHasPrefix != nil {
		predicates = append(predicates, company.AddressHasPrefix(*i.AddressHasPrefix))
	}
	if i.AddressHasSuffix != nil {
		predicates = append(predicates, company.AddressHasSuffix(*i.AddressHasSuffix))
	}
	if i.AddressIsNil {
		predicates = append(predicates, company.AddressIsNil())
	}
	if i.AddressNotNil {
		predicates = append(predicates, company.AddressNotNil())
	}
	if i.AddressEqualFold != nil {
		predicates = append(predicates, company.AddressEqualFold(*i.AddressEqualFold))
	}
	if i.AddressContainsFold != nil {
		predicates = append(predicates, company.AddressContainsFold(*i.AddressContainsFold))
	}
	if i.BaseCurrency != nil {
		predicates = append(predicates, company.BaseCurrencyEQ(*i.BaseCurrency))
	}
	if i.BaseCurrencyNEQ != nil {
		predicates = append(predicates, company.BaseCurrencyNEQ(*i.BaseCurrencyNEQ))
	}
	if len(i.BaseCurrencyIn) > 0 {
		predicates = append(predicates, company.BaseCurrencyIn(i.BaseCurrencyIn...))
	}
	if len(i.BaseCurrencyNotIn) > 0 {
		predicates = append(predicates, company.BaseCurrencyNotIn(i.BaseCurrencyNotIn...))
	}
	if i.BaseCurrencyGT != nil {
		predicates = append(predicates, company.BaseCurrencyGT(*i.BaseCurrencyGT))
	}
	if i.BaseCurrencyGTE != nil {
		predicates = append(predicates, company.BaseCurrencyGTE(*i.BaseCurrencyGTE))
	}
	if i.BaseCurrencyLT != nil {
		predicates = append(predicates, company.BaseCurrencyLT(*i.BaseCurrencyLT))
	}
	if i.BaseCurrencyLTE != nil {
		predicates = append(predicates, company.BaseCurrencyLTE(*i.BaseCurrencyLTE))
	}
	if i.BaseCurrencyContains != nil {
		predicates = append(predicates, company.BaseCurrencyContains(*i.BaseCurrencyContains))
	}
	if i.BaseCurrencyHasPrefix != nil {
		predicates = append(predicates, company.BaseCurrencyHasPrefix(*i.BaseCurrencyHasPrefix))
	}
	if i.BaseCurrencyHasSuffix != nil {
		predicates = append(predicates, company.BaseCurrencyHasSuffix(*i.BaseCurrencyHasSuffix))
	}
	if i.BaseCurrencyEqualFold != nil {
		predicates = append(predicates, company.BaseCurrencyEqualFold(*i.BaseCurrencyEqualFold))
	}
	if i.BaseCurrencyContainsFold != nil {
		predicates = append(predicates, company.BaseCurrencyContainsFold(*i.BaseCurrencyContainsFold))
	}
	if i.CeoName != nil {
		predicates = append(predicates, company.CeoNameEQ(*i.CeoName))
	}
	if i.CeoNameNEQ != nil {
		predicates = append(predicates, company.CeoNameNEQ(*i.CeoNameNEQ))
	}
	if len(i.CeoNameIn) > 0 {
		predicates = append(predicates, company.CeoNameIn(i.CeoNameIn...))
	}
	if len(i.CeoNameNotIn) > 0 {
		predicates = append(predicates, company.CeoNameNotIn(i.CeoNameNotIn...))
	}
	if i.CeoNameGT != nil {
		predicates = append(predicates, company.CeoNameGT(*i.CeoNameGT))
	}
	if i.CeoNameGTE != nil {
		predicates = append(predicates, company.CeoNameGTE(*i.CeoNameGTE))
	}
	if i.CeoNameLT != nil {
		predicates = append(predicates, company.CeoNameLT(*i.CeoNameLT))
	}
	if i.CeoNameLTE != nil {
		predicates = append(predicates, company.CeoNameLTE(*i.CeoNameLTE))
	}
	if i.CeoNameContains != nil {
		predicates = append(predicates, company.CeoNameContains(*i.CeoNameContains))
	}
	if i.CeoNameHasPrefix != nil {
		predicates = append(predicates, company.CeoNameHasPrefix(*i.CeoNameHasPrefix))
	}
	if i.CeoNameHasSuffix != nil {
		predicates = append(predicates, company.CeoNameHasSuffix(*i.CeoNameHasSuffix))
	}
	if i.CeoNameIsNil {
		predicates = append(predicates, company.CeoNameIsNil())
	}
	if i.CeoNameNotNil {
		predicates = append(predicates, company.CeoNameNotNil())
	}
	if i.CeoNameEqualFold != nil {
		predicates = append(predicates, company.CeoNameEqualFold(*i.CeoNameEqualFold))
	}
	if i.CeoNameContainsFold != nil {
		predicates = append(predicates, company.CeoNameContainsFold(*i.CeoNameContainsFold))
	}
	if i.City != nil {
		predicates = append(predicates, company.CityEQ(*i.City))
	}
	if i.CityNEQ != nil {
		predicates = append(predicates, company.CityNEQ(*i.CityNEQ))
	}
	if len(i.CityIn) > 0 {
		predicates = append(predicates, company.CityIn(i.CityIn...))
	}
	if len(i.CityNotIn) > 0 {
		predicates = append(predicates, company.CityNotIn(i.CityNotIn...))
	}
	if i.CityGT != nil {
		predicates = append(predicates, company.CityGT(*i.CityGT))
	}
	if i.CityGTE != nil {
		predicates = append(predicates, company.CityGTE(*i.CityGTE))
	}
	if i.CityLT != nil {
		predicates = append(predicates, company.CityLT(*i.CityLT))
	}
	if i.CityLTE != nil {
		predicates = append(predicates, company.CityLTE(*i.CityLTE))
	}
	if i.CityContains != nil {
		predicates = append(predicates, company.CityContains(*i.CityContains))
	}
	if i.CityHasPrefix != nil {
		predicates = append(predicates, company.CityHasPrefix(*i.CityHasPrefix))
	}
	if i.CityHasSuffix != nil {
		predicates = append(predicates, company.CityHasSuffix(*i.CityHasSuffix))
	}
	if i.CityEqualFold != nil {
		predicates = append(predicates, company.CityEqualFold(*i.CityEqualFold))
	}
	if i.CityContainsFold != nil {
		predicates = append(predicates, company.CityContainsFold(*i.CityContainsFold))
	}
	if i.Country != nil {
		predicates = append(predicates, company.CountryEQ(*i.Country))
	}
	if i.CountryNEQ != nil {
		predicates = append(predicates, company.CountryNEQ(*i.CountryNEQ))
	}
	if len(i.CountryIn) > 0 {
		predicates = append(predicates, company.CountryIn(i.CountryIn...))
	}
	if len(i.CountryNotIn) > 0 {
		predicates = append(predicates, company.CountryNotIn(i.CountryNotIn...))
	}
	if i.CountryGT != nil {
		predicates = append(predicates, company.CountryGT(*i.CountryGT))
	}
	if i.CountryGTE != nil {
		predicates = append(predicates, company.CountryGTE(*i.CountryGTE))
	}
	if i.CountryLT != nil {
		predicates = append(predicates, company.CountryLT(*i.CountryLT))
	}
	if i.CountryLTE != nil {
		predicates = append(predicates, company.CountryLTE(*i.CountryLTE))
	}
	if i.CountryContains != nil {
		predicates = append(predicates, company.CountryContains(*i.CountryContains))
	}
	if i.CountryHasPrefix != nil {
		predicates = append(predicates, company.CountryHasPrefix(*i.CountryHasPrefix))
	}
	if i.CountryHasSuffix != nil {
		predicates = append(predicates, company.CountryHasSuffix(*i.CountryHasSuffix))
	}
	if i.CountryEqualFold != nil {
		predicates = append(predicates, company.CountryEqualFold(*i.CountryEqualFold))
	}
	if i.CountryContainsFold != nil {
		predicates = append(predicates, company.CountryContainsFold(*i.CountryContainsFold))
	}
	if i.EstablishedAt != nil {
		predicates = append(predicates, company.EstablishedAtEQ(*i.EstablishedAt))
	}
	if i.EstablishedAtNEQ != nil {
		predicates = append(predicates, company.EstablishedAtNEQ(*i.EstablishedAtNEQ))
	}
	if len(i.EstablishedAtIn) > 0 {
		predicates = append(predicates, company.EstablishedAtIn(i.EstablishedAtIn...))
	}
	if len(i.EstablishedAtNotIn) > 0 {
		predicates = append(predicates, company.EstablishedAtNotIn(i.EstablishedAtNotIn...))
	}
	if i.EstablishedAtGT != nil {
		predicates = append(predicates, company.EstablishedAtGT(*i.EstablishedAtGT))
	}
	if i.EstablishedAtGTE != nil {
		predicates = append(predicates, company.EstablishedAtGTE(*i.EstablishedAtGTE))
	}
	if i.EstablishedAtLT != nil {
		predicates = append(predicates, company.EstablishedAtLT(*i.EstablishedAtLT))
	}
	if i.EstablishedAtLTE != nil {
		predicates = append(predicates, company.EstablishedAtLTE(*i.EstablishedAtLTE))
	}
	if i.Description != nil {
		predicates = append(predicates, company.DescriptionEQ(*i.Description))
	}
	if i.DescriptionNEQ != nil {
		predicates = append(predicates, company.DescriptionNEQ(*i.DescriptionNEQ))
	}
	if len(i.DescriptionIn) > 0 {
		predicates = append(predicates, company.DescriptionIn(i.DescriptionIn...))
	}
	if len(i.DescriptionNotIn) > 0 {
		predicates = append(predicates, company.DescriptionNotIn(i.DescriptionNotIn...))
	}
	if i.DescriptionGT != nil {
		predicates = append(predicates, company.DescriptionGT(*i.DescriptionGT))
	}
	if i.DescriptionGTE != nil {
		predicates = append(predicates, company.DescriptionGTE(*i.DescriptionGTE))
	}
	if i.DescriptionLT != nil {
		predicates = append(predicates, company.DescriptionLT(*i.DescriptionLT))
	}
	if i.DescriptionLTE != nil {
		predicates = append(predicates, company.DescriptionLTE(*i.DescriptionLTE))
	}
	if i.DescriptionContains != nil {
		predicates = append(predicates, company.DescriptionContains(*i.DescriptionContains))
	}
	if i.DescriptionHasPrefix != nil {
		predicates = append(predicates, company.DescriptionHasPrefix(*i.DescriptionHasPrefix))
	}
	if i.DescriptionHasSuffix != nil {
		predicates = append(predicates, company.DescriptionHasSuffix(*i.DescriptionHasSuffix))
	}
	if i.DescriptionIsNil {
		predicates = append(predicates, company.DescriptionIsNil())
	}
	if i.DescriptionNotNil {
		predicates = append(predicates, company.DescriptionNotNil())
	}
	if i.DescriptionEqualFold != nil {
		predicates = append(predicates, company.DescriptionEqualFold(*i.DescriptionEqualFold))
	}
	if i.DescriptionContainsFold != nil {
		predicates = append(predicates, company.DescriptionContainsFold(*i.DescriptionContainsFold))
	}
	if i.Email != nil {
		predicates = append(predicates, company.EmailEQ(*i.Email))
	}
	if i.EmailNEQ != nil {
		predicates = append(predicates, company.EmailNEQ(*i.EmailNEQ))
	}
	if len(i.EmailIn) > 0 {
		predicates = append(predicates, company.EmailIn(i.EmailIn...))
	}
	if len(i.EmailNotIn) > 0 {
		predicates = append(predicates, company.EmailNotIn(i.EmailNotIn...))
	}
	if i.EmailGT != nil {
		predicates = append(predicates, company.EmailGT(*i.EmailGT))
	}
	if i.EmailGTE != nil {
		predicates = append(predicates, company.EmailGTE(*i.EmailGTE))
	}
	if i.EmailLT != nil {
		predicates = append(predicates, company.EmailLT(*i.EmailLT))
	}
	if i.EmailLTE != nil {
		predicates = append(predicates, company.EmailLTE(*i.EmailLTE))
	}
	if i.EmailContains != nil {
		predicates = append(predicates, company.EmailContains(*i.EmailContains))
	}
	if i.EmailHasPrefix != nil {
		predicates = append(predicates, company.EmailHasPrefix(*i.EmailHasPrefix))
	}
	if i.EmailHasSuffix != nil {
		predicates = append(predicates, company.EmailHasSuffix(*i.EmailHasSuffix))
	}
	if i.EmailIsNil {
		predicates = append(predicates, company.EmailIsNil())
	}
	if i.EmailNotNil {
		predicates = append(predicates, company.EmailNotNil())
	}
	if i.EmailEqualFold != nil {
		predicates = append(predicates, company.EmailEqualFold(*i.EmailEqualFold))
	}
	if i.EmailContainsFold != nil {
		predicates = append(predicates, company.EmailContainsFold(*i.EmailContainsFold))
	}
	if i.Industry != nil {
		predicates = append(predicates, company.IndustryEQ(*i.Industry))
	}
	if i.IndustryNEQ != nil {
		predicates = append(predicates, company.IndustryNEQ(*i.IndustryNEQ))
	}
	if len(i.IndustryIn) > 0 {
		predicates = append(predicates, company.IndustryIn(i.IndustryIn...))
	}
	if len(i.IndustryNotIn) > 0 {
		predicates = append(predicates, company.IndustryNotIn(i.IndustryNotIn...))
	}
	if i.IndustryGT != nil {
		predicates = append(predicates, company.IndustryGT(*i.IndustryGT))
	}
	if i.IndustryGTE != nil {
		predicates = append(predicates, company.IndustryGTE(*i.IndustryGTE))
	}
	if i.IndustryLT != nil {
		predicates = append(predicates, company.IndustryLT(*i.IndustryLT))
	}
	if i.IndustryLTE != nil {
		predicates = append(predicates, company.IndustryLTE(*i.IndustryLTE))
	}
	if i.IndustryContains != nil {
		predicates = append(predicates, company.IndustryContains(*i.IndustryContains))
	}
	if i.IndustryHasPrefix != nil {
		predicates = append(predicates, company.IndustryHasPrefix(*i.IndustryHasPrefix))
	}
	if i.IndustryHasSuffix != nil {
		predicates = append(predicates, company.IndustryHasSuffix(*i.IndustryHasSuffix))
	}
	if i.IndustryIsNil {
		predicates = append(predicates, company.IndustryIsNil())
	}
	if i.IndustryNotNil {
		predicates = append(predicates, company.IndustryNotNil())
	}
	if i.IndustryEqualFold != nil {
		predicates = append(predicates, company.IndustryEqualFold(*i.IndustryEqualFold))
	}
	if i.IndustryContainsFold != nil {
		predicates = append(predicates, company.IndustryContainsFold(*i.IndustryContainsFold))
	}
	if i.LastEntryDate != nil {
		predicates = append(predicates, company.LastEntryDateEQ(*i.LastEntryDate))
	}
	if i.LastEntryDateNEQ != nil {
		predicates = append(predicates, company.LastEntryDateNEQ(*i.LastEntryDateNEQ))
	}
	if len(i.LastEntryDateIn) > 0 {
		predicates = append(predicates, company.LastEntryDateIn(i.LastEntryDateIn...))
	}
	if len(i.LastEntryDateNotIn) > 0 {
		predicates = append(predicates, company.LastEntryDateNotIn(i.LastEntryDateNotIn...))
	}
	if i.LastEntryDateGT != nil {
		predicates = append(predicates, company.LastEntryDateGT(*i.LastEntryDateGT))
	}
	if i.LastEntryDateGTE != nil {
		predicates = append(predicates, company.LastEntryDateGTE(*i.LastEntryDateGTE))
	}
	if i.LastEntryDateLT != nil {
		predicates = append(predicates, company.LastEntryDateLT(*i.LastEntryDateLT))
	}
	if i.LastEntryDateLTE != nil {
		predicates = append(predicates, company.LastEntryDateLTE(*i.LastEntryDateLTE))
	}
	if i.LastInvoiceNumber != nil {
		predicates = append(predicates, company.LastInvoiceNumberEQ(*i.LastInvoiceNumber))
	}
	if i.LastInvoiceNumberNEQ != nil {
		predicates = append(predicates, company.LastInvoiceNumberNEQ(*i.LastInvoiceNumberNEQ))
	}
	if len(i.LastInvoiceNumberIn) > 0 {
		predicates = append(predicates, company.LastInvoiceNumberIn(i.LastInvoiceNumberIn...))
	}
	if len(i.LastInvoiceNumberNotIn) > 0 {
		predicates = append(predicates, company.LastInvoiceNumberNotIn(i.LastInvoiceNumberNotIn...))
	}
	if i.LastInvoiceNumberGT != nil {
		predicates = append(predicates, company.LastInvoiceNumberGT(*i.LastInvoiceNumberGT))
	}
	if i.LastInvoiceNumberGTE != nil {
		predicates = append(predicates, company.LastInvoiceNumberGTE(*i.LastInvoiceNumberGTE))
	}
	if i.LastInvoiceNumberLT != nil {
		predicates = append(predicates, company.LastInvoiceNumberLT(*i.LastInvoiceNumberLT))
	}
	if i.LastInvoiceNumberLTE != nil {
		predicates = append(predicates, company.LastInvoiceNumberLTE(*i.LastInvoiceNumberLTE))
	}
	if i.LastInvoiceNumberIsNil {
		predicates = append(predicates, company.LastInvoiceNumberIsNil())
	}
	if i.LastInvoiceNumberNotNil {
		predicates = append(predicates, company.LastInvoiceNumberNotNil())
	}
	if i.LogoURL != nil {
		predicates = append(predicates, company.LogoURLEQ(*i.LogoURL))
	}
	if i.LogoURLNEQ != nil {
		predicates = append(predicates, company.LogoURLNEQ(*i.LogoURLNEQ))
	}
	if len(i.LogoURLIn) > 0 {
		predicates = append(predicates, company.LogoURLIn(i.LogoURLIn...))
	}
	if len(i.LogoURLNotIn) > 0 {
		predicates = append(predicates, company.LogoURLNotIn(i.LogoURLNotIn...))
	}
	if i.LogoURLGT != nil {
		predicates = append(predicates, company.LogoURLGT(*i.LogoURLGT))
	}
	if i.LogoURLGTE != nil {
		predicates = append(predicates, company.LogoURLGTE(*i.LogoURLGTE))
	}
	if i.LogoURLLT != nil {
		predicates = append(predicates, company.LogoURLLT(*i.LogoURLLT))
	}
	if i.LogoURLLTE != nil {
		predicates = append(predicates, company.LogoURLLTE(*i.LogoURLLTE))
	}
	if i.LogoURLContains != nil {
		predicates = append(predicates, company.LogoURLContains(*i.LogoURLContains))
	}
	if i.LogoURLHasPrefix != nil {
		predicates = append(predicates, company.LogoURLHasPrefix(*i.LogoURLHasPrefix))
	}
	if i.LogoURLHasSuffix != nil {
		predicates = append(predicates, company.LogoURLHasSuffix(*i.LogoURLHasSuffix))
	}
	if i.LogoURLIsNil {
		predicates = append(predicates, company.LogoURLIsNil())
	}
	if i.LogoURLNotNil {
		predicates = append(predicates, company.LogoURLNotNil())
	}
	if i.LogoURLEqualFold != nil {
		predicates = append(predicates, company.LogoURLEqualFold(*i.LogoURLEqualFold))
	}
	if i.LogoURLContainsFold != nil {
		predicates = append(predicates, company.LogoURLContainsFold(*i.LogoURLContainsFold))
	}
	if i.LogoStorageURI != nil {
		predicates = append(predicates, company.LogoStorageURIEQ(*i.LogoStorageURI))
	}
	if i.LogoStorageURINEQ != nil {
		predicates = append(predicates, company.LogoStorageURINEQ(*i.LogoStorageURINEQ))
	}
	if len(i.LogoStorageURIIn) > 0 {
		predicates = append(predicates, company.LogoStorageURIIn(i.LogoStorageURIIn...))
	}
	if len(i.LogoStorageURINotIn) > 0 {
		predicates = append(predicates, company.LogoStorageURINotIn(i.LogoStorageURINotIn...))
	}
	if i.LogoStorageURIGT != nil {
		predicates = append(predicates, company.LogoStorageURIGT(*i.LogoStorageURIGT))
	}
	if i.LogoStorageURIGTE != nil {
		predicates = append(predicates, company.LogoStorageURIGTE(*i.LogoStorageURIGTE))
	}
	if i.LogoStorageURILT != nil {
		predicates = append(predicates, company.LogoStorageURILT(*i.LogoStorageURILT))
	}
	if i.LogoStorageURILTE != nil {
		predicates = append(predicates, company.LogoStorageURILTE(*i.LogoStorageURILTE))
	}
	if i.LogoStorageURIContains != nil {
		predicates = append(predicates, company.LogoStorageURIContains(*i.LogoStorageURIContains))
	}
	if i.LogoStorageURIHasPrefix != nil {
		predicates = append(predicates, company.LogoStorageURIHasPrefix(*i.LogoStorageURIHasPrefix))
	}
	if i.LogoStorageURIHasSuffix != nil {
		predicates = append(predicates, company.LogoStorageURIHasSuffix(*i.LogoStorageURIHasSuffix))
	}
	if i.LogoStorageURIIsNil {
		predicates = append(predicates, company.LogoStorageURIIsNil())
	}
	if i.LogoStorageURINotNil {
		predicates = append(predicates, company.LogoStorageURINotNil())
	}
	if i.LogoStorageURIEqualFold != nil {
		predicates = append(predicates, company.LogoStorageURIEqualFold(*i.LogoStorageURIEqualFold))
	}
	if i.LogoStorageURIContainsFold != nil {
		predicates = append(predicates, company.LogoStorageURIContainsFold(*i.LogoStorageURIContainsFold))
	}
	if i.Name != nil {
		predicates = append(predicates, company.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, company.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, company.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, company.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, company.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, company.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, company.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, company.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, company.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, company.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, company.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, company.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, company.NameContainsFold(*i.NameContainsFold))
	}
	if i.NumberOfEmployees != nil {
		predicates = append(predicates, company.NumberOfEmployeesEQ(*i.NumberOfEmployees))
	}
	if i.NumberOfEmployeesNEQ != nil {
		predicates = append(predicates, company.NumberOfEmployeesNEQ(*i.NumberOfEmployeesNEQ))
	}
	if len(i.NumberOfEmployeesIn) > 0 {
		predicates = append(predicates, company.NumberOfEmployeesIn(i.NumberOfEmployeesIn...))
	}
	if len(i.NumberOfEmployeesNotIn) > 0 {
		predicates = append(predicates, company.NumberOfEmployeesNotIn(i.NumberOfEmployeesNotIn...))
	}
	if i.NumberOfEmployeesGT != nil {
		predicates = append(predicates, company.NumberOfEmployeesGT(*i.NumberOfEmployeesGT))
	}
	if i.NumberOfEmployeesGTE != nil {
		predicates = append(predicates, company.NumberOfEmployeesGTE(*i.NumberOfEmployeesGTE))
	}
	if i.NumberOfEmployeesLT != nil {
		predicates = append(predicates, company.NumberOfEmployeesLT(*i.NumberOfEmployeesLT))
	}
	if i.NumberOfEmployeesLTE != nil {
		predicates = append(predicates, company.NumberOfEmployeesLTE(*i.NumberOfEmployeesLTE))
	}
	if i.Phone != nil {
		predicates = append(predicates, company.PhoneEQ(*i.Phone))
	}
	if i.PhoneNEQ != nil {
		predicates = append(predicates, company.PhoneNEQ(*i.PhoneNEQ))
	}
	if len(i.PhoneIn) > 0 {
		predicates = append(predicates, company.PhoneIn(i.PhoneIn...))
	}
	if len(i.PhoneNotIn) > 0 {
		predicates = append(predicates, company.PhoneNotIn(i.PhoneNotIn...))
	}
	if i.PhoneGT != nil {
		predicates = append(predicates, company.PhoneGT(*i.PhoneGT))
	}
	if i.PhoneGTE != nil {
		predicates = append(predicates, company.PhoneGTE(*i.PhoneGTE))
	}
	if i.PhoneLT != nil {
		predicates = append(predicates, company.PhoneLT(*i.PhoneLT))
	}
	if i.PhoneLTE != nil {
		predicates = append(predicates, company.PhoneLTE(*i.PhoneLTE))
	}
	if i.PhoneContains != nil {
		predicates = append(predicates, company.PhoneContains(*i.PhoneContains))
	}
	if i.PhoneHasPrefix != nil {
		predicates = append(predicates, company.PhoneHasPrefix(*i.PhoneHasPrefix))
	}
	if i.PhoneHasSuffix != nil {
		predicates = append(predicates, company.PhoneHasSuffix(*i.PhoneHasSuffix))
	}
	if i.PhoneIsNil {
		predicates = append(predicates, company.PhoneIsNil())
	}
	if i.PhoneNotNil {
		predicates = append(predicates, company.PhoneNotNil())
	}
	if i.PhoneEqualFold != nil {
		predicates = append(predicates, company.PhoneEqualFold(*i.PhoneEqualFold))
	}
	if i.PhoneContainsFold != nil {
		predicates = append(predicates, company.PhoneContainsFold(*i.PhoneContainsFold))
	}
	if i.TaxId != nil {
		predicates = append(predicates, company.TaxIdEQ(*i.TaxId))
	}
	if i.TaxIdNEQ != nil {
		predicates = append(predicates, company.TaxIdNEQ(*i.TaxIdNEQ))
	}
	if len(i.TaxIdIn) > 0 {
		predicates = append(predicates, company.TaxIdIn(i.TaxIdIn...))
	}
	if len(i.TaxIdNotIn) > 0 {
		predicates = append(predicates, company.TaxIdNotIn(i.TaxIdNotIn...))
	}
	if i.TaxIdGT != nil {
		predicates = append(predicates, company.TaxIdGT(*i.TaxIdGT))
	}
	if i.TaxIdGTE != nil {
		predicates = append(predicates, company.TaxIdGTE(*i.TaxIdGTE))
	}
	if i.TaxIdLT != nil {
		predicates = append(predicates, company.TaxIdLT(*i.TaxIdLT))
	}
	if i.TaxIdLTE != nil {
		predicates = append(predicates, company.TaxIdLTE(*i.TaxIdLTE))
	}
	if i.TaxIdContains != nil {
		predicates = append(predicates, company.TaxIdContains(*i.TaxIdContains))
	}
	if i.TaxIdHasPrefix != nil {
		predicates = append(predicates, company.TaxIdHasPrefix(*i.TaxIdHasPrefix))
	}
	if i.TaxIdHasSuffix != nil {
		predicates = append(predicates, company.TaxIdHasSuffix(*i.TaxIdHasSuffix))
	}
	if i.TaxIdEqualFold != nil {
		predicates = append(predicates, company.TaxIdEqualFold(*i.TaxIdEqualFold))
	}
	if i.TaxIdContainsFold != nil {
		predicates = append(predicates, company.TaxIdContainsFold(*i.TaxIdContainsFold))
	}
	if i.VatRate != nil {
		predicates = append(predicates, company.VatRateEQ(*i.VatRate))
	}
	if i.VatRateNEQ != nil {
		predicates = append(predicates, company.VatRateNEQ(*i.VatRateNEQ))
	}
	if len(i.VatRateIn) > 0 {
		predicates = append(predicates, company.VatRateIn(i.VatRateIn...))
	}
	if len(i.VatRateNotIn) > 0 {
		predicates = append(predicates, company.VatRateNotIn(i.VatRateNotIn...))
	}
	if i.VatRateGT != nil {
		predicates = append(predicates, company.VatRateGT(*i.VatRateGT))
	}
	if i.VatRateGTE != nil {
		predicates = append(predicates, company.VatRateGTE(*i.VatRateGTE))
	}
	if i.VatRateLT != nil {
		predicates = append(predicates, company.VatRateLT(*i.VatRateLT))
	}
	if i.VatRateLTE != nil {
		predicates = append(predicates, company.VatRateLTE(*i.VatRateLTE))
	}
	if i.Website != nil {
		predicates = append(predicates, company.WebsiteEQ(*i.Website))
	}
	if i.WebsiteNEQ != nil {
		predicates = append(predicates, company.WebsiteNEQ(*i.WebsiteNEQ))
	}
	if len(i.WebsiteIn) > 0 {
		predicates = append(predicates, company.WebsiteIn(i.WebsiteIn...))
	}
	if len(i.WebsiteNotIn) > 0 {
		predicates = append(predicates, company.WebsiteNotIn(i.WebsiteNotIn...))
	}
	if i.WebsiteGT != nil {
		predicates = append(predicates, company.WebsiteGT(*i.WebsiteGT))
	}
	if i.WebsiteGTE != nil {
		predicates = append(predicates, company.WebsiteGTE(*i.WebsiteGTE))
	}
	if i.WebsiteLT != nil {
		predicates = append(predicates, company.WebsiteLT(*i.WebsiteLT))
	}
	if i.WebsiteLTE != nil {
		predicates = append(predicates, company.WebsiteLTE(*i.WebsiteLTE))
	}
	if i.WebsiteContains != nil {
		predicates = append(predicates, company.WebsiteContains(*i.WebsiteContains))
	}
	if i.WebsiteHasPrefix != nil {
		predicates = append(predicates, company.WebsiteHasPrefix(*i.WebsiteHasPrefix))
	}
	if i.WebsiteHasSuffix != nil {
		predicates = append(predicates, company.WebsiteHasSuffix(*i.WebsiteHasSuffix))
	}
	if i.WebsiteIsNil {
		predicates = append(predicates, company.WebsiteIsNil())
	}
	if i.WebsiteNotNil {
		predicates = append(predicates, company.WebsiteNotNil())
	}
	if i.WebsiteEqualFold != nil {
		predicates = append(predicates, company.WebsiteEqualFold(*i.WebsiteEqualFold))
	}
	if i.WebsiteContainsFold != nil {
		predicates = append(predicates, company.WebsiteContainsFold(*i.WebsiteContainsFold))
	}
	if i.IncompleteSetup != nil {
		predicates = append(predicates, company.IncompleteSetupEQ(*i.IncompleteSetup))
	}
	if i.IncompleteSetupNEQ != nil {
		predicates = append(predicates, company.IncompleteSetupNEQ(*i.IncompleteSetupNEQ))
	}
	if i.IncompleteSetupIsNil {
		predicates = append(predicates, company.IncompleteSetupIsNil())
	}
	if i.IncompleteSetupNotNil {
		predicates = append(predicates, company.IncompleteSetupNotNil())
	}

	if i.HasAvailableRoles != nil {
		p := company.HasAvailableRoles()
		if !*i.HasAvailableRoles {
			p = company.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasAvailableRolesWith) > 0 {
		with := make([]predicate.UserRole, 0, len(i.HasAvailableRolesWith))
		for _, w := range i.HasAvailableRolesWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasAvailableRolesWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, company.HasAvailableRolesWith(with...))
	}
	if i.HasAccountingEntries != nil {
		p := company.HasAccountingEntries()
		if !*i.HasAccountingEntries {
			p = company.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasAccountingEntriesWith) > 0 {
		with := make([]predicate.AccountingEntry, 0, len(i.HasAccountingEntriesWith))
		for _, w := range i.HasAccountingEntriesWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasAccountingEntriesWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, company.HasAccountingEntriesWith(with...))
	}
	if i.HasCustomers != nil {
		p := company.HasCustomers()
		if !*i.HasCustomers {
			p = company.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasCustomersWith) > 0 {
		with := make([]predicate.Customer, 0, len(i.HasCustomersWith))
		for _, w := range i.HasCustomersWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasCustomersWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, company.HasCustomersWith(with...))
	}
	if i.HasDocuments != nil {
		p := company.HasDocuments()
		if !*i.HasDocuments {
			p = company.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasDocumentsWith) > 0 {
		with := make([]predicate.CompanyDocument, 0, len(i.HasDocumentsWith))
		for _, w := range i.HasDocumentsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasDocumentsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, company.HasDocumentsWith(with...))
	}
	if i.HasEmployees != nil {
		p := company.HasEmployees()
		if !*i.HasEmployees {
			p = company.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasEmployeesWith) > 0 {
		with := make([]predicate.Employee, 0, len(i.HasEmployeesWith))
		for _, w := range i.HasEmployeesWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasEmployeesWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, company.HasEmployeesWith(with...))
	}
	if i.HasFiles != nil {
		p := company.HasFiles()
		if !*i.HasFiles {
			p = company.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasFilesWith) > 0 {
		with := make([]predicate.File, 0, len(i.HasFilesWith))
		for _, w := range i.HasFilesWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasFilesWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, company.HasFilesWith(with...))
	}
	if i.HasInventory != nil {
		p := company.HasInventory()
		if !*i.HasInventory {
			p = company.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasInventoryWith) > 0 {
		with := make([]predicate.Inventory, 0, len(i.HasInventoryWith))
		for _, w := range i.HasInventoryWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasInventoryWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, company.HasInventoryWith(with...))
	}
	if i.HasInventoryMovements != nil {
		p := company.HasInventoryMovements()
		if !*i.HasInventoryMovements {
			p = company.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasInventoryMovementsWith) > 0 {
		with := make([]predicate.InventoryMovement, 0, len(i.HasInventoryMovementsWith))
		for _, w := range i.HasInventoryMovementsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasInventoryMovementsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, company.HasInventoryMovementsWith(with...))
	}
	if i.HasInvoices != nil {
		p := company.HasInvoices()
		if !*i.HasInvoices {
			p = company.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasInvoicesWith) > 0 {
		with := make([]predicate.Invoice, 0, len(i.HasInvoicesWith))
		for _, w := range i.HasInvoicesWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasInvoicesWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, company.HasInvoicesWith(with...))
	}
	if i.HasLoans != nil {
		p := company.HasLoans()
		if !*i.HasLoans {
			p = company.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasLoansWith) > 0 {
		with := make([]predicate.Loan, 0, len(i.HasLoansWith))
		for _, w := range i.HasLoansWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasLoansWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, company.HasLoansWith(with...))
	}
	if i.HasMemberSignupTokens != nil {
		p := company.HasMemberSignupTokens()
		if !*i.HasMemberSignupTokens {
			p = company.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasMemberSignupTokensWith) > 0 {
		with := make([]predicate.MemberSignupToken, 0, len(i.HasMemberSignupTokensWith))
		for _, w := range i.HasMemberSignupTokensWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasMemberSignupTokensWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, company.HasMemberSignupTokensWith(with...))
	}
	if i.HasProducts != nil {
		p := company.HasProducts()
		if !*i.HasProducts {
			p = company.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasProductsWith) > 0 {
		with := make([]predicate.Product, 0, len(i.HasProductsWith))
		for _, w := range i.HasProductsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasProductsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, company.HasProductsWith(with...))
	}
	if i.HasProjects != nil {
		p := company.HasProjects()
		if !*i.HasProjects {
			p = company.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasProjectsWith) > 0 {
		with := make([]predicate.Project, 0, len(i.HasProjectsWith))
		for _, w := range i.HasProjectsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasProjectsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, company.HasProjectsWith(with...))
	}
	if i.HasPayables != nil {
		p := company.HasPayables()
		if !*i.HasPayables {
			p = company.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasPayablesWith) > 0 {
		with := make([]predicate.Payable, 0, len(i.HasPayablesWith))
		for _, w := range i.HasPayablesWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasPayablesWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, company.HasPayablesWith(with...))
	}
	if i.HasReceivables != nil {
		p := company.HasReceivables()
		if !*i.HasReceivables {
			p = company.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasReceivablesWith) > 0 {
		with := make([]predicate.Receivable, 0, len(i.HasReceivablesWith))
		for _, w := range i.HasReceivablesWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasReceivablesWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, company.HasReceivablesWith(with...))
	}
	if i.HasSuppliers != nil {
		p := company.HasSuppliers()
		if !*i.HasSuppliers {
			p = company.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasSuppliersWith) > 0 {
		with := make([]predicate.Supplier, 0, len(i.HasSuppliersWith))
		for _, w := range i.HasSuppliersWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasSuppliersWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, company.HasSuppliersWith(with...))
	}
	if i.HasTokens != nil {
		p := company.HasTokens()
		if !*i.HasTokens {
			p = company.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasTokensWith) > 0 {
		with := make([]predicate.Token, 0, len(i.HasTokensWith))
		for _, w := range i.HasTokensWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasTokensWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, company.HasTokensWith(with...))
	}
	if i.HasTreasuries != nil {
		p := company.HasTreasuries()
		if !*i.HasTreasuries {
			p = company.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasTreasuriesWith) > 0 {
		with := make([]predicate.Treasury, 0, len(i.HasTreasuriesWith))
		for _, w := range i.HasTreasuriesWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasTreasuriesWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, company.HasTreasuriesWith(with...))
	}
	if i.HasWorkShifts != nil {
		p := company.HasWorkShifts()
		if !*i.HasWorkShifts {
			p = company.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasWorkShiftsWith) > 0 {
		with := make([]predicate.Workshift, 0, len(i.HasWorkShiftsWith))
		for _, w := range i.HasWorkShiftsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasWorkShiftsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, company.HasWorkShiftsWith(with...))
	}
	if i.HasUsers != nil {
		p := company.HasUsers()
		if !*i.HasUsers {
			p = company.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasUsersWith) > 0 {
		with := make([]predicate.User, 0, len(i.HasUsersWith))
		for _, w := range i.HasUsersWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasUsersWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, company.HasUsersWith(with...))
	}
	if i.HasDaughterCompanies != nil {
		p := company.HasDaughterCompanies()
		if !*i.HasDaughterCompanies {
			p = company.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasDaughterCompaniesWith) > 0 {
		with := make([]predicate.Company, 0, len(i.HasDaughterCompaniesWith))
		for _, w := range i.HasDaughterCompaniesWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasDaughterCompaniesWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, company.HasDaughterCompaniesWith(with...))
	}
	if i.HasParentCompany != nil {
		p := company.HasParentCompany()
		if !*i.HasParentCompany {
			p = company.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasParentCompanyWith) > 0 {
		with := make([]predicate.Company, 0, len(i.HasParentCompanyWith))
		for _, w := range i.HasParentCompanyWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasParentCompanyWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, company.HasParentCompanyWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyCompanyWhereInput
	case 1:
		return predicates[0], nil
	default:
		return company.And(predicates...), nil
	}
}

// CompanyDocumentWhereInput represents a where input for filtering CompanyDocument queries.
type CompanyDocumentWhereInput struct {
	Predicates []predicate.CompanyDocument  `json:"-"`
	Not        *CompanyDocumentWhereInput   `json:"not,omitempty"`
	Or         []*CompanyDocumentWhereInput `json:"or,omitempty"`
	And        []*CompanyDocumentWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "createdAt" field predicates.
	CreatedAt      *time.Time  `json:"createdat,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdatNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdatIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdatNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdatGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdatGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdatLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdatLTE,omitempty"`

	// "updatedAt" field predicates.
	UpdatedAt      *time.Time  `json:"updatedat,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedatNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedatIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedatNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedatGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedatGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedatLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedatLTE,omitempty"`

	// "deletedAt" field predicates.
	DeletedAt       *time.Time  `json:"deletedat,omitempty"`
	DeletedAtNEQ    *time.Time  `json:"deletedatNEQ,omitempty"`
	DeletedAtIn     []time.Time `json:"deletedatIn,omitempty"`
	DeletedAtNotIn  []time.Time `json:"deletedatNotIn,omitempty"`
	DeletedAtGT     *time.Time  `json:"deletedatGT,omitempty"`
	DeletedAtGTE    *time.Time  `json:"deletedatGTE,omitempty"`
	DeletedAtLT     *time.Time  `json:"deletedatLT,omitempty"`
	DeletedAtLTE    *time.Time  `json:"deletedatLTE,omitempty"`
	DeletedAtIsNil  bool        `json:"deletedatIsNil,omitempty"`
	DeletedAtNotNil bool        `json:"deletedatNotNil,omitempty"`

	// "filename" field predicates.
	Filename             *string  `json:"filename,omitempty"`
	FilenameNEQ          *string  `json:"filenameNEQ,omitempty"`
	FilenameIn           []string `json:"filenameIn,omitempty"`
	FilenameNotIn        []string `json:"filenameNotIn,omitempty"`
	FilenameGT           *string  `json:"filenameGT,omitempty"`
	FilenameGTE          *string  `json:"filenameGTE,omitempty"`
	FilenameLT           *string  `json:"filenameLT,omitempty"`
	FilenameLTE          *string  `json:"filenameLTE,omitempty"`
	FilenameContains     *string  `json:"filenameContains,omitempty"`
	FilenameHasPrefix    *string  `json:"filenameHasPrefix,omitempty"`
	FilenameHasSuffix    *string  `json:"filenameHasSuffix,omitempty"`
	FilenameEqualFold    *string  `json:"filenameEqualFold,omitempty"`
	FilenameContainsFold *string  `json:"filenameContainsFold,omitempty"`

	// "title" field predicates.
	Title             *string  `json:"title,omitempty"`
	TitleNEQ          *string  `json:"titleNEQ,omitempty"`
	TitleIn           []string `json:"titleIn,omitempty"`
	TitleNotIn        []string `json:"titleNotIn,omitempty"`
	TitleGT           *string  `json:"titleGT,omitempty"`
	TitleGTE          *string  `json:"titleGTE,omitempty"`
	TitleLT           *string  `json:"titleLT,omitempty"`
	TitleLTE          *string  `json:"titleLTE,omitempty"`
	TitleContains     *string  `json:"titleContains,omitempty"`
	TitleHasPrefix    *string  `json:"titleHasPrefix,omitempty"`
	TitleHasSuffix    *string  `json:"titleHasSuffix,omitempty"`
	TitleEqualFold    *string  `json:"titleEqualFold,omitempty"`
	TitleContainsFold *string  `json:"titleContainsFold,omitempty"`

	// "keywords" field predicates.
	Keywords             *string  `json:"keywords,omitempty"`
	KeywordsNEQ          *string  `json:"keywordsNEQ,omitempty"`
	KeywordsIn           []string `json:"keywordsIn,omitempty"`
	KeywordsNotIn        []string `json:"keywordsNotIn,omitempty"`
	KeywordsGT           *string  `json:"keywordsGT,omitempty"`
	KeywordsGTE          *string  `json:"keywordsGTE,omitempty"`
	KeywordsLT           *string  `json:"keywordsLT,omitempty"`
	KeywordsLTE          *string  `json:"keywordsLTE,omitempty"`
	KeywordsContains     *string  `json:"keywordsContains,omitempty"`
	KeywordsHasPrefix    *string  `json:"keywordsHasPrefix,omitempty"`
	KeywordsHasSuffix    *string  `json:"keywordsHasSuffix,omitempty"`
	KeywordsEqualFold    *string  `json:"keywordsEqualFold,omitempty"`
	KeywordsContainsFold *string  `json:"keywordsContainsFold,omitempty"`

	// "category" field predicates.
	Category      *companydocument.Category  `json:"category,omitempty"`
	CategoryNEQ   *companydocument.Category  `json:"categoryNEQ,omitempty"`
	CategoryIn    []companydocument.Category `json:"categoryIn,omitempty"`
	CategoryNotIn []companydocument.Category `json:"categoryNotIn,omitempty"`

	// "size" field predicates.
	Size      *int  `json:"size,omitempty"`
	SizeNEQ   *int  `json:"sizeNEQ,omitempty"`
	SizeIn    []int `json:"sizeIn,omitempty"`
	SizeNotIn []int `json:"sizeNotIn,omitempty"`
	SizeGT    *int  `json:"sizeGT,omitempty"`
	SizeGTE   *int  `json:"sizeGTE,omitempty"`
	SizeLT    *int  `json:"sizeLT,omitempty"`
	SizeLTE   *int  `json:"sizeLTE,omitempty"`

	// "fileType" field predicates.
	FileType             *string  `json:"filetype,omitempty"`
	FileTypeNEQ          *string  `json:"filetypeNEQ,omitempty"`
	FileTypeIn           []string `json:"filetypeIn,omitempty"`
	FileTypeNotIn        []string `json:"filetypeNotIn,omitempty"`
	FileTypeGT           *string  `json:"filetypeGT,omitempty"`
	FileTypeGTE          *string  `json:"filetypeGTE,omitempty"`
	FileTypeLT           *string  `json:"filetypeLT,omitempty"`
	FileTypeLTE          *string  `json:"filetypeLTE,omitempty"`
	FileTypeContains     *string  `json:"filetypeContains,omitempty"`
	FileTypeHasPrefix    *string  `json:"filetypeHasPrefix,omitempty"`
	FileTypeHasSuffix    *string  `json:"filetypeHasSuffix,omitempty"`
	FileTypeEqualFold    *string  `json:"filetypeEqualFold,omitempty"`
	FileTypeContainsFold *string  `json:"filetypeContainsFold,omitempty"`

	// "status" field predicates.
	Status      *companydocument.Status  `json:"status,omitempty"`
	StatusNEQ   *companydocument.Status  `json:"statusNEQ,omitempty"`
	StatusIn    []companydocument.Status `json:"statusIn,omitempty"`
	StatusNotIn []companydocument.Status `json:"statusNotIn,omitempty"`

	// "url" field predicates.
	URL             *string  `json:"url,omitempty"`
	URLNEQ          *string  `json:"urlNEQ,omitempty"`
	URLIn           []string `json:"urlIn,omitempty"`
	URLNotIn        []string `json:"urlNotIn,omitempty"`
	URLGT           *string  `json:"urlGT,omitempty"`
	URLGTE          *string  `json:"urlGTE,omitempty"`
	URLLT           *string  `json:"urlLT,omitempty"`
	URLLTE          *string  `json:"urlLTE,omitempty"`
	URLContains     *string  `json:"urlContains,omitempty"`
	URLHasPrefix    *string  `json:"urlHasPrefix,omitempty"`
	URLHasSuffix    *string  `json:"urlHasSuffix,omitempty"`
	URLEqualFold    *string  `json:"urlEqualFold,omitempty"`
	URLContainsFold *string  `json:"urlContainsFold,omitempty"`

	// "storageURI" field predicates.
	StorageURI             *string  `json:"storageuri,omitempty"`
	StorageURINEQ          *string  `json:"storageuriNEQ,omitempty"`
	StorageURIIn           []string `json:"storageuriIn,omitempty"`
	StorageURINotIn        []string `json:"storageuriNotIn,omitempty"`
	StorageURIGT           *string  `json:"storageuriGT,omitempty"`
	StorageURIGTE          *string  `json:"storageuriGTE,omitempty"`
	StorageURILT           *string  `json:"storageuriLT,omitempty"`
	StorageURILTE          *string  `json:"storageuriLTE,omitempty"`
	StorageURIContains     *string  `json:"storageuriContains,omitempty"`
	StorageURIHasPrefix    *string  `json:"storageuriHasPrefix,omitempty"`
	StorageURIHasSuffix    *string  `json:"storageuriHasSuffix,omitempty"`
	StorageURIEqualFold    *string  `json:"storageuriEqualFold,omitempty"`
	StorageURIContainsFold *string  `json:"storageuriContainsFold,omitempty"`

	// "thumbnail" field predicates.
	Thumbnail             *string  `json:"thumbnail,omitempty"`
	ThumbnailNEQ          *string  `json:"thumbnailNEQ,omitempty"`
	ThumbnailIn           []string `json:"thumbnailIn,omitempty"`
	ThumbnailNotIn        []string `json:"thumbnailNotIn,omitempty"`
	ThumbnailGT           *string  `json:"thumbnailGT,omitempty"`
	ThumbnailGTE          *string  `json:"thumbnailGTE,omitempty"`
	ThumbnailLT           *string  `json:"thumbnailLT,omitempty"`
	ThumbnailLTE          *string  `json:"thumbnailLTE,omitempty"`
	ThumbnailContains     *string  `json:"thumbnailContains,omitempty"`
	ThumbnailHasPrefix    *string  `json:"thumbnailHasPrefix,omitempty"`
	ThumbnailHasSuffix    *string  `json:"thumbnailHasSuffix,omitempty"`
	ThumbnailIsNil        bool     `json:"thumbnailIsNil,omitempty"`
	ThumbnailNotNil       bool     `json:"thumbnailNotNil,omitempty"`
	ThumbnailEqualFold    *string  `json:"thumbnailEqualFold,omitempty"`
	ThumbnailContainsFold *string  `json:"thumbnailContainsFold,omitempty"`

	// "expiryDate" field predicates.
	ExpiryDate      *time.Time  `json:"expirydate,omitempty"`
	ExpiryDateNEQ   *time.Time  `json:"expirydateNEQ,omitempty"`
	ExpiryDateIn    []time.Time `json:"expirydateIn,omitempty"`
	ExpiryDateNotIn []time.Time `json:"expirydateNotIn,omitempty"`
	ExpiryDateGT    *time.Time  `json:"expirydateGT,omitempty"`
	ExpiryDateGTE   *time.Time  `json:"expirydateGTE,omitempty"`
	ExpiryDateLT    *time.Time  `json:"expirydateLT,omitempty"`
	ExpiryDateLTE   *time.Time  `json:"expirydateLTE,omitempty"`

	// "company" edge predicates.
	HasCompany     *bool                `json:"hasCompany,omitempty"`
	HasCompanyWith []*CompanyWhereInput `json:"hasCompanyWith,omitempty"`

	// "uploadedBy" edge predicates.
	HasUploadedBy     *bool             `json:"hasUploadedBy,omitempty"`
	HasUploadedByWith []*UserWhereInput `json:"hasUploadedByWith,omitempty"`

	// "approvedBy" edge predicates.
	HasApprovedBy     *bool             `json:"hasApprovedBy,omitempty"`
	HasApprovedByWith []*UserWhereInput `json:"hasApprovedByWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *CompanyDocumentWhereInput) AddPredicates(predicates ...predicate.CompanyDocument) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the CompanyDocumentWhereInput filter on the CompanyDocumentQuery builder.
func (i *CompanyDocumentWhereInput) Filter(q *CompanyDocumentQuery) (*CompanyDocumentQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyCompanyDocumentWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyCompanyDocumentWhereInput is returned in case the CompanyDocumentWhereInput is empty.
var ErrEmptyCompanyDocumentWhereInput = errors.New("generated: empty predicate CompanyDocumentWhereInput")

// P returns a predicate for filtering companydocuments.
// An error is returned if the input is empty or invalid.
func (i *CompanyDocumentWhereInput) P() (predicate.CompanyDocument, error) {
	var predicates []predicate.CompanyDocument
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, companydocument.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.CompanyDocument, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, companydocument.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.CompanyDocument, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, companydocument.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, companydocument.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, companydocument.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, companydocument.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, companydocument.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, companydocument.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, companydocument.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, companydocument.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, companydocument.IDLTE(*i.IDLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, companydocument.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, companydocument.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, companydocument.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, companydocument.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, companydocument.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, companydocument.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, companydocument.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, companydocument.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, companydocument.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, companydocument.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, companydocument.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, companydocument.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, companydocument.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, companydocument.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, companydocument.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, companydocument.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.DeletedAt != nil {
		predicates = append(predicates, companydocument.DeletedAtEQ(*i.DeletedAt))
	}
	if i.DeletedAtNEQ != nil {
		predicates = append(predicates, companydocument.DeletedAtNEQ(*i.DeletedAtNEQ))
	}
	if len(i.DeletedAtIn) > 0 {
		predicates = append(predicates, companydocument.DeletedAtIn(i.DeletedAtIn...))
	}
	if len(i.DeletedAtNotIn) > 0 {
		predicates = append(predicates, companydocument.DeletedAtNotIn(i.DeletedAtNotIn...))
	}
	if i.DeletedAtGT != nil {
		predicates = append(predicates, companydocument.DeletedAtGT(*i.DeletedAtGT))
	}
	if i.DeletedAtGTE != nil {
		predicates = append(predicates, companydocument.DeletedAtGTE(*i.DeletedAtGTE))
	}
	if i.DeletedAtLT != nil {
		predicates = append(predicates, companydocument.DeletedAtLT(*i.DeletedAtLT))
	}
	if i.DeletedAtLTE != nil {
		predicates = append(predicates, companydocument.DeletedAtLTE(*i.DeletedAtLTE))
	}
	if i.DeletedAtIsNil {
		predicates = append(predicates, companydocument.DeletedAtIsNil())
	}
	if i.DeletedAtNotNil {
		predicates = append(predicates, companydocument.DeletedAtNotNil())
	}
	if i.Filename != nil {
		predicates = append(predicates, companydocument.FilenameEQ(*i.Filename))
	}
	if i.FilenameNEQ != nil {
		predicates = append(predicates, companydocument.FilenameNEQ(*i.FilenameNEQ))
	}
	if len(i.FilenameIn) > 0 {
		predicates = append(predicates, companydocument.FilenameIn(i.FilenameIn...))
	}
	if len(i.FilenameNotIn) > 0 {
		predicates = append(predicates, companydocument.FilenameNotIn(i.FilenameNotIn...))
	}
	if i.FilenameGT != nil {
		predicates = append(predicates, companydocument.FilenameGT(*i.FilenameGT))
	}
	if i.FilenameGTE != nil {
		predicates = append(predicates, companydocument.FilenameGTE(*i.FilenameGTE))
	}
	if i.FilenameLT != nil {
		predicates = append(predicates, companydocument.FilenameLT(*i.FilenameLT))
	}
	if i.FilenameLTE != nil {
		predicates = append(predicates, companydocument.FilenameLTE(*i.FilenameLTE))
	}
	if i.FilenameContains != nil {
		predicates = append(predicates, companydocument.FilenameContains(*i.FilenameContains))
	}
	if i.FilenameHasPrefix != nil {
		predicates = append(predicates, companydocument.FilenameHasPrefix(*i.FilenameHasPrefix))
	}
	if i.FilenameHasSuffix != nil {
		predicates = append(predicates, companydocument.FilenameHasSuffix(*i.FilenameHasSuffix))
	}
	if i.FilenameEqualFold != nil {
		predicates = append(predicates, companydocument.FilenameEqualFold(*i.FilenameEqualFold))
	}
	if i.FilenameContainsFold != nil {
		predicates = append(predicates, companydocument.FilenameContainsFold(*i.FilenameContainsFold))
	}
	if i.Title != nil {
		predicates = append(predicates, companydocument.TitleEQ(*i.Title))
	}
	if i.TitleNEQ != nil {
		predicates = append(predicates, companydocument.TitleNEQ(*i.TitleNEQ))
	}
	if len(i.TitleIn) > 0 {
		predicates = append(predicates, companydocument.TitleIn(i.TitleIn...))
	}
	if len(i.TitleNotIn) > 0 {
		predicates = append(predicates, companydocument.TitleNotIn(i.TitleNotIn...))
	}
	if i.TitleGT != nil {
		predicates = append(predicates, companydocument.TitleGT(*i.TitleGT))
	}
	if i.TitleGTE != nil {
		predicates = append(predicates, companydocument.TitleGTE(*i.TitleGTE))
	}
	if i.TitleLT != nil {
		predicates = append(predicates, companydocument.TitleLT(*i.TitleLT))
	}
	if i.TitleLTE != nil {
		predicates = append(predicates, companydocument.TitleLTE(*i.TitleLTE))
	}
	if i.TitleContains != nil {
		predicates = append(predicates, companydocument.TitleContains(*i.TitleContains))
	}
	if i.TitleHasPrefix != nil {
		predicates = append(predicates, companydocument.TitleHasPrefix(*i.TitleHasPrefix))
	}
	if i.TitleHasSuffix != nil {
		predicates = append(predicates, companydocument.TitleHasSuffix(*i.TitleHasSuffix))
	}
	if i.TitleEqualFold != nil {
		predicates = append(predicates, companydocument.TitleEqualFold(*i.TitleEqualFold))
	}
	if i.TitleContainsFold != nil {
		predicates = append(predicates, companydocument.TitleContainsFold(*i.TitleContainsFold))
	}
	if i.Keywords != nil {
		predicates = append(predicates, companydocument.KeywordsEQ(*i.Keywords))
	}
	if i.KeywordsNEQ != nil {
		predicates = append(predicates, companydocument.KeywordsNEQ(*i.KeywordsNEQ))
	}
	if len(i.KeywordsIn) > 0 {
		predicates = append(predicates, companydocument.KeywordsIn(i.KeywordsIn...))
	}
	if len(i.KeywordsNotIn) > 0 {
		predicates = append(predicates, companydocument.KeywordsNotIn(i.KeywordsNotIn...))
	}
	if i.KeywordsGT != nil {
		predicates = append(predicates, companydocument.KeywordsGT(*i.KeywordsGT))
	}
	if i.KeywordsGTE != nil {
		predicates = append(predicates, companydocument.KeywordsGTE(*i.KeywordsGTE))
	}
	if i.KeywordsLT != nil {
		predicates = append(predicates, companydocument.KeywordsLT(*i.KeywordsLT))
	}
	if i.KeywordsLTE != nil {
		predicates = append(predicates, companydocument.KeywordsLTE(*i.KeywordsLTE))
	}
	if i.KeywordsContains != nil {
		predicates = append(predicates, companydocument.KeywordsContains(*i.KeywordsContains))
	}
	if i.KeywordsHasPrefix != nil {
		predicates = append(predicates, companydocument.KeywordsHasPrefix(*i.KeywordsHasPrefix))
	}
	if i.KeywordsHasSuffix != nil {
		predicates = append(predicates, companydocument.KeywordsHasSuffix(*i.KeywordsHasSuffix))
	}
	if i.KeywordsEqualFold != nil {
		predicates = append(predicates, companydocument.KeywordsEqualFold(*i.KeywordsEqualFold))
	}
	if i.KeywordsContainsFold != nil {
		predicates = append(predicates, companydocument.KeywordsContainsFold(*i.KeywordsContainsFold))
	}
	if i.Category != nil {
		predicates = append(predicates, companydocument.CategoryEQ(*i.Category))
	}
	if i.CategoryNEQ != nil {
		predicates = append(predicates, companydocument.CategoryNEQ(*i.CategoryNEQ))
	}
	if len(i.CategoryIn) > 0 {
		predicates = append(predicates, companydocument.CategoryIn(i.CategoryIn...))
	}
	if len(i.CategoryNotIn) > 0 {
		predicates = append(predicates, companydocument.CategoryNotIn(i.CategoryNotIn...))
	}
	if i.Size != nil {
		predicates = append(predicates, companydocument.SizeEQ(*i.Size))
	}
	if i.SizeNEQ != nil {
		predicates = append(predicates, companydocument.SizeNEQ(*i.SizeNEQ))
	}
	if len(i.SizeIn) > 0 {
		predicates = append(predicates, companydocument.SizeIn(i.SizeIn...))
	}
	if len(i.SizeNotIn) > 0 {
		predicates = append(predicates, companydocument.SizeNotIn(i.SizeNotIn...))
	}
	if i.SizeGT != nil {
		predicates = append(predicates, companydocument.SizeGT(*i.SizeGT))
	}
	if i.SizeGTE != nil {
		predicates = append(predicates, companydocument.SizeGTE(*i.SizeGTE))
	}
	if i.SizeLT != nil {
		predicates = append(predicates, companydocument.SizeLT(*i.SizeLT))
	}
	if i.SizeLTE != nil {
		predicates = append(predicates, companydocument.SizeLTE(*i.SizeLTE))
	}
	if i.FileType != nil {
		predicates = append(predicates, companydocument.FileTypeEQ(*i.FileType))
	}
	if i.FileTypeNEQ != nil {
		predicates = append(predicates, companydocument.FileTypeNEQ(*i.FileTypeNEQ))
	}
	if len(i.FileTypeIn) > 0 {
		predicates = append(predicates, companydocument.FileTypeIn(i.FileTypeIn...))
	}
	if len(i.FileTypeNotIn) > 0 {
		predicates = append(predicates, companydocument.FileTypeNotIn(i.FileTypeNotIn...))
	}
	if i.FileTypeGT != nil {
		predicates = append(predicates, companydocument.FileTypeGT(*i.FileTypeGT))
	}
	if i.FileTypeGTE != nil {
		predicates = append(predicates, companydocument.FileTypeGTE(*i.FileTypeGTE))
	}
	if i.FileTypeLT != nil {
		predicates = append(predicates, companydocument.FileTypeLT(*i.FileTypeLT))
	}
	if i.FileTypeLTE != nil {
		predicates = append(predicates, companydocument.FileTypeLTE(*i.FileTypeLTE))
	}
	if i.FileTypeContains != nil {
		predicates = append(predicates, companydocument.FileTypeContains(*i.FileTypeContains))
	}
	if i.FileTypeHasPrefix != nil {
		predicates = append(predicates, companydocument.FileTypeHasPrefix(*i.FileTypeHasPrefix))
	}
	if i.FileTypeHasSuffix != nil {
		predicates = append(predicates, companydocument.FileTypeHasSuffix(*i.FileTypeHasSuffix))
	}
	if i.FileTypeEqualFold != nil {
		predicates = append(predicates, companydocument.FileTypeEqualFold(*i.FileTypeEqualFold))
	}
	if i.FileTypeContainsFold != nil {
		predicates = append(predicates, companydocument.FileTypeContainsFold(*i.FileTypeContainsFold))
	}
	if i.Status != nil {
		predicates = append(predicates, companydocument.StatusEQ(*i.Status))
	}
	if i.StatusNEQ != nil {
		predicates = append(predicates, companydocument.StatusNEQ(*i.StatusNEQ))
	}
	if len(i.StatusIn) > 0 {
		predicates = append(predicates, companydocument.StatusIn(i.StatusIn...))
	}
	if len(i.StatusNotIn) > 0 {
		predicates = append(predicates, companydocument.StatusNotIn(i.StatusNotIn...))
	}
	if i.URL != nil {
		predicates = append(predicates, companydocument.URLEQ(*i.URL))
	}
	if i.URLNEQ != nil {
		predicates = append(predicates, companydocument.URLNEQ(*i.URLNEQ))
	}
	if len(i.URLIn) > 0 {
		predicates = append(predicates, companydocument.URLIn(i.URLIn...))
	}
	if len(i.URLNotIn) > 0 {
		predicates = append(predicates, companydocument.URLNotIn(i.URLNotIn...))
	}
	if i.URLGT != nil {
		predicates = append(predicates, companydocument.URLGT(*i.URLGT))
	}
	if i.URLGTE != nil {
		predicates = append(predicates, companydocument.URLGTE(*i.URLGTE))
	}
	if i.URLLT != nil {
		predicates = append(predicates, companydocument.URLLT(*i.URLLT))
	}
	if i.URLLTE != nil {
		predicates = append(predicates, companydocument.URLLTE(*i.URLLTE))
	}
	if i.URLContains != nil {
		predicates = append(predicates, companydocument.URLContains(*i.URLContains))
	}
	if i.URLHasPrefix != nil {
		predicates = append(predicates, companydocument.URLHasPrefix(*i.URLHasPrefix))
	}
	if i.URLHasSuffix != nil {
		predicates = append(predicates, companydocument.URLHasSuffix(*i.URLHasSuffix))
	}
	if i.URLEqualFold != nil {
		predicates = append(predicates, companydocument.URLEqualFold(*i.URLEqualFold))
	}
	if i.URLContainsFold != nil {
		predicates = append(predicates, companydocument.URLContainsFold(*i.URLContainsFold))
	}
	if i.StorageURI != nil {
		predicates = append(predicates, companydocument.StorageURIEQ(*i.StorageURI))
	}
	if i.StorageURINEQ != nil {
		predicates = append(predicates, companydocument.StorageURINEQ(*i.StorageURINEQ))
	}
	if len(i.StorageURIIn) > 0 {
		predicates = append(predicates, companydocument.StorageURIIn(i.StorageURIIn...))
	}
	if len(i.StorageURINotIn) > 0 {
		predicates = append(predicates, companydocument.StorageURINotIn(i.StorageURINotIn...))
	}
	if i.StorageURIGT != nil {
		predicates = append(predicates, companydocument.StorageURIGT(*i.StorageURIGT))
	}
	if i.StorageURIGTE != nil {
		predicates = append(predicates, companydocument.StorageURIGTE(*i.StorageURIGTE))
	}
	if i.StorageURILT != nil {
		predicates = append(predicates, companydocument.StorageURILT(*i.StorageURILT))
	}
	if i.StorageURILTE != nil {
		predicates = append(predicates, companydocument.StorageURILTE(*i.StorageURILTE))
	}
	if i.StorageURIContains != nil {
		predicates = append(predicates, companydocument.StorageURIContains(*i.StorageURIContains))
	}
	if i.StorageURIHasPrefix != nil {
		predicates = append(predicates, companydocument.StorageURIHasPrefix(*i.StorageURIHasPrefix))
	}
	if i.StorageURIHasSuffix != nil {
		predicates = append(predicates, companydocument.StorageURIHasSuffix(*i.StorageURIHasSuffix))
	}
	if i.StorageURIEqualFold != nil {
		predicates = append(predicates, companydocument.StorageURIEqualFold(*i.StorageURIEqualFold))
	}
	if i.StorageURIContainsFold != nil {
		predicates = append(predicates, companydocument.StorageURIContainsFold(*i.StorageURIContainsFold))
	}
	if i.Thumbnail != nil {
		predicates = append(predicates, companydocument.ThumbnailEQ(*i.Thumbnail))
	}
	if i.ThumbnailNEQ != nil {
		predicates = append(predicates, companydocument.ThumbnailNEQ(*i.ThumbnailNEQ))
	}
	if len(i.ThumbnailIn) > 0 {
		predicates = append(predicates, companydocument.ThumbnailIn(i.ThumbnailIn...))
	}
	if len(i.ThumbnailNotIn) > 0 {
		predicates = append(predicates, companydocument.ThumbnailNotIn(i.ThumbnailNotIn...))
	}
	if i.ThumbnailGT != nil {
		predicates = append(predicates, companydocument.ThumbnailGT(*i.ThumbnailGT))
	}
	if i.ThumbnailGTE != nil {
		predicates = append(predicates, companydocument.ThumbnailGTE(*i.ThumbnailGTE))
	}
	if i.ThumbnailLT != nil {
		predicates = append(predicates, companydocument.ThumbnailLT(*i.ThumbnailLT))
	}
	if i.ThumbnailLTE != nil {
		predicates = append(predicates, companydocument.ThumbnailLTE(*i.ThumbnailLTE))
	}
	if i.ThumbnailContains != nil {
		predicates = append(predicates, companydocument.ThumbnailContains(*i.ThumbnailContains))
	}
	if i.ThumbnailHasPrefix != nil {
		predicates = append(predicates, companydocument.ThumbnailHasPrefix(*i.ThumbnailHasPrefix))
	}
	if i.ThumbnailHasSuffix != nil {
		predicates = append(predicates, companydocument.ThumbnailHasSuffix(*i.ThumbnailHasSuffix))
	}
	if i.ThumbnailIsNil {
		predicates = append(predicates, companydocument.ThumbnailIsNil())
	}
	if i.ThumbnailNotNil {
		predicates = append(predicates, companydocument.ThumbnailNotNil())
	}
	if i.ThumbnailEqualFold != nil {
		predicates = append(predicates, companydocument.ThumbnailEqualFold(*i.ThumbnailEqualFold))
	}
	if i.ThumbnailContainsFold != nil {
		predicates = append(predicates, companydocument.ThumbnailContainsFold(*i.ThumbnailContainsFold))
	}
	if i.ExpiryDate != nil {
		predicates = append(predicates, companydocument.ExpiryDateEQ(*i.ExpiryDate))
	}
	if i.ExpiryDateNEQ != nil {
		predicates = append(predicates, companydocument.ExpiryDateNEQ(*i.ExpiryDateNEQ))
	}
	if len(i.ExpiryDateIn) > 0 {
		predicates = append(predicates, companydocument.ExpiryDateIn(i.ExpiryDateIn...))
	}
	if len(i.ExpiryDateNotIn) > 0 {
		predicates = append(predicates, companydocument.ExpiryDateNotIn(i.ExpiryDateNotIn...))
	}
	if i.ExpiryDateGT != nil {
		predicates = append(predicates, companydocument.ExpiryDateGT(*i.ExpiryDateGT))
	}
	if i.ExpiryDateGTE != nil {
		predicates = append(predicates, companydocument.ExpiryDateGTE(*i.ExpiryDateGTE))
	}
	if i.ExpiryDateLT != nil {
		predicates = append(predicates, companydocument.ExpiryDateLT(*i.ExpiryDateLT))
	}
	if i.ExpiryDateLTE != nil {
		predicates = append(predicates, companydocument.ExpiryDateLTE(*i.ExpiryDateLTE))
	}

	if i.HasCompany != nil {
		p := companydocument.HasCompany()
		if !*i.HasCompany {
			p = companydocument.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasCompanyWith) > 0 {
		with := make([]predicate.Company, 0, len(i.HasCompanyWith))
		for _, w := range i.HasCompanyWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasCompanyWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, companydocument.HasCompanyWith(with...))
	}
	if i.HasUploadedBy != nil {
		p := companydocument.HasUploadedBy()
		if !*i.HasUploadedBy {
			p = companydocument.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasUploadedByWith) > 0 {
		with := make([]predicate.User, 0, len(i.HasUploadedByWith))
		for _, w := range i.HasUploadedByWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasUploadedByWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, companydocument.HasUploadedByWith(with...))
	}
	if i.HasApprovedBy != nil {
		p := companydocument.HasApprovedBy()
		if !*i.HasApprovedBy {
			p = companydocument.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasApprovedByWith) > 0 {
		with := make([]predicate.User, 0, len(i.HasApprovedByWith))
		for _, w := range i.HasApprovedByWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasApprovedByWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, companydocument.HasApprovedByWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyCompanyDocumentWhereInput
	case 1:
		return predicates[0], nil
	default:
		return companydocument.And(predicates...), nil
	}
}

// CustomerWhereInput represents a where input for filtering Customer queries.
type CustomerWhereInput struct {
	Predicates []predicate.Customer  `json:"-"`
	Not        *CustomerWhereInput   `json:"not,omitempty"`
	Or         []*CustomerWhereInput `json:"or,omitempty"`
	And        []*CustomerWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "createdAt" field predicates.
	CreatedAt      *time.Time  `json:"createdat,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdatNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdatIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdatNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdatGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdatGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdatLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdatLTE,omitempty"`

	// "updatedAt" field predicates.
	UpdatedAt      *time.Time  `json:"updatedat,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedatNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedatIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedatNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedatGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedatGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedatLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedatLTE,omitempty"`

	// "deletedAt" field predicates.
	DeletedAt       *time.Time  `json:"deletedat,omitempty"`
	DeletedAtNEQ    *time.Time  `json:"deletedatNEQ,omitempty"`
	DeletedAtIn     []time.Time `json:"deletedatIn,omitempty"`
	DeletedAtNotIn  []time.Time `json:"deletedatNotIn,omitempty"`
	DeletedAtGT     *time.Time  `json:"deletedatGT,omitempty"`
	DeletedAtGTE    *time.Time  `json:"deletedatGTE,omitempty"`
	DeletedAtLT     *time.Time  `json:"deletedatLT,omitempty"`
	DeletedAtLTE    *time.Time  `json:"deletedatLTE,omitempty"`
	DeletedAtIsNil  bool        `json:"deletedatIsNil,omitempty"`
	DeletedAtNotNil bool        `json:"deletedatNotNil,omitempty"`

	// "address" field predicates.
	Address             *string  `json:"address,omitempty"`
	AddressNEQ          *string  `json:"addressNEQ,omitempty"`
	AddressIn           []string `json:"addressIn,omitempty"`
	AddressNotIn        []string `json:"addressNotIn,omitempty"`
	AddressGT           *string  `json:"addressGT,omitempty"`
	AddressGTE          *string  `json:"addressGTE,omitempty"`
	AddressLT           *string  `json:"addressLT,omitempty"`
	AddressLTE          *string  `json:"addressLTE,omitempty"`
	AddressContains     *string  `json:"addressContains,omitempty"`
	AddressHasPrefix    *string  `json:"addressHasPrefix,omitempty"`
	AddressHasSuffix    *string  `json:"addressHasSuffix,omitempty"`
	AddressEqualFold    *string  `json:"addressEqualFold,omitempty"`
	AddressContainsFold *string  `json:"addressContainsFold,omitempty"`

	// "city" field predicates.
	City             *string  `json:"city,omitempty"`
	CityNEQ          *string  `json:"cityNEQ,omitempty"`
	CityIn           []string `json:"cityIn,omitempty"`
	CityNotIn        []string `json:"cityNotIn,omitempty"`
	CityGT           *string  `json:"cityGT,omitempty"`
	CityGTE          *string  `json:"cityGTE,omitempty"`
	CityLT           *string  `json:"cityLT,omitempty"`
	CityLTE          *string  `json:"cityLTE,omitempty"`
	CityContains     *string  `json:"cityContains,omitempty"`
	CityHasPrefix    *string  `json:"cityHasPrefix,omitempty"`
	CityHasSuffix    *string  `json:"cityHasSuffix,omitempty"`
	CityEqualFold    *string  `json:"cityEqualFold,omitempty"`
	CityContainsFold *string  `json:"cityContainsFold,omitempty"`

	// "country" field predicates.
	Country             *string  `json:"country,omitempty"`
	CountryNEQ          *string  `json:"countryNEQ,omitempty"`
	CountryIn           []string `json:"countryIn,omitempty"`
	CountryNotIn        []string `json:"countryNotIn,omitempty"`
	CountryGT           *string  `json:"countryGT,omitempty"`
	CountryGTE          *string  `json:"countryGTE,omitempty"`
	CountryLT           *string  `json:"countryLT,omitempty"`
	CountryLTE          *string  `json:"countryLTE,omitempty"`
	CountryContains     *string  `json:"countryContains,omitempty"`
	CountryHasPrefix    *string  `json:"countryHasPrefix,omitempty"`
	CountryHasSuffix    *string  `json:"countryHasSuffix,omitempty"`
	CountryIsNil        bool     `json:"countryIsNil,omitempty"`
	CountryNotNil       bool     `json:"countryNotNil,omitempty"`
	CountryEqualFold    *string  `json:"countryEqualFold,omitempty"`
	CountryContainsFold *string  `json:"countryContainsFold,omitempty"`

	// "description" field predicates.
	Description             *string  `json:"description,omitempty"`
	DescriptionNEQ          *string  `json:"descriptionNEQ,omitempty"`
	DescriptionIn           []string `json:"descriptionIn,omitempty"`
	DescriptionNotIn        []string `json:"descriptionNotIn,omitempty"`
	DescriptionGT           *string  `json:"descriptionGT,omitempty"`
	DescriptionGTE          *string  `json:"descriptionGTE,omitempty"`
	DescriptionLT           *string  `json:"descriptionLT,omitempty"`
	DescriptionLTE          *string  `json:"descriptionLTE,omitempty"`
	DescriptionContains     *string  `json:"descriptionContains,omitempty"`
	DescriptionHasPrefix    *string  `json:"descriptionHasPrefix,omitempty"`
	DescriptionHasSuffix    *string  `json:"descriptionHasSuffix,omitempty"`
	DescriptionIsNil        bool     `json:"descriptionIsNil,omitempty"`
	DescriptionNotNil       bool     `json:"descriptionNotNil,omitempty"`
	DescriptionEqualFold    *string  `json:"descriptionEqualFold,omitempty"`
	DescriptionContainsFold *string  `json:"descriptionContainsFold,omitempty"`

	// "email" field predicates.
	Email             *string  `json:"email,omitempty"`
	EmailNEQ          *string  `json:"emailNEQ,omitempty"`
	EmailIn           []string `json:"emailIn,omitempty"`
	EmailNotIn        []string `json:"emailNotIn,omitempty"`
	EmailGT           *string  `json:"emailGT,omitempty"`
	EmailGTE          *string  `json:"emailGTE,omitempty"`
	EmailLT           *string  `json:"emailLT,omitempty"`
	EmailLTE          *string  `json:"emailLTE,omitempty"`
	EmailContains     *string  `json:"emailContains,omitempty"`
	EmailHasPrefix    *string  `json:"emailHasPrefix,omitempty"`
	EmailHasSuffix    *string  `json:"emailHasSuffix,omitempty"`
	EmailIsNil        bool     `json:"emailIsNil,omitempty"`
	EmailNotNil       bool     `json:"emailNotNil,omitempty"`
	EmailEqualFold    *string  `json:"emailEqualFold,omitempty"`
	EmailContainsFold *string  `json:"emailContainsFold,omitempty"`

	// "isDefault" field predicates.
	IsDefault       *bool `json:"isdefault,omitempty"`
	IsDefaultNEQ    *bool `json:"isdefaultNEQ,omitempty"`
	IsDefaultIsNil  bool  `json:"isdefaultIsNil,omitempty"`
	IsDefaultNotNil bool  `json:"isdefaultNotNil,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "phone" field predicates.
	Phone             *string  `json:"phone,omitempty"`
	PhoneNEQ          *string  `json:"phoneNEQ,omitempty"`
	PhoneIn           []string `json:"phoneIn,omitempty"`
	PhoneNotIn        []string `json:"phoneNotIn,omitempty"`
	PhoneGT           *string  `json:"phoneGT,omitempty"`
	PhoneGTE          *string  `json:"phoneGTE,omitempty"`
	PhoneLT           *string  `json:"phoneLT,omitempty"`
	PhoneLTE          *string  `json:"phoneLTE,omitempty"`
	PhoneContains     *string  `json:"phoneContains,omitempty"`
	PhoneHasPrefix    *string  `json:"phoneHasPrefix,omitempty"`
	PhoneHasSuffix    *string  `json:"phoneHasSuffix,omitempty"`
	PhoneEqualFold    *string  `json:"phoneEqualFold,omitempty"`
	PhoneContainsFold *string  `json:"phoneContainsFold,omitempty"`

	// "taxId" field predicates.
	TaxId             *string  `json:"taxid,omitempty"`
	TaxIdNEQ          *string  `json:"taxidNEQ,omitempty"`
	TaxIdIn           []string `json:"taxidIn,omitempty"`
	TaxIdNotIn        []string `json:"taxidNotIn,omitempty"`
	TaxIdGT           *string  `json:"taxidGT,omitempty"`
	TaxIdGTE          *string  `json:"taxidGTE,omitempty"`
	TaxIdLT           *string  `json:"taxidLT,omitempty"`
	TaxIdLTE          *string  `json:"taxidLTE,omitempty"`
	TaxIdContains     *string  `json:"taxidContains,omitempty"`
	TaxIdHasPrefix    *string  `json:"taxidHasPrefix,omitempty"`
	TaxIdHasSuffix    *string  `json:"taxidHasSuffix,omitempty"`
	TaxIdEqualFold    *string  `json:"taxidEqualFold,omitempty"`
	TaxIdContainsFold *string  `json:"taxidContainsFold,omitempty"`

	// "company" edge predicates.
	HasCompany     *bool                `json:"hasCompany,omitempty"`
	HasCompanyWith []*CompanyWhereInput `json:"hasCompanyWith,omitempty"`

	// "receivables" edge predicates.
	HasReceivables     *bool                   `json:"hasReceivables,omitempty"`
	HasReceivablesWith []*ReceivableWhereInput `json:"hasReceivablesWith,omitempty"`

	// "invoices" edge predicates.
	HasInvoices     *bool                `json:"hasInvoices,omitempty"`
	HasInvoicesWith []*InvoiceWhereInput `json:"hasInvoicesWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *CustomerWhereInput) AddPredicates(predicates ...predicate.Customer) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the CustomerWhereInput filter on the CustomerQuery builder.
func (i *CustomerWhereInput) Filter(q *CustomerQuery) (*CustomerQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyCustomerWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyCustomerWhereInput is returned in case the CustomerWhereInput is empty.
var ErrEmptyCustomerWhereInput = errors.New("generated: empty predicate CustomerWhereInput")

// P returns a predicate for filtering customers.
// An error is returned if the input is empty or invalid.
func (i *CustomerWhereInput) P() (predicate.Customer, error) {
	var predicates []predicate.Customer
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, customer.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Customer, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, customer.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Customer, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, customer.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, customer.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, customer.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, customer.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, customer.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, customer.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, customer.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, customer.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, customer.IDLTE(*i.IDLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, customer.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, customer.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, customer.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, customer.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, customer.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, customer.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, customer.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, customer.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, customer.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, customer.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, customer.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, customer.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, customer.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, customer.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, customer.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, customer.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.DeletedAt != nil {
		predicates = append(predicates, customer.DeletedAtEQ(*i.DeletedAt))
	}
	if i.DeletedAtNEQ != nil {
		predicates = append(predicates, customer.DeletedAtNEQ(*i.DeletedAtNEQ))
	}
	if len(i.DeletedAtIn) > 0 {
		predicates = append(predicates, customer.DeletedAtIn(i.DeletedAtIn...))
	}
	if len(i.DeletedAtNotIn) > 0 {
		predicates = append(predicates, customer.DeletedAtNotIn(i.DeletedAtNotIn...))
	}
	if i.DeletedAtGT != nil {
		predicates = append(predicates, customer.DeletedAtGT(*i.DeletedAtGT))
	}
	if i.DeletedAtGTE != nil {
		predicates = append(predicates, customer.DeletedAtGTE(*i.DeletedAtGTE))
	}
	if i.DeletedAtLT != nil {
		predicates = append(predicates, customer.DeletedAtLT(*i.DeletedAtLT))
	}
	if i.DeletedAtLTE != nil {
		predicates = append(predicates, customer.DeletedAtLTE(*i.DeletedAtLTE))
	}
	if i.DeletedAtIsNil {
		predicates = append(predicates, customer.DeletedAtIsNil())
	}
	if i.DeletedAtNotNil {
		predicates = append(predicates, customer.DeletedAtNotNil())
	}
	if i.Address != nil {
		predicates = append(predicates, customer.AddressEQ(*i.Address))
	}
	if i.AddressNEQ != nil {
		predicates = append(predicates, customer.AddressNEQ(*i.AddressNEQ))
	}
	if len(i.AddressIn) > 0 {
		predicates = append(predicates, customer.AddressIn(i.AddressIn...))
	}
	if len(i.AddressNotIn) > 0 {
		predicates = append(predicates, customer.AddressNotIn(i.AddressNotIn...))
	}
	if i.AddressGT != nil {
		predicates = append(predicates, customer.AddressGT(*i.AddressGT))
	}
	if i.AddressGTE != nil {
		predicates = append(predicates, customer.AddressGTE(*i.AddressGTE))
	}
	if i.AddressLT != nil {
		predicates = append(predicates, customer.AddressLT(*i.AddressLT))
	}
	if i.AddressLTE != nil {
		predicates = append(predicates, customer.AddressLTE(*i.AddressLTE))
	}
	if i.AddressContains != nil {
		predicates = append(predicates, customer.AddressContains(*i.AddressContains))
	}
	if i.AddressHasPrefix != nil {
		predicates = append(predicates, customer.AddressHasPrefix(*i.AddressHasPrefix))
	}
	if i.AddressHasSuffix != nil {
		predicates = append(predicates, customer.AddressHasSuffix(*i.AddressHasSuffix))
	}
	if i.AddressEqualFold != nil {
		predicates = append(predicates, customer.AddressEqualFold(*i.AddressEqualFold))
	}
	if i.AddressContainsFold != nil {
		predicates = append(predicates, customer.AddressContainsFold(*i.AddressContainsFold))
	}
	if i.City != nil {
		predicates = append(predicates, customer.CityEQ(*i.City))
	}
	if i.CityNEQ != nil {
		predicates = append(predicates, customer.CityNEQ(*i.CityNEQ))
	}
	if len(i.CityIn) > 0 {
		predicates = append(predicates, customer.CityIn(i.CityIn...))
	}
	if len(i.CityNotIn) > 0 {
		predicates = append(predicates, customer.CityNotIn(i.CityNotIn...))
	}
	if i.CityGT != nil {
		predicates = append(predicates, customer.CityGT(*i.CityGT))
	}
	if i.CityGTE != nil {
		predicates = append(predicates, customer.CityGTE(*i.CityGTE))
	}
	if i.CityLT != nil {
		predicates = append(predicates, customer.CityLT(*i.CityLT))
	}
	if i.CityLTE != nil {
		predicates = append(predicates, customer.CityLTE(*i.CityLTE))
	}
	if i.CityContains != nil {
		predicates = append(predicates, customer.CityContains(*i.CityContains))
	}
	if i.CityHasPrefix != nil {
		predicates = append(predicates, customer.CityHasPrefix(*i.CityHasPrefix))
	}
	if i.CityHasSuffix != nil {
		predicates = append(predicates, customer.CityHasSuffix(*i.CityHasSuffix))
	}
	if i.CityEqualFold != nil {
		predicates = append(predicates, customer.CityEqualFold(*i.CityEqualFold))
	}
	if i.CityContainsFold != nil {
		predicates = append(predicates, customer.CityContainsFold(*i.CityContainsFold))
	}
	if i.Country != nil {
		predicates = append(predicates, customer.CountryEQ(*i.Country))
	}
	if i.CountryNEQ != nil {
		predicates = append(predicates, customer.CountryNEQ(*i.CountryNEQ))
	}
	if len(i.CountryIn) > 0 {
		predicates = append(predicates, customer.CountryIn(i.CountryIn...))
	}
	if len(i.CountryNotIn) > 0 {
		predicates = append(predicates, customer.CountryNotIn(i.CountryNotIn...))
	}
	if i.CountryGT != nil {
		predicates = append(predicates, customer.CountryGT(*i.CountryGT))
	}
	if i.CountryGTE != nil {
		predicates = append(predicates, customer.CountryGTE(*i.CountryGTE))
	}
	if i.CountryLT != nil {
		predicates = append(predicates, customer.CountryLT(*i.CountryLT))
	}
	if i.CountryLTE != nil {
		predicates = append(predicates, customer.CountryLTE(*i.CountryLTE))
	}
	if i.CountryContains != nil {
		predicates = append(predicates, customer.CountryContains(*i.CountryContains))
	}
	if i.CountryHasPrefix != nil {
		predicates = append(predicates, customer.CountryHasPrefix(*i.CountryHasPrefix))
	}
	if i.CountryHasSuffix != nil {
		predicates = append(predicates, customer.CountryHasSuffix(*i.CountryHasSuffix))
	}
	if i.CountryIsNil {
		predicates = append(predicates, customer.CountryIsNil())
	}
	if i.CountryNotNil {
		predicates = append(predicates, customer.CountryNotNil())
	}
	if i.CountryEqualFold != nil {
		predicates = append(predicates, customer.CountryEqualFold(*i.CountryEqualFold))
	}
	if i.CountryContainsFold != nil {
		predicates = append(predicates, customer.CountryContainsFold(*i.CountryContainsFold))
	}
	if i.Description != nil {
		predicates = append(predicates, customer.DescriptionEQ(*i.Description))
	}
	if i.DescriptionNEQ != nil {
		predicates = append(predicates, customer.DescriptionNEQ(*i.DescriptionNEQ))
	}
	if len(i.DescriptionIn) > 0 {
		predicates = append(predicates, customer.DescriptionIn(i.DescriptionIn...))
	}
	if len(i.DescriptionNotIn) > 0 {
		predicates = append(predicates, customer.DescriptionNotIn(i.DescriptionNotIn...))
	}
	if i.DescriptionGT != nil {
		predicates = append(predicates, customer.DescriptionGT(*i.DescriptionGT))
	}
	if i.DescriptionGTE != nil {
		predicates = append(predicates, customer.DescriptionGTE(*i.DescriptionGTE))
	}
	if i.DescriptionLT != nil {
		predicates = append(predicates, customer.DescriptionLT(*i.DescriptionLT))
	}
	if i.DescriptionLTE != nil {
		predicates = append(predicates, customer.DescriptionLTE(*i.DescriptionLTE))
	}
	if i.DescriptionContains != nil {
		predicates = append(predicates, customer.DescriptionContains(*i.DescriptionContains))
	}
	if i.DescriptionHasPrefix != nil {
		predicates = append(predicates, customer.DescriptionHasPrefix(*i.DescriptionHasPrefix))
	}
	if i.DescriptionHasSuffix != nil {
		predicates = append(predicates, customer.DescriptionHasSuffix(*i.DescriptionHasSuffix))
	}
	if i.DescriptionIsNil {
		predicates = append(predicates, customer.DescriptionIsNil())
	}
	if i.DescriptionNotNil {
		predicates = append(predicates, customer.DescriptionNotNil())
	}
	if i.DescriptionEqualFold != nil {
		predicates = append(predicates, customer.DescriptionEqualFold(*i.DescriptionEqualFold))
	}
	if i.DescriptionContainsFold != nil {
		predicates = append(predicates, customer.DescriptionContainsFold(*i.DescriptionContainsFold))
	}
	if i.Email != nil {
		predicates = append(predicates, customer.EmailEQ(*i.Email))
	}
	if i.EmailNEQ != nil {
		predicates = append(predicates, customer.EmailNEQ(*i.EmailNEQ))
	}
	if len(i.EmailIn) > 0 {
		predicates = append(predicates, customer.EmailIn(i.EmailIn...))
	}
	if len(i.EmailNotIn) > 0 {
		predicates = append(predicates, customer.EmailNotIn(i.EmailNotIn...))
	}
	if i.EmailGT != nil {
		predicates = append(predicates, customer.EmailGT(*i.EmailGT))
	}
	if i.EmailGTE != nil {
		predicates = append(predicates, customer.EmailGTE(*i.EmailGTE))
	}
	if i.EmailLT != nil {
		predicates = append(predicates, customer.EmailLT(*i.EmailLT))
	}
	if i.EmailLTE != nil {
		predicates = append(predicates, customer.EmailLTE(*i.EmailLTE))
	}
	if i.EmailContains != nil {
		predicates = append(predicates, customer.EmailContains(*i.EmailContains))
	}
	if i.EmailHasPrefix != nil {
		predicates = append(predicates, customer.EmailHasPrefix(*i.EmailHasPrefix))
	}
	if i.EmailHasSuffix != nil {
		predicates = append(predicates, customer.EmailHasSuffix(*i.EmailHasSuffix))
	}
	if i.EmailIsNil {
		predicates = append(predicates, customer.EmailIsNil())
	}
	if i.EmailNotNil {
		predicates = append(predicates, customer.EmailNotNil())
	}
	if i.EmailEqualFold != nil {
		predicates = append(predicates, customer.EmailEqualFold(*i.EmailEqualFold))
	}
	if i.EmailContainsFold != nil {
		predicates = append(predicates, customer.EmailContainsFold(*i.EmailContainsFold))
	}
	if i.IsDefault != nil {
		predicates = append(predicates, customer.IsDefaultEQ(*i.IsDefault))
	}
	if i.IsDefaultNEQ != nil {
		predicates = append(predicates, customer.IsDefaultNEQ(*i.IsDefaultNEQ))
	}
	if i.IsDefaultIsNil {
		predicates = append(predicates, customer.IsDefaultIsNil())
	}
	if i.IsDefaultNotNil {
		predicates = append(predicates, customer.IsDefaultNotNil())
	}
	if i.Name != nil {
		predicates = append(predicates, customer.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, customer.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, customer.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, customer.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, customer.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, customer.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, customer.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, customer.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, customer.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, customer.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, customer.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, customer.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, customer.NameContainsFold(*i.NameContainsFold))
	}
	if i.Phone != nil {
		predicates = append(predicates, customer.PhoneEQ(*i.Phone))
	}
	if i.PhoneNEQ != nil {
		predicates = append(predicates, customer.PhoneNEQ(*i.PhoneNEQ))
	}
	if len(i.PhoneIn) > 0 {
		predicates = append(predicates, customer.PhoneIn(i.PhoneIn...))
	}
	if len(i.PhoneNotIn) > 0 {
		predicates = append(predicates, customer.PhoneNotIn(i.PhoneNotIn...))
	}
	if i.PhoneGT != nil {
		predicates = append(predicates, customer.PhoneGT(*i.PhoneGT))
	}
	if i.PhoneGTE != nil {
		predicates = append(predicates, customer.PhoneGTE(*i.PhoneGTE))
	}
	if i.PhoneLT != nil {
		predicates = append(predicates, customer.PhoneLT(*i.PhoneLT))
	}
	if i.PhoneLTE != nil {
		predicates = append(predicates, customer.PhoneLTE(*i.PhoneLTE))
	}
	if i.PhoneContains != nil {
		predicates = append(predicates, customer.PhoneContains(*i.PhoneContains))
	}
	if i.PhoneHasPrefix != nil {
		predicates = append(predicates, customer.PhoneHasPrefix(*i.PhoneHasPrefix))
	}
	if i.PhoneHasSuffix != nil {
		predicates = append(predicates, customer.PhoneHasSuffix(*i.PhoneHasSuffix))
	}
	if i.PhoneEqualFold != nil {
		predicates = append(predicates, customer.PhoneEqualFold(*i.PhoneEqualFold))
	}
	if i.PhoneContainsFold != nil {
		predicates = append(predicates, customer.PhoneContainsFold(*i.PhoneContainsFold))
	}
	if i.TaxId != nil {
		predicates = append(predicates, customer.TaxIdEQ(*i.TaxId))
	}
	if i.TaxIdNEQ != nil {
		predicates = append(predicates, customer.TaxIdNEQ(*i.TaxIdNEQ))
	}
	if len(i.TaxIdIn) > 0 {
		predicates = append(predicates, customer.TaxIdIn(i.TaxIdIn...))
	}
	if len(i.TaxIdNotIn) > 0 {
		predicates = append(predicates, customer.TaxIdNotIn(i.TaxIdNotIn...))
	}
	if i.TaxIdGT != nil {
		predicates = append(predicates, customer.TaxIdGT(*i.TaxIdGT))
	}
	if i.TaxIdGTE != nil {
		predicates = append(predicates, customer.TaxIdGTE(*i.TaxIdGTE))
	}
	if i.TaxIdLT != nil {
		predicates = append(predicates, customer.TaxIdLT(*i.TaxIdLT))
	}
	if i.TaxIdLTE != nil {
		predicates = append(predicates, customer.TaxIdLTE(*i.TaxIdLTE))
	}
	if i.TaxIdContains != nil {
		predicates = append(predicates, customer.TaxIdContains(*i.TaxIdContains))
	}
	if i.TaxIdHasPrefix != nil {
		predicates = append(predicates, customer.TaxIdHasPrefix(*i.TaxIdHasPrefix))
	}
	if i.TaxIdHasSuffix != nil {
		predicates = append(predicates, customer.TaxIdHasSuffix(*i.TaxIdHasSuffix))
	}
	if i.TaxIdEqualFold != nil {
		predicates = append(predicates, customer.TaxIdEqualFold(*i.TaxIdEqualFold))
	}
	if i.TaxIdContainsFold != nil {
		predicates = append(predicates, customer.TaxIdContainsFold(*i.TaxIdContainsFold))
	}

	if i.HasCompany != nil {
		p := customer.HasCompany()
		if !*i.HasCompany {
			p = customer.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasCompanyWith) > 0 {
		with := make([]predicate.Company, 0, len(i.HasCompanyWith))
		for _, w := range i.HasCompanyWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasCompanyWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, customer.HasCompanyWith(with...))
	}
	if i.HasReceivables != nil {
		p := customer.HasReceivables()
		if !*i.HasReceivables {
			p = customer.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasReceivablesWith) > 0 {
		with := make([]predicate.Receivable, 0, len(i.HasReceivablesWith))
		for _, w := range i.HasReceivablesWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasReceivablesWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, customer.HasReceivablesWith(with...))
	}
	if i.HasInvoices != nil {
		p := customer.HasInvoices()
		if !*i.HasInvoices {
			p = customer.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasInvoicesWith) > 0 {
		with := make([]predicate.Invoice, 0, len(i.HasInvoicesWith))
		for _, w := range i.HasInvoicesWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasInvoicesWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, customer.HasInvoicesWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyCustomerWhereInput
	case 1:
		return predicates[0], nil
	default:
		return customer.And(predicates...), nil
	}
}

// EmployeeWhereInput represents a where input for filtering Employee queries.
type EmployeeWhereInput struct {
	Predicates []predicate.Employee  `json:"-"`
	Not        *EmployeeWhereInput   `json:"not,omitempty"`
	Or         []*EmployeeWhereInput `json:"or,omitempty"`
	And        []*EmployeeWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "createdAt" field predicates.
	CreatedAt      *time.Time  `json:"createdat,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdatNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdatIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdatNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdatGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdatGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdatLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdatLTE,omitempty"`

	// "updatedAt" field predicates.
	UpdatedAt      *time.Time  `json:"updatedat,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedatNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedatIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedatNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedatGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedatGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedatLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedatLTE,omitempty"`

	// "deletedAt" field predicates.
	DeletedAt       *time.Time  `json:"deletedat,omitempty"`
	DeletedAtNEQ    *time.Time  `json:"deletedatNEQ,omitempty"`
	DeletedAtIn     []time.Time `json:"deletedatIn,omitempty"`
	DeletedAtNotIn  []time.Time `json:"deletedatNotIn,omitempty"`
	DeletedAtGT     *time.Time  `json:"deletedatGT,omitempty"`
	DeletedAtGTE    *time.Time  `json:"deletedatGTE,omitempty"`
	DeletedAtLT     *time.Time  `json:"deletedatLT,omitempty"`
	DeletedAtLTE    *time.Time  `json:"deletedatLTE,omitempty"`
	DeletedAtIsNil  bool        `json:"deletedatIsNil,omitempty"`
	DeletedAtNotNil bool        `json:"deletedatNotNil,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "birthdate" field predicates.
	Birthdate       *time.Time  `json:"birthdate,omitempty"`
	BirthdateNEQ    *time.Time  `json:"birthdateNEQ,omitempty"`
	BirthdateIn     []time.Time `json:"birthdateIn,omitempty"`
	BirthdateNotIn  []time.Time `json:"birthdateNotIn,omitempty"`
	BirthdateGT     *time.Time  `json:"birthdateGT,omitempty"`
	BirthdateGTE    *time.Time  `json:"birthdateGTE,omitempty"`
	BirthdateLT     *time.Time  `json:"birthdateLT,omitempty"`
	BirthdateLTE    *time.Time  `json:"birthdateLTE,omitempty"`
	BirthdateIsNil  bool        `json:"birthdateIsNil,omitempty"`
	BirthdateNotNil bool        `json:"birthdateNotNil,omitempty"`

	// "gender" field predicates.
	Gender      *employee.Gender  `json:"gender,omitempty"`
	GenderNEQ   *employee.Gender  `json:"genderNEQ,omitempty"`
	GenderIn    []employee.Gender `json:"genderIn,omitempty"`
	GenderNotIn []employee.Gender `json:"genderNotIn,omitempty"`

	// "position" field predicates.
	Position             *string  `json:"position,omitempty"`
	PositionNEQ          *string  `json:"positionNEQ,omitempty"`
	PositionIn           []string `json:"positionIn,omitempty"`
	PositionNotIn        []string `json:"positionNotIn,omitempty"`
	PositionGT           *string  `json:"positionGT,omitempty"`
	PositionGTE          *string  `json:"positionGTE,omitempty"`
	PositionLT           *string  `json:"positionLT,omitempty"`
	PositionLTE          *string  `json:"positionLTE,omitempty"`
	PositionContains     *string  `json:"positionContains,omitempty"`
	PositionHasPrefix    *string  `json:"positionHasPrefix,omitempty"`
	PositionHasSuffix    *string  `json:"positionHasSuffix,omitempty"`
	PositionEqualFold    *string  `json:"positionEqualFold,omitempty"`
	PositionContainsFold *string  `json:"positionContainsFold,omitempty"`

	// "department" field predicates.
	Department             *string  `json:"department,omitempty"`
	DepartmentNEQ          *string  `json:"departmentNEQ,omitempty"`
	DepartmentIn           []string `json:"departmentIn,omitempty"`
	DepartmentNotIn        []string `json:"departmentNotIn,omitempty"`
	DepartmentGT           *string  `json:"departmentGT,omitempty"`
	DepartmentGTE          *string  `json:"departmentGTE,omitempty"`
	DepartmentLT           *string  `json:"departmentLT,omitempty"`
	DepartmentLTE          *string  `json:"departmentLTE,omitempty"`
	DepartmentContains     *string  `json:"departmentContains,omitempty"`
	DepartmentHasPrefix    *string  `json:"departmentHasPrefix,omitempty"`
	DepartmentHasSuffix    *string  `json:"departmentHasSuffix,omitempty"`
	DepartmentIsNil        bool     `json:"departmentIsNil,omitempty"`
	DepartmentNotNil       bool     `json:"departmentNotNil,omitempty"`
	DepartmentEqualFold    *string  `json:"departmentEqualFold,omitempty"`
	DepartmentContainsFold *string  `json:"departmentContainsFold,omitempty"`

	// "email" field predicates.
	Email             *string  `json:"email,omitempty"`
	EmailNEQ          *string  `json:"emailNEQ,omitempty"`
	EmailIn           []string `json:"emailIn,omitempty"`
	EmailNotIn        []string `json:"emailNotIn,omitempty"`
	EmailGT           *string  `json:"emailGT,omitempty"`
	EmailGTE          *string  `json:"emailGTE,omitempty"`
	EmailLT           *string  `json:"emailLT,omitempty"`
	EmailLTE          *string  `json:"emailLTE,omitempty"`
	EmailContains     *string  `json:"emailContains,omitempty"`
	EmailHasPrefix    *string  `json:"emailHasPrefix,omitempty"`
	EmailHasSuffix    *string  `json:"emailHasSuffix,omitempty"`
	EmailIsNil        bool     `json:"emailIsNil,omitempty"`
	EmailNotNil       bool     `json:"emailNotNil,omitempty"`
	EmailEqualFold    *string  `json:"emailEqualFold,omitempty"`
	EmailContainsFold *string  `json:"emailContainsFold,omitempty"`

	// "phone" field predicates.
	Phone             *string  `json:"phone,omitempty"`
	PhoneNEQ          *string  `json:"phoneNEQ,omitempty"`
	PhoneIn           []string `json:"phoneIn,omitempty"`
	PhoneNotIn        []string `json:"phoneNotIn,omitempty"`
	PhoneGT           *string  `json:"phoneGT,omitempty"`
	PhoneGTE          *string  `json:"phoneGTE,omitempty"`
	PhoneLT           *string  `json:"phoneLT,omitempty"`
	PhoneLTE          *string  `json:"phoneLTE,omitempty"`
	PhoneContains     *string  `json:"phoneContains,omitempty"`
	PhoneHasPrefix    *string  `json:"phoneHasPrefix,omitempty"`
	PhoneHasSuffix    *string  `json:"phoneHasSuffix,omitempty"`
	PhoneIsNil        bool     `json:"phoneIsNil,omitempty"`
	PhoneNotNil       bool     `json:"phoneNotNil,omitempty"`
	PhoneEqualFold    *string  `json:"phoneEqualFold,omitempty"`
	PhoneContainsFold *string  `json:"phoneContainsFold,omitempty"`

	// "avatar" field predicates.
	Avatar             *string  `json:"avatar,omitempty"`
	AvatarNEQ          *string  `json:"avatarNEQ,omitempty"`
	AvatarIn           []string `json:"avatarIn,omitempty"`
	AvatarNotIn        []string `json:"avatarNotIn,omitempty"`
	AvatarGT           *string  `json:"avatarGT,omitempty"`
	AvatarGTE          *string  `json:"avatarGTE,omitempty"`
	AvatarLT           *string  `json:"avatarLT,omitempty"`
	AvatarLTE          *string  `json:"avatarLTE,omitempty"`
	AvatarContains     *string  `json:"avatarContains,omitempty"`
	AvatarHasPrefix    *string  `json:"avatarHasPrefix,omitempty"`
	AvatarHasSuffix    *string  `json:"avatarHasSuffix,omitempty"`
	AvatarIsNil        bool     `json:"avatarIsNil,omitempty"`
	AvatarNotNil       bool     `json:"avatarNotNil,omitempty"`
	AvatarEqualFold    *string  `json:"avatarEqualFold,omitempty"`
	AvatarContainsFold *string  `json:"avatarContainsFold,omitempty"`

	// "hireDate" field predicates.
	HireDate      *time.Time  `json:"hiredate,omitempty"`
	HireDateNEQ   *time.Time  `json:"hiredateNEQ,omitempty"`
	HireDateIn    []time.Time `json:"hiredateIn,omitempty"`
	HireDateNotIn []time.Time `json:"hiredateNotIn,omitempty"`
	HireDateGT    *time.Time  `json:"hiredateGT,omitempty"`
	HireDateGTE   *time.Time  `json:"hiredateGTE,omitempty"`
	HireDateLT    *time.Time  `json:"hiredateLT,omitempty"`
	HireDateLTE   *time.Time  `json:"hiredateLTE,omitempty"`

	// "monthlySalary" field predicates.
	MonthlySalary      *int  `json:"monthlysalary,omitempty"`
	MonthlySalaryNEQ   *int  `json:"monthlysalaryNEQ,omitempty"`
	MonthlySalaryIn    []int `json:"monthlysalaryIn,omitempty"`
	MonthlySalaryNotIn []int `json:"monthlysalaryNotIn,omitempty"`
	MonthlySalaryGT    *int  `json:"monthlysalaryGT,omitempty"`
	MonthlySalaryGTE   *int  `json:"monthlysalaryGTE,omitempty"`
	MonthlySalaryLT    *int  `json:"monthlysalaryLT,omitempty"`
	MonthlySalaryLTE   *int  `json:"monthlysalaryLTE,omitempty"`

	// "status" field predicates.
	Status       *employee.Status  `json:"status,omitempty"`
	StatusNEQ    *employee.Status  `json:"statusNEQ,omitempty"`
	StatusIn     []employee.Status `json:"statusIn,omitempty"`
	StatusNotIn  []employee.Status `json:"statusNotIn,omitempty"`
	StatusIsNil  bool              `json:"statusIsNil,omitempty"`
	StatusNotNil bool              `json:"statusNotNil,omitempty"`

	// "performaceScore" field predicates.
	PerformaceScore       *float64  `json:"performacescore,omitempty"`
	PerformaceScoreNEQ    *float64  `json:"performacescoreNEQ,omitempty"`
	PerformaceScoreIn     []float64 `json:"performacescoreIn,omitempty"`
	PerformaceScoreNotIn  []float64 `json:"performacescoreNotIn,omitempty"`
	PerformaceScoreGT     *float64  `json:"performacescoreGT,omitempty"`
	PerformaceScoreGTE    *float64  `json:"performacescoreGTE,omitempty"`
	PerformaceScoreLT     *float64  `json:"performacescoreLT,omitempty"`
	PerformaceScoreLTE    *float64  `json:"performacescoreLTE,omitempty"`
	PerformaceScoreIsNil  bool      `json:"performacescoreIsNil,omitempty"`
	PerformaceScoreNotNil bool      `json:"performacescoreNotNil,omitempty"`

	// "company" edge predicates.
	HasCompany     *bool                `json:"hasCompany,omitempty"`
	HasCompanyWith []*CompanyWhereInput `json:"hasCompanyWith,omitempty"`

	// "user" edge predicates.
	HasUser     *bool             `json:"hasUser,omitempty"`
	HasUserWith []*UserWhereInput `json:"hasUserWith,omitempty"`

	// "subordinates" edge predicates.
	HasSubordinates     *bool                 `json:"hasSubordinates,omitempty"`
	HasSubordinatesWith []*EmployeeWhereInput `json:"hasSubordinatesWith,omitempty"`

	// "leader" edge predicates.
	HasLeader     *bool                 `json:"hasLeader,omitempty"`
	HasLeaderWith []*EmployeeWhereInput `json:"hasLeaderWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *EmployeeWhereInput) AddPredicates(predicates ...predicate.Employee) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the EmployeeWhereInput filter on the EmployeeQuery builder.
func (i *EmployeeWhereInput) Filter(q *EmployeeQuery) (*EmployeeQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyEmployeeWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyEmployeeWhereInput is returned in case the EmployeeWhereInput is empty.
var ErrEmptyEmployeeWhereInput = errors.New("generated: empty predicate EmployeeWhereInput")

// P returns a predicate for filtering employees.
// An error is returned if the input is empty or invalid.
func (i *EmployeeWhereInput) P() (predicate.Employee, error) {
	var predicates []predicate.Employee
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, employee.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Employee, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, employee.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Employee, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, employee.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, employee.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, employee.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, employee.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, employee.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, employee.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, employee.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, employee.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, employee.IDLTE(*i.IDLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, employee.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, employee.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, employee.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, employee.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, employee.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, employee.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, employee.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, employee.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, employee.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, employee.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, employee.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, employee.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, employee.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, employee.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, employee.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, employee.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.DeletedAt != nil {
		predicates = append(predicates, employee.DeletedAtEQ(*i.DeletedAt))
	}
	if i.DeletedAtNEQ != nil {
		predicates = append(predicates, employee.DeletedAtNEQ(*i.DeletedAtNEQ))
	}
	if len(i.DeletedAtIn) > 0 {
		predicates = append(predicates, employee.DeletedAtIn(i.DeletedAtIn...))
	}
	if len(i.DeletedAtNotIn) > 0 {
		predicates = append(predicates, employee.DeletedAtNotIn(i.DeletedAtNotIn...))
	}
	if i.DeletedAtGT != nil {
		predicates = append(predicates, employee.DeletedAtGT(*i.DeletedAtGT))
	}
	if i.DeletedAtGTE != nil {
		predicates = append(predicates, employee.DeletedAtGTE(*i.DeletedAtGTE))
	}
	if i.DeletedAtLT != nil {
		predicates = append(predicates, employee.DeletedAtLT(*i.DeletedAtLT))
	}
	if i.DeletedAtLTE != nil {
		predicates = append(predicates, employee.DeletedAtLTE(*i.DeletedAtLTE))
	}
	if i.DeletedAtIsNil {
		predicates = append(predicates, employee.DeletedAtIsNil())
	}
	if i.DeletedAtNotNil {
		predicates = append(predicates, employee.DeletedAtNotNil())
	}
	if i.Name != nil {
		predicates = append(predicates, employee.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, employee.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, employee.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, employee.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, employee.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, employee.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, employee.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, employee.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, employee.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, employee.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, employee.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, employee.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, employee.NameContainsFold(*i.NameContainsFold))
	}
	if i.Birthdate != nil {
		predicates = append(predicates, employee.BirthdateEQ(*i.Birthdate))
	}
	if i.BirthdateNEQ != nil {
		predicates = append(predicates, employee.BirthdateNEQ(*i.BirthdateNEQ))
	}
	if len(i.BirthdateIn) > 0 {
		predicates = append(predicates, employee.BirthdateIn(i.BirthdateIn...))
	}
	if len(i.BirthdateNotIn) > 0 {
		predicates = append(predicates, employee.BirthdateNotIn(i.BirthdateNotIn...))
	}
	if i.BirthdateGT != nil {
		predicates = append(predicates, employee.BirthdateGT(*i.BirthdateGT))
	}
	if i.BirthdateGTE != nil {
		predicates = append(predicates, employee.BirthdateGTE(*i.BirthdateGTE))
	}
	if i.BirthdateLT != nil {
		predicates = append(predicates, employee.BirthdateLT(*i.BirthdateLT))
	}
	if i.BirthdateLTE != nil {
		predicates = append(predicates, employee.BirthdateLTE(*i.BirthdateLTE))
	}
	if i.BirthdateIsNil {
		predicates = append(predicates, employee.BirthdateIsNil())
	}
	if i.BirthdateNotNil {
		predicates = append(predicates, employee.BirthdateNotNil())
	}
	if i.Gender != nil {
		predicates = append(predicates, employee.GenderEQ(*i.Gender))
	}
	if i.GenderNEQ != nil {
		predicates = append(predicates, employee.GenderNEQ(*i.GenderNEQ))
	}
	if len(i.GenderIn) > 0 {
		predicates = append(predicates, employee.GenderIn(i.GenderIn...))
	}
	if len(i.GenderNotIn) > 0 {
		predicates = append(predicates, employee.GenderNotIn(i.GenderNotIn...))
	}
	if i.Position != nil {
		predicates = append(predicates, employee.PositionEQ(*i.Position))
	}
	if i.PositionNEQ != nil {
		predicates = append(predicates, employee.PositionNEQ(*i.PositionNEQ))
	}
	if len(i.PositionIn) > 0 {
		predicates = append(predicates, employee.PositionIn(i.PositionIn...))
	}
	if len(i.PositionNotIn) > 0 {
		predicates = append(predicates, employee.PositionNotIn(i.PositionNotIn...))
	}
	if i.PositionGT != nil {
		predicates = append(predicates, employee.PositionGT(*i.PositionGT))
	}
	if i.PositionGTE != nil {
		predicates = append(predicates, employee.PositionGTE(*i.PositionGTE))
	}
	if i.PositionLT != nil {
		predicates = append(predicates, employee.PositionLT(*i.PositionLT))
	}
	if i.PositionLTE != nil {
		predicates = append(predicates, employee.PositionLTE(*i.PositionLTE))
	}
	if i.PositionContains != nil {
		predicates = append(predicates, employee.PositionContains(*i.PositionContains))
	}
	if i.PositionHasPrefix != nil {
		predicates = append(predicates, employee.PositionHasPrefix(*i.PositionHasPrefix))
	}
	if i.PositionHasSuffix != nil {
		predicates = append(predicates, employee.PositionHasSuffix(*i.PositionHasSuffix))
	}
	if i.PositionEqualFold != nil {
		predicates = append(predicates, employee.PositionEqualFold(*i.PositionEqualFold))
	}
	if i.PositionContainsFold != nil {
		predicates = append(predicates, employee.PositionContainsFold(*i.PositionContainsFold))
	}
	if i.Department != nil {
		predicates = append(predicates, employee.DepartmentEQ(*i.Department))
	}
	if i.DepartmentNEQ != nil {
		predicates = append(predicates, employee.DepartmentNEQ(*i.DepartmentNEQ))
	}
	if len(i.DepartmentIn) > 0 {
		predicates = append(predicates, employee.DepartmentIn(i.DepartmentIn...))
	}
	if len(i.DepartmentNotIn) > 0 {
		predicates = append(predicates, employee.DepartmentNotIn(i.DepartmentNotIn...))
	}
	if i.DepartmentGT != nil {
		predicates = append(predicates, employee.DepartmentGT(*i.DepartmentGT))
	}
	if i.DepartmentGTE != nil {
		predicates = append(predicates, employee.DepartmentGTE(*i.DepartmentGTE))
	}
	if i.DepartmentLT != nil {
		predicates = append(predicates, employee.DepartmentLT(*i.DepartmentLT))
	}
	if i.DepartmentLTE != nil {
		predicates = append(predicates, employee.DepartmentLTE(*i.DepartmentLTE))
	}
	if i.DepartmentContains != nil {
		predicates = append(predicates, employee.DepartmentContains(*i.DepartmentContains))
	}
	if i.DepartmentHasPrefix != nil {
		predicates = append(predicates, employee.DepartmentHasPrefix(*i.DepartmentHasPrefix))
	}
	if i.DepartmentHasSuffix != nil {
		predicates = append(predicates, employee.DepartmentHasSuffix(*i.DepartmentHasSuffix))
	}
	if i.DepartmentIsNil {
		predicates = append(predicates, employee.DepartmentIsNil())
	}
	if i.DepartmentNotNil {
		predicates = append(predicates, employee.DepartmentNotNil())
	}
	if i.DepartmentEqualFold != nil {
		predicates = append(predicates, employee.DepartmentEqualFold(*i.DepartmentEqualFold))
	}
	if i.DepartmentContainsFold != nil {
		predicates = append(predicates, employee.DepartmentContainsFold(*i.DepartmentContainsFold))
	}
	if i.Email != nil {
		predicates = append(predicates, employee.EmailEQ(*i.Email))
	}
	if i.EmailNEQ != nil {
		predicates = append(predicates, employee.EmailNEQ(*i.EmailNEQ))
	}
	if len(i.EmailIn) > 0 {
		predicates = append(predicates, employee.EmailIn(i.EmailIn...))
	}
	if len(i.EmailNotIn) > 0 {
		predicates = append(predicates, employee.EmailNotIn(i.EmailNotIn...))
	}
	if i.EmailGT != nil {
		predicates = append(predicates, employee.EmailGT(*i.EmailGT))
	}
	if i.EmailGTE != nil {
		predicates = append(predicates, employee.EmailGTE(*i.EmailGTE))
	}
	if i.EmailLT != nil {
		predicates = append(predicates, employee.EmailLT(*i.EmailLT))
	}
	if i.EmailLTE != nil {
		predicates = append(predicates, employee.EmailLTE(*i.EmailLTE))
	}
	if i.EmailContains != nil {
		predicates = append(predicates, employee.EmailContains(*i.EmailContains))
	}
	if i.EmailHasPrefix != nil {
		predicates = append(predicates, employee.EmailHasPrefix(*i.EmailHasPrefix))
	}
	if i.EmailHasSuffix != nil {
		predicates = append(predicates, employee.EmailHasSuffix(*i.EmailHasSuffix))
	}
	if i.EmailIsNil {
		predicates = append(predicates, employee.EmailIsNil())
	}
	if i.EmailNotNil {
		predicates = append(predicates, employee.EmailNotNil())
	}
	if i.EmailEqualFold != nil {
		predicates = append(predicates, employee.EmailEqualFold(*i.EmailEqualFold))
	}
	if i.EmailContainsFold != nil {
		predicates = append(predicates, employee.EmailContainsFold(*i.EmailContainsFold))
	}
	if i.Phone != nil {
		predicates = append(predicates, employee.PhoneEQ(*i.Phone))
	}
	if i.PhoneNEQ != nil {
		predicates = append(predicates, employee.PhoneNEQ(*i.PhoneNEQ))
	}
	if len(i.PhoneIn) > 0 {
		predicates = append(predicates, employee.PhoneIn(i.PhoneIn...))
	}
	if len(i.PhoneNotIn) > 0 {
		predicates = append(predicates, employee.PhoneNotIn(i.PhoneNotIn...))
	}
	if i.PhoneGT != nil {
		predicates = append(predicates, employee.PhoneGT(*i.PhoneGT))
	}
	if i.PhoneGTE != nil {
		predicates = append(predicates, employee.PhoneGTE(*i.PhoneGTE))
	}
	if i.PhoneLT != nil {
		predicates = append(predicates, employee.PhoneLT(*i.PhoneLT))
	}
	if i.PhoneLTE != nil {
		predicates = append(predicates, employee.PhoneLTE(*i.PhoneLTE))
	}
	if i.PhoneContains != nil {
		predicates = append(predicates, employee.PhoneContains(*i.PhoneContains))
	}
	if i.PhoneHasPrefix != nil {
		predicates = append(predicates, employee.PhoneHasPrefix(*i.PhoneHasPrefix))
	}
	if i.PhoneHasSuffix != nil {
		predicates = append(predicates, employee.PhoneHasSuffix(*i.PhoneHasSuffix))
	}
	if i.PhoneIsNil {
		predicates = append(predicates, employee.PhoneIsNil())
	}
	if i.PhoneNotNil {
		predicates = append(predicates, employee.PhoneNotNil())
	}
	if i.PhoneEqualFold != nil {
		predicates = append(predicates, employee.PhoneEqualFold(*i.PhoneEqualFold))
	}
	if i.PhoneContainsFold != nil {
		predicates = append(predicates, employee.PhoneContainsFold(*i.PhoneContainsFold))
	}
	if i.Avatar != nil {
		predicates = append(predicates, employee.AvatarEQ(*i.Avatar))
	}
	if i.AvatarNEQ != nil {
		predicates = append(predicates, employee.AvatarNEQ(*i.AvatarNEQ))
	}
	if len(i.AvatarIn) > 0 {
		predicates = append(predicates, employee.AvatarIn(i.AvatarIn...))
	}
	if len(i.AvatarNotIn) > 0 {
		predicates = append(predicates, employee.AvatarNotIn(i.AvatarNotIn...))
	}
	if i.AvatarGT != nil {
		predicates = append(predicates, employee.AvatarGT(*i.AvatarGT))
	}
	if i.AvatarGTE != nil {
		predicates = append(predicates, employee.AvatarGTE(*i.AvatarGTE))
	}
	if i.AvatarLT != nil {
		predicates = append(predicates, employee.AvatarLT(*i.AvatarLT))
	}
	if i.AvatarLTE != nil {
		predicates = append(predicates, employee.AvatarLTE(*i.AvatarLTE))
	}
	if i.AvatarContains != nil {
		predicates = append(predicates, employee.AvatarContains(*i.AvatarContains))
	}
	if i.AvatarHasPrefix != nil {
		predicates = append(predicates, employee.AvatarHasPrefix(*i.AvatarHasPrefix))
	}
	if i.AvatarHasSuffix != nil {
		predicates = append(predicates, employee.AvatarHasSuffix(*i.AvatarHasSuffix))
	}
	if i.AvatarIsNil {
		predicates = append(predicates, employee.AvatarIsNil())
	}
	if i.AvatarNotNil {
		predicates = append(predicates, employee.AvatarNotNil())
	}
	if i.AvatarEqualFold != nil {
		predicates = append(predicates, employee.AvatarEqualFold(*i.AvatarEqualFold))
	}
	if i.AvatarContainsFold != nil {
		predicates = append(predicates, employee.AvatarContainsFold(*i.AvatarContainsFold))
	}
	if i.HireDate != nil {
		predicates = append(predicates, employee.HireDateEQ(*i.HireDate))
	}
	if i.HireDateNEQ != nil {
		predicates = append(predicates, employee.HireDateNEQ(*i.HireDateNEQ))
	}
	if len(i.HireDateIn) > 0 {
		predicates = append(predicates, employee.HireDateIn(i.HireDateIn...))
	}
	if len(i.HireDateNotIn) > 0 {
		predicates = append(predicates, employee.HireDateNotIn(i.HireDateNotIn...))
	}
	if i.HireDateGT != nil {
		predicates = append(predicates, employee.HireDateGT(*i.HireDateGT))
	}
	if i.HireDateGTE != nil {
		predicates = append(predicates, employee.HireDateGTE(*i.HireDateGTE))
	}
	if i.HireDateLT != nil {
		predicates = append(predicates, employee.HireDateLT(*i.HireDateLT))
	}
	if i.HireDateLTE != nil {
		predicates = append(predicates, employee.HireDateLTE(*i.HireDateLTE))
	}
	if i.MonthlySalary != nil {
		predicates = append(predicates, employee.MonthlySalaryEQ(*i.MonthlySalary))
	}
	if i.MonthlySalaryNEQ != nil {
		predicates = append(predicates, employee.MonthlySalaryNEQ(*i.MonthlySalaryNEQ))
	}
	if len(i.MonthlySalaryIn) > 0 {
		predicates = append(predicates, employee.MonthlySalaryIn(i.MonthlySalaryIn...))
	}
	if len(i.MonthlySalaryNotIn) > 0 {
		predicates = append(predicates, employee.MonthlySalaryNotIn(i.MonthlySalaryNotIn...))
	}
	if i.MonthlySalaryGT != nil {
		predicates = append(predicates, employee.MonthlySalaryGT(*i.MonthlySalaryGT))
	}
	if i.MonthlySalaryGTE != nil {
		predicates = append(predicates, employee.MonthlySalaryGTE(*i.MonthlySalaryGTE))
	}
	if i.MonthlySalaryLT != nil {
		predicates = append(predicates, employee.MonthlySalaryLT(*i.MonthlySalaryLT))
	}
	if i.MonthlySalaryLTE != nil {
		predicates = append(predicates, employee.MonthlySalaryLTE(*i.MonthlySalaryLTE))
	}
	if i.Status != nil {
		predicates = append(predicates, employee.StatusEQ(*i.Status))
	}
	if i.StatusNEQ != nil {
		predicates = append(predicates, employee.StatusNEQ(*i.StatusNEQ))
	}
	if len(i.StatusIn) > 0 {
		predicates = append(predicates, employee.StatusIn(i.StatusIn...))
	}
	if len(i.StatusNotIn) > 0 {
		predicates = append(predicates, employee.StatusNotIn(i.StatusNotIn...))
	}
	if i.StatusIsNil {
		predicates = append(predicates, employee.StatusIsNil())
	}
	if i.StatusNotNil {
		predicates = append(predicates, employee.StatusNotNil())
	}
	if i.PerformaceScore != nil {
		predicates = append(predicates, employee.PerformaceScoreEQ(*i.PerformaceScore))
	}
	if i.PerformaceScoreNEQ != nil {
		predicates = append(predicates, employee.PerformaceScoreNEQ(*i.PerformaceScoreNEQ))
	}
	if len(i.PerformaceScoreIn) > 0 {
		predicates = append(predicates, employee.PerformaceScoreIn(i.PerformaceScoreIn...))
	}
	if len(i.PerformaceScoreNotIn) > 0 {
		predicates = append(predicates, employee.PerformaceScoreNotIn(i.PerformaceScoreNotIn...))
	}
	if i.PerformaceScoreGT != nil {
		predicates = append(predicates, employee.PerformaceScoreGT(*i.PerformaceScoreGT))
	}
	if i.PerformaceScoreGTE != nil {
		predicates = append(predicates, employee.PerformaceScoreGTE(*i.PerformaceScoreGTE))
	}
	if i.PerformaceScoreLT != nil {
		predicates = append(predicates, employee.PerformaceScoreLT(*i.PerformaceScoreLT))
	}
	if i.PerformaceScoreLTE != nil {
		predicates = append(predicates, employee.PerformaceScoreLTE(*i.PerformaceScoreLTE))
	}
	if i.PerformaceScoreIsNil {
		predicates = append(predicates, employee.PerformaceScoreIsNil())
	}
	if i.PerformaceScoreNotNil {
		predicates = append(predicates, employee.PerformaceScoreNotNil())
	}

	if i.HasCompany != nil {
		p := employee.HasCompany()
		if !*i.HasCompany {
			p = employee.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasCompanyWith) > 0 {
		with := make([]predicate.Company, 0, len(i.HasCompanyWith))
		for _, w := range i.HasCompanyWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasCompanyWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, employee.HasCompanyWith(with...))
	}
	if i.HasUser != nil {
		p := employee.HasUser()
		if !*i.HasUser {
			p = employee.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasUserWith) > 0 {
		with := make([]predicate.User, 0, len(i.HasUserWith))
		for _, w := range i.HasUserWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasUserWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, employee.HasUserWith(with...))
	}
	if i.HasSubordinates != nil {
		p := employee.HasSubordinates()
		if !*i.HasSubordinates {
			p = employee.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasSubordinatesWith) > 0 {
		with := make([]predicate.Employee, 0, len(i.HasSubordinatesWith))
		for _, w := range i.HasSubordinatesWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasSubordinatesWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, employee.HasSubordinatesWith(with...))
	}
	if i.HasLeader != nil {
		p := employee.HasLeader()
		if !*i.HasLeader {
			p = employee.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasLeaderWith) > 0 {
		with := make([]predicate.Employee, 0, len(i.HasLeaderWith))
		for _, w := range i.HasLeaderWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasLeaderWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, employee.HasLeaderWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyEmployeeWhereInput
	case 1:
		return predicates[0], nil
	default:
		return employee.And(predicates...), nil
	}
}

// FileWhereInput represents a where input for filtering File queries.
type FileWhereInput struct {
	Predicates []predicate.File  `json:"-"`
	Not        *FileWhereInput   `json:"not,omitempty"`
	Or         []*FileWhereInput `json:"or,omitempty"`
	And        []*FileWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "createdAt" field predicates.
	CreatedAt      *time.Time  `json:"createdat,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdatNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdatIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdatNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdatGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdatGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdatLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdatLTE,omitempty"`

	// "updatedAt" field predicates.
	UpdatedAt      *time.Time  `json:"updatedat,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedatNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedatIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedatNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedatGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedatGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedatLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedatLTE,omitempty"`

	// "deletedAt" field predicates.
	DeletedAt       *time.Time  `json:"deletedat,omitempty"`
	DeletedAtNEQ    *time.Time  `json:"deletedatNEQ,omitempty"`
	DeletedAtIn     []time.Time `json:"deletedatIn,omitempty"`
	DeletedAtNotIn  []time.Time `json:"deletedatNotIn,omitempty"`
	DeletedAtGT     *time.Time  `json:"deletedatGT,omitempty"`
	DeletedAtGTE    *time.Time  `json:"deletedatGTE,omitempty"`
	DeletedAtLT     *time.Time  `json:"deletedatLT,omitempty"`
	DeletedAtLTE    *time.Time  `json:"deletedatLTE,omitempty"`
	DeletedAtIsNil  bool        `json:"deletedatIsNil,omitempty"`
	DeletedAtNotNil bool        `json:"deletedatNotNil,omitempty"`

	// "category" field predicates.
	Category      *file.Category  `json:"category,omitempty"`
	CategoryNEQ   *file.Category  `json:"categoryNEQ,omitempty"`
	CategoryIn    []file.Category `json:"categoryIn,omitempty"`
	CategoryNotIn []file.Category `json:"categoryNotIn,omitempty"`

	// "extension" field predicates.
	Extension             *string  `json:"extension,omitempty"`
	ExtensionNEQ          *string  `json:"extensionNEQ,omitempty"`
	ExtensionIn           []string `json:"extensionIn,omitempty"`
	ExtensionNotIn        []string `json:"extensionNotIn,omitempty"`
	ExtensionGT           *string  `json:"extensionGT,omitempty"`
	ExtensionGTE          *string  `json:"extensionGTE,omitempty"`
	ExtensionLT           *string  `json:"extensionLT,omitempty"`
	ExtensionLTE          *string  `json:"extensionLTE,omitempty"`
	ExtensionContains     *string  `json:"extensionContains,omitempty"`
	ExtensionHasPrefix    *string  `json:"extensionHasPrefix,omitempty"`
	ExtensionHasSuffix    *string  `json:"extensionHasSuffix,omitempty"`
	ExtensionEqualFold    *string  `json:"extensionEqualFold,omitempty"`
	ExtensionContainsFold *string  `json:"extensionContainsFold,omitempty"`

	// "size" field predicates.
	Size             *string  `json:"size,omitempty"`
	SizeNEQ          *string  `json:"sizeNEQ,omitempty"`
	SizeIn           []string `json:"sizeIn,omitempty"`
	SizeNotIn        []string `json:"sizeNotIn,omitempty"`
	SizeGT           *string  `json:"sizeGT,omitempty"`
	SizeGTE          *string  `json:"sizeGTE,omitempty"`
	SizeLT           *string  `json:"sizeLT,omitempty"`
	SizeLTE          *string  `json:"sizeLTE,omitempty"`
	SizeContains     *string  `json:"sizeContains,omitempty"`
	SizeHasPrefix    *string  `json:"sizeHasPrefix,omitempty"`
	SizeHasSuffix    *string  `json:"sizeHasSuffix,omitempty"`
	SizeEqualFold    *string  `json:"sizeEqualFold,omitempty"`
	SizeContainsFold *string  `json:"sizeContainsFold,omitempty"`

	// "uri" field predicates.
	URI             *string  `json:"uri,omitempty"`
	URINEQ          *string  `json:"uriNEQ,omitempty"`
	URIIn           []string `json:"uriIn,omitempty"`
	URINotIn        []string `json:"uriNotIn,omitempty"`
	URIGT           *string  `json:"uriGT,omitempty"`
	URIGTE          *string  `json:"uriGTE,omitempty"`
	URILT           *string  `json:"uriLT,omitempty"`
	URILTE          *string  `json:"uriLTE,omitempty"`
	URIContains     *string  `json:"uriContains,omitempty"`
	URIHasPrefix    *string  `json:"uriHasPrefix,omitempty"`
	URIHasSuffix    *string  `json:"uriHasSuffix,omitempty"`
	URIEqualFold    *string  `json:"uriEqualFold,omitempty"`
	URIContainsFold *string  `json:"uriContainsFold,omitempty"`

	// "url" field predicates.
	URL             *string  `json:"url,omitempty"`
	URLNEQ          *string  `json:"urlNEQ,omitempty"`
	URLIn           []string `json:"urlIn,omitempty"`
	URLNotIn        []string `json:"urlNotIn,omitempty"`
	URLGT           *string  `json:"urlGT,omitempty"`
	URLGTE          *string  `json:"urlGTE,omitempty"`
	URLLT           *string  `json:"urlLT,omitempty"`
	URLLTE          *string  `json:"urlLTE,omitempty"`
	URLContains     *string  `json:"urlContains,omitempty"`
	URLHasPrefix    *string  `json:"urlHasPrefix,omitempty"`
	URLHasSuffix    *string  `json:"urlHasSuffix,omitempty"`
	URLEqualFold    *string  `json:"urlEqualFold,omitempty"`
	URLContainsFold *string  `json:"urlContainsFold,omitempty"`

	// "description" field predicates.
	Description             *string  `json:"description,omitempty"`
	DescriptionNEQ          *string  `json:"descriptionNEQ,omitempty"`
	DescriptionIn           []string `json:"descriptionIn,omitempty"`
	DescriptionNotIn        []string `json:"descriptionNotIn,omitempty"`
	DescriptionGT           *string  `json:"descriptionGT,omitempty"`
	DescriptionGTE          *string  `json:"descriptionGTE,omitempty"`
	DescriptionLT           *string  `json:"descriptionLT,omitempty"`
	DescriptionLTE          *string  `json:"descriptionLTE,omitempty"`
	DescriptionContains     *string  `json:"descriptionContains,omitempty"`
	DescriptionHasPrefix    *string  `json:"descriptionHasPrefix,omitempty"`
	DescriptionHasSuffix    *string  `json:"descriptionHasSuffix,omitempty"`
	DescriptionEqualFold    *string  `json:"descriptionEqualFold,omitempty"`
	DescriptionContainsFold *string  `json:"descriptionContainsFold,omitempty"`

	// "company" edge predicates.
	HasCompany     *bool                `json:"hasCompany,omitempty"`
	HasCompanyWith []*CompanyWhereInput `json:"hasCompanyWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *FileWhereInput) AddPredicates(predicates ...predicate.File) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the FileWhereInput filter on the FileQuery builder.
func (i *FileWhereInput) Filter(q *FileQuery) (*FileQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyFileWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyFileWhereInput is returned in case the FileWhereInput is empty.
var ErrEmptyFileWhereInput = errors.New("generated: empty predicate FileWhereInput")

// P returns a predicate for filtering files.
// An error is returned if the input is empty or invalid.
func (i *FileWhereInput) P() (predicate.File, error) {
	var predicates []predicate.File
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, file.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.File, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, file.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.File, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, file.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, file.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, file.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, file.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, file.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, file.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, file.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, file.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, file.IDLTE(*i.IDLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, file.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, file.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, file.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, file.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, file.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, file.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, file.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, file.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, file.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, file.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, file.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, file.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, file.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, file.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, file.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, file.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.DeletedAt != nil {
		predicates = append(predicates, file.DeletedAtEQ(*i.DeletedAt))
	}
	if i.DeletedAtNEQ != nil {
		predicates = append(predicates, file.DeletedAtNEQ(*i.DeletedAtNEQ))
	}
	if len(i.DeletedAtIn) > 0 {
		predicates = append(predicates, file.DeletedAtIn(i.DeletedAtIn...))
	}
	if len(i.DeletedAtNotIn) > 0 {
		predicates = append(predicates, file.DeletedAtNotIn(i.DeletedAtNotIn...))
	}
	if i.DeletedAtGT != nil {
		predicates = append(predicates, file.DeletedAtGT(*i.DeletedAtGT))
	}
	if i.DeletedAtGTE != nil {
		predicates = append(predicates, file.DeletedAtGTE(*i.DeletedAtGTE))
	}
	if i.DeletedAtLT != nil {
		predicates = append(predicates, file.DeletedAtLT(*i.DeletedAtLT))
	}
	if i.DeletedAtLTE != nil {
		predicates = append(predicates, file.DeletedAtLTE(*i.DeletedAtLTE))
	}
	if i.DeletedAtIsNil {
		predicates = append(predicates, file.DeletedAtIsNil())
	}
	if i.DeletedAtNotNil {
		predicates = append(predicates, file.DeletedAtNotNil())
	}
	if i.Category != nil {
		predicates = append(predicates, file.CategoryEQ(*i.Category))
	}
	if i.CategoryNEQ != nil {
		predicates = append(predicates, file.CategoryNEQ(*i.CategoryNEQ))
	}
	if len(i.CategoryIn) > 0 {
		predicates = append(predicates, file.CategoryIn(i.CategoryIn...))
	}
	if len(i.CategoryNotIn) > 0 {
		predicates = append(predicates, file.CategoryNotIn(i.CategoryNotIn...))
	}
	if i.Extension != nil {
		predicates = append(predicates, file.ExtensionEQ(*i.Extension))
	}
	if i.ExtensionNEQ != nil {
		predicates = append(predicates, file.ExtensionNEQ(*i.ExtensionNEQ))
	}
	if len(i.ExtensionIn) > 0 {
		predicates = append(predicates, file.ExtensionIn(i.ExtensionIn...))
	}
	if len(i.ExtensionNotIn) > 0 {
		predicates = append(predicates, file.ExtensionNotIn(i.ExtensionNotIn...))
	}
	if i.ExtensionGT != nil {
		predicates = append(predicates, file.ExtensionGT(*i.ExtensionGT))
	}
	if i.ExtensionGTE != nil {
		predicates = append(predicates, file.ExtensionGTE(*i.ExtensionGTE))
	}
	if i.ExtensionLT != nil {
		predicates = append(predicates, file.ExtensionLT(*i.ExtensionLT))
	}
	if i.ExtensionLTE != nil {
		predicates = append(predicates, file.ExtensionLTE(*i.ExtensionLTE))
	}
	if i.ExtensionContains != nil {
		predicates = append(predicates, file.ExtensionContains(*i.ExtensionContains))
	}
	if i.ExtensionHasPrefix != nil {
		predicates = append(predicates, file.ExtensionHasPrefix(*i.ExtensionHasPrefix))
	}
	if i.ExtensionHasSuffix != nil {
		predicates = append(predicates, file.ExtensionHasSuffix(*i.ExtensionHasSuffix))
	}
	if i.ExtensionEqualFold != nil {
		predicates = append(predicates, file.ExtensionEqualFold(*i.ExtensionEqualFold))
	}
	if i.ExtensionContainsFold != nil {
		predicates = append(predicates, file.ExtensionContainsFold(*i.ExtensionContainsFold))
	}
	if i.Size != nil {
		predicates = append(predicates, file.SizeEQ(*i.Size))
	}
	if i.SizeNEQ != nil {
		predicates = append(predicates, file.SizeNEQ(*i.SizeNEQ))
	}
	if len(i.SizeIn) > 0 {
		predicates = append(predicates, file.SizeIn(i.SizeIn...))
	}
	if len(i.SizeNotIn) > 0 {
		predicates = append(predicates, file.SizeNotIn(i.SizeNotIn...))
	}
	if i.SizeGT != nil {
		predicates = append(predicates, file.SizeGT(*i.SizeGT))
	}
	if i.SizeGTE != nil {
		predicates = append(predicates, file.SizeGTE(*i.SizeGTE))
	}
	if i.SizeLT != nil {
		predicates = append(predicates, file.SizeLT(*i.SizeLT))
	}
	if i.SizeLTE != nil {
		predicates = append(predicates, file.SizeLTE(*i.SizeLTE))
	}
	if i.SizeContains != nil {
		predicates = append(predicates, file.SizeContains(*i.SizeContains))
	}
	if i.SizeHasPrefix != nil {
		predicates = append(predicates, file.SizeHasPrefix(*i.SizeHasPrefix))
	}
	if i.SizeHasSuffix != nil {
		predicates = append(predicates, file.SizeHasSuffix(*i.SizeHasSuffix))
	}
	if i.SizeEqualFold != nil {
		predicates = append(predicates, file.SizeEqualFold(*i.SizeEqualFold))
	}
	if i.SizeContainsFold != nil {
		predicates = append(predicates, file.SizeContainsFold(*i.SizeContainsFold))
	}
	if i.URI != nil {
		predicates = append(predicates, file.URIEQ(*i.URI))
	}
	if i.URINEQ != nil {
		predicates = append(predicates, file.URINEQ(*i.URINEQ))
	}
	if len(i.URIIn) > 0 {
		predicates = append(predicates, file.URIIn(i.URIIn...))
	}
	if len(i.URINotIn) > 0 {
		predicates = append(predicates, file.URINotIn(i.URINotIn...))
	}
	if i.URIGT != nil {
		predicates = append(predicates, file.URIGT(*i.URIGT))
	}
	if i.URIGTE != nil {
		predicates = append(predicates, file.URIGTE(*i.URIGTE))
	}
	if i.URILT != nil {
		predicates = append(predicates, file.URILT(*i.URILT))
	}
	if i.URILTE != nil {
		predicates = append(predicates, file.URILTE(*i.URILTE))
	}
	if i.URIContains != nil {
		predicates = append(predicates, file.URIContains(*i.URIContains))
	}
	if i.URIHasPrefix != nil {
		predicates = append(predicates, file.URIHasPrefix(*i.URIHasPrefix))
	}
	if i.URIHasSuffix != nil {
		predicates = append(predicates, file.URIHasSuffix(*i.URIHasSuffix))
	}
	if i.URIEqualFold != nil {
		predicates = append(predicates, file.URIEqualFold(*i.URIEqualFold))
	}
	if i.URIContainsFold != nil {
		predicates = append(predicates, file.URIContainsFold(*i.URIContainsFold))
	}
	if i.URL != nil {
		predicates = append(predicates, file.URLEQ(*i.URL))
	}
	if i.URLNEQ != nil {
		predicates = append(predicates, file.URLNEQ(*i.URLNEQ))
	}
	if len(i.URLIn) > 0 {
		predicates = append(predicates, file.URLIn(i.URLIn...))
	}
	if len(i.URLNotIn) > 0 {
		predicates = append(predicates, file.URLNotIn(i.URLNotIn...))
	}
	if i.URLGT != nil {
		predicates = append(predicates, file.URLGT(*i.URLGT))
	}
	if i.URLGTE != nil {
		predicates = append(predicates, file.URLGTE(*i.URLGTE))
	}
	if i.URLLT != nil {
		predicates = append(predicates, file.URLLT(*i.URLLT))
	}
	if i.URLLTE != nil {
		predicates = append(predicates, file.URLLTE(*i.URLLTE))
	}
	if i.URLContains != nil {
		predicates = append(predicates, file.URLContains(*i.URLContains))
	}
	if i.URLHasPrefix != nil {
		predicates = append(predicates, file.URLHasPrefix(*i.URLHasPrefix))
	}
	if i.URLHasSuffix != nil {
		predicates = append(predicates, file.URLHasSuffix(*i.URLHasSuffix))
	}
	if i.URLEqualFold != nil {
		predicates = append(predicates, file.URLEqualFold(*i.URLEqualFold))
	}
	if i.URLContainsFold != nil {
		predicates = append(predicates, file.URLContainsFold(*i.URLContainsFold))
	}
	if i.Description != nil {
		predicates = append(predicates, file.DescriptionEQ(*i.Description))
	}
	if i.DescriptionNEQ != nil {
		predicates = append(predicates, file.DescriptionNEQ(*i.DescriptionNEQ))
	}
	if len(i.DescriptionIn) > 0 {
		predicates = append(predicates, file.DescriptionIn(i.DescriptionIn...))
	}
	if len(i.DescriptionNotIn) > 0 {
		predicates = append(predicates, file.DescriptionNotIn(i.DescriptionNotIn...))
	}
	if i.DescriptionGT != nil {
		predicates = append(predicates, file.DescriptionGT(*i.DescriptionGT))
	}
	if i.DescriptionGTE != nil {
		predicates = append(predicates, file.DescriptionGTE(*i.DescriptionGTE))
	}
	if i.DescriptionLT != nil {
		predicates = append(predicates, file.DescriptionLT(*i.DescriptionLT))
	}
	if i.DescriptionLTE != nil {
		predicates = append(predicates, file.DescriptionLTE(*i.DescriptionLTE))
	}
	if i.DescriptionContains != nil {
		predicates = append(predicates, file.DescriptionContains(*i.DescriptionContains))
	}
	if i.DescriptionHasPrefix != nil {
		predicates = append(predicates, file.DescriptionHasPrefix(*i.DescriptionHasPrefix))
	}
	if i.DescriptionHasSuffix != nil {
		predicates = append(predicates, file.DescriptionHasSuffix(*i.DescriptionHasSuffix))
	}
	if i.DescriptionEqualFold != nil {
		predicates = append(predicates, file.DescriptionEqualFold(*i.DescriptionEqualFold))
	}
	if i.DescriptionContainsFold != nil {
		predicates = append(predicates, file.DescriptionContainsFold(*i.DescriptionContainsFold))
	}

	if i.HasCompany != nil {
		p := file.HasCompany()
		if !*i.HasCompany {
			p = file.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasCompanyWith) > 0 {
		with := make([]predicate.Company, 0, len(i.HasCompanyWith))
		for _, w := range i.HasCompanyWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasCompanyWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, file.HasCompanyWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyFileWhereInput
	case 1:
		return predicates[0], nil
	default:
		return file.And(predicates...), nil
	}
}

// InventoryWhereInput represents a where input for filtering Inventory queries.
type InventoryWhereInput struct {
	Predicates []predicate.Inventory  `json:"-"`
	Not        *InventoryWhereInput   `json:"not,omitempty"`
	Or         []*InventoryWhereInput `json:"or,omitempty"`
	And        []*InventoryWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "createdAt" field predicates.
	CreatedAt      *time.Time  `json:"createdat,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdatNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdatIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdatNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdatGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdatGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdatLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdatLTE,omitempty"`

	// "updatedAt" field predicates.
	UpdatedAt      *time.Time  `json:"updatedat,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedatNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedatIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedatNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedatGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedatGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedatLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedatLTE,omitempty"`

	// "deletedAt" field predicates.
	DeletedAt       *time.Time  `json:"deletedat,omitempty"`
	DeletedAtNEQ    *time.Time  `json:"deletedatNEQ,omitempty"`
	DeletedAtIn     []time.Time `json:"deletedatIn,omitempty"`
	DeletedAtNotIn  []time.Time `json:"deletedatNotIn,omitempty"`
	DeletedAtGT     *time.Time  `json:"deletedatGT,omitempty"`
	DeletedAtGTE    *time.Time  `json:"deletedatGTE,omitempty"`
	DeletedAtLT     *time.Time  `json:"deletedatLT,omitempty"`
	DeletedAtLTE    *time.Time  `json:"deletedatLTE,omitempty"`
	DeletedAtIsNil  bool        `json:"deletedatIsNil,omitempty"`
	DeletedAtNotNil bool        `json:"deletedatNotNil,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "category" field predicates.
	Category      *inventory.Category  `json:"category,omitempty"`
	CategoryNEQ   *inventory.Category  `json:"categoryNEQ,omitempty"`
	CategoryIn    []inventory.Category `json:"categoryIn,omitempty"`
	CategoryNotIn []inventory.Category `json:"categoryNotIn,omitempty"`

	// "quantity" field predicates.
	Quantity      *float64  `json:"quantity,omitempty"`
	QuantityNEQ   *float64  `json:"quantityNEQ,omitempty"`
	QuantityIn    []float64 `json:"quantityIn,omitempty"`
	QuantityNotIn []float64 `json:"quantityNotIn,omitempty"`
	QuantityGT    *float64  `json:"quantityGT,omitempty"`
	QuantityGTE   *float64  `json:"quantityGTE,omitempty"`
	QuantityLT    *float64  `json:"quantityLT,omitempty"`
	QuantityLTE   *float64  `json:"quantityLTE,omitempty"`

	// "unit" field predicates.
	Unit             *string  `json:"unit,omitempty"`
	UnitNEQ          *string  `json:"unitNEQ,omitempty"`
	UnitIn           []string `json:"unitIn,omitempty"`
	UnitNotIn        []string `json:"unitNotIn,omitempty"`
	UnitGT           *string  `json:"unitGT,omitempty"`
	UnitGTE          *string  `json:"unitGTE,omitempty"`
	UnitLT           *string  `json:"unitLT,omitempty"`
	UnitLTE          *string  `json:"unitLTE,omitempty"`
	UnitContains     *string  `json:"unitContains,omitempty"`
	UnitHasPrefix    *string  `json:"unitHasPrefix,omitempty"`
	UnitHasSuffix    *string  `json:"unitHasSuffix,omitempty"`
	UnitEqualFold    *string  `json:"unitEqualFold,omitempty"`
	UnitContainsFold *string  `json:"unitContainsFold,omitempty"`

	// "minimumLevel" field predicates.
	MinimumLevel      *float64  `json:"minimumlevel,omitempty"`
	MinimumLevelNEQ   *float64  `json:"minimumlevelNEQ,omitempty"`
	MinimumLevelIn    []float64 `json:"minimumlevelIn,omitempty"`
	MinimumLevelNotIn []float64 `json:"minimumlevelNotIn,omitempty"`
	MinimumLevelGT    *float64  `json:"minimumlevelGT,omitempty"`
	MinimumLevelGTE   *float64  `json:"minimumlevelGTE,omitempty"`
	MinimumLevelLT    *float64  `json:"minimumlevelLT,omitempty"`
	MinimumLevelLTE   *float64  `json:"minimumlevelLTE,omitempty"`

	// "currentValue" field predicates.
	CurrentValue      *float64  `json:"currentvalue,omitempty"`
	CurrentValueNEQ   *float64  `json:"currentvalueNEQ,omitempty"`
	CurrentValueIn    []float64 `json:"currentvalueIn,omitempty"`
	CurrentValueNotIn []float64 `json:"currentvalueNotIn,omitempty"`
	CurrentValueGT    *float64  `json:"currentvalueGT,omitempty"`
	CurrentValueGTE   *float64  `json:"currentvalueGTE,omitempty"`
	CurrentValueLT    *float64  `json:"currentvalueLT,omitempty"`
	CurrentValueLTE   *float64  `json:"currentvalueLTE,omitempty"`

	// "notes" field predicates.
	Notes             *string  `json:"notes,omitempty"`
	NotesNEQ          *string  `json:"notesNEQ,omitempty"`
	NotesIn           []string `json:"notesIn,omitempty"`
	NotesNotIn        []string `json:"notesNotIn,omitempty"`
	NotesGT           *string  `json:"notesGT,omitempty"`
	NotesGTE          *string  `json:"notesGTE,omitempty"`
	NotesLT           *string  `json:"notesLT,omitempty"`
	NotesLTE          *string  `json:"notesLTE,omitempty"`
	NotesContains     *string  `json:"notesContains,omitempty"`
	NotesHasPrefix    *string  `json:"notesHasPrefix,omitempty"`
	NotesHasSuffix    *string  `json:"notesHasSuffix,omitempty"`
	NotesEqualFold    *string  `json:"notesEqualFold,omitempty"`
	NotesContainsFold *string  `json:"notesContainsFold,omitempty"`

	// "company" edge predicates.
	HasCompany     *bool                `json:"hasCompany,omitempty"`
	HasCompanyWith []*CompanyWhereInput `json:"hasCompanyWith,omitempty"`

	// "movements" edge predicates.
	HasMovements     *bool                          `json:"hasMovements,omitempty"`
	HasMovementsWith []*InventoryMovementWhereInput `json:"hasMovementsWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *InventoryWhereInput) AddPredicates(predicates ...predicate.Inventory) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the InventoryWhereInput filter on the InventoryQuery builder.
func (i *InventoryWhereInput) Filter(q *InventoryQuery) (*InventoryQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyInventoryWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyInventoryWhereInput is returned in case the InventoryWhereInput is empty.
var ErrEmptyInventoryWhereInput = errors.New("generated: empty predicate InventoryWhereInput")

// P returns a predicate for filtering inventories.
// An error is returned if the input is empty or invalid.
func (i *InventoryWhereInput) P() (predicate.Inventory, error) {
	var predicates []predicate.Inventory
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, inventory.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Inventory, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, inventory.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Inventory, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, inventory.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, inventory.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, inventory.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, inventory.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, inventory.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, inventory.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, inventory.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, inventory.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, inventory.IDLTE(*i.IDLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, inventory.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, inventory.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, inventory.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, inventory.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, inventory.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, inventory.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, inventory.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, inventory.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, inventory.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, inventory.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, inventory.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, inventory.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, inventory.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, inventory.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, inventory.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, inventory.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.DeletedAt != nil {
		predicates = append(predicates, inventory.DeletedAtEQ(*i.DeletedAt))
	}
	if i.DeletedAtNEQ != nil {
		predicates = append(predicates, inventory.DeletedAtNEQ(*i.DeletedAtNEQ))
	}
	if len(i.DeletedAtIn) > 0 {
		predicates = append(predicates, inventory.DeletedAtIn(i.DeletedAtIn...))
	}
	if len(i.DeletedAtNotIn) > 0 {
		predicates = append(predicates, inventory.DeletedAtNotIn(i.DeletedAtNotIn...))
	}
	if i.DeletedAtGT != nil {
		predicates = append(predicates, inventory.DeletedAtGT(*i.DeletedAtGT))
	}
	if i.DeletedAtGTE != nil {
		predicates = append(predicates, inventory.DeletedAtGTE(*i.DeletedAtGTE))
	}
	if i.DeletedAtLT != nil {
		predicates = append(predicates, inventory.DeletedAtLT(*i.DeletedAtLT))
	}
	if i.DeletedAtLTE != nil {
		predicates = append(predicates, inventory.DeletedAtLTE(*i.DeletedAtLTE))
	}
	if i.DeletedAtIsNil {
		predicates = append(predicates, inventory.DeletedAtIsNil())
	}
	if i.DeletedAtNotNil {
		predicates = append(predicates, inventory.DeletedAtNotNil())
	}
	if i.Name != nil {
		predicates = append(predicates, inventory.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, inventory.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, inventory.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, inventory.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, inventory.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, inventory.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, inventory.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, inventory.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, inventory.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, inventory.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, inventory.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, inventory.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, inventory.NameContainsFold(*i.NameContainsFold))
	}
	if i.Category != nil {
		predicates = append(predicates, inventory.CategoryEQ(*i.Category))
	}
	if i.CategoryNEQ != nil {
		predicates = append(predicates, inventory.CategoryNEQ(*i.CategoryNEQ))
	}
	if len(i.CategoryIn) > 0 {
		predicates = append(predicates, inventory.CategoryIn(i.CategoryIn...))
	}
	if len(i.CategoryNotIn) > 0 {
		predicates = append(predicates, inventory.CategoryNotIn(i.CategoryNotIn...))
	}
	if i.Quantity != nil {
		predicates = append(predicates, inventory.QuantityEQ(*i.Quantity))
	}
	if i.QuantityNEQ != nil {
		predicates = append(predicates, inventory.QuantityNEQ(*i.QuantityNEQ))
	}
	if len(i.QuantityIn) > 0 {
		predicates = append(predicates, inventory.QuantityIn(i.QuantityIn...))
	}
	if len(i.QuantityNotIn) > 0 {
		predicates = append(predicates, inventory.QuantityNotIn(i.QuantityNotIn...))
	}
	if i.QuantityGT != nil {
		predicates = append(predicates, inventory.QuantityGT(*i.QuantityGT))
	}
	if i.QuantityGTE != nil {
		predicates = append(predicates, inventory.QuantityGTE(*i.QuantityGTE))
	}
	if i.QuantityLT != nil {
		predicates = append(predicates, inventory.QuantityLT(*i.QuantityLT))
	}
	if i.QuantityLTE != nil {
		predicates = append(predicates, inventory.QuantityLTE(*i.QuantityLTE))
	}
	if i.Unit != nil {
		predicates = append(predicates, inventory.UnitEQ(*i.Unit))
	}
	if i.UnitNEQ != nil {
		predicates = append(predicates, inventory.UnitNEQ(*i.UnitNEQ))
	}
	if len(i.UnitIn) > 0 {
		predicates = append(predicates, inventory.UnitIn(i.UnitIn...))
	}
	if len(i.UnitNotIn) > 0 {
		predicates = append(predicates, inventory.UnitNotIn(i.UnitNotIn...))
	}
	if i.UnitGT != nil {
		predicates = append(predicates, inventory.UnitGT(*i.UnitGT))
	}
	if i.UnitGTE != nil {
		predicates = append(predicates, inventory.UnitGTE(*i.UnitGTE))
	}
	if i.UnitLT != nil {
		predicates = append(predicates, inventory.UnitLT(*i.UnitLT))
	}
	if i.UnitLTE != nil {
		predicates = append(predicates, inventory.UnitLTE(*i.UnitLTE))
	}
	if i.UnitContains != nil {
		predicates = append(predicates, inventory.UnitContains(*i.UnitContains))
	}
	if i.UnitHasPrefix != nil {
		predicates = append(predicates, inventory.UnitHasPrefix(*i.UnitHasPrefix))
	}
	if i.UnitHasSuffix != nil {
		predicates = append(predicates, inventory.UnitHasSuffix(*i.UnitHasSuffix))
	}
	if i.UnitEqualFold != nil {
		predicates = append(predicates, inventory.UnitEqualFold(*i.UnitEqualFold))
	}
	if i.UnitContainsFold != nil {
		predicates = append(predicates, inventory.UnitContainsFold(*i.UnitContainsFold))
	}
	if i.MinimumLevel != nil {
		predicates = append(predicates, inventory.MinimumLevelEQ(*i.MinimumLevel))
	}
	if i.MinimumLevelNEQ != nil {
		predicates = append(predicates, inventory.MinimumLevelNEQ(*i.MinimumLevelNEQ))
	}
	if len(i.MinimumLevelIn) > 0 {
		predicates = append(predicates, inventory.MinimumLevelIn(i.MinimumLevelIn...))
	}
	if len(i.MinimumLevelNotIn) > 0 {
		predicates = append(predicates, inventory.MinimumLevelNotIn(i.MinimumLevelNotIn...))
	}
	if i.MinimumLevelGT != nil {
		predicates = append(predicates, inventory.MinimumLevelGT(*i.MinimumLevelGT))
	}
	if i.MinimumLevelGTE != nil {
		predicates = append(predicates, inventory.MinimumLevelGTE(*i.MinimumLevelGTE))
	}
	if i.MinimumLevelLT != nil {
		predicates = append(predicates, inventory.MinimumLevelLT(*i.MinimumLevelLT))
	}
	if i.MinimumLevelLTE != nil {
		predicates = append(predicates, inventory.MinimumLevelLTE(*i.MinimumLevelLTE))
	}
	if i.CurrentValue != nil {
		predicates = append(predicates, inventory.CurrentValueEQ(*i.CurrentValue))
	}
	if i.CurrentValueNEQ != nil {
		predicates = append(predicates, inventory.CurrentValueNEQ(*i.CurrentValueNEQ))
	}
	if len(i.CurrentValueIn) > 0 {
		predicates = append(predicates, inventory.CurrentValueIn(i.CurrentValueIn...))
	}
	if len(i.CurrentValueNotIn) > 0 {
		predicates = append(predicates, inventory.CurrentValueNotIn(i.CurrentValueNotIn...))
	}
	if i.CurrentValueGT != nil {
		predicates = append(predicates, inventory.CurrentValueGT(*i.CurrentValueGT))
	}
	if i.CurrentValueGTE != nil {
		predicates = append(predicates, inventory.CurrentValueGTE(*i.CurrentValueGTE))
	}
	if i.CurrentValueLT != nil {
		predicates = append(predicates, inventory.CurrentValueLT(*i.CurrentValueLT))
	}
	if i.CurrentValueLTE != nil {
		predicates = append(predicates, inventory.CurrentValueLTE(*i.CurrentValueLTE))
	}
	if i.Notes != nil {
		predicates = append(predicates, inventory.NotesEQ(*i.Notes))
	}
	if i.NotesNEQ != nil {
		predicates = append(predicates, inventory.NotesNEQ(*i.NotesNEQ))
	}
	if len(i.NotesIn) > 0 {
		predicates = append(predicates, inventory.NotesIn(i.NotesIn...))
	}
	if len(i.NotesNotIn) > 0 {
		predicates = append(predicates, inventory.NotesNotIn(i.NotesNotIn...))
	}
	if i.NotesGT != nil {
		predicates = append(predicates, inventory.NotesGT(*i.NotesGT))
	}
	if i.NotesGTE != nil {
		predicates = append(predicates, inventory.NotesGTE(*i.NotesGTE))
	}
	if i.NotesLT != nil {
		predicates = append(predicates, inventory.NotesLT(*i.NotesLT))
	}
	if i.NotesLTE != nil {
		predicates = append(predicates, inventory.NotesLTE(*i.NotesLTE))
	}
	if i.NotesContains != nil {
		predicates = append(predicates, inventory.NotesContains(*i.NotesContains))
	}
	if i.NotesHasPrefix != nil {
		predicates = append(predicates, inventory.NotesHasPrefix(*i.NotesHasPrefix))
	}
	if i.NotesHasSuffix != nil {
		predicates = append(predicates, inventory.NotesHasSuffix(*i.NotesHasSuffix))
	}
	if i.NotesEqualFold != nil {
		predicates = append(predicates, inventory.NotesEqualFold(*i.NotesEqualFold))
	}
	if i.NotesContainsFold != nil {
		predicates = append(predicates, inventory.NotesContainsFold(*i.NotesContainsFold))
	}

	if i.HasCompany != nil {
		p := inventory.HasCompany()
		if !*i.HasCompany {
			p = inventory.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasCompanyWith) > 0 {
		with := make([]predicate.Company, 0, len(i.HasCompanyWith))
		for _, w := range i.HasCompanyWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasCompanyWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, inventory.HasCompanyWith(with...))
	}
	if i.HasMovements != nil {
		p := inventory.HasMovements()
		if !*i.HasMovements {
			p = inventory.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasMovementsWith) > 0 {
		with := make([]predicate.InventoryMovement, 0, len(i.HasMovementsWith))
		for _, w := range i.HasMovementsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasMovementsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, inventory.HasMovementsWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyInventoryWhereInput
	case 1:
		return predicates[0], nil
	default:
		return inventory.And(predicates...), nil
	}
}

// InventoryMovementWhereInput represents a where input for filtering InventoryMovement queries.
type InventoryMovementWhereInput struct {
	Predicates []predicate.InventoryMovement  `json:"-"`
	Not        *InventoryMovementWhereInput   `json:"not,omitempty"`
	Or         []*InventoryMovementWhereInput `json:"or,omitempty"`
	And        []*InventoryMovementWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "createdAt" field predicates.
	CreatedAt      *time.Time  `json:"createdat,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdatNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdatIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdatNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdatGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdatGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdatLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdatLTE,omitempty"`

	// "updatedAt" field predicates.
	UpdatedAt      *time.Time  `json:"updatedat,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedatNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedatIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedatNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedatGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedatGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedatLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedatLTE,omitempty"`

	// "deletedAt" field predicates.
	DeletedAt       *time.Time  `json:"deletedat,omitempty"`
	DeletedAtNEQ    *time.Time  `json:"deletedatNEQ,omitempty"`
	DeletedAtIn     []time.Time `json:"deletedatIn,omitempty"`
	DeletedAtNotIn  []time.Time `json:"deletedatNotIn,omitempty"`
	DeletedAtGT     *time.Time  `json:"deletedatGT,omitempty"`
	DeletedAtGTE    *time.Time  `json:"deletedatGTE,omitempty"`
	DeletedAtLT     *time.Time  `json:"deletedatLT,omitempty"`
	DeletedAtLTE    *time.Time  `json:"deletedatLTE,omitempty"`
	DeletedAtIsNil  bool        `json:"deletedatIsNil,omitempty"`
	DeletedAtNotNil bool        `json:"deletedatNotNil,omitempty"`

	// "category" field predicates.
	Category      *inventorymovement.Category  `json:"category,omitempty"`
	CategoryNEQ   *inventorymovement.Category  `json:"categoryNEQ,omitempty"`
	CategoryIn    []inventorymovement.Category `json:"categoryIn,omitempty"`
	CategoryNotIn []inventorymovement.Category `json:"categoryNotIn,omitempty"`

	// "quantity" field predicates.
	Quantity      *float64  `json:"quantity,omitempty"`
	QuantityNEQ   *float64  `json:"quantityNEQ,omitempty"`
	QuantityIn    []float64 `json:"quantityIn,omitempty"`
	QuantityNotIn []float64 `json:"quantityNotIn,omitempty"`
	QuantityGT    *float64  `json:"quantityGT,omitempty"`
	QuantityGTE   *float64  `json:"quantityGTE,omitempty"`
	QuantityLT    *float64  `json:"quantityLT,omitempty"`
	QuantityLTE   *float64  `json:"quantityLTE,omitempty"`

	// "value" field predicates.
	Value      *float64  `json:"value,omitempty"`
	ValueNEQ   *float64  `json:"valueNEQ,omitempty"`
	ValueIn    []float64 `json:"valueIn,omitempty"`
	ValueNotIn []float64 `json:"valueNotIn,omitempty"`
	ValueGT    *float64  `json:"valueGT,omitempty"`
	ValueGTE   *float64  `json:"valueGTE,omitempty"`
	ValueLT    *float64  `json:"valueLT,omitempty"`
	ValueLTE   *float64  `json:"valueLTE,omitempty"`

	// "date" field predicates.
	Date      *time.Time  `json:"date,omitempty"`
	DateNEQ   *time.Time  `json:"dateNEQ,omitempty"`
	DateIn    []time.Time `json:"dateIn,omitempty"`
	DateNotIn []time.Time `json:"dateNotIn,omitempty"`
	DateGT    *time.Time  `json:"dateGT,omitempty"`
	DateGTE   *time.Time  `json:"dateGTE,omitempty"`
	DateLT    *time.Time  `json:"dateLT,omitempty"`
	DateLTE   *time.Time  `json:"dateLTE,omitempty"`

	// "source" field predicates.
	Source             *string  `json:"source,omitempty"`
	SourceNEQ          *string  `json:"sourceNEQ,omitempty"`
	SourceIn           []string `json:"sourceIn,omitempty"`
	SourceNotIn        []string `json:"sourceNotIn,omitempty"`
	SourceGT           *string  `json:"sourceGT,omitempty"`
	SourceGTE          *string  `json:"sourceGTE,omitempty"`
	SourceLT           *string  `json:"sourceLT,omitempty"`
	SourceLTE          *string  `json:"sourceLTE,omitempty"`
	SourceContains     *string  `json:"sourceContains,omitempty"`
	SourceHasPrefix    *string  `json:"sourceHasPrefix,omitempty"`
	SourceHasSuffix    *string  `json:"sourceHasSuffix,omitempty"`
	SourceIsNil        bool     `json:"sourceIsNil,omitempty"`
	SourceNotNil       bool     `json:"sourceNotNil,omitempty"`
	SourceEqualFold    *string  `json:"sourceEqualFold,omitempty"`
	SourceContainsFold *string  `json:"sourceContainsFold,omitempty"`

	// "destination" field predicates.
	Destination             *string  `json:"destination,omitempty"`
	DestinationNEQ          *string  `json:"destinationNEQ,omitempty"`
	DestinationIn           []string `json:"destinationIn,omitempty"`
	DestinationNotIn        []string `json:"destinationNotIn,omitempty"`
	DestinationGT           *string  `json:"destinationGT,omitempty"`
	DestinationGTE          *string  `json:"destinationGTE,omitempty"`
	DestinationLT           *string  `json:"destinationLT,omitempty"`
	DestinationLTE          *string  `json:"destinationLTE,omitempty"`
	DestinationContains     *string  `json:"destinationContains,omitempty"`
	DestinationHasPrefix    *string  `json:"destinationHasPrefix,omitempty"`
	DestinationHasSuffix    *string  `json:"destinationHasSuffix,omitempty"`
	DestinationIsNil        bool     `json:"destinationIsNil,omitempty"`
	DestinationNotNil       bool     `json:"destinationNotNil,omitempty"`
	DestinationEqualFold    *string  `json:"destinationEqualFold,omitempty"`
	DestinationContainsFold *string  `json:"destinationContainsFold,omitempty"`

	// "notes" field predicates.
	Notes             *string  `json:"notes,omitempty"`
	NotesNEQ          *string  `json:"notesNEQ,omitempty"`
	NotesIn           []string `json:"notesIn,omitempty"`
	NotesNotIn        []string `json:"notesNotIn,omitempty"`
	NotesGT           *string  `json:"notesGT,omitempty"`
	NotesGTE          *string  `json:"notesGTE,omitempty"`
	NotesLT           *string  `json:"notesLT,omitempty"`
	NotesLTE          *string  `json:"notesLTE,omitempty"`
	NotesContains     *string  `json:"notesContains,omitempty"`
	NotesHasPrefix    *string  `json:"notesHasPrefix,omitempty"`
	NotesHasSuffix    *string  `json:"notesHasSuffix,omitempty"`
	NotesEqualFold    *string  `json:"notesEqualFold,omitempty"`
	NotesContainsFold *string  `json:"notesContainsFold,omitempty"`

	// "company" edge predicates.
	HasCompany     *bool                `json:"hasCompany,omitempty"`
	HasCompanyWith []*CompanyWhereInput `json:"hasCompanyWith,omitempty"`

	// "inventory" edge predicates.
	HasInventory     *bool                  `json:"hasInventory,omitempty"`
	HasInventoryWith []*InventoryWhereInput `json:"hasInventoryWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *InventoryMovementWhereInput) AddPredicates(predicates ...predicate.InventoryMovement) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the InventoryMovementWhereInput filter on the InventoryMovementQuery builder.
func (i *InventoryMovementWhereInput) Filter(q *InventoryMovementQuery) (*InventoryMovementQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyInventoryMovementWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyInventoryMovementWhereInput is returned in case the InventoryMovementWhereInput is empty.
var ErrEmptyInventoryMovementWhereInput = errors.New("generated: empty predicate InventoryMovementWhereInput")

// P returns a predicate for filtering inventorymovements.
// An error is returned if the input is empty or invalid.
func (i *InventoryMovementWhereInput) P() (predicate.InventoryMovement, error) {
	var predicates []predicate.InventoryMovement
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, inventorymovement.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.InventoryMovement, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, inventorymovement.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.InventoryMovement, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, inventorymovement.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, inventorymovement.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, inventorymovement.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, inventorymovement.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, inventorymovement.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, inventorymovement.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, inventorymovement.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, inventorymovement.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, inventorymovement.IDLTE(*i.IDLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, inventorymovement.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, inventorymovement.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, inventorymovement.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, inventorymovement.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, inventorymovement.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, inventorymovement.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, inventorymovement.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, inventorymovement.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, inventorymovement.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, inventorymovement.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, inventorymovement.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, inventorymovement.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, inventorymovement.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, inventorymovement.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, inventorymovement.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, inventorymovement.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.DeletedAt != nil {
		predicates = append(predicates, inventorymovement.DeletedAtEQ(*i.DeletedAt))
	}
	if i.DeletedAtNEQ != nil {
		predicates = append(predicates, inventorymovement.DeletedAtNEQ(*i.DeletedAtNEQ))
	}
	if len(i.DeletedAtIn) > 0 {
		predicates = append(predicates, inventorymovement.DeletedAtIn(i.DeletedAtIn...))
	}
	if len(i.DeletedAtNotIn) > 0 {
		predicates = append(predicates, inventorymovement.DeletedAtNotIn(i.DeletedAtNotIn...))
	}
	if i.DeletedAtGT != nil {
		predicates = append(predicates, inventorymovement.DeletedAtGT(*i.DeletedAtGT))
	}
	if i.DeletedAtGTE != nil {
		predicates = append(predicates, inventorymovement.DeletedAtGTE(*i.DeletedAtGTE))
	}
	if i.DeletedAtLT != nil {
		predicates = append(predicates, inventorymovement.DeletedAtLT(*i.DeletedAtLT))
	}
	if i.DeletedAtLTE != nil {
		predicates = append(predicates, inventorymovement.DeletedAtLTE(*i.DeletedAtLTE))
	}
	if i.DeletedAtIsNil {
		predicates = append(predicates, inventorymovement.DeletedAtIsNil())
	}
	if i.DeletedAtNotNil {
		predicates = append(predicates, inventorymovement.DeletedAtNotNil())
	}
	if i.Category != nil {
		predicates = append(predicates, inventorymovement.CategoryEQ(*i.Category))
	}
	if i.CategoryNEQ != nil {
		predicates = append(predicates, inventorymovement.CategoryNEQ(*i.CategoryNEQ))
	}
	if len(i.CategoryIn) > 0 {
		predicates = append(predicates, inventorymovement.CategoryIn(i.CategoryIn...))
	}
	if len(i.CategoryNotIn) > 0 {
		predicates = append(predicates, inventorymovement.CategoryNotIn(i.CategoryNotIn...))
	}
	if i.Quantity != nil {
		predicates = append(predicates, inventorymovement.QuantityEQ(*i.Quantity))
	}
	if i.QuantityNEQ != nil {
		predicates = append(predicates, inventorymovement.QuantityNEQ(*i.QuantityNEQ))
	}
	if len(i.QuantityIn) > 0 {
		predicates = append(predicates, inventorymovement.QuantityIn(i.QuantityIn...))
	}
	if len(i.QuantityNotIn) > 0 {
		predicates = append(predicates, inventorymovement.QuantityNotIn(i.QuantityNotIn...))
	}
	if i.QuantityGT != nil {
		predicates = append(predicates, inventorymovement.QuantityGT(*i.QuantityGT))
	}
	if i.QuantityGTE != nil {
		predicates = append(predicates, inventorymovement.QuantityGTE(*i.QuantityGTE))
	}
	if i.QuantityLT != nil {
		predicates = append(predicates, inventorymovement.QuantityLT(*i.QuantityLT))
	}
	if i.QuantityLTE != nil {
		predicates = append(predicates, inventorymovement.QuantityLTE(*i.QuantityLTE))
	}
	if i.Value != nil {
		predicates = append(predicates, inventorymovement.ValueEQ(*i.Value))
	}
	if i.ValueNEQ != nil {
		predicates = append(predicates, inventorymovement.ValueNEQ(*i.ValueNEQ))
	}
	if len(i.ValueIn) > 0 {
		predicates = append(predicates, inventorymovement.ValueIn(i.ValueIn...))
	}
	if len(i.ValueNotIn) > 0 {
		predicates = append(predicates, inventorymovement.ValueNotIn(i.ValueNotIn...))
	}
	if i.ValueGT != nil {
		predicates = append(predicates, inventorymovement.ValueGT(*i.ValueGT))
	}
	if i.ValueGTE != nil {
		predicates = append(predicates, inventorymovement.ValueGTE(*i.ValueGTE))
	}
	if i.ValueLT != nil {
		predicates = append(predicates, inventorymovement.ValueLT(*i.ValueLT))
	}
	if i.ValueLTE != nil {
		predicates = append(predicates, inventorymovement.ValueLTE(*i.ValueLTE))
	}
	if i.Date != nil {
		predicates = append(predicates, inventorymovement.DateEQ(*i.Date))
	}
	if i.DateNEQ != nil {
		predicates = append(predicates, inventorymovement.DateNEQ(*i.DateNEQ))
	}
	if len(i.DateIn) > 0 {
		predicates = append(predicates, inventorymovement.DateIn(i.DateIn...))
	}
	if len(i.DateNotIn) > 0 {
		predicates = append(predicates, inventorymovement.DateNotIn(i.DateNotIn...))
	}
	if i.DateGT != nil {
		predicates = append(predicates, inventorymovement.DateGT(*i.DateGT))
	}
	if i.DateGTE != nil {
		predicates = append(predicates, inventorymovement.DateGTE(*i.DateGTE))
	}
	if i.DateLT != nil {
		predicates = append(predicates, inventorymovement.DateLT(*i.DateLT))
	}
	if i.DateLTE != nil {
		predicates = append(predicates, inventorymovement.DateLTE(*i.DateLTE))
	}
	if i.Source != nil {
		predicates = append(predicates, inventorymovement.SourceEQ(*i.Source))
	}
	if i.SourceNEQ != nil {
		predicates = append(predicates, inventorymovement.SourceNEQ(*i.SourceNEQ))
	}
	if len(i.SourceIn) > 0 {
		predicates = append(predicates, inventorymovement.SourceIn(i.SourceIn...))
	}
	if len(i.SourceNotIn) > 0 {
		predicates = append(predicates, inventorymovement.SourceNotIn(i.SourceNotIn...))
	}
	if i.SourceGT != nil {
		predicates = append(predicates, inventorymovement.SourceGT(*i.SourceGT))
	}
	if i.SourceGTE != nil {
		predicates = append(predicates, inventorymovement.SourceGTE(*i.SourceGTE))
	}
	if i.SourceLT != nil {
		predicates = append(predicates, inventorymovement.SourceLT(*i.SourceLT))
	}
	if i.SourceLTE != nil {
		predicates = append(predicates, inventorymovement.SourceLTE(*i.SourceLTE))
	}
	if i.SourceContains != nil {
		predicates = append(predicates, inventorymovement.SourceContains(*i.SourceContains))
	}
	if i.SourceHasPrefix != nil {
		predicates = append(predicates, inventorymovement.SourceHasPrefix(*i.SourceHasPrefix))
	}
	if i.SourceHasSuffix != nil {
		predicates = append(predicates, inventorymovement.SourceHasSuffix(*i.SourceHasSuffix))
	}
	if i.SourceIsNil {
		predicates = append(predicates, inventorymovement.SourceIsNil())
	}
	if i.SourceNotNil {
		predicates = append(predicates, inventorymovement.SourceNotNil())
	}
	if i.SourceEqualFold != nil {
		predicates = append(predicates, inventorymovement.SourceEqualFold(*i.SourceEqualFold))
	}
	if i.SourceContainsFold != nil {
		predicates = append(predicates, inventorymovement.SourceContainsFold(*i.SourceContainsFold))
	}
	if i.Destination != nil {
		predicates = append(predicates, inventorymovement.DestinationEQ(*i.Destination))
	}
	if i.DestinationNEQ != nil {
		predicates = append(predicates, inventorymovement.DestinationNEQ(*i.DestinationNEQ))
	}
	if len(i.DestinationIn) > 0 {
		predicates = append(predicates, inventorymovement.DestinationIn(i.DestinationIn...))
	}
	if len(i.DestinationNotIn) > 0 {
		predicates = append(predicates, inventorymovement.DestinationNotIn(i.DestinationNotIn...))
	}
	if i.DestinationGT != nil {
		predicates = append(predicates, inventorymovement.DestinationGT(*i.DestinationGT))
	}
	if i.DestinationGTE != nil {
		predicates = append(predicates, inventorymovement.DestinationGTE(*i.DestinationGTE))
	}
	if i.DestinationLT != nil {
		predicates = append(predicates, inventorymovement.DestinationLT(*i.DestinationLT))
	}
	if i.DestinationLTE != nil {
		predicates = append(predicates, inventorymovement.DestinationLTE(*i.DestinationLTE))
	}
	if i.DestinationContains != nil {
		predicates = append(predicates, inventorymovement.DestinationContains(*i.DestinationContains))
	}
	if i.DestinationHasPrefix != nil {
		predicates = append(predicates, inventorymovement.DestinationHasPrefix(*i.DestinationHasPrefix))
	}
	if i.DestinationHasSuffix != nil {
		predicates = append(predicates, inventorymovement.DestinationHasSuffix(*i.DestinationHasSuffix))
	}
	if i.DestinationIsNil {
		predicates = append(predicates, inventorymovement.DestinationIsNil())
	}
	if i.DestinationNotNil {
		predicates = append(predicates, inventorymovement.DestinationNotNil())
	}
	if i.DestinationEqualFold != nil {
		predicates = append(predicates, inventorymovement.DestinationEqualFold(*i.DestinationEqualFold))
	}
	if i.DestinationContainsFold != nil {
		predicates = append(predicates, inventorymovement.DestinationContainsFold(*i.DestinationContainsFold))
	}
	if i.Notes != nil {
		predicates = append(predicates, inventorymovement.NotesEQ(*i.Notes))
	}
	if i.NotesNEQ != nil {
		predicates = append(predicates, inventorymovement.NotesNEQ(*i.NotesNEQ))
	}
	if len(i.NotesIn) > 0 {
		predicates = append(predicates, inventorymovement.NotesIn(i.NotesIn...))
	}
	if len(i.NotesNotIn) > 0 {
		predicates = append(predicates, inventorymovement.NotesNotIn(i.NotesNotIn...))
	}
	if i.NotesGT != nil {
		predicates = append(predicates, inventorymovement.NotesGT(*i.NotesGT))
	}
	if i.NotesGTE != nil {
		predicates = append(predicates, inventorymovement.NotesGTE(*i.NotesGTE))
	}
	if i.NotesLT != nil {
		predicates = append(predicates, inventorymovement.NotesLT(*i.NotesLT))
	}
	if i.NotesLTE != nil {
		predicates = append(predicates, inventorymovement.NotesLTE(*i.NotesLTE))
	}
	if i.NotesContains != nil {
		predicates = append(predicates, inventorymovement.NotesContains(*i.NotesContains))
	}
	if i.NotesHasPrefix != nil {
		predicates = append(predicates, inventorymovement.NotesHasPrefix(*i.NotesHasPrefix))
	}
	if i.NotesHasSuffix != nil {
		predicates = append(predicates, inventorymovement.NotesHasSuffix(*i.NotesHasSuffix))
	}
	if i.NotesEqualFold != nil {
		predicates = append(predicates, inventorymovement.NotesEqualFold(*i.NotesEqualFold))
	}
	if i.NotesContainsFold != nil {
		predicates = append(predicates, inventorymovement.NotesContainsFold(*i.NotesContainsFold))
	}

	if i.HasCompany != nil {
		p := inventorymovement.HasCompany()
		if !*i.HasCompany {
			p = inventorymovement.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasCompanyWith) > 0 {
		with := make([]predicate.Company, 0, len(i.HasCompanyWith))
		for _, w := range i.HasCompanyWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasCompanyWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, inventorymovement.HasCompanyWith(with...))
	}
	if i.HasInventory != nil {
		p := inventorymovement.HasInventory()
		if !*i.HasInventory {
			p = inventorymovement.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasInventoryWith) > 0 {
		with := make([]predicate.Inventory, 0, len(i.HasInventoryWith))
		for _, w := range i.HasInventoryWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasInventoryWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, inventorymovement.HasInventoryWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyInventoryMovementWhereInput
	case 1:
		return predicates[0], nil
	default:
		return inventorymovement.And(predicates...), nil
	}
}

// InvoiceWhereInput represents a where input for filtering Invoice queries.
type InvoiceWhereInput struct {
	Predicates []predicate.Invoice  `json:"-"`
	Not        *InvoiceWhereInput   `json:"not,omitempty"`
	Or         []*InvoiceWhereInput `json:"or,omitempty"`
	And        []*InvoiceWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "createdAt" field predicates.
	CreatedAt      *time.Time  `json:"createdat,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdatNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdatIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdatNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdatGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdatGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdatLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdatLTE,omitempty"`

	// "updatedAt" field predicates.
	UpdatedAt      *time.Time  `json:"updatedat,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedatNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedatIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedatNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedatGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedatGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedatLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedatLTE,omitempty"`

	// "deletedAt" field predicates.
	DeletedAt       *time.Time  `json:"deletedat,omitempty"`
	DeletedAtNEQ    *time.Time  `json:"deletedatNEQ,omitempty"`
	DeletedAtIn     []time.Time `json:"deletedatIn,omitempty"`
	DeletedAtNotIn  []time.Time `json:"deletedatNotIn,omitempty"`
	DeletedAtGT     *time.Time  `json:"deletedatGT,omitempty"`
	DeletedAtGTE    *time.Time  `json:"deletedatGTE,omitempty"`
	DeletedAtLT     *time.Time  `json:"deletedatLT,omitempty"`
	DeletedAtLTE    *time.Time  `json:"deletedatLTE,omitempty"`
	DeletedAtIsNil  bool        `json:"deletedatIsNil,omitempty"`
	DeletedAtNotNil bool        `json:"deletedatNotNil,omitempty"`

	// "companyLogo" field predicates.
	CompanyLogo             *string  `json:"companylogo,omitempty"`
	CompanyLogoNEQ          *string  `json:"companylogoNEQ,omitempty"`
	CompanyLogoIn           []string `json:"companylogoIn,omitempty"`
	CompanyLogoNotIn        []string `json:"companylogoNotIn,omitempty"`
	CompanyLogoGT           *string  `json:"companylogoGT,omitempty"`
	CompanyLogoGTE          *string  `json:"companylogoGTE,omitempty"`
	CompanyLogoLT           *string  `json:"companylogoLT,omitempty"`
	CompanyLogoLTE          *string  `json:"companylogoLTE,omitempty"`
	CompanyLogoContains     *string  `json:"companylogoContains,omitempty"`
	CompanyLogoHasPrefix    *string  `json:"companylogoHasPrefix,omitempty"`
	CompanyLogoHasSuffix    *string  `json:"companylogoHasSuffix,omitempty"`
	CompanyLogoIsNil        bool     `json:"companylogoIsNil,omitempty"`
	CompanyLogoNotNil       bool     `json:"companylogoNotNil,omitempty"`
	CompanyLogoEqualFold    *string  `json:"companylogoEqualFold,omitempty"`
	CompanyLogoContainsFold *string  `json:"companylogoContainsFold,omitempty"`

	// "companyName" field predicates.
	CompanyName             *string  `json:"companyname,omitempty"`
	CompanyNameNEQ          *string  `json:"companynameNEQ,omitempty"`
	CompanyNameIn           []string `json:"companynameIn,omitempty"`
	CompanyNameNotIn        []string `json:"companynameNotIn,omitempty"`
	CompanyNameGT           *string  `json:"companynameGT,omitempty"`
	CompanyNameGTE          *string  `json:"companynameGTE,omitempty"`
	CompanyNameLT           *string  `json:"companynameLT,omitempty"`
	CompanyNameLTE          *string  `json:"companynameLTE,omitempty"`
	CompanyNameContains     *string  `json:"companynameContains,omitempty"`
	CompanyNameHasPrefix    *string  `json:"companynameHasPrefix,omitempty"`
	CompanyNameHasSuffix    *string  `json:"companynameHasSuffix,omitempty"`
	CompanyNameEqualFold    *string  `json:"companynameEqualFold,omitempty"`
	CompanyNameContainsFold *string  `json:"companynameContainsFold,omitempty"`

	// "companyTaxID" field predicates.
	CompanyTaxID             *string  `json:"companytaxid,omitempty"`
	CompanyTaxIDNEQ          *string  `json:"companytaxidNEQ,omitempty"`
	CompanyTaxIDIn           []string `json:"companytaxidIn,omitempty"`
	CompanyTaxIDNotIn        []string `json:"companytaxidNotIn,omitempty"`
	CompanyTaxIDGT           *string  `json:"companytaxidGT,omitempty"`
	CompanyTaxIDGTE          *string  `json:"companytaxidGTE,omitempty"`
	CompanyTaxIDLT           *string  `json:"companytaxidLT,omitempty"`
	CompanyTaxIDLTE          *string  `json:"companytaxidLTE,omitempty"`
	CompanyTaxIDContains     *string  `json:"companytaxidContains,omitempty"`
	CompanyTaxIDHasPrefix    *string  `json:"companytaxidHasPrefix,omitempty"`
	CompanyTaxIDHasSuffix    *string  `json:"companytaxidHasSuffix,omitempty"`
	CompanyTaxIDIsNil        bool     `json:"companytaxidIsNil,omitempty"`
	CompanyTaxIDNotNil       bool     `json:"companytaxidNotNil,omitempty"`
	CompanyTaxIDEqualFold    *string  `json:"companytaxidEqualFold,omitempty"`
	CompanyTaxIDContainsFold *string  `json:"companytaxidContainsFold,omitempty"`

	// "companyAddress" field predicates.
	CompanyAddress             *string  `json:"companyaddress,omitempty"`
	CompanyAddressNEQ          *string  `json:"companyaddressNEQ,omitempty"`
	CompanyAddressIn           []string `json:"companyaddressIn,omitempty"`
	CompanyAddressNotIn        []string `json:"companyaddressNotIn,omitempty"`
	CompanyAddressGT           *string  `json:"companyaddressGT,omitempty"`
	CompanyAddressGTE          *string  `json:"companyaddressGTE,omitempty"`
	CompanyAddressLT           *string  `json:"companyaddressLT,omitempty"`
	CompanyAddressLTE          *string  `json:"companyaddressLTE,omitempty"`
	CompanyAddressContains     *string  `json:"companyaddressContains,omitempty"`
	CompanyAddressHasPrefix    *string  `json:"companyaddressHasPrefix,omitempty"`
	CompanyAddressHasSuffix    *string  `json:"companyaddressHasSuffix,omitempty"`
	CompanyAddressEqualFold    *string  `json:"companyaddressEqualFold,omitempty"`
	CompanyAddressContainsFold *string  `json:"companyaddressContainsFold,omitempty"`

	// "companyCity" field predicates.
	CompanyCity             *string  `json:"companycity,omitempty"`
	CompanyCityNEQ          *string  `json:"companycityNEQ,omitempty"`
	CompanyCityIn           []string `json:"companycityIn,omitempty"`
	CompanyCityNotIn        []string `json:"companycityNotIn,omitempty"`
	CompanyCityGT           *string  `json:"companycityGT,omitempty"`
	CompanyCityGTE          *string  `json:"companycityGTE,omitempty"`
	CompanyCityLT           *string  `json:"companycityLT,omitempty"`
	CompanyCityLTE          *string  `json:"companycityLTE,omitempty"`
	CompanyCityContains     *string  `json:"companycityContains,omitempty"`
	CompanyCityHasPrefix    *string  `json:"companycityHasPrefix,omitempty"`
	CompanyCityHasSuffix    *string  `json:"companycityHasSuffix,omitempty"`
	CompanyCityEqualFold    *string  `json:"companycityEqualFold,omitempty"`
	CompanyCityContainsFold *string  `json:"companycityContainsFold,omitempty"`

	// "companyEmail" field predicates.
	CompanyEmail             *string  `json:"companyemail,omitempty"`
	CompanyEmailNEQ          *string  `json:"companyemailNEQ,omitempty"`
	CompanyEmailIn           []string `json:"companyemailIn,omitempty"`
	CompanyEmailNotIn        []string `json:"companyemailNotIn,omitempty"`
	CompanyEmailGT           *string  `json:"companyemailGT,omitempty"`
	CompanyEmailGTE          *string  `json:"companyemailGTE,omitempty"`
	CompanyEmailLT           *string  `json:"companyemailLT,omitempty"`
	CompanyEmailLTE          *string  `json:"companyemailLTE,omitempty"`
	CompanyEmailContains     *string  `json:"companyemailContains,omitempty"`
	CompanyEmailHasPrefix    *string  `json:"companyemailHasPrefix,omitempty"`
	CompanyEmailHasSuffix    *string  `json:"companyemailHasSuffix,omitempty"`
	CompanyEmailIsNil        bool     `json:"companyemailIsNil,omitempty"`
	CompanyEmailNotNil       bool     `json:"companyemailNotNil,omitempty"`
	CompanyEmailEqualFold    *string  `json:"companyemailEqualFold,omitempty"`
	CompanyEmailContainsFold *string  `json:"companyemailContainsFold,omitempty"`

	// "companyPhone" field predicates.
	CompanyPhone             *string  `json:"companyphone,omitempty"`
	CompanyPhoneNEQ          *string  `json:"companyphoneNEQ,omitempty"`
	CompanyPhoneIn           []string `json:"companyphoneIn,omitempty"`
	CompanyPhoneNotIn        []string `json:"companyphoneNotIn,omitempty"`
	CompanyPhoneGT           *string  `json:"companyphoneGT,omitempty"`
	CompanyPhoneGTE          *string  `json:"companyphoneGTE,omitempty"`
	CompanyPhoneLT           *string  `json:"companyphoneLT,omitempty"`
	CompanyPhoneLTE          *string  `json:"companyphoneLTE,omitempty"`
	CompanyPhoneContains     *string  `json:"companyphoneContains,omitempty"`
	CompanyPhoneHasPrefix    *string  `json:"companyphoneHasPrefix,omitempty"`
	CompanyPhoneHasSuffix    *string  `json:"companyphoneHasSuffix,omitempty"`
	CompanyPhoneIsNil        bool     `json:"companyphoneIsNil,omitempty"`
	CompanyPhoneNotNil       bool     `json:"companyphoneNotNil,omitempty"`
	CompanyPhoneEqualFold    *string  `json:"companyphoneEqualFold,omitempty"`
	CompanyPhoneContainsFold *string  `json:"companyphoneContainsFold,omitempty"`

	// "number" field predicates.
	Number             *string  `json:"number,omitempty"`
	NumberNEQ          *string  `json:"numberNEQ,omitempty"`
	NumberIn           []string `json:"numberIn,omitempty"`
	NumberNotIn        []string `json:"numberNotIn,omitempty"`
	NumberGT           *string  `json:"numberGT,omitempty"`
	NumberGTE          *string  `json:"numberGTE,omitempty"`
	NumberLT           *string  `json:"numberLT,omitempty"`
	NumberLTE          *string  `json:"numberLTE,omitempty"`
	NumberContains     *string  `json:"numberContains,omitempty"`
	NumberHasPrefix    *string  `json:"numberHasPrefix,omitempty"`
	NumberHasSuffix    *string  `json:"numberHasSuffix,omitempty"`
	NumberIsNil        bool     `json:"numberIsNil,omitempty"`
	NumberNotNil       bool     `json:"numberNotNil,omitempty"`
	NumberEqualFold    *string  `json:"numberEqualFold,omitempty"`
	NumberContainsFold *string  `json:"numberContainsFold,omitempty"`

	// "issueDate" field predicates.
	IssueDate      *time.Time  `json:"issuedate,omitempty"`
	IssueDateNEQ   *time.Time  `json:"issuedateNEQ,omitempty"`
	IssueDateIn    []time.Time `json:"issuedateIn,omitempty"`
	IssueDateNotIn []time.Time `json:"issuedateNotIn,omitempty"`
	IssueDateGT    *time.Time  `json:"issuedateGT,omitempty"`
	IssueDateGTE   *time.Time  `json:"issuedateGTE,omitempty"`
	IssueDateLT    *time.Time  `json:"issuedateLT,omitempty"`
	IssueDateLTE   *time.Time  `json:"issuedateLTE,omitempty"`

	// "dueDate" field predicates.
	DueDate      *time.Time  `json:"duedate,omitempty"`
	DueDateNEQ   *time.Time  `json:"duedateNEQ,omitempty"`
	DueDateIn    []time.Time `json:"duedateIn,omitempty"`
	DueDateNotIn []time.Time `json:"duedateNotIn,omitempty"`
	DueDateGT    *time.Time  `json:"duedateGT,omitempty"`
	DueDateGTE   *time.Time  `json:"duedateGTE,omitempty"`
	DueDateLT    *time.Time  `json:"duedateLT,omitempty"`
	DueDateLTE   *time.Time  `json:"duedateLTE,omitempty"`

	// "paidAt" field predicates.
	PaidAt       *time.Time  `json:"paidat,omitempty"`
	PaidAtNEQ    *time.Time  `json:"paidatNEQ,omitempty"`
	PaidAtIn     []time.Time `json:"paidatIn,omitempty"`
	PaidAtNotIn  []time.Time `json:"paidatNotIn,omitempty"`
	PaidAtGT     *time.Time  `json:"paidatGT,omitempty"`
	PaidAtGTE    *time.Time  `json:"paidatGTE,omitempty"`
	PaidAtLT     *time.Time  `json:"paidatLT,omitempty"`
	PaidAtLTE    *time.Time  `json:"paidatLTE,omitempty"`
	PaidAtIsNil  bool        `json:"paidatIsNil,omitempty"`
	PaidAtNotNil bool        `json:"paidatNotNil,omitempty"`

	// "status" field predicates.
	Status      *invoice.Status  `json:"status,omitempty"`
	StatusNEQ   *invoice.Status  `json:"statusNEQ,omitempty"`
	StatusIn    []invoice.Status `json:"statusIn,omitempty"`
	StatusNotIn []invoice.Status `json:"statusNotIn,omitempty"`

	// "customerName" field predicates.
	CustomerName             *string  `json:"customername,omitempty"`
	CustomerNameNEQ          *string  `json:"customernameNEQ,omitempty"`
	CustomerNameIn           []string `json:"customernameIn,omitempty"`
	CustomerNameNotIn        []string `json:"customernameNotIn,omitempty"`
	CustomerNameGT           *string  `json:"customernameGT,omitempty"`
	CustomerNameGTE          *string  `json:"customernameGTE,omitempty"`
	CustomerNameLT           *string  `json:"customernameLT,omitempty"`
	CustomerNameLTE          *string  `json:"customernameLTE,omitempty"`
	CustomerNameContains     *string  `json:"customernameContains,omitempty"`
	CustomerNameHasPrefix    *string  `json:"customernameHasPrefix,omitempty"`
	CustomerNameHasSuffix    *string  `json:"customernameHasSuffix,omitempty"`
	CustomerNameIsNil        bool     `json:"customernameIsNil,omitempty"`
	CustomerNameNotNil       bool     `json:"customernameNotNil,omitempty"`
	CustomerNameEqualFold    *string  `json:"customernameEqualFold,omitempty"`
	CustomerNameContainsFold *string  `json:"customernameContainsFold,omitempty"`

	// "customerTaxID" field predicates.
	CustomerTaxID             *string  `json:"customertaxid,omitempty"`
	CustomerTaxIDNEQ          *string  `json:"customertaxidNEQ,omitempty"`
	CustomerTaxIDIn           []string `json:"customertaxidIn,omitempty"`
	CustomerTaxIDNotIn        []string `json:"customertaxidNotIn,omitempty"`
	CustomerTaxIDGT           *string  `json:"customertaxidGT,omitempty"`
	CustomerTaxIDGTE          *string  `json:"customertaxidGTE,omitempty"`
	CustomerTaxIDLT           *string  `json:"customertaxidLT,omitempty"`
	CustomerTaxIDLTE          *string  `json:"customertaxidLTE,omitempty"`
	CustomerTaxIDContains     *string  `json:"customertaxidContains,omitempty"`
	CustomerTaxIDHasPrefix    *string  `json:"customertaxidHasPrefix,omitempty"`
	CustomerTaxIDHasSuffix    *string  `json:"customertaxidHasSuffix,omitempty"`
	CustomerTaxIDIsNil        bool     `json:"customertaxidIsNil,omitempty"`
	CustomerTaxIDNotNil       bool     `json:"customertaxidNotNil,omitempty"`
	CustomerTaxIDEqualFold    *string  `json:"customertaxidEqualFold,omitempty"`
	CustomerTaxIDContainsFold *string  `json:"customertaxidContainsFold,omitempty"`

	// "customerAddress" field predicates.
	CustomerAddress             *string  `json:"customeraddress,omitempty"`
	CustomerAddressNEQ          *string  `json:"customeraddressNEQ,omitempty"`
	CustomerAddressIn           []string `json:"customeraddressIn,omitempty"`
	CustomerAddressNotIn        []string `json:"customeraddressNotIn,omitempty"`
	CustomerAddressGT           *string  `json:"customeraddressGT,omitempty"`
	CustomerAddressGTE          *string  `json:"customeraddressGTE,omitempty"`
	CustomerAddressLT           *string  `json:"customeraddressLT,omitempty"`
	CustomerAddressLTE          *string  `json:"customeraddressLTE,omitempty"`
	CustomerAddressContains     *string  `json:"customeraddressContains,omitempty"`
	CustomerAddressHasPrefix    *string  `json:"customeraddressHasPrefix,omitempty"`
	CustomerAddressHasSuffix    *string  `json:"customeraddressHasSuffix,omitempty"`
	CustomerAddressIsNil        bool     `json:"customeraddressIsNil,omitempty"`
	CustomerAddressNotNil       bool     `json:"customeraddressNotNil,omitempty"`
	CustomerAddressEqualFold    *string  `json:"customeraddressEqualFold,omitempty"`
	CustomerAddressContainsFold *string  `json:"customeraddressContainsFold,omitempty"`

	// "customerCity" field predicates.
	CustomerCity             *string  `json:"customercity,omitempty"`
	CustomerCityNEQ          *string  `json:"customercityNEQ,omitempty"`
	CustomerCityIn           []string `json:"customercityIn,omitempty"`
	CustomerCityNotIn        []string `json:"customercityNotIn,omitempty"`
	CustomerCityGT           *string  `json:"customercityGT,omitempty"`
	CustomerCityGTE          *string  `json:"customercityGTE,omitempty"`
	CustomerCityLT           *string  `json:"customercityLT,omitempty"`
	CustomerCityLTE          *string  `json:"customercityLTE,omitempty"`
	CustomerCityContains     *string  `json:"customercityContains,omitempty"`
	CustomerCityHasPrefix    *string  `json:"customercityHasPrefix,omitempty"`
	CustomerCityHasSuffix    *string  `json:"customercityHasSuffix,omitempty"`
	CustomerCityIsNil        bool     `json:"customercityIsNil,omitempty"`
	CustomerCityNotNil       bool     `json:"customercityNotNil,omitempty"`
	CustomerCityEqualFold    *string  `json:"customercityEqualFold,omitempty"`
	CustomerCityContainsFold *string  `json:"customercityContainsFold,omitempty"`

	// "customerEmail" field predicates.
	CustomerEmail             *string  `json:"customeremail,omitempty"`
	CustomerEmailNEQ          *string  `json:"customeremailNEQ,omitempty"`
	CustomerEmailIn           []string `json:"customeremailIn,omitempty"`
	CustomerEmailNotIn        []string `json:"customeremailNotIn,omitempty"`
	CustomerEmailGT           *string  `json:"customeremailGT,omitempty"`
	CustomerEmailGTE          *string  `json:"customeremailGTE,omitempty"`
	CustomerEmailLT           *string  `json:"customeremailLT,omitempty"`
	CustomerEmailLTE          *string  `json:"customeremailLTE,omitempty"`
	CustomerEmailContains     *string  `json:"customeremailContains,omitempty"`
	CustomerEmailHasPrefix    *string  `json:"customeremailHasPrefix,omitempty"`
	CustomerEmailHasSuffix    *string  `json:"customeremailHasSuffix,omitempty"`
	CustomerEmailIsNil        bool     `json:"customeremailIsNil,omitempty"`
	CustomerEmailNotNil       bool     `json:"customeremailNotNil,omitempty"`
	CustomerEmailEqualFold    *string  `json:"customeremailEqualFold,omitempty"`
	CustomerEmailContainsFold *string  `json:"customeremailContainsFold,omitempty"`

	// "customerPhone" field predicates.
	CustomerPhone             *string  `json:"customerphone,omitempty"`
	CustomerPhoneNEQ          *string  `json:"customerphoneNEQ,omitempty"`
	CustomerPhoneIn           []string `json:"customerphoneIn,omitempty"`
	CustomerPhoneNotIn        []string `json:"customerphoneNotIn,omitempty"`
	CustomerPhoneGT           *string  `json:"customerphoneGT,omitempty"`
	CustomerPhoneGTE          *string  `json:"customerphoneGTE,omitempty"`
	CustomerPhoneLT           *string  `json:"customerphoneLT,omitempty"`
	CustomerPhoneLTE          *string  `json:"customerphoneLTE,omitempty"`
	CustomerPhoneContains     *string  `json:"customerphoneContains,omitempty"`
	CustomerPhoneHasPrefix    *string  `json:"customerphoneHasPrefix,omitempty"`
	CustomerPhoneHasSuffix    *string  `json:"customerphoneHasSuffix,omitempty"`
	CustomerPhoneIsNil        bool     `json:"customerphoneIsNil,omitempty"`
	CustomerPhoneNotNil       bool     `json:"customerphoneNotNil,omitempty"`
	CustomerPhoneEqualFold    *string  `json:"customerphoneEqualFold,omitempty"`
	CustomerPhoneContainsFold *string  `json:"customerphoneContainsFold,omitempty"`

	// "items" field predicates.
	Items             *string  `json:"items,omitempty"`
	ItemsNEQ          *string  `json:"itemsNEQ,omitempty"`
	ItemsIn           []string `json:"itemsIn,omitempty"`
	ItemsNotIn        []string `json:"itemsNotIn,omitempty"`
	ItemsGT           *string  `json:"itemsGT,omitempty"`
	ItemsGTE          *string  `json:"itemsGTE,omitempty"`
	ItemsLT           *string  `json:"itemsLT,omitempty"`
	ItemsLTE          *string  `json:"itemsLTE,omitempty"`
	ItemsContains     *string  `json:"itemsContains,omitempty"`
	ItemsHasPrefix    *string  `json:"itemsHasPrefix,omitempty"`
	ItemsHasSuffix    *string  `json:"itemsHasSuffix,omitempty"`
	ItemsEqualFold    *string  `json:"itemsEqualFold,omitempty"`
	ItemsContainsFold *string  `json:"itemsContainsFold,omitempty"`

	// "subtotal" field predicates.
	Subtotal      *float64  `json:"subtotal,omitempty"`
	SubtotalNEQ   *float64  `json:"subtotalNEQ,omitempty"`
	SubtotalIn    []float64 `json:"subtotalIn,omitempty"`
	SubtotalNotIn []float64 `json:"subtotalNotIn,omitempty"`
	SubtotalGT    *float64  `json:"subtotalGT,omitempty"`
	SubtotalGTE   *float64  `json:"subtotalGTE,omitempty"`
	SubtotalLT    *float64  `json:"subtotalLT,omitempty"`
	SubtotalLTE   *float64  `json:"subtotalLTE,omitempty"`

	// "tax" field predicates.
	Tax      *float64  `json:"tax,omitempty"`
	TaxNEQ   *float64  `json:"taxNEQ,omitempty"`
	TaxIn    []float64 `json:"taxIn,omitempty"`
	TaxNotIn []float64 `json:"taxNotIn,omitempty"`
	TaxGT    *float64  `json:"taxGT,omitempty"`
	TaxGTE   *float64  `json:"taxGTE,omitempty"`
	TaxLT    *float64  `json:"taxLT,omitempty"`
	TaxLTE   *float64  `json:"taxLTE,omitempty"`

	// "total" field predicates.
	Total      *float64  `json:"total,omitempty"`
	TotalNEQ   *float64  `json:"totalNEQ,omitempty"`
	TotalIn    []float64 `json:"totalIn,omitempty"`
	TotalNotIn []float64 `json:"totalNotIn,omitempty"`
	TotalGT    *float64  `json:"totalGT,omitempty"`
	TotalGTE   *float64  `json:"totalGTE,omitempty"`
	TotalLT    *float64  `json:"totalLT,omitempty"`
	TotalLTE   *float64  `json:"totalLTE,omitempty"`

	// "notes" field predicates.
	Notes             *string  `json:"notes,omitempty"`
	NotesNEQ          *string  `json:"notesNEQ,omitempty"`
	NotesIn           []string `json:"notesIn,omitempty"`
	NotesNotIn        []string `json:"notesNotIn,omitempty"`
	NotesGT           *string  `json:"notesGT,omitempty"`
	NotesGTE          *string  `json:"notesGTE,omitempty"`
	NotesLT           *string  `json:"notesLT,omitempty"`
	NotesLTE          *string  `json:"notesLTE,omitempty"`
	NotesContains     *string  `json:"notesContains,omitempty"`
	NotesHasPrefix    *string  `json:"notesHasPrefix,omitempty"`
	NotesHasSuffix    *string  `json:"notesHasSuffix,omitempty"`
	NotesIsNil        bool     `json:"notesIsNil,omitempty"`
	NotesNotNil       bool     `json:"notesNotNil,omitempty"`
	NotesEqualFold    *string  `json:"notesEqualFold,omitempty"`
	NotesContainsFold *string  `json:"notesContainsFold,omitempty"`

	// "paymentMethod" field predicates.
	PaymentMethod             *string  `json:"paymentmethod,omitempty"`
	PaymentMethodNEQ          *string  `json:"paymentmethodNEQ,omitempty"`
	PaymentMethodIn           []string `json:"paymentmethodIn,omitempty"`
	PaymentMethodNotIn        []string `json:"paymentmethodNotIn,omitempty"`
	PaymentMethodGT           *string  `json:"paymentmethodGT,omitempty"`
	PaymentMethodGTE          *string  `json:"paymentmethodGTE,omitempty"`
	PaymentMethodLT           *string  `json:"paymentmethodLT,omitempty"`
	PaymentMethodLTE          *string  `json:"paymentmethodLTE,omitempty"`
	PaymentMethodContains     *string  `json:"paymentmethodContains,omitempty"`
	PaymentMethodHasPrefix    *string  `json:"paymentmethodHasPrefix,omitempty"`
	PaymentMethodHasSuffix    *string  `json:"paymentmethodHasSuffix,omitempty"`
	PaymentMethodIsNil        bool     `json:"paymentmethodIsNil,omitempty"`
	PaymentMethodNotNil       bool     `json:"paymentmethodNotNil,omitempty"`
	PaymentMethodEqualFold    *string  `json:"paymentmethodEqualFold,omitempty"`
	PaymentMethodContainsFold *string  `json:"paymentmethodContainsFold,omitempty"`

	// "bankName" field predicates.
	BankName             *string  `json:"bankname,omitempty"`
	BankNameNEQ          *string  `json:"banknameNEQ,omitempty"`
	BankNameIn           []string `json:"banknameIn,omitempty"`
	BankNameNotIn        []string `json:"banknameNotIn,omitempty"`
	BankNameGT           *string  `json:"banknameGT,omitempty"`
	BankNameGTE          *string  `json:"banknameGTE,omitempty"`
	BankNameLT           *string  `json:"banknameLT,omitempty"`
	BankNameLTE          *string  `json:"banknameLTE,omitempty"`
	BankNameContains     *string  `json:"banknameContains,omitempty"`
	BankNameHasPrefix    *string  `json:"banknameHasPrefix,omitempty"`
	BankNameHasSuffix    *string  `json:"banknameHasSuffix,omitempty"`
	BankNameIsNil        bool     `json:"banknameIsNil,omitempty"`
	BankNameNotNil       bool     `json:"banknameNotNil,omitempty"`
	BankNameEqualFold    *string  `json:"banknameEqualFold,omitempty"`
	BankNameContainsFold *string  `json:"banknameContainsFold,omitempty"`

	// "bankAgency" field predicates.
	BankAgency             *string  `json:"bankagency,omitempty"`
	BankAgencyNEQ          *string  `json:"bankagencyNEQ,omitempty"`
	BankAgencyIn           []string `json:"bankagencyIn,omitempty"`
	BankAgencyNotIn        []string `json:"bankagencyNotIn,omitempty"`
	BankAgencyGT           *string  `json:"bankagencyGT,omitempty"`
	BankAgencyGTE          *string  `json:"bankagencyGTE,omitempty"`
	BankAgencyLT           *string  `json:"bankagencyLT,omitempty"`
	BankAgencyLTE          *string  `json:"bankagencyLTE,omitempty"`
	BankAgencyContains     *string  `json:"bankagencyContains,omitempty"`
	BankAgencyHasPrefix    *string  `json:"bankagencyHasPrefix,omitempty"`
	BankAgencyHasSuffix    *string  `json:"bankagencyHasSuffix,omitempty"`
	BankAgencyIsNil        bool     `json:"bankagencyIsNil,omitempty"`
	BankAgencyNotNil       bool     `json:"bankagencyNotNil,omitempty"`
	BankAgencyEqualFold    *string  `json:"bankagencyEqualFold,omitempty"`
	BankAgencyContainsFold *string  `json:"bankagencyContainsFold,omitempty"`

	// "bankAccountNumber" field predicates.
	BankAccountNumber             *string  `json:"bankaccountnumber,omitempty"`
	BankAccountNumberNEQ          *string  `json:"bankaccountnumberNEQ,omitempty"`
	BankAccountNumberIn           []string `json:"bankaccountnumberIn,omitempty"`
	BankAccountNumberNotIn        []string `json:"bankaccountnumberNotIn,omitempty"`
	BankAccountNumberGT           *string  `json:"bankaccountnumberGT,omitempty"`
	BankAccountNumberGTE          *string  `json:"bankaccountnumberGTE,omitempty"`
	BankAccountNumberLT           *string  `json:"bankaccountnumberLT,omitempty"`
	BankAccountNumberLTE          *string  `json:"bankaccountnumberLTE,omitempty"`
	BankAccountNumberContains     *string  `json:"bankaccountnumberContains,omitempty"`
	BankAccountNumberHasPrefix    *string  `json:"bankaccountnumberHasPrefix,omitempty"`
	BankAccountNumberHasSuffix    *string  `json:"bankaccountnumberHasSuffix,omitempty"`
	BankAccountNumberIsNil        bool     `json:"bankaccountnumberIsNil,omitempty"`
	BankAccountNumberNotNil       bool     `json:"bankaccountnumberNotNil,omitempty"`
	BankAccountNumberEqualFold    *string  `json:"bankaccountnumberEqualFold,omitempty"`
	BankAccountNumberContainsFold *string  `json:"bankaccountnumberContainsFold,omitempty"`

	// "bankAccountName" field predicates.
	BankAccountName             *string  `json:"bankaccountname,omitempty"`
	BankAccountNameNEQ          *string  `json:"bankaccountnameNEQ,omitempty"`
	BankAccountNameIn           []string `json:"bankaccountnameIn,omitempty"`
	BankAccountNameNotIn        []string `json:"bankaccountnameNotIn,omitempty"`
	BankAccountNameGT           *string  `json:"bankaccountnameGT,omitempty"`
	BankAccountNameGTE          *string  `json:"bankaccountnameGTE,omitempty"`
	BankAccountNameLT           *string  `json:"bankaccountnameLT,omitempty"`
	BankAccountNameLTE          *string  `json:"bankaccountnameLTE,omitempty"`
	BankAccountNameContains     *string  `json:"bankaccountnameContains,omitempty"`
	BankAccountNameHasPrefix    *string  `json:"bankaccountnameHasPrefix,omitempty"`
	BankAccountNameHasSuffix    *string  `json:"bankaccountnameHasSuffix,omitempty"`
	BankAccountNameIsNil        bool     `json:"bankaccountnameIsNil,omitempty"`
	BankAccountNameNotNil       bool     `json:"bankaccountnameNotNil,omitempty"`
	BankAccountNameEqualFold    *string  `json:"bankaccountnameEqualFold,omitempty"`
	BankAccountNameContainsFold *string  `json:"bankaccountnameContainsFold,omitempty"`

	// "storageURI" field predicates.
	StorageURI             *string  `json:"storageuri,omitempty"`
	StorageURINEQ          *string  `json:"storageuriNEQ,omitempty"`
	StorageURIIn           []string `json:"storageuriIn,omitempty"`
	StorageURINotIn        []string `json:"storageuriNotIn,omitempty"`
	StorageURIGT           *string  `json:"storageuriGT,omitempty"`
	StorageURIGTE          *string  `json:"storageuriGTE,omitempty"`
	StorageURILT           *string  `json:"storageuriLT,omitempty"`
	StorageURILTE          *string  `json:"storageuriLTE,omitempty"`
	StorageURIContains     *string  `json:"storageuriContains,omitempty"`
	StorageURIHasPrefix    *string  `json:"storageuriHasPrefix,omitempty"`
	StorageURIHasSuffix    *string  `json:"storageuriHasSuffix,omitempty"`
	StorageURIIsNil        bool     `json:"storageuriIsNil,omitempty"`
	StorageURINotNil       bool     `json:"storageuriNotNil,omitempty"`
	StorageURIEqualFold    *string  `json:"storageuriEqualFold,omitempty"`
	StorageURIContainsFold *string  `json:"storageuriContainsFold,omitempty"`

	// "URL" field predicates.
	URL             *string  `json:"url,omitempty"`
	URLNEQ          *string  `json:"urlNEQ,omitempty"`
	URLIn           []string `json:"urlIn,omitempty"`
	URLNotIn        []string `json:"urlNotIn,omitempty"`
	URLGT           *string  `json:"urlGT,omitempty"`
	URLGTE          *string  `json:"urlGTE,omitempty"`
	URLLT           *string  `json:"urlLT,omitempty"`
	URLLTE          *string  `json:"urlLTE,omitempty"`
	URLContains     *string  `json:"urlContains,omitempty"`
	URLHasPrefix    *string  `json:"urlHasPrefix,omitempty"`
	URLHasSuffix    *string  `json:"urlHasSuffix,omitempty"`
	URLIsNil        bool     `json:"urlIsNil,omitempty"`
	URLNotNil       bool     `json:"urlNotNil,omitempty"`
	URLEqualFold    *string  `json:"urlEqualFold,omitempty"`
	URLContainsFold *string  `json:"urlContainsFold,omitempty"`

	// "filename" field predicates.
	Filename             *string  `json:"filename,omitempty"`
	FilenameNEQ          *string  `json:"filenameNEQ,omitempty"`
	FilenameIn           []string `json:"filenameIn,omitempty"`
	FilenameNotIn        []string `json:"filenameNotIn,omitempty"`
	FilenameGT           *string  `json:"filenameGT,omitempty"`
	FilenameGTE          *string  `json:"filenameGTE,omitempty"`
	FilenameLT           *string  `json:"filenameLT,omitempty"`
	FilenameLTE          *string  `json:"filenameLTE,omitempty"`
	FilenameContains     *string  `json:"filenameContains,omitempty"`
	FilenameHasPrefix    *string  `json:"filenameHasPrefix,omitempty"`
	FilenameHasSuffix    *string  `json:"filenameHasSuffix,omitempty"`
	FilenameIsNil        bool     `json:"filenameIsNil,omitempty"`
	FilenameNotNil       bool     `json:"filenameNotNil,omitempty"`
	FilenameEqualFold    *string  `json:"filenameEqualFold,omitempty"`
	FilenameContainsFold *string  `json:"filenameContainsFold,omitempty"`

	// "size" field predicates.
	Size       *float64  `json:"size,omitempty"`
	SizeNEQ    *float64  `json:"sizeNEQ,omitempty"`
	SizeIn     []float64 `json:"sizeIn,omitempty"`
	SizeNotIn  []float64 `json:"sizeNotIn,omitempty"`
	SizeGT     *float64  `json:"sizeGT,omitempty"`
	SizeGTE    *float64  `json:"sizeGTE,omitempty"`
	SizeLT     *float64  `json:"sizeLT,omitempty"`
	SizeLTE    *float64  `json:"sizeLTE,omitempty"`
	SizeIsNil  bool      `json:"sizeIsNil,omitempty"`
	SizeNotNil bool      `json:"sizeNotNil,omitempty"`

	// "keywords" field predicates.
	Keywords             *string  `json:"keywords,omitempty"`
	KeywordsNEQ          *string  `json:"keywordsNEQ,omitempty"`
	KeywordsIn           []string `json:"keywordsIn,omitempty"`
	KeywordsNotIn        []string `json:"keywordsNotIn,omitempty"`
	KeywordsGT           *string  `json:"keywordsGT,omitempty"`
	KeywordsGTE          *string  `json:"keywordsGTE,omitempty"`
	KeywordsLT           *string  `json:"keywordsLT,omitempty"`
	KeywordsLTE          *string  `json:"keywordsLTE,omitempty"`
	KeywordsContains     *string  `json:"keywordsContains,omitempty"`
	KeywordsHasPrefix    *string  `json:"keywordsHasPrefix,omitempty"`
	KeywordsHasSuffix    *string  `json:"keywordsHasSuffix,omitempty"`
	KeywordsEqualFold    *string  `json:"keywordsEqualFold,omitempty"`
	KeywordsContainsFold *string  `json:"keywordsContainsFold,omitempty"`

	// "company" edge predicates.
	HasCompany     *bool                `json:"hasCompany,omitempty"`
	HasCompanyWith []*CompanyWhereInput `json:"hasCompanyWith,omitempty"`

	// "issuedBy" edge predicates.
	HasIssuedBy     *bool             `json:"hasIssuedBy,omitempty"`
	HasIssuedByWith []*UserWhereInput `json:"hasIssuedByWith,omitempty"`

	// "client" edge predicates.
	HasClient     *bool                 `json:"hasClient,omitempty"`
	HasClientWith []*CustomerWhereInput `json:"hasClientWith,omitempty"`

	// "receivable" edge predicates.
	HasReceivable     *bool                   `json:"hasReceivable,omitempty"`
	HasReceivableWith []*ReceivableWhereInput `json:"hasReceivableWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *InvoiceWhereInput) AddPredicates(predicates ...predicate.Invoice) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the InvoiceWhereInput filter on the InvoiceQuery builder.
func (i *InvoiceWhereInput) Filter(q *InvoiceQuery) (*InvoiceQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyInvoiceWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyInvoiceWhereInput is returned in case the InvoiceWhereInput is empty.
var ErrEmptyInvoiceWhereInput = errors.New("generated: empty predicate InvoiceWhereInput")

// P returns a predicate for filtering invoices.
// An error is returned if the input is empty or invalid.
func (i *InvoiceWhereInput) P() (predicate.Invoice, error) {
	var predicates []predicate.Invoice
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, invoice.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Invoice, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, invoice.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Invoice, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, invoice.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, invoice.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, invoice.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, invoice.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, invoice.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, invoice.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, invoice.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, invoice.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, invoice.IDLTE(*i.IDLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, invoice.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, invoice.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, invoice.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, invoice.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, invoice.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, invoice.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, invoice.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, invoice.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, invoice.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, invoice.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, invoice.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, invoice.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, invoice.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, invoice.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, invoice.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, invoice.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.DeletedAt != nil {
		predicates = append(predicates, invoice.DeletedAtEQ(*i.DeletedAt))
	}
	if i.DeletedAtNEQ != nil {
		predicates = append(predicates, invoice.DeletedAtNEQ(*i.DeletedAtNEQ))
	}
	if len(i.DeletedAtIn) > 0 {
		predicates = append(predicates, invoice.DeletedAtIn(i.DeletedAtIn...))
	}
	if len(i.DeletedAtNotIn) > 0 {
		predicates = append(predicates, invoice.DeletedAtNotIn(i.DeletedAtNotIn...))
	}
	if i.DeletedAtGT != nil {
		predicates = append(predicates, invoice.DeletedAtGT(*i.DeletedAtGT))
	}
	if i.DeletedAtGTE != nil {
		predicates = append(predicates, invoice.DeletedAtGTE(*i.DeletedAtGTE))
	}
	if i.DeletedAtLT != nil {
		predicates = append(predicates, invoice.DeletedAtLT(*i.DeletedAtLT))
	}
	if i.DeletedAtLTE != nil {
		predicates = append(predicates, invoice.DeletedAtLTE(*i.DeletedAtLTE))
	}
	if i.DeletedAtIsNil {
		predicates = append(predicates, invoice.DeletedAtIsNil())
	}
	if i.DeletedAtNotNil {
		predicates = append(predicates, invoice.DeletedAtNotNil())
	}
	if i.CompanyLogo != nil {
		predicates = append(predicates, invoice.CompanyLogoEQ(*i.CompanyLogo))
	}
	if i.CompanyLogoNEQ != nil {
		predicates = append(predicates, invoice.CompanyLogoNEQ(*i.CompanyLogoNEQ))
	}
	if len(i.CompanyLogoIn) > 0 {
		predicates = append(predicates, invoice.CompanyLogoIn(i.CompanyLogoIn...))
	}
	if len(i.CompanyLogoNotIn) > 0 {
		predicates = append(predicates, invoice.CompanyLogoNotIn(i.CompanyLogoNotIn...))
	}
	if i.CompanyLogoGT != nil {
		predicates = append(predicates, invoice.CompanyLogoGT(*i.CompanyLogoGT))
	}
	if i.CompanyLogoGTE != nil {
		predicates = append(predicates, invoice.CompanyLogoGTE(*i.CompanyLogoGTE))
	}
	if i.CompanyLogoLT != nil {
		predicates = append(predicates, invoice.CompanyLogoLT(*i.CompanyLogoLT))
	}
	if i.CompanyLogoLTE != nil {
		predicates = append(predicates, invoice.CompanyLogoLTE(*i.CompanyLogoLTE))
	}
	if i.CompanyLogoContains != nil {
		predicates = append(predicates, invoice.CompanyLogoContains(*i.CompanyLogoContains))
	}
	if i.CompanyLogoHasPrefix != nil {
		predicates = append(predicates, invoice.CompanyLogoHasPrefix(*i.CompanyLogoHasPrefix))
	}
	if i.CompanyLogoHasSuffix != nil {
		predicates = append(predicates, invoice.CompanyLogoHasSuffix(*i.CompanyLogoHasSuffix))
	}
	if i.CompanyLogoIsNil {
		predicates = append(predicates, invoice.CompanyLogoIsNil())
	}
	if i.CompanyLogoNotNil {
		predicates = append(predicates, invoice.CompanyLogoNotNil())
	}
	if i.CompanyLogoEqualFold != nil {
		predicates = append(predicates, invoice.CompanyLogoEqualFold(*i.CompanyLogoEqualFold))
	}
	if i.CompanyLogoContainsFold != nil {
		predicates = append(predicates, invoice.CompanyLogoContainsFold(*i.CompanyLogoContainsFold))
	}
	if i.CompanyName != nil {
		predicates = append(predicates, invoice.CompanyNameEQ(*i.CompanyName))
	}
	if i.CompanyNameNEQ != nil {
		predicates = append(predicates, invoice.CompanyNameNEQ(*i.CompanyNameNEQ))
	}
	if len(i.CompanyNameIn) > 0 {
		predicates = append(predicates, invoice.CompanyNameIn(i.CompanyNameIn...))
	}
	if len(i.CompanyNameNotIn) > 0 {
		predicates = append(predicates, invoice.CompanyNameNotIn(i.CompanyNameNotIn...))
	}
	if i.CompanyNameGT != nil {
		predicates = append(predicates, invoice.CompanyNameGT(*i.CompanyNameGT))
	}
	if i.CompanyNameGTE != nil {
		predicates = append(predicates, invoice.CompanyNameGTE(*i.CompanyNameGTE))
	}
	if i.CompanyNameLT != nil {
		predicates = append(predicates, invoice.CompanyNameLT(*i.CompanyNameLT))
	}
	if i.CompanyNameLTE != nil {
		predicates = append(predicates, invoice.CompanyNameLTE(*i.CompanyNameLTE))
	}
	if i.CompanyNameContains != nil {
		predicates = append(predicates, invoice.CompanyNameContains(*i.CompanyNameContains))
	}
	if i.CompanyNameHasPrefix != nil {
		predicates = append(predicates, invoice.CompanyNameHasPrefix(*i.CompanyNameHasPrefix))
	}
	if i.CompanyNameHasSuffix != nil {
		predicates = append(predicates, invoice.CompanyNameHasSuffix(*i.CompanyNameHasSuffix))
	}
	if i.CompanyNameEqualFold != nil {
		predicates = append(predicates, invoice.CompanyNameEqualFold(*i.CompanyNameEqualFold))
	}
	if i.CompanyNameContainsFold != nil {
		predicates = append(predicates, invoice.CompanyNameContainsFold(*i.CompanyNameContainsFold))
	}
	if i.CompanyTaxID != nil {
		predicates = append(predicates, invoice.CompanyTaxIDEQ(*i.CompanyTaxID))
	}
	if i.CompanyTaxIDNEQ != nil {
		predicates = append(predicates, invoice.CompanyTaxIDNEQ(*i.CompanyTaxIDNEQ))
	}
	if len(i.CompanyTaxIDIn) > 0 {
		predicates = append(predicates, invoice.CompanyTaxIDIn(i.CompanyTaxIDIn...))
	}
	if len(i.CompanyTaxIDNotIn) > 0 {
		predicates = append(predicates, invoice.CompanyTaxIDNotIn(i.CompanyTaxIDNotIn...))
	}
	if i.CompanyTaxIDGT != nil {
		predicates = append(predicates, invoice.CompanyTaxIDGT(*i.CompanyTaxIDGT))
	}
	if i.CompanyTaxIDGTE != nil {
		predicates = append(predicates, invoice.CompanyTaxIDGTE(*i.CompanyTaxIDGTE))
	}
	if i.CompanyTaxIDLT != nil {
		predicates = append(predicates, invoice.CompanyTaxIDLT(*i.CompanyTaxIDLT))
	}
	if i.CompanyTaxIDLTE != nil {
		predicates = append(predicates, invoice.CompanyTaxIDLTE(*i.CompanyTaxIDLTE))
	}
	if i.CompanyTaxIDContains != nil {
		predicates = append(predicates, invoice.CompanyTaxIDContains(*i.CompanyTaxIDContains))
	}
	if i.CompanyTaxIDHasPrefix != nil {
		predicates = append(predicates, invoice.CompanyTaxIDHasPrefix(*i.CompanyTaxIDHasPrefix))
	}
	if i.CompanyTaxIDHasSuffix != nil {
		predicates = append(predicates, invoice.CompanyTaxIDHasSuffix(*i.CompanyTaxIDHasSuffix))
	}
	if i.CompanyTaxIDIsNil {
		predicates = append(predicates, invoice.CompanyTaxIDIsNil())
	}
	if i.CompanyTaxIDNotNil {
		predicates = append(predicates, invoice.CompanyTaxIDNotNil())
	}
	if i.CompanyTaxIDEqualFold != nil {
		predicates = append(predicates, invoice.CompanyTaxIDEqualFold(*i.CompanyTaxIDEqualFold))
	}
	if i.CompanyTaxIDContainsFold != nil {
		predicates = append(predicates, invoice.CompanyTaxIDContainsFold(*i.CompanyTaxIDContainsFold))
	}
	if i.CompanyAddress != nil {
		predicates = append(predicates, invoice.CompanyAddressEQ(*i.CompanyAddress))
	}
	if i.CompanyAddressNEQ != nil {
		predicates = append(predicates, invoice.CompanyAddressNEQ(*i.CompanyAddressNEQ))
	}
	if len(i.CompanyAddressIn) > 0 {
		predicates = append(predicates, invoice.CompanyAddressIn(i.CompanyAddressIn...))
	}
	if len(i.CompanyAddressNotIn) > 0 {
		predicates = append(predicates, invoice.CompanyAddressNotIn(i.CompanyAddressNotIn...))
	}
	if i.CompanyAddressGT != nil {
		predicates = append(predicates, invoice.CompanyAddressGT(*i.CompanyAddressGT))
	}
	if i.CompanyAddressGTE != nil {
		predicates = append(predicates, invoice.CompanyAddressGTE(*i.CompanyAddressGTE))
	}
	if i.CompanyAddressLT != nil {
		predicates = append(predicates, invoice.CompanyAddressLT(*i.CompanyAddressLT))
	}
	if i.CompanyAddressLTE != nil {
		predicates = append(predicates, invoice.CompanyAddressLTE(*i.CompanyAddressLTE))
	}
	if i.CompanyAddressContains != nil {
		predicates = append(predicates, invoice.CompanyAddressContains(*i.CompanyAddressContains))
	}
	if i.CompanyAddressHasPrefix != nil {
		predicates = append(predicates, invoice.CompanyAddressHasPrefix(*i.CompanyAddressHasPrefix))
	}
	if i.CompanyAddressHasSuffix != nil {
		predicates = append(predicates, invoice.CompanyAddressHasSuffix(*i.CompanyAddressHasSuffix))
	}
	if i.CompanyAddressEqualFold != nil {
		predicates = append(predicates, invoice.CompanyAddressEqualFold(*i.CompanyAddressEqualFold))
	}
	if i.CompanyAddressContainsFold != nil {
		predicates = append(predicates, invoice.CompanyAddressContainsFold(*i.CompanyAddressContainsFold))
	}
	if i.CompanyCity != nil {
		predicates = append(predicates, invoice.CompanyCityEQ(*i.CompanyCity))
	}
	if i.CompanyCityNEQ != nil {
		predicates = append(predicates, invoice.CompanyCityNEQ(*i.CompanyCityNEQ))
	}
	if len(i.CompanyCityIn) > 0 {
		predicates = append(predicates, invoice.CompanyCityIn(i.CompanyCityIn...))
	}
	if len(i.CompanyCityNotIn) > 0 {
		predicates = append(predicates, invoice.CompanyCityNotIn(i.CompanyCityNotIn...))
	}
	if i.CompanyCityGT != nil {
		predicates = append(predicates, invoice.CompanyCityGT(*i.CompanyCityGT))
	}
	if i.CompanyCityGTE != nil {
		predicates = append(predicates, invoice.CompanyCityGTE(*i.CompanyCityGTE))
	}
	if i.CompanyCityLT != nil {
		predicates = append(predicates, invoice.CompanyCityLT(*i.CompanyCityLT))
	}
	if i.CompanyCityLTE != nil {
		predicates = append(predicates, invoice.CompanyCityLTE(*i.CompanyCityLTE))
	}
	if i.CompanyCityContains != nil {
		predicates = append(predicates, invoice.CompanyCityContains(*i.CompanyCityContains))
	}
	if i.CompanyCityHasPrefix != nil {
		predicates = append(predicates, invoice.CompanyCityHasPrefix(*i.CompanyCityHasPrefix))
	}
	if i.CompanyCityHasSuffix != nil {
		predicates = append(predicates, invoice.CompanyCityHasSuffix(*i.CompanyCityHasSuffix))
	}
	if i.CompanyCityEqualFold != nil {
		predicates = append(predicates, invoice.CompanyCityEqualFold(*i.CompanyCityEqualFold))
	}
	if i.CompanyCityContainsFold != nil {
		predicates = append(predicates, invoice.CompanyCityContainsFold(*i.CompanyCityContainsFold))
	}
	if i.CompanyEmail != nil {
		predicates = append(predicates, invoice.CompanyEmailEQ(*i.CompanyEmail))
	}
	if i.CompanyEmailNEQ != nil {
		predicates = append(predicates, invoice.CompanyEmailNEQ(*i.CompanyEmailNEQ))
	}
	if len(i.CompanyEmailIn) > 0 {
		predicates = append(predicates, invoice.CompanyEmailIn(i.CompanyEmailIn...))
	}
	if len(i.CompanyEmailNotIn) > 0 {
		predicates = append(predicates, invoice.CompanyEmailNotIn(i.CompanyEmailNotIn...))
	}
	if i.CompanyEmailGT != nil {
		predicates = append(predicates, invoice.CompanyEmailGT(*i.CompanyEmailGT))
	}
	if i.CompanyEmailGTE != nil {
		predicates = append(predicates, invoice.CompanyEmailGTE(*i.CompanyEmailGTE))
	}
	if i.CompanyEmailLT != nil {
		predicates = append(predicates, invoice.CompanyEmailLT(*i.CompanyEmailLT))
	}
	if i.CompanyEmailLTE != nil {
		predicates = append(predicates, invoice.CompanyEmailLTE(*i.CompanyEmailLTE))
	}
	if i.CompanyEmailContains != nil {
		predicates = append(predicates, invoice.CompanyEmailContains(*i.CompanyEmailContains))
	}
	if i.CompanyEmailHasPrefix != nil {
		predicates = append(predicates, invoice.CompanyEmailHasPrefix(*i.CompanyEmailHasPrefix))
	}
	if i.CompanyEmailHasSuffix != nil {
		predicates = append(predicates, invoice.CompanyEmailHasSuffix(*i.CompanyEmailHasSuffix))
	}
	if i.CompanyEmailIsNil {
		predicates = append(predicates, invoice.CompanyEmailIsNil())
	}
	if i.CompanyEmailNotNil {
		predicates = append(predicates, invoice.CompanyEmailNotNil())
	}
	if i.CompanyEmailEqualFold != nil {
		predicates = append(predicates, invoice.CompanyEmailEqualFold(*i.CompanyEmailEqualFold))
	}
	if i.CompanyEmailContainsFold != nil {
		predicates = append(predicates, invoice.CompanyEmailContainsFold(*i.CompanyEmailContainsFold))
	}
	if i.CompanyPhone != nil {
		predicates = append(predicates, invoice.CompanyPhoneEQ(*i.CompanyPhone))
	}
	if i.CompanyPhoneNEQ != nil {
		predicates = append(predicates, invoice.CompanyPhoneNEQ(*i.CompanyPhoneNEQ))
	}
	if len(i.CompanyPhoneIn) > 0 {
		predicates = append(predicates, invoice.CompanyPhoneIn(i.CompanyPhoneIn...))
	}
	if len(i.CompanyPhoneNotIn) > 0 {
		predicates = append(predicates, invoice.CompanyPhoneNotIn(i.CompanyPhoneNotIn...))
	}
	if i.CompanyPhoneGT != nil {
		predicates = append(predicates, invoice.CompanyPhoneGT(*i.CompanyPhoneGT))
	}
	if i.CompanyPhoneGTE != nil {
		predicates = append(predicates, invoice.CompanyPhoneGTE(*i.CompanyPhoneGTE))
	}
	if i.CompanyPhoneLT != nil {
		predicates = append(predicates, invoice.CompanyPhoneLT(*i.CompanyPhoneLT))
	}
	if i.CompanyPhoneLTE != nil {
		predicates = append(predicates, invoice.CompanyPhoneLTE(*i.CompanyPhoneLTE))
	}
	if i.CompanyPhoneContains != nil {
		predicates = append(predicates, invoice.CompanyPhoneContains(*i.CompanyPhoneContains))
	}
	if i.CompanyPhoneHasPrefix != nil {
		predicates = append(predicates, invoice.CompanyPhoneHasPrefix(*i.CompanyPhoneHasPrefix))
	}
	if i.CompanyPhoneHasSuffix != nil {
		predicates = append(predicates, invoice.CompanyPhoneHasSuffix(*i.CompanyPhoneHasSuffix))
	}
	if i.CompanyPhoneIsNil {
		predicates = append(predicates, invoice.CompanyPhoneIsNil())
	}
	if i.CompanyPhoneNotNil {
		predicates = append(predicates, invoice.CompanyPhoneNotNil())
	}
	if i.CompanyPhoneEqualFold != nil {
		predicates = append(predicates, invoice.CompanyPhoneEqualFold(*i.CompanyPhoneEqualFold))
	}
	if i.CompanyPhoneContainsFold != nil {
		predicates = append(predicates, invoice.CompanyPhoneContainsFold(*i.CompanyPhoneContainsFold))
	}
	if i.Number != nil {
		predicates = append(predicates, invoice.NumberEQ(*i.Number))
	}
	if i.NumberNEQ != nil {
		predicates = append(predicates, invoice.NumberNEQ(*i.NumberNEQ))
	}
	if len(i.NumberIn) > 0 {
		predicates = append(predicates, invoice.NumberIn(i.NumberIn...))
	}
	if len(i.NumberNotIn) > 0 {
		predicates = append(predicates, invoice.NumberNotIn(i.NumberNotIn...))
	}
	if i.NumberGT != nil {
		predicates = append(predicates, invoice.NumberGT(*i.NumberGT))
	}
	if i.NumberGTE != nil {
		predicates = append(predicates, invoice.NumberGTE(*i.NumberGTE))
	}
	if i.NumberLT != nil {
		predicates = append(predicates, invoice.NumberLT(*i.NumberLT))
	}
	if i.NumberLTE != nil {
		predicates = append(predicates, invoice.NumberLTE(*i.NumberLTE))
	}
	if i.NumberContains != nil {
		predicates = append(predicates, invoice.NumberContains(*i.NumberContains))
	}
	if i.NumberHasPrefix != nil {
		predicates = append(predicates, invoice.NumberHasPrefix(*i.NumberHasPrefix))
	}
	if i.NumberHasSuffix != nil {
		predicates = append(predicates, invoice.NumberHasSuffix(*i.NumberHasSuffix))
	}
	if i.NumberIsNil {
		predicates = append(predicates, invoice.NumberIsNil())
	}
	if i.NumberNotNil {
		predicates = append(predicates, invoice.NumberNotNil())
	}
	if i.NumberEqualFold != nil {
		predicates = append(predicates, invoice.NumberEqualFold(*i.NumberEqualFold))
	}
	if i.NumberContainsFold != nil {
		predicates = append(predicates, invoice.NumberContainsFold(*i.NumberContainsFold))
	}
	if i.IssueDate != nil {
		predicates = append(predicates, invoice.IssueDateEQ(*i.IssueDate))
	}
	if i.IssueDateNEQ != nil {
		predicates = append(predicates, invoice.IssueDateNEQ(*i.IssueDateNEQ))
	}
	if len(i.IssueDateIn) > 0 {
		predicates = append(predicates, invoice.IssueDateIn(i.IssueDateIn...))
	}
	if len(i.IssueDateNotIn) > 0 {
		predicates = append(predicates, invoice.IssueDateNotIn(i.IssueDateNotIn...))
	}
	if i.IssueDateGT != nil {
		predicates = append(predicates, invoice.IssueDateGT(*i.IssueDateGT))
	}
	if i.IssueDateGTE != nil {
		predicates = append(predicates, invoice.IssueDateGTE(*i.IssueDateGTE))
	}
	if i.IssueDateLT != nil {
		predicates = append(predicates, invoice.IssueDateLT(*i.IssueDateLT))
	}
	if i.IssueDateLTE != nil {
		predicates = append(predicates, invoice.IssueDateLTE(*i.IssueDateLTE))
	}
	if i.DueDate != nil {
		predicates = append(predicates, invoice.DueDateEQ(*i.DueDate))
	}
	if i.DueDateNEQ != nil {
		predicates = append(predicates, invoice.DueDateNEQ(*i.DueDateNEQ))
	}
	if len(i.DueDateIn) > 0 {
		predicates = append(predicates, invoice.DueDateIn(i.DueDateIn...))
	}
	if len(i.DueDateNotIn) > 0 {
		predicates = append(predicates, invoice.DueDateNotIn(i.DueDateNotIn...))
	}
	if i.DueDateGT != nil {
		predicates = append(predicates, invoice.DueDateGT(*i.DueDateGT))
	}
	if i.DueDateGTE != nil {
		predicates = append(predicates, invoice.DueDateGTE(*i.DueDateGTE))
	}
	if i.DueDateLT != nil {
		predicates = append(predicates, invoice.DueDateLT(*i.DueDateLT))
	}
	if i.DueDateLTE != nil {
		predicates = append(predicates, invoice.DueDateLTE(*i.DueDateLTE))
	}
	if i.PaidAt != nil {
		predicates = append(predicates, invoice.PaidAtEQ(*i.PaidAt))
	}
	if i.PaidAtNEQ != nil {
		predicates = append(predicates, invoice.PaidAtNEQ(*i.PaidAtNEQ))
	}
	if len(i.PaidAtIn) > 0 {
		predicates = append(predicates, invoice.PaidAtIn(i.PaidAtIn...))
	}
	if len(i.PaidAtNotIn) > 0 {
		predicates = append(predicates, invoice.PaidAtNotIn(i.PaidAtNotIn...))
	}
	if i.PaidAtGT != nil {
		predicates = append(predicates, invoice.PaidAtGT(*i.PaidAtGT))
	}
	if i.PaidAtGTE != nil {
		predicates = append(predicates, invoice.PaidAtGTE(*i.PaidAtGTE))
	}
	if i.PaidAtLT != nil {
		predicates = append(predicates, invoice.PaidAtLT(*i.PaidAtLT))
	}
	if i.PaidAtLTE != nil {
		predicates = append(predicates, invoice.PaidAtLTE(*i.PaidAtLTE))
	}
	if i.PaidAtIsNil {
		predicates = append(predicates, invoice.PaidAtIsNil())
	}
	if i.PaidAtNotNil {
		predicates = append(predicates, invoice.PaidAtNotNil())
	}
	if i.Status != nil {
		predicates = append(predicates, invoice.StatusEQ(*i.Status))
	}
	if i.StatusNEQ != nil {
		predicates = append(predicates, invoice.StatusNEQ(*i.StatusNEQ))
	}
	if len(i.StatusIn) > 0 {
		predicates = append(predicates, invoice.StatusIn(i.StatusIn...))
	}
	if len(i.StatusNotIn) > 0 {
		predicates = append(predicates, invoice.StatusNotIn(i.StatusNotIn...))
	}
	if i.CustomerName != nil {
		predicates = append(predicates, invoice.CustomerNameEQ(*i.CustomerName))
	}
	if i.CustomerNameNEQ != nil {
		predicates = append(predicates, invoice.CustomerNameNEQ(*i.CustomerNameNEQ))
	}
	if len(i.CustomerNameIn) > 0 {
		predicates = append(predicates, invoice.CustomerNameIn(i.CustomerNameIn...))
	}
	if len(i.CustomerNameNotIn) > 0 {
		predicates = append(predicates, invoice.CustomerNameNotIn(i.CustomerNameNotIn...))
	}
	if i.CustomerNameGT != nil {
		predicates = append(predicates, invoice.CustomerNameGT(*i.CustomerNameGT))
	}
	if i.CustomerNameGTE != nil {
		predicates = append(predicates, invoice.CustomerNameGTE(*i.CustomerNameGTE))
	}
	if i.CustomerNameLT != nil {
		predicates = append(predicates, invoice.CustomerNameLT(*i.CustomerNameLT))
	}
	if i.CustomerNameLTE != nil {
		predicates = append(predicates, invoice.CustomerNameLTE(*i.CustomerNameLTE))
	}
	if i.CustomerNameContains != nil {
		predicates = append(predicates, invoice.CustomerNameContains(*i.CustomerNameContains))
	}
	if i.CustomerNameHasPrefix != nil {
		predicates = append(predicates, invoice.CustomerNameHasPrefix(*i.CustomerNameHasPrefix))
	}
	if i.CustomerNameHasSuffix != nil {
		predicates = append(predicates, invoice.CustomerNameHasSuffix(*i.CustomerNameHasSuffix))
	}
	if i.CustomerNameIsNil {
		predicates = append(predicates, invoice.CustomerNameIsNil())
	}
	if i.CustomerNameNotNil {
		predicates = append(predicates, invoice.CustomerNameNotNil())
	}
	if i.CustomerNameEqualFold != nil {
		predicates = append(predicates, invoice.CustomerNameEqualFold(*i.CustomerNameEqualFold))
	}
	if i.CustomerNameContainsFold != nil {
		predicates = append(predicates, invoice.CustomerNameContainsFold(*i.CustomerNameContainsFold))
	}
	if i.CustomerTaxID != nil {
		predicates = append(predicates, invoice.CustomerTaxIDEQ(*i.CustomerTaxID))
	}
	if i.CustomerTaxIDNEQ != nil {
		predicates = append(predicates, invoice.CustomerTaxIDNEQ(*i.CustomerTaxIDNEQ))
	}
	if len(i.CustomerTaxIDIn) > 0 {
		predicates = append(predicates, invoice.CustomerTaxIDIn(i.CustomerTaxIDIn...))
	}
	if len(i.CustomerTaxIDNotIn) > 0 {
		predicates = append(predicates, invoice.CustomerTaxIDNotIn(i.CustomerTaxIDNotIn...))
	}
	if i.CustomerTaxIDGT != nil {
		predicates = append(predicates, invoice.CustomerTaxIDGT(*i.CustomerTaxIDGT))
	}
	if i.CustomerTaxIDGTE != nil {
		predicates = append(predicates, invoice.CustomerTaxIDGTE(*i.CustomerTaxIDGTE))
	}
	if i.CustomerTaxIDLT != nil {
		predicates = append(predicates, invoice.CustomerTaxIDLT(*i.CustomerTaxIDLT))
	}
	if i.CustomerTaxIDLTE != nil {
		predicates = append(predicates, invoice.CustomerTaxIDLTE(*i.CustomerTaxIDLTE))
	}
	if i.CustomerTaxIDContains != nil {
		predicates = append(predicates, invoice.CustomerTaxIDContains(*i.CustomerTaxIDContains))
	}
	if i.CustomerTaxIDHasPrefix != nil {
		predicates = append(predicates, invoice.CustomerTaxIDHasPrefix(*i.CustomerTaxIDHasPrefix))
	}
	if i.CustomerTaxIDHasSuffix != nil {
		predicates = append(predicates, invoice.CustomerTaxIDHasSuffix(*i.CustomerTaxIDHasSuffix))
	}
	if i.CustomerTaxIDIsNil {
		predicates = append(predicates, invoice.CustomerTaxIDIsNil())
	}
	if i.CustomerTaxIDNotNil {
		predicates = append(predicates, invoice.CustomerTaxIDNotNil())
	}
	if i.CustomerTaxIDEqualFold != nil {
		predicates = append(predicates, invoice.CustomerTaxIDEqualFold(*i.CustomerTaxIDEqualFold))
	}
	if i.CustomerTaxIDContainsFold != nil {
		predicates = append(predicates, invoice.CustomerTaxIDContainsFold(*i.CustomerTaxIDContainsFold))
	}
	if i.CustomerAddress != nil {
		predicates = append(predicates, invoice.CustomerAddressEQ(*i.CustomerAddress))
	}
	if i.CustomerAddressNEQ != nil {
		predicates = append(predicates, invoice.CustomerAddressNEQ(*i.CustomerAddressNEQ))
	}
	if len(i.CustomerAddressIn) > 0 {
		predicates = append(predicates, invoice.CustomerAddressIn(i.CustomerAddressIn...))
	}
	if len(i.CustomerAddressNotIn) > 0 {
		predicates = append(predicates, invoice.CustomerAddressNotIn(i.CustomerAddressNotIn...))
	}
	if i.CustomerAddressGT != nil {
		predicates = append(predicates, invoice.CustomerAddressGT(*i.CustomerAddressGT))
	}
	if i.CustomerAddressGTE != nil {
		predicates = append(predicates, invoice.CustomerAddressGTE(*i.CustomerAddressGTE))
	}
	if i.CustomerAddressLT != nil {
		predicates = append(predicates, invoice.CustomerAddressLT(*i.CustomerAddressLT))
	}
	if i.CustomerAddressLTE != nil {
		predicates = append(predicates, invoice.CustomerAddressLTE(*i.CustomerAddressLTE))
	}
	if i.CustomerAddressContains != nil {
		predicates = append(predicates, invoice.CustomerAddressContains(*i.CustomerAddressContains))
	}
	if i.CustomerAddressHasPrefix != nil {
		predicates = append(predicates, invoice.CustomerAddressHasPrefix(*i.CustomerAddressHasPrefix))
	}
	if i.CustomerAddressHasSuffix != nil {
		predicates = append(predicates, invoice.CustomerAddressHasSuffix(*i.CustomerAddressHasSuffix))
	}
	if i.CustomerAddressIsNil {
		predicates = append(predicates, invoice.CustomerAddressIsNil())
	}
	if i.CustomerAddressNotNil {
		predicates = append(predicates, invoice.CustomerAddressNotNil())
	}
	if i.CustomerAddressEqualFold != nil {
		predicates = append(predicates, invoice.CustomerAddressEqualFold(*i.CustomerAddressEqualFold))
	}
	if i.CustomerAddressContainsFold != nil {
		predicates = append(predicates, invoice.CustomerAddressContainsFold(*i.CustomerAddressContainsFold))
	}
	if i.CustomerCity != nil {
		predicates = append(predicates, invoice.CustomerCityEQ(*i.CustomerCity))
	}
	if i.CustomerCityNEQ != nil {
		predicates = append(predicates, invoice.CustomerCityNEQ(*i.CustomerCityNEQ))
	}
	if len(i.CustomerCityIn) > 0 {
		predicates = append(predicates, invoice.CustomerCityIn(i.CustomerCityIn...))
	}
	if len(i.CustomerCityNotIn) > 0 {
		predicates = append(predicates, invoice.CustomerCityNotIn(i.CustomerCityNotIn...))
	}
	if i.CustomerCityGT != nil {
		predicates = append(predicates, invoice.CustomerCityGT(*i.CustomerCityGT))
	}
	if i.CustomerCityGTE != nil {
		predicates = append(predicates, invoice.CustomerCityGTE(*i.CustomerCityGTE))
	}
	if i.CustomerCityLT != nil {
		predicates = append(predicates, invoice.CustomerCityLT(*i.CustomerCityLT))
	}
	if i.CustomerCityLTE != nil {
		predicates = append(predicates, invoice.CustomerCityLTE(*i.CustomerCityLTE))
	}
	if i.CustomerCityContains != nil {
		predicates = append(predicates, invoice.CustomerCityContains(*i.CustomerCityContains))
	}
	if i.CustomerCityHasPrefix != nil {
		predicates = append(predicates, invoice.CustomerCityHasPrefix(*i.CustomerCityHasPrefix))
	}
	if i.CustomerCityHasSuffix != nil {
		predicates = append(predicates, invoice.CustomerCityHasSuffix(*i.CustomerCityHasSuffix))
	}
	if i.CustomerCityIsNil {
		predicates = append(predicates, invoice.CustomerCityIsNil())
	}
	if i.CustomerCityNotNil {
		predicates = append(predicates, invoice.CustomerCityNotNil())
	}
	if i.CustomerCityEqualFold != nil {
		predicates = append(predicates, invoice.CustomerCityEqualFold(*i.CustomerCityEqualFold))
	}
	if i.CustomerCityContainsFold != nil {
		predicates = append(predicates, invoice.CustomerCityContainsFold(*i.CustomerCityContainsFold))
	}
	if i.CustomerEmail != nil {
		predicates = append(predicates, invoice.CustomerEmailEQ(*i.CustomerEmail))
	}
	if i.CustomerEmailNEQ != nil {
		predicates = append(predicates, invoice.CustomerEmailNEQ(*i.CustomerEmailNEQ))
	}
	if len(i.CustomerEmailIn) > 0 {
		predicates = append(predicates, invoice.CustomerEmailIn(i.CustomerEmailIn...))
	}
	if len(i.CustomerEmailNotIn) > 0 {
		predicates = append(predicates, invoice.CustomerEmailNotIn(i.CustomerEmailNotIn...))
	}
	if i.CustomerEmailGT != nil {
		predicates = append(predicates, invoice.CustomerEmailGT(*i.CustomerEmailGT))
	}
	if i.CustomerEmailGTE != nil {
		predicates = append(predicates, invoice.CustomerEmailGTE(*i.CustomerEmailGTE))
	}
	if i.CustomerEmailLT != nil {
		predicates = append(predicates, invoice.CustomerEmailLT(*i.CustomerEmailLT))
	}
	if i.CustomerEmailLTE != nil {
		predicates = append(predicates, invoice.CustomerEmailLTE(*i.CustomerEmailLTE))
	}
	if i.CustomerEmailContains != nil {
		predicates = append(predicates, invoice.CustomerEmailContains(*i.CustomerEmailContains))
	}
	if i.CustomerEmailHasPrefix != nil {
		predicates = append(predicates, invoice.CustomerEmailHasPrefix(*i.CustomerEmailHasPrefix))
	}
	if i.CustomerEmailHasSuffix != nil {
		predicates = append(predicates, invoice.CustomerEmailHasSuffix(*i.CustomerEmailHasSuffix))
	}
	if i.CustomerEmailIsNil {
		predicates = append(predicates, invoice.CustomerEmailIsNil())
	}
	if i.CustomerEmailNotNil {
		predicates = append(predicates, invoice.CustomerEmailNotNil())
	}
	if i.CustomerEmailEqualFold != nil {
		predicates = append(predicates, invoice.CustomerEmailEqualFold(*i.CustomerEmailEqualFold))
	}
	if i.CustomerEmailContainsFold != nil {
		predicates = append(predicates, invoice.CustomerEmailContainsFold(*i.CustomerEmailContainsFold))
	}
	if i.CustomerPhone != nil {
		predicates = append(predicates, invoice.CustomerPhoneEQ(*i.CustomerPhone))
	}
	if i.CustomerPhoneNEQ != nil {
		predicates = append(predicates, invoice.CustomerPhoneNEQ(*i.CustomerPhoneNEQ))
	}
	if len(i.CustomerPhoneIn) > 0 {
		predicates = append(predicates, invoice.CustomerPhoneIn(i.CustomerPhoneIn...))
	}
	if len(i.CustomerPhoneNotIn) > 0 {
		predicates = append(predicates, invoice.CustomerPhoneNotIn(i.CustomerPhoneNotIn...))
	}
	if i.CustomerPhoneGT != nil {
		predicates = append(predicates, invoice.CustomerPhoneGT(*i.CustomerPhoneGT))
	}
	if i.CustomerPhoneGTE != nil {
		predicates = append(predicates, invoice.CustomerPhoneGTE(*i.CustomerPhoneGTE))
	}
	if i.CustomerPhoneLT != nil {
		predicates = append(predicates, invoice.CustomerPhoneLT(*i.CustomerPhoneLT))
	}
	if i.CustomerPhoneLTE != nil {
		predicates = append(predicates, invoice.CustomerPhoneLTE(*i.CustomerPhoneLTE))
	}
	if i.CustomerPhoneContains != nil {
		predicates = append(predicates, invoice.CustomerPhoneContains(*i.CustomerPhoneContains))
	}
	if i.CustomerPhoneHasPrefix != nil {
		predicates = append(predicates, invoice.CustomerPhoneHasPrefix(*i.CustomerPhoneHasPrefix))
	}
	if i.CustomerPhoneHasSuffix != nil {
		predicates = append(predicates, invoice.CustomerPhoneHasSuffix(*i.CustomerPhoneHasSuffix))
	}
	if i.CustomerPhoneIsNil {
		predicates = append(predicates, invoice.CustomerPhoneIsNil())
	}
	if i.CustomerPhoneNotNil {
		predicates = append(predicates, invoice.CustomerPhoneNotNil())
	}
	if i.CustomerPhoneEqualFold != nil {
		predicates = append(predicates, invoice.CustomerPhoneEqualFold(*i.CustomerPhoneEqualFold))
	}
	if i.CustomerPhoneContainsFold != nil {
		predicates = append(predicates, invoice.CustomerPhoneContainsFold(*i.CustomerPhoneContainsFold))
	}
	if i.Items != nil {
		predicates = append(predicates, invoice.ItemsEQ(*i.Items))
	}
	if i.ItemsNEQ != nil {
		predicates = append(predicates, invoice.ItemsNEQ(*i.ItemsNEQ))
	}
	if len(i.ItemsIn) > 0 {
		predicates = append(predicates, invoice.ItemsIn(i.ItemsIn...))
	}
	if len(i.ItemsNotIn) > 0 {
		predicates = append(predicates, invoice.ItemsNotIn(i.ItemsNotIn...))
	}
	if i.ItemsGT != nil {
		predicates = append(predicates, invoice.ItemsGT(*i.ItemsGT))
	}
	if i.ItemsGTE != nil {
		predicates = append(predicates, invoice.ItemsGTE(*i.ItemsGTE))
	}
	if i.ItemsLT != nil {
		predicates = append(predicates, invoice.ItemsLT(*i.ItemsLT))
	}
	if i.ItemsLTE != nil {
		predicates = append(predicates, invoice.ItemsLTE(*i.ItemsLTE))
	}
	if i.ItemsContains != nil {
		predicates = append(predicates, invoice.ItemsContains(*i.ItemsContains))
	}
	if i.ItemsHasPrefix != nil {
		predicates = append(predicates, invoice.ItemsHasPrefix(*i.ItemsHasPrefix))
	}
	if i.ItemsHasSuffix != nil {
		predicates = append(predicates, invoice.ItemsHasSuffix(*i.ItemsHasSuffix))
	}
	if i.ItemsEqualFold != nil {
		predicates = append(predicates, invoice.ItemsEqualFold(*i.ItemsEqualFold))
	}
	if i.ItemsContainsFold != nil {
		predicates = append(predicates, invoice.ItemsContainsFold(*i.ItemsContainsFold))
	}
	if i.Subtotal != nil {
		predicates = append(predicates, invoice.SubtotalEQ(*i.Subtotal))
	}
	if i.SubtotalNEQ != nil {
		predicates = append(predicates, invoice.SubtotalNEQ(*i.SubtotalNEQ))
	}
	if len(i.SubtotalIn) > 0 {
		predicates = append(predicates, invoice.SubtotalIn(i.SubtotalIn...))
	}
	if len(i.SubtotalNotIn) > 0 {
		predicates = append(predicates, invoice.SubtotalNotIn(i.SubtotalNotIn...))
	}
	if i.SubtotalGT != nil {
		predicates = append(predicates, invoice.SubtotalGT(*i.SubtotalGT))
	}
	if i.SubtotalGTE != nil {
		predicates = append(predicates, invoice.SubtotalGTE(*i.SubtotalGTE))
	}
	if i.SubtotalLT != nil {
		predicates = append(predicates, invoice.SubtotalLT(*i.SubtotalLT))
	}
	if i.SubtotalLTE != nil {
		predicates = append(predicates, invoice.SubtotalLTE(*i.SubtotalLTE))
	}
	if i.Tax != nil {
		predicates = append(predicates, invoice.TaxEQ(*i.Tax))
	}
	if i.TaxNEQ != nil {
		predicates = append(predicates, invoice.TaxNEQ(*i.TaxNEQ))
	}
	if len(i.TaxIn) > 0 {
		predicates = append(predicates, invoice.TaxIn(i.TaxIn...))
	}
	if len(i.TaxNotIn) > 0 {
		predicates = append(predicates, invoice.TaxNotIn(i.TaxNotIn...))
	}
	if i.TaxGT != nil {
		predicates = append(predicates, invoice.TaxGT(*i.TaxGT))
	}
	if i.TaxGTE != nil {
		predicates = append(predicates, invoice.TaxGTE(*i.TaxGTE))
	}
	if i.TaxLT != nil {
		predicates = append(predicates, invoice.TaxLT(*i.TaxLT))
	}
	if i.TaxLTE != nil {
		predicates = append(predicates, invoice.TaxLTE(*i.TaxLTE))
	}
	if i.Total != nil {
		predicates = append(predicates, invoice.TotalEQ(*i.Total))
	}
	if i.TotalNEQ != nil {
		predicates = append(predicates, invoice.TotalNEQ(*i.TotalNEQ))
	}
	if len(i.TotalIn) > 0 {
		predicates = append(predicates, invoice.TotalIn(i.TotalIn...))
	}
	if len(i.TotalNotIn) > 0 {
		predicates = append(predicates, invoice.TotalNotIn(i.TotalNotIn...))
	}
	if i.TotalGT != nil {
		predicates = append(predicates, invoice.TotalGT(*i.TotalGT))
	}
	if i.TotalGTE != nil {
		predicates = append(predicates, invoice.TotalGTE(*i.TotalGTE))
	}
	if i.TotalLT != nil {
		predicates = append(predicates, invoice.TotalLT(*i.TotalLT))
	}
	if i.TotalLTE != nil {
		predicates = append(predicates, invoice.TotalLTE(*i.TotalLTE))
	}
	if i.Notes != nil {
		predicates = append(predicates, invoice.NotesEQ(*i.Notes))
	}
	if i.NotesNEQ != nil {
		predicates = append(predicates, invoice.NotesNEQ(*i.NotesNEQ))
	}
	if len(i.NotesIn) > 0 {
		predicates = append(predicates, invoice.NotesIn(i.NotesIn...))
	}
	if len(i.NotesNotIn) > 0 {
		predicates = append(predicates, invoice.NotesNotIn(i.NotesNotIn...))
	}
	if i.NotesGT != nil {
		predicates = append(predicates, invoice.NotesGT(*i.NotesGT))
	}
	if i.NotesGTE != nil {
		predicates = append(predicates, invoice.NotesGTE(*i.NotesGTE))
	}
	if i.NotesLT != nil {
		predicates = append(predicates, invoice.NotesLT(*i.NotesLT))
	}
	if i.NotesLTE != nil {
		predicates = append(predicates, invoice.NotesLTE(*i.NotesLTE))
	}
	if i.NotesContains != nil {
		predicates = append(predicates, invoice.NotesContains(*i.NotesContains))
	}
	if i.NotesHasPrefix != nil {
		predicates = append(predicates, invoice.NotesHasPrefix(*i.NotesHasPrefix))
	}
	if i.NotesHasSuffix != nil {
		predicates = append(predicates, invoice.NotesHasSuffix(*i.NotesHasSuffix))
	}
	if i.NotesIsNil {
		predicates = append(predicates, invoice.NotesIsNil())
	}
	if i.NotesNotNil {
		predicates = append(predicates, invoice.NotesNotNil())
	}
	if i.NotesEqualFold != nil {
		predicates = append(predicates, invoice.NotesEqualFold(*i.NotesEqualFold))
	}
	if i.NotesContainsFold != nil {
		predicates = append(predicates, invoice.NotesContainsFold(*i.NotesContainsFold))
	}
	if i.PaymentMethod != nil {
		predicates = append(predicates, invoice.PaymentMethodEQ(*i.PaymentMethod))
	}
	if i.PaymentMethodNEQ != nil {
		predicates = append(predicates, invoice.PaymentMethodNEQ(*i.PaymentMethodNEQ))
	}
	if len(i.PaymentMethodIn) > 0 {
		predicates = append(predicates, invoice.PaymentMethodIn(i.PaymentMethodIn...))
	}
	if len(i.PaymentMethodNotIn) > 0 {
		predicates = append(predicates, invoice.PaymentMethodNotIn(i.PaymentMethodNotIn...))
	}
	if i.PaymentMethodGT != nil {
		predicates = append(predicates, invoice.PaymentMethodGT(*i.PaymentMethodGT))
	}
	if i.PaymentMethodGTE != nil {
		predicates = append(predicates, invoice.PaymentMethodGTE(*i.PaymentMethodGTE))
	}
	if i.PaymentMethodLT != nil {
		predicates = append(predicates, invoice.PaymentMethodLT(*i.PaymentMethodLT))
	}
	if i.PaymentMethodLTE != nil {
		predicates = append(predicates, invoice.PaymentMethodLTE(*i.PaymentMethodLTE))
	}
	if i.PaymentMethodContains != nil {
		predicates = append(predicates, invoice.PaymentMethodContains(*i.PaymentMethodContains))
	}
	if i.PaymentMethodHasPrefix != nil {
		predicates = append(predicates, invoice.PaymentMethodHasPrefix(*i.PaymentMethodHasPrefix))
	}
	if i.PaymentMethodHasSuffix != nil {
		predicates = append(predicates, invoice.PaymentMethodHasSuffix(*i.PaymentMethodHasSuffix))
	}
	if i.PaymentMethodIsNil {
		predicates = append(predicates, invoice.PaymentMethodIsNil())
	}
	if i.PaymentMethodNotNil {
		predicates = append(predicates, invoice.PaymentMethodNotNil())
	}
	if i.PaymentMethodEqualFold != nil {
		predicates = append(predicates, invoice.PaymentMethodEqualFold(*i.PaymentMethodEqualFold))
	}
	if i.PaymentMethodContainsFold != nil {
		predicates = append(predicates, invoice.PaymentMethodContainsFold(*i.PaymentMethodContainsFold))
	}
	if i.BankName != nil {
		predicates = append(predicates, invoice.BankNameEQ(*i.BankName))
	}
	if i.BankNameNEQ != nil {
		predicates = append(predicates, invoice.BankNameNEQ(*i.BankNameNEQ))
	}
	if len(i.BankNameIn) > 0 {
		predicates = append(predicates, invoice.BankNameIn(i.BankNameIn...))
	}
	if len(i.BankNameNotIn) > 0 {
		predicates = append(predicates, invoice.BankNameNotIn(i.BankNameNotIn...))
	}
	if i.BankNameGT != nil {
		predicates = append(predicates, invoice.BankNameGT(*i.BankNameGT))
	}
	if i.BankNameGTE != nil {
		predicates = append(predicates, invoice.BankNameGTE(*i.BankNameGTE))
	}
	if i.BankNameLT != nil {
		predicates = append(predicates, invoice.BankNameLT(*i.BankNameLT))
	}
	if i.BankNameLTE != nil {
		predicates = append(predicates, invoice.BankNameLTE(*i.BankNameLTE))
	}
	if i.BankNameContains != nil {
		predicates = append(predicates, invoice.BankNameContains(*i.BankNameContains))
	}
	if i.BankNameHasPrefix != nil {
		predicates = append(predicates, invoice.BankNameHasPrefix(*i.BankNameHasPrefix))
	}
	if i.BankNameHasSuffix != nil {
		predicates = append(predicates, invoice.BankNameHasSuffix(*i.BankNameHasSuffix))
	}
	if i.BankNameIsNil {
		predicates = append(predicates, invoice.BankNameIsNil())
	}
	if i.BankNameNotNil {
		predicates = append(predicates, invoice.BankNameNotNil())
	}
	if i.BankNameEqualFold != nil {
		predicates = append(predicates, invoice.BankNameEqualFold(*i.BankNameEqualFold))
	}
	if i.BankNameContainsFold != nil {
		predicates = append(predicates, invoice.BankNameContainsFold(*i.BankNameContainsFold))
	}
	if i.BankAgency != nil {
		predicates = append(predicates, invoice.BankAgencyEQ(*i.BankAgency))
	}
	if i.BankAgencyNEQ != nil {
		predicates = append(predicates, invoice.BankAgencyNEQ(*i.BankAgencyNEQ))
	}
	if len(i.BankAgencyIn) > 0 {
		predicates = append(predicates, invoice.BankAgencyIn(i.BankAgencyIn...))
	}
	if len(i.BankAgencyNotIn) > 0 {
		predicates = append(predicates, invoice.BankAgencyNotIn(i.BankAgencyNotIn...))
	}
	if i.BankAgencyGT != nil {
		predicates = append(predicates, invoice.BankAgencyGT(*i.BankAgencyGT))
	}
	if i.BankAgencyGTE != nil {
		predicates = append(predicates, invoice.BankAgencyGTE(*i.BankAgencyGTE))
	}
	if i.BankAgencyLT != nil {
		predicates = append(predicates, invoice.BankAgencyLT(*i.BankAgencyLT))
	}
	if i.BankAgencyLTE != nil {
		predicates = append(predicates, invoice.BankAgencyLTE(*i.BankAgencyLTE))
	}
	if i.BankAgencyContains != nil {
		predicates = append(predicates, invoice.BankAgencyContains(*i.BankAgencyContains))
	}
	if i.BankAgencyHasPrefix != nil {
		predicates = append(predicates, invoice.BankAgencyHasPrefix(*i.BankAgencyHasPrefix))
	}
	if i.BankAgencyHasSuffix != nil {
		predicates = append(predicates, invoice.BankAgencyHasSuffix(*i.BankAgencyHasSuffix))
	}
	if i.BankAgencyIsNil {
		predicates = append(predicates, invoice.BankAgencyIsNil())
	}
	if i.BankAgencyNotNil {
		predicates = append(predicates, invoice.BankAgencyNotNil())
	}
	if i.BankAgencyEqualFold != nil {
		predicates = append(predicates, invoice.BankAgencyEqualFold(*i.BankAgencyEqualFold))
	}
	if i.BankAgencyContainsFold != nil {
		predicates = append(predicates, invoice.BankAgencyContainsFold(*i.BankAgencyContainsFold))
	}
	if i.BankAccountNumber != nil {
		predicates = append(predicates, invoice.BankAccountNumberEQ(*i.BankAccountNumber))
	}
	if i.BankAccountNumberNEQ != nil {
		predicates = append(predicates, invoice.BankAccountNumberNEQ(*i.BankAccountNumberNEQ))
	}
	if len(i.BankAccountNumberIn) > 0 {
		predicates = append(predicates, invoice.BankAccountNumberIn(i.BankAccountNumberIn...))
	}
	if len(i.BankAccountNumberNotIn) > 0 {
		predicates = append(predicates, invoice.BankAccountNumberNotIn(i.BankAccountNumberNotIn...))
	}
	if i.BankAccountNumberGT != nil {
		predicates = append(predicates, invoice.BankAccountNumberGT(*i.BankAccountNumberGT))
	}
	if i.BankAccountNumberGTE != nil {
		predicates = append(predicates, invoice.BankAccountNumberGTE(*i.BankAccountNumberGTE))
	}
	if i.BankAccountNumberLT != nil {
		predicates = append(predicates, invoice.BankAccountNumberLT(*i.BankAccountNumberLT))
	}
	if i.BankAccountNumberLTE != nil {
		predicates = append(predicates, invoice.BankAccountNumberLTE(*i.BankAccountNumberLTE))
	}
	if i.BankAccountNumberContains != nil {
		predicates = append(predicates, invoice.BankAccountNumberContains(*i.BankAccountNumberContains))
	}
	if i.BankAccountNumberHasPrefix != nil {
		predicates = append(predicates, invoice.BankAccountNumberHasPrefix(*i.BankAccountNumberHasPrefix))
	}
	if i.BankAccountNumberHasSuffix != nil {
		predicates = append(predicates, invoice.BankAccountNumberHasSuffix(*i.BankAccountNumberHasSuffix))
	}
	if i.BankAccountNumberIsNil {
		predicates = append(predicates, invoice.BankAccountNumberIsNil())
	}
	if i.BankAccountNumberNotNil {
		predicates = append(predicates, invoice.BankAccountNumberNotNil())
	}
	if i.BankAccountNumberEqualFold != nil {
		predicates = append(predicates, invoice.BankAccountNumberEqualFold(*i.BankAccountNumberEqualFold))
	}
	if i.BankAccountNumberContainsFold != nil {
		predicates = append(predicates, invoice.BankAccountNumberContainsFold(*i.BankAccountNumberContainsFold))
	}
	if i.BankAccountName != nil {
		predicates = append(predicates, invoice.BankAccountNameEQ(*i.BankAccountName))
	}
	if i.BankAccountNameNEQ != nil {
		predicates = append(predicates, invoice.BankAccountNameNEQ(*i.BankAccountNameNEQ))
	}
	if len(i.BankAccountNameIn) > 0 {
		predicates = append(predicates, invoice.BankAccountNameIn(i.BankAccountNameIn...))
	}
	if len(i.BankAccountNameNotIn) > 0 {
		predicates = append(predicates, invoice.BankAccountNameNotIn(i.BankAccountNameNotIn...))
	}
	if i.BankAccountNameGT != nil {
		predicates = append(predicates, invoice.BankAccountNameGT(*i.BankAccountNameGT))
	}
	if i.BankAccountNameGTE != nil {
		predicates = append(predicates, invoice.BankAccountNameGTE(*i.BankAccountNameGTE))
	}
	if i.BankAccountNameLT != nil {
		predicates = append(predicates, invoice.BankAccountNameLT(*i.BankAccountNameLT))
	}
	if i.BankAccountNameLTE != nil {
		predicates = append(predicates, invoice.BankAccountNameLTE(*i.BankAccountNameLTE))
	}
	if i.BankAccountNameContains != nil {
		predicates = append(predicates, invoice.BankAccountNameContains(*i.BankAccountNameContains))
	}
	if i.BankAccountNameHasPrefix != nil {
		predicates = append(predicates, invoice.BankAccountNameHasPrefix(*i.BankAccountNameHasPrefix))
	}
	if i.BankAccountNameHasSuffix != nil {
		predicates = append(predicates, invoice.BankAccountNameHasSuffix(*i.BankAccountNameHasSuffix))
	}
	if i.BankAccountNameIsNil {
		predicates = append(predicates, invoice.BankAccountNameIsNil())
	}
	if i.BankAccountNameNotNil {
		predicates = append(predicates, invoice.BankAccountNameNotNil())
	}
	if i.BankAccountNameEqualFold != nil {
		predicates = append(predicates, invoice.BankAccountNameEqualFold(*i.BankAccountNameEqualFold))
	}
	if i.BankAccountNameContainsFold != nil {
		predicates = append(predicates, invoice.BankAccountNameContainsFold(*i.BankAccountNameContainsFold))
	}
	if i.StorageURI != nil {
		predicates = append(predicates, invoice.StorageURIEQ(*i.StorageURI))
	}
	if i.StorageURINEQ != nil {
		predicates = append(predicates, invoice.StorageURINEQ(*i.StorageURINEQ))
	}
	if len(i.StorageURIIn) > 0 {
		predicates = append(predicates, invoice.StorageURIIn(i.StorageURIIn...))
	}
	if len(i.StorageURINotIn) > 0 {
		predicates = append(predicates, invoice.StorageURINotIn(i.StorageURINotIn...))
	}
	if i.StorageURIGT != nil {
		predicates = append(predicates, invoice.StorageURIGT(*i.StorageURIGT))
	}
	if i.StorageURIGTE != nil {
		predicates = append(predicates, invoice.StorageURIGTE(*i.StorageURIGTE))
	}
	if i.StorageURILT != nil {
		predicates = append(predicates, invoice.StorageURILT(*i.StorageURILT))
	}
	if i.StorageURILTE != nil {
		predicates = append(predicates, invoice.StorageURILTE(*i.StorageURILTE))
	}
	if i.StorageURIContains != nil {
		predicates = append(predicates, invoice.StorageURIContains(*i.StorageURIContains))
	}
	if i.StorageURIHasPrefix != nil {
		predicates = append(predicates, invoice.StorageURIHasPrefix(*i.StorageURIHasPrefix))
	}
	if i.StorageURIHasSuffix != nil {
		predicates = append(predicates, invoice.StorageURIHasSuffix(*i.StorageURIHasSuffix))
	}
	if i.StorageURIIsNil {
		predicates = append(predicates, invoice.StorageURIIsNil())
	}
	if i.StorageURINotNil {
		predicates = append(predicates, invoice.StorageURINotNil())
	}
	if i.StorageURIEqualFold != nil {
		predicates = append(predicates, invoice.StorageURIEqualFold(*i.StorageURIEqualFold))
	}
	if i.StorageURIContainsFold != nil {
		predicates = append(predicates, invoice.StorageURIContainsFold(*i.StorageURIContainsFold))
	}
	if i.URL != nil {
		predicates = append(predicates, invoice.URLEQ(*i.URL))
	}
	if i.URLNEQ != nil {
		predicates = append(predicates, invoice.URLNEQ(*i.URLNEQ))
	}
	if len(i.URLIn) > 0 {
		predicates = append(predicates, invoice.URLIn(i.URLIn...))
	}
	if len(i.URLNotIn) > 0 {
		predicates = append(predicates, invoice.URLNotIn(i.URLNotIn...))
	}
	if i.URLGT != nil {
		predicates = append(predicates, invoice.URLGT(*i.URLGT))
	}
	if i.URLGTE != nil {
		predicates = append(predicates, invoice.URLGTE(*i.URLGTE))
	}
	if i.URLLT != nil {
		predicates = append(predicates, invoice.URLLT(*i.URLLT))
	}
	if i.URLLTE != nil {
		predicates = append(predicates, invoice.URLLTE(*i.URLLTE))
	}
	if i.URLContains != nil {
		predicates = append(predicates, invoice.URLContains(*i.URLContains))
	}
	if i.URLHasPrefix != nil {
		predicates = append(predicates, invoice.URLHasPrefix(*i.URLHasPrefix))
	}
	if i.URLHasSuffix != nil {
		predicates = append(predicates, invoice.URLHasSuffix(*i.URLHasSuffix))
	}
	if i.URLIsNil {
		predicates = append(predicates, invoice.URLIsNil())
	}
	if i.URLNotNil {
		predicates = append(predicates, invoice.URLNotNil())
	}
	if i.URLEqualFold != nil {
		predicates = append(predicates, invoice.URLEqualFold(*i.URLEqualFold))
	}
	if i.URLContainsFold != nil {
		predicates = append(predicates, invoice.URLContainsFold(*i.URLContainsFold))
	}
	if i.Filename != nil {
		predicates = append(predicates, invoice.FilenameEQ(*i.Filename))
	}
	if i.FilenameNEQ != nil {
		predicates = append(predicates, invoice.FilenameNEQ(*i.FilenameNEQ))
	}
	if len(i.FilenameIn) > 0 {
		predicates = append(predicates, invoice.FilenameIn(i.FilenameIn...))
	}
	if len(i.FilenameNotIn) > 0 {
		predicates = append(predicates, invoice.FilenameNotIn(i.FilenameNotIn...))
	}
	if i.FilenameGT != nil {
		predicates = append(predicates, invoice.FilenameGT(*i.FilenameGT))
	}
	if i.FilenameGTE != nil {
		predicates = append(predicates, invoice.FilenameGTE(*i.FilenameGTE))
	}
	if i.FilenameLT != nil {
		predicates = append(predicates, invoice.FilenameLT(*i.FilenameLT))
	}
	if i.FilenameLTE != nil {
		predicates = append(predicates, invoice.FilenameLTE(*i.FilenameLTE))
	}
	if i.FilenameContains != nil {
		predicates = append(predicates, invoice.FilenameContains(*i.FilenameContains))
	}
	if i.FilenameHasPrefix != nil {
		predicates = append(predicates, invoice.FilenameHasPrefix(*i.FilenameHasPrefix))
	}
	if i.FilenameHasSuffix != nil {
		predicates = append(predicates, invoice.FilenameHasSuffix(*i.FilenameHasSuffix))
	}
	if i.FilenameIsNil {
		predicates = append(predicates, invoice.FilenameIsNil())
	}
	if i.FilenameNotNil {
		predicates = append(predicates, invoice.FilenameNotNil())
	}
	if i.FilenameEqualFold != nil {
		predicates = append(predicates, invoice.FilenameEqualFold(*i.FilenameEqualFold))
	}
	if i.FilenameContainsFold != nil {
		predicates = append(predicates, invoice.FilenameContainsFold(*i.FilenameContainsFold))
	}
	if i.Size != nil {
		predicates = append(predicates, invoice.SizeEQ(*i.Size))
	}
	if i.SizeNEQ != nil {
		predicates = append(predicates, invoice.SizeNEQ(*i.SizeNEQ))
	}
	if len(i.SizeIn) > 0 {
		predicates = append(predicates, invoice.SizeIn(i.SizeIn...))
	}
	if len(i.SizeNotIn) > 0 {
		predicates = append(predicates, invoice.SizeNotIn(i.SizeNotIn...))
	}
	if i.SizeGT != nil {
		predicates = append(predicates, invoice.SizeGT(*i.SizeGT))
	}
	if i.SizeGTE != nil {
		predicates = append(predicates, invoice.SizeGTE(*i.SizeGTE))
	}
	if i.SizeLT != nil {
		predicates = append(predicates, invoice.SizeLT(*i.SizeLT))
	}
	if i.SizeLTE != nil {
		predicates = append(predicates, invoice.SizeLTE(*i.SizeLTE))
	}
	if i.SizeIsNil {
		predicates = append(predicates, invoice.SizeIsNil())
	}
	if i.SizeNotNil {
		predicates = append(predicates, invoice.SizeNotNil())
	}
	if i.Keywords != nil {
		predicates = append(predicates, invoice.KeywordsEQ(*i.Keywords))
	}
	if i.KeywordsNEQ != nil {
		predicates = append(predicates, invoice.KeywordsNEQ(*i.KeywordsNEQ))
	}
	if len(i.KeywordsIn) > 0 {
		predicates = append(predicates, invoice.KeywordsIn(i.KeywordsIn...))
	}
	if len(i.KeywordsNotIn) > 0 {
		predicates = append(predicates, invoice.KeywordsNotIn(i.KeywordsNotIn...))
	}
	if i.KeywordsGT != nil {
		predicates = append(predicates, invoice.KeywordsGT(*i.KeywordsGT))
	}
	if i.KeywordsGTE != nil {
		predicates = append(predicates, invoice.KeywordsGTE(*i.KeywordsGTE))
	}
	if i.KeywordsLT != nil {
		predicates = append(predicates, invoice.KeywordsLT(*i.KeywordsLT))
	}
	if i.KeywordsLTE != nil {
		predicates = append(predicates, invoice.KeywordsLTE(*i.KeywordsLTE))
	}
	if i.KeywordsContains != nil {
		predicates = append(predicates, invoice.KeywordsContains(*i.KeywordsContains))
	}
	if i.KeywordsHasPrefix != nil {
		predicates = append(predicates, invoice.KeywordsHasPrefix(*i.KeywordsHasPrefix))
	}
	if i.KeywordsHasSuffix != nil {
		predicates = append(predicates, invoice.KeywordsHasSuffix(*i.KeywordsHasSuffix))
	}
	if i.KeywordsEqualFold != nil {
		predicates = append(predicates, invoice.KeywordsEqualFold(*i.KeywordsEqualFold))
	}
	if i.KeywordsContainsFold != nil {
		predicates = append(predicates, invoice.KeywordsContainsFold(*i.KeywordsContainsFold))
	}

	if i.HasCompany != nil {
		p := invoice.HasCompany()
		if !*i.HasCompany {
			p = invoice.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasCompanyWith) > 0 {
		with := make([]predicate.Company, 0, len(i.HasCompanyWith))
		for _, w := range i.HasCompanyWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasCompanyWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, invoice.HasCompanyWith(with...))
	}
	if i.HasIssuedBy != nil {
		p := invoice.HasIssuedBy()
		if !*i.HasIssuedBy {
			p = invoice.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasIssuedByWith) > 0 {
		with := make([]predicate.User, 0, len(i.HasIssuedByWith))
		for _, w := range i.HasIssuedByWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasIssuedByWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, invoice.HasIssuedByWith(with...))
	}
	if i.HasClient != nil {
		p := invoice.HasClient()
		if !*i.HasClient {
			p = invoice.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasClientWith) > 0 {
		with := make([]predicate.Customer, 0, len(i.HasClientWith))
		for _, w := range i.HasClientWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasClientWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, invoice.HasClientWith(with...))
	}
	if i.HasReceivable != nil {
		p := invoice.HasReceivable()
		if !*i.HasReceivable {
			p = invoice.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasReceivableWith) > 0 {
		with := make([]predicate.Receivable, 0, len(i.HasReceivableWith))
		for _, w := range i.HasReceivableWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasReceivableWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, invoice.HasReceivableWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyInvoiceWhereInput
	case 1:
		return predicates[0], nil
	default:
		return invoice.And(predicates...), nil
	}
}

// LoanWhereInput represents a where input for filtering Loan queries.
type LoanWhereInput struct {
	Predicates []predicate.Loan  `json:"-"`
	Not        *LoanWhereInput   `json:"not,omitempty"`
	Or         []*LoanWhereInput `json:"or,omitempty"`
	And        []*LoanWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "createdAt" field predicates.
	CreatedAt      *time.Time  `json:"createdat,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdatNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdatIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdatNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdatGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdatGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdatLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdatLTE,omitempty"`

	// "updatedAt" field predicates.
	UpdatedAt      *time.Time  `json:"updatedat,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedatNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedatIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedatNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedatGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedatGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedatLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedatLTE,omitempty"`

	// "deletedAt" field predicates.
	DeletedAt       *time.Time  `json:"deletedat,omitempty"`
	DeletedAtNEQ    *time.Time  `json:"deletedatNEQ,omitempty"`
	DeletedAtIn     []time.Time `json:"deletedatIn,omitempty"`
	DeletedAtNotIn  []time.Time `json:"deletedatNotIn,omitempty"`
	DeletedAtGT     *time.Time  `json:"deletedatGT,omitempty"`
	DeletedAtGTE    *time.Time  `json:"deletedatGTE,omitempty"`
	DeletedAtLT     *time.Time  `json:"deletedatLT,omitempty"`
	DeletedAtLTE    *time.Time  `json:"deletedatLTE,omitempty"`
	DeletedAtIsNil  bool        `json:"deletedatIsNil,omitempty"`
	DeletedAtNotNil bool        `json:"deletedatNotNil,omitempty"`

	// "amount" field predicates.
	Amount      *float64  `json:"amount,omitempty"`
	AmountNEQ   *float64  `json:"amountNEQ,omitempty"`
	AmountIn    []float64 `json:"amountIn,omitempty"`
	AmountNotIn []float64 `json:"amountNotIn,omitempty"`
	AmountGT    *float64  `json:"amountGT,omitempty"`
	AmountGTE   *float64  `json:"amountGTE,omitempty"`
	AmountLT    *float64  `json:"amountLT,omitempty"`
	AmountLTE   *float64  `json:"amountLTE,omitempty"`

	// "category" field predicates.
	Category      *loan.Category  `json:"category,omitempty"`
	CategoryNEQ   *loan.Category  `json:"categoryNEQ,omitempty"`
	CategoryIn    []loan.Category `json:"categoryIn,omitempty"`
	CategoryNotIn []loan.Category `json:"categoryNotIn,omitempty"`

	// "collateral" field predicates.
	Collateral             *string  `json:"collateral,omitempty"`
	CollateralNEQ          *string  `json:"collateralNEQ,omitempty"`
	CollateralIn           []string `json:"collateralIn,omitempty"`
	CollateralNotIn        []string `json:"collateralNotIn,omitempty"`
	CollateralGT           *string  `json:"collateralGT,omitempty"`
	CollateralGTE          *string  `json:"collateralGTE,omitempty"`
	CollateralLT           *string  `json:"collateralLT,omitempty"`
	CollateralLTE          *string  `json:"collateralLTE,omitempty"`
	CollateralContains     *string  `json:"collateralContains,omitempty"`
	CollateralHasPrefix    *string  `json:"collateralHasPrefix,omitempty"`
	CollateralHasSuffix    *string  `json:"collateralHasSuffix,omitempty"`
	CollateralIsNil        bool     `json:"collateralIsNil,omitempty"`
	CollateralNotNil       bool     `json:"collateralNotNil,omitempty"`
	CollateralEqualFold    *string  `json:"collateralEqualFold,omitempty"`
	CollateralContainsFold *string  `json:"collateralContainsFold,omitempty"`

	// "description" field predicates.
	Description             *string  `json:"description,omitempty"`
	DescriptionNEQ          *string  `json:"descriptionNEQ,omitempty"`
	DescriptionIn           []string `json:"descriptionIn,omitempty"`
	DescriptionNotIn        []string `json:"descriptionNotIn,omitempty"`
	DescriptionGT           *string  `json:"descriptionGT,omitempty"`
	DescriptionGTE          *string  `json:"descriptionGTE,omitempty"`
	DescriptionLT           *string  `json:"descriptionLT,omitempty"`
	DescriptionLTE          *string  `json:"descriptionLTE,omitempty"`
	DescriptionContains     *string  `json:"descriptionContains,omitempty"`
	DescriptionHasPrefix    *string  `json:"descriptionHasPrefix,omitempty"`
	DescriptionHasSuffix    *string  `json:"descriptionHasSuffix,omitempty"`
	DescriptionIsNil        bool     `json:"descriptionIsNil,omitempty"`
	DescriptionNotNil       bool     `json:"descriptionNotNil,omitempty"`
	DescriptionEqualFold    *string  `json:"descriptionEqualFold,omitempty"`
	DescriptionContainsFold *string  `json:"descriptionContainsFold,omitempty"`

	// "interestRate" field predicates.
	InterestRate      *float64  `json:"interestrate,omitempty"`
	InterestRateNEQ   *float64  `json:"interestrateNEQ,omitempty"`
	InterestRateIn    []float64 `json:"interestrateIn,omitempty"`
	InterestRateNotIn []float64 `json:"interestrateNotIn,omitempty"`
	InterestRateGT    *float64  `json:"interestrateGT,omitempty"`
	InterestRateGTE   *float64  `json:"interestrateGTE,omitempty"`
	InterestRateLT    *float64  `json:"interestrateLT,omitempty"`
	InterestRateLTE   *float64  `json:"interestrateLTE,omitempty"`

	// "installments" field predicates.
	Installments      *int  `json:"installments,omitempty"`
	InstallmentsNEQ   *int  `json:"installmentsNEQ,omitempty"`
	InstallmentsIn    []int `json:"installmentsIn,omitempty"`
	InstallmentsNotIn []int `json:"installmentsNotIn,omitempty"`
	InstallmentsGT    *int  `json:"installmentsGT,omitempty"`
	InstallmentsGTE   *int  `json:"installmentsGTE,omitempty"`
	InstallmentsLT    *int  `json:"installmentsLT,omitempty"`
	InstallmentsLTE   *int  `json:"installmentsLTE,omitempty"`

	// "maturityDate" field predicates.
	MaturityDate      *time.Time  `json:"maturitydate,omitempty"`
	MaturityDateNEQ   *time.Time  `json:"maturitydateNEQ,omitempty"`
	MaturityDateIn    []time.Time `json:"maturitydateIn,omitempty"`
	MaturityDateNotIn []time.Time `json:"maturitydateNotIn,omitempty"`
	MaturityDateGT    *time.Time  `json:"maturitydateGT,omitempty"`
	MaturityDateGTE   *time.Time  `json:"maturitydateGTE,omitempty"`
	MaturityDateLT    *time.Time  `json:"maturitydateLT,omitempty"`
	MaturityDateLTE   *time.Time  `json:"maturitydateLTE,omitempty"`

	// "nextPayment" field predicates.
	NextPayment       *time.Time  `json:"nextpayment,omitempty"`
	NextPaymentNEQ    *time.Time  `json:"nextpaymentNEQ,omitempty"`
	NextPaymentIn     []time.Time `json:"nextpaymentIn,omitempty"`
	NextPaymentNotIn  []time.Time `json:"nextpaymentNotIn,omitempty"`
	NextPaymentGT     *time.Time  `json:"nextpaymentGT,omitempty"`
	NextPaymentGTE    *time.Time  `json:"nextpaymentGTE,omitempty"`
	NextPaymentLT     *time.Time  `json:"nextpaymentLT,omitempty"`
	NextPaymentLTE    *time.Time  `json:"nextpaymentLTE,omitempty"`
	NextPaymentIsNil  bool        `json:"nextpaymentIsNil,omitempty"`
	NextPaymentNotNil bool        `json:"nextpaymentNotNil,omitempty"`

	// "nextPaymentAmount" field predicates.
	NextPaymentAmount       *float64  `json:"nextpaymentamount,omitempty"`
	NextPaymentAmountNEQ    *float64  `json:"nextpaymentamountNEQ,omitempty"`
	NextPaymentAmountIn     []float64 `json:"nextpaymentamountIn,omitempty"`
	NextPaymentAmountNotIn  []float64 `json:"nextpaymentamountNotIn,omitempty"`
	NextPaymentAmountGT     *float64  `json:"nextpaymentamountGT,omitempty"`
	NextPaymentAmountGTE    *float64  `json:"nextpaymentamountGTE,omitempty"`
	NextPaymentAmountLT     *float64  `json:"nextpaymentamountLT,omitempty"`
	NextPaymentAmountLTE    *float64  `json:"nextpaymentamountLTE,omitempty"`
	NextPaymentAmountIsNil  bool      `json:"nextpaymentamountIsNil,omitempty"`
	NextPaymentAmountNotNil bool      `json:"nextpaymentamountNotNil,omitempty"`

	// "outstandingBalance" field predicates.
	OutstandingBalance      *float64  `json:"outstandingbalance,omitempty"`
	OutstandingBalanceNEQ   *float64  `json:"outstandingbalanceNEQ,omitempty"`
	OutstandingBalanceIn    []float64 `json:"outstandingbalanceIn,omitempty"`
	OutstandingBalanceNotIn []float64 `json:"outstandingbalanceNotIn,omitempty"`
	OutstandingBalanceGT    *float64  `json:"outstandingbalanceGT,omitempty"`
	OutstandingBalanceGTE   *float64  `json:"outstandingbalanceGTE,omitempty"`
	OutstandingBalanceLT    *float64  `json:"outstandingbalanceLT,omitempty"`
	OutstandingBalanceLTE   *float64  `json:"outstandingbalanceLTE,omitempty"`

	// "paymentFrequency" field predicates.
	PaymentFrequency      *loan.PaymentFrequency  `json:"paymentfrequency,omitempty"`
	PaymentFrequencyNEQ   *loan.PaymentFrequency  `json:"paymentfrequencyNEQ,omitempty"`
	PaymentFrequencyIn    []loan.PaymentFrequency `json:"paymentfrequencyIn,omitempty"`
	PaymentFrequencyNotIn []loan.PaymentFrequency `json:"paymentfrequencyNotIn,omitempty"`

	// "paidInstallments" field predicates.
	PaidInstallments      *int  `json:"paidinstallments,omitempty"`
	PaidInstallmentsNEQ   *int  `json:"paidinstallmentsNEQ,omitempty"`
	PaidInstallmentsIn    []int `json:"paidinstallmentsIn,omitempty"`
	PaidInstallmentsNotIn []int `json:"paidinstallmentsNotIn,omitempty"`
	PaidInstallmentsGT    *int  `json:"paidinstallmentsGT,omitempty"`
	PaidInstallmentsGTE   *int  `json:"paidinstallmentsGTE,omitempty"`
	PaidInstallmentsLT    *int  `json:"paidinstallmentsLT,omitempty"`
	PaidInstallmentsLTE   *int  `json:"paidinstallmentsLTE,omitempty"`

	// "provider" field predicates.
	Provider             *string  `json:"provider,omitempty"`
	ProviderNEQ          *string  `json:"providerNEQ,omitempty"`
	ProviderIn           []string `json:"providerIn,omitempty"`
	ProviderNotIn        []string `json:"providerNotIn,omitempty"`
	ProviderGT           *string  `json:"providerGT,omitempty"`
	ProviderGTE          *string  `json:"providerGTE,omitempty"`
	ProviderLT           *string  `json:"providerLT,omitempty"`
	ProviderLTE          *string  `json:"providerLTE,omitempty"`
	ProviderContains     *string  `json:"providerContains,omitempty"`
	ProviderHasPrefix    *string  `json:"providerHasPrefix,omitempty"`
	ProviderHasSuffix    *string  `json:"providerHasSuffix,omitempty"`
	ProviderEqualFold    *string  `json:"providerEqualFold,omitempty"`
	ProviderContainsFold *string  `json:"providerContainsFold,omitempty"`

	// "startDate" field predicates.
	StartDate      *time.Time  `json:"startdate,omitempty"`
	StartDateNEQ   *time.Time  `json:"startdateNEQ,omitempty"`
	StartDateIn    []time.Time `json:"startdateIn,omitempty"`
	StartDateNotIn []time.Time `json:"startdateNotIn,omitempty"`
	StartDateGT    *time.Time  `json:"startdateGT,omitempty"`
	StartDateGTE   *time.Time  `json:"startdateGTE,omitempty"`
	StartDateLT    *time.Time  `json:"startdateLT,omitempty"`
	StartDateLTE   *time.Time  `json:"startdateLTE,omitempty"`

	// "status" field predicates.
	Status      *loan.Status  `json:"status,omitempty"`
	StatusNEQ   *loan.Status  `json:"statusNEQ,omitempty"`
	StatusIn    []loan.Status `json:"statusIn,omitempty"`
	StatusNotIn []loan.Status `json:"statusNotIn,omitempty"`

	// "company" edge predicates.
	HasCompany     *bool                `json:"hasCompany,omitempty"`
	HasCompanyWith []*CompanyWhereInput `json:"hasCompanyWith,omitempty"`

	// "transactionHistory" edge predicates.
	HasTransactionHistory     *bool                        `json:"hasTransactionHistory,omitempty"`
	HasTransactionHistoryWith []*AccountingEntryWhereInput `json:"hasTransactionHistoryWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *LoanWhereInput) AddPredicates(predicates ...predicate.Loan) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the LoanWhereInput filter on the LoanQuery builder.
func (i *LoanWhereInput) Filter(q *LoanQuery) (*LoanQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyLoanWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyLoanWhereInput is returned in case the LoanWhereInput is empty.
var ErrEmptyLoanWhereInput = errors.New("generated: empty predicate LoanWhereInput")

// P returns a predicate for filtering loans.
// An error is returned if the input is empty or invalid.
func (i *LoanWhereInput) P() (predicate.Loan, error) {
	var predicates []predicate.Loan
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, loan.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Loan, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, loan.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Loan, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, loan.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, loan.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, loan.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, loan.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, loan.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, loan.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, loan.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, loan.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, loan.IDLTE(*i.IDLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, loan.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, loan.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, loan.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, loan.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, loan.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, loan.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, loan.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, loan.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, loan.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, loan.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, loan.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, loan.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, loan.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, loan.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, loan.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, loan.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.DeletedAt != nil {
		predicates = append(predicates, loan.DeletedAtEQ(*i.DeletedAt))
	}
	if i.DeletedAtNEQ != nil {
		predicates = append(predicates, loan.DeletedAtNEQ(*i.DeletedAtNEQ))
	}
	if len(i.DeletedAtIn) > 0 {
		predicates = append(predicates, loan.DeletedAtIn(i.DeletedAtIn...))
	}
	if len(i.DeletedAtNotIn) > 0 {
		predicates = append(predicates, loan.DeletedAtNotIn(i.DeletedAtNotIn...))
	}
	if i.DeletedAtGT != nil {
		predicates = append(predicates, loan.DeletedAtGT(*i.DeletedAtGT))
	}
	if i.DeletedAtGTE != nil {
		predicates = append(predicates, loan.DeletedAtGTE(*i.DeletedAtGTE))
	}
	if i.DeletedAtLT != nil {
		predicates = append(predicates, loan.DeletedAtLT(*i.DeletedAtLT))
	}
	if i.DeletedAtLTE != nil {
		predicates = append(predicates, loan.DeletedAtLTE(*i.DeletedAtLTE))
	}
	if i.DeletedAtIsNil {
		predicates = append(predicates, loan.DeletedAtIsNil())
	}
	if i.DeletedAtNotNil {
		predicates = append(predicates, loan.DeletedAtNotNil())
	}
	if i.Amount != nil {
		predicates = append(predicates, loan.AmountEQ(*i.Amount))
	}
	if i.AmountNEQ != nil {
		predicates = append(predicates, loan.AmountNEQ(*i.AmountNEQ))
	}
	if len(i.AmountIn) > 0 {
		predicates = append(predicates, loan.AmountIn(i.AmountIn...))
	}
	if len(i.AmountNotIn) > 0 {
		predicates = append(predicates, loan.AmountNotIn(i.AmountNotIn...))
	}
	if i.AmountGT != nil {
		predicates = append(predicates, loan.AmountGT(*i.AmountGT))
	}
	if i.AmountGTE != nil {
		predicates = append(predicates, loan.AmountGTE(*i.AmountGTE))
	}
	if i.AmountLT != nil {
		predicates = append(predicates, loan.AmountLT(*i.AmountLT))
	}
	if i.AmountLTE != nil {
		predicates = append(predicates, loan.AmountLTE(*i.AmountLTE))
	}
	if i.Category != nil {
		predicates = append(predicates, loan.CategoryEQ(*i.Category))
	}
	if i.CategoryNEQ != nil {
		predicates = append(predicates, loan.CategoryNEQ(*i.CategoryNEQ))
	}
	if len(i.CategoryIn) > 0 {
		predicates = append(predicates, loan.CategoryIn(i.CategoryIn...))
	}
	if len(i.CategoryNotIn) > 0 {
		predicates = append(predicates, loan.CategoryNotIn(i.CategoryNotIn...))
	}
	if i.Collateral != nil {
		predicates = append(predicates, loan.CollateralEQ(*i.Collateral))
	}
	if i.CollateralNEQ != nil {
		predicates = append(predicates, loan.CollateralNEQ(*i.CollateralNEQ))
	}
	if len(i.CollateralIn) > 0 {
		predicates = append(predicates, loan.CollateralIn(i.CollateralIn...))
	}
	if len(i.CollateralNotIn) > 0 {
		predicates = append(predicates, loan.CollateralNotIn(i.CollateralNotIn...))
	}
	if i.CollateralGT != nil {
		predicates = append(predicates, loan.CollateralGT(*i.CollateralGT))
	}
	if i.CollateralGTE != nil {
		predicates = append(predicates, loan.CollateralGTE(*i.CollateralGTE))
	}
	if i.CollateralLT != nil {
		predicates = append(predicates, loan.CollateralLT(*i.CollateralLT))
	}
	if i.CollateralLTE != nil {
		predicates = append(predicates, loan.CollateralLTE(*i.CollateralLTE))
	}
	if i.CollateralContains != nil {
		predicates = append(predicates, loan.CollateralContains(*i.CollateralContains))
	}
	if i.CollateralHasPrefix != nil {
		predicates = append(predicates, loan.CollateralHasPrefix(*i.CollateralHasPrefix))
	}
	if i.CollateralHasSuffix != nil {
		predicates = append(predicates, loan.CollateralHasSuffix(*i.CollateralHasSuffix))
	}
	if i.CollateralIsNil {
		predicates = append(predicates, loan.CollateralIsNil())
	}
	if i.CollateralNotNil {
		predicates = append(predicates, loan.CollateralNotNil())
	}
	if i.CollateralEqualFold != nil {
		predicates = append(predicates, loan.CollateralEqualFold(*i.CollateralEqualFold))
	}
	if i.CollateralContainsFold != nil {
		predicates = append(predicates, loan.CollateralContainsFold(*i.CollateralContainsFold))
	}
	if i.Description != nil {
		predicates = append(predicates, loan.DescriptionEQ(*i.Description))
	}
	if i.DescriptionNEQ != nil {
		predicates = append(predicates, loan.DescriptionNEQ(*i.DescriptionNEQ))
	}
	if len(i.DescriptionIn) > 0 {
		predicates = append(predicates, loan.DescriptionIn(i.DescriptionIn...))
	}
	if len(i.DescriptionNotIn) > 0 {
		predicates = append(predicates, loan.DescriptionNotIn(i.DescriptionNotIn...))
	}
	if i.DescriptionGT != nil {
		predicates = append(predicates, loan.DescriptionGT(*i.DescriptionGT))
	}
	if i.DescriptionGTE != nil {
		predicates = append(predicates, loan.DescriptionGTE(*i.DescriptionGTE))
	}
	if i.DescriptionLT != nil {
		predicates = append(predicates, loan.DescriptionLT(*i.DescriptionLT))
	}
	if i.DescriptionLTE != nil {
		predicates = append(predicates, loan.DescriptionLTE(*i.DescriptionLTE))
	}
	if i.DescriptionContains != nil {
		predicates = append(predicates, loan.DescriptionContains(*i.DescriptionContains))
	}
	if i.DescriptionHasPrefix != nil {
		predicates = append(predicates, loan.DescriptionHasPrefix(*i.DescriptionHasPrefix))
	}
	if i.DescriptionHasSuffix != nil {
		predicates = append(predicates, loan.DescriptionHasSuffix(*i.DescriptionHasSuffix))
	}
	if i.DescriptionIsNil {
		predicates = append(predicates, loan.DescriptionIsNil())
	}
	if i.DescriptionNotNil {
		predicates = append(predicates, loan.DescriptionNotNil())
	}
	if i.DescriptionEqualFold != nil {
		predicates = append(predicates, loan.DescriptionEqualFold(*i.DescriptionEqualFold))
	}
	if i.DescriptionContainsFold != nil {
		predicates = append(predicates, loan.DescriptionContainsFold(*i.DescriptionContainsFold))
	}
	if i.InterestRate != nil {
		predicates = append(predicates, loan.InterestRateEQ(*i.InterestRate))
	}
	if i.InterestRateNEQ != nil {
		predicates = append(predicates, loan.InterestRateNEQ(*i.InterestRateNEQ))
	}
	if len(i.InterestRateIn) > 0 {
		predicates = append(predicates, loan.InterestRateIn(i.InterestRateIn...))
	}
	if len(i.InterestRateNotIn) > 0 {
		predicates = append(predicates, loan.InterestRateNotIn(i.InterestRateNotIn...))
	}
	if i.InterestRateGT != nil {
		predicates = append(predicates, loan.InterestRateGT(*i.InterestRateGT))
	}
	if i.InterestRateGTE != nil {
		predicates = append(predicates, loan.InterestRateGTE(*i.InterestRateGTE))
	}
	if i.InterestRateLT != nil {
		predicates = append(predicates, loan.InterestRateLT(*i.InterestRateLT))
	}
	if i.InterestRateLTE != nil {
		predicates = append(predicates, loan.InterestRateLTE(*i.InterestRateLTE))
	}
	if i.Installments != nil {
		predicates = append(predicates, loan.InstallmentsEQ(*i.Installments))
	}
	if i.InstallmentsNEQ != nil {
		predicates = append(predicates, loan.InstallmentsNEQ(*i.InstallmentsNEQ))
	}
	if len(i.InstallmentsIn) > 0 {
		predicates = append(predicates, loan.InstallmentsIn(i.InstallmentsIn...))
	}
	if len(i.InstallmentsNotIn) > 0 {
		predicates = append(predicates, loan.InstallmentsNotIn(i.InstallmentsNotIn...))
	}
	if i.InstallmentsGT != nil {
		predicates = append(predicates, loan.InstallmentsGT(*i.InstallmentsGT))
	}
	if i.InstallmentsGTE != nil {
		predicates = append(predicates, loan.InstallmentsGTE(*i.InstallmentsGTE))
	}
	if i.InstallmentsLT != nil {
		predicates = append(predicates, loan.InstallmentsLT(*i.InstallmentsLT))
	}
	if i.InstallmentsLTE != nil {
		predicates = append(predicates, loan.InstallmentsLTE(*i.InstallmentsLTE))
	}
	if i.MaturityDate != nil {
		predicates = append(predicates, loan.MaturityDateEQ(*i.MaturityDate))
	}
	if i.MaturityDateNEQ != nil {
		predicates = append(predicates, loan.MaturityDateNEQ(*i.MaturityDateNEQ))
	}
	if len(i.MaturityDateIn) > 0 {
		predicates = append(predicates, loan.MaturityDateIn(i.MaturityDateIn...))
	}
	if len(i.MaturityDateNotIn) > 0 {
		predicates = append(predicates, loan.MaturityDateNotIn(i.MaturityDateNotIn...))
	}
	if i.MaturityDateGT != nil {
		predicates = append(predicates, loan.MaturityDateGT(*i.MaturityDateGT))
	}
	if i.MaturityDateGTE != nil {
		predicates = append(predicates, loan.MaturityDateGTE(*i.MaturityDateGTE))
	}
	if i.MaturityDateLT != nil {
		predicates = append(predicates, loan.MaturityDateLT(*i.MaturityDateLT))
	}
	if i.MaturityDateLTE != nil {
		predicates = append(predicates, loan.MaturityDateLTE(*i.MaturityDateLTE))
	}
	if i.NextPayment != nil {
		predicates = append(predicates, loan.NextPaymentEQ(*i.NextPayment))
	}
	if i.NextPaymentNEQ != nil {
		predicates = append(predicates, loan.NextPaymentNEQ(*i.NextPaymentNEQ))
	}
	if len(i.NextPaymentIn) > 0 {
		predicates = append(predicates, loan.NextPaymentIn(i.NextPaymentIn...))
	}
	if len(i.NextPaymentNotIn) > 0 {
		predicates = append(predicates, loan.NextPaymentNotIn(i.NextPaymentNotIn...))
	}
	if i.NextPaymentGT != nil {
		predicates = append(predicates, loan.NextPaymentGT(*i.NextPaymentGT))
	}
	if i.NextPaymentGTE != nil {
		predicates = append(predicates, loan.NextPaymentGTE(*i.NextPaymentGTE))
	}
	if i.NextPaymentLT != nil {
		predicates = append(predicates, loan.NextPaymentLT(*i.NextPaymentLT))
	}
	if i.NextPaymentLTE != nil {
		predicates = append(predicates, loan.NextPaymentLTE(*i.NextPaymentLTE))
	}
	if i.NextPaymentIsNil {
		predicates = append(predicates, loan.NextPaymentIsNil())
	}
	if i.NextPaymentNotNil {
		predicates = append(predicates, loan.NextPaymentNotNil())
	}
	if i.NextPaymentAmount != nil {
		predicates = append(predicates, loan.NextPaymentAmountEQ(*i.NextPaymentAmount))
	}
	if i.NextPaymentAmountNEQ != nil {
		predicates = append(predicates, loan.NextPaymentAmountNEQ(*i.NextPaymentAmountNEQ))
	}
	if len(i.NextPaymentAmountIn) > 0 {
		predicates = append(predicates, loan.NextPaymentAmountIn(i.NextPaymentAmountIn...))
	}
	if len(i.NextPaymentAmountNotIn) > 0 {
		predicates = append(predicates, loan.NextPaymentAmountNotIn(i.NextPaymentAmountNotIn...))
	}
	if i.NextPaymentAmountGT != nil {
		predicates = append(predicates, loan.NextPaymentAmountGT(*i.NextPaymentAmountGT))
	}
	if i.NextPaymentAmountGTE != nil {
		predicates = append(predicates, loan.NextPaymentAmountGTE(*i.NextPaymentAmountGTE))
	}
	if i.NextPaymentAmountLT != nil {
		predicates = append(predicates, loan.NextPaymentAmountLT(*i.NextPaymentAmountLT))
	}
	if i.NextPaymentAmountLTE != nil {
		predicates = append(predicates, loan.NextPaymentAmountLTE(*i.NextPaymentAmountLTE))
	}
	if i.NextPaymentAmountIsNil {
		predicates = append(predicates, loan.NextPaymentAmountIsNil())
	}
	if i.NextPaymentAmountNotNil {
		predicates = append(predicates, loan.NextPaymentAmountNotNil())
	}
	if i.OutstandingBalance != nil {
		predicates = append(predicates, loan.OutstandingBalanceEQ(*i.OutstandingBalance))
	}
	if i.OutstandingBalanceNEQ != nil {
		predicates = append(predicates, loan.OutstandingBalanceNEQ(*i.OutstandingBalanceNEQ))
	}
	if len(i.OutstandingBalanceIn) > 0 {
		predicates = append(predicates, loan.OutstandingBalanceIn(i.OutstandingBalanceIn...))
	}
	if len(i.OutstandingBalanceNotIn) > 0 {
		predicates = append(predicates, loan.OutstandingBalanceNotIn(i.OutstandingBalanceNotIn...))
	}
	if i.OutstandingBalanceGT != nil {
		predicates = append(predicates, loan.OutstandingBalanceGT(*i.OutstandingBalanceGT))
	}
	if i.OutstandingBalanceGTE != nil {
		predicates = append(predicates, loan.OutstandingBalanceGTE(*i.OutstandingBalanceGTE))
	}
	if i.OutstandingBalanceLT != nil {
		predicates = append(predicates, loan.OutstandingBalanceLT(*i.OutstandingBalanceLT))
	}
	if i.OutstandingBalanceLTE != nil {
		predicates = append(predicates, loan.OutstandingBalanceLTE(*i.OutstandingBalanceLTE))
	}
	if i.PaymentFrequency != nil {
		predicates = append(predicates, loan.PaymentFrequencyEQ(*i.PaymentFrequency))
	}
	if i.PaymentFrequencyNEQ != nil {
		predicates = append(predicates, loan.PaymentFrequencyNEQ(*i.PaymentFrequencyNEQ))
	}
	if len(i.PaymentFrequencyIn) > 0 {
		predicates = append(predicates, loan.PaymentFrequencyIn(i.PaymentFrequencyIn...))
	}
	if len(i.PaymentFrequencyNotIn) > 0 {
		predicates = append(predicates, loan.PaymentFrequencyNotIn(i.PaymentFrequencyNotIn...))
	}
	if i.PaidInstallments != nil {
		predicates = append(predicates, loan.PaidInstallmentsEQ(*i.PaidInstallments))
	}
	if i.PaidInstallmentsNEQ != nil {
		predicates = append(predicates, loan.PaidInstallmentsNEQ(*i.PaidInstallmentsNEQ))
	}
	if len(i.PaidInstallmentsIn) > 0 {
		predicates = append(predicates, loan.PaidInstallmentsIn(i.PaidInstallmentsIn...))
	}
	if len(i.PaidInstallmentsNotIn) > 0 {
		predicates = append(predicates, loan.PaidInstallmentsNotIn(i.PaidInstallmentsNotIn...))
	}
	if i.PaidInstallmentsGT != nil {
		predicates = append(predicates, loan.PaidInstallmentsGT(*i.PaidInstallmentsGT))
	}
	if i.PaidInstallmentsGTE != nil {
		predicates = append(predicates, loan.PaidInstallmentsGTE(*i.PaidInstallmentsGTE))
	}
	if i.PaidInstallmentsLT != nil {
		predicates = append(predicates, loan.PaidInstallmentsLT(*i.PaidInstallmentsLT))
	}
	if i.PaidInstallmentsLTE != nil {
		predicates = append(predicates, loan.PaidInstallmentsLTE(*i.PaidInstallmentsLTE))
	}
	if i.Provider != nil {
		predicates = append(predicates, loan.ProviderEQ(*i.Provider))
	}
	if i.ProviderNEQ != nil {
		predicates = append(predicates, loan.ProviderNEQ(*i.ProviderNEQ))
	}
	if len(i.ProviderIn) > 0 {
		predicates = append(predicates, loan.ProviderIn(i.ProviderIn...))
	}
	if len(i.ProviderNotIn) > 0 {
		predicates = append(predicates, loan.ProviderNotIn(i.ProviderNotIn...))
	}
	if i.ProviderGT != nil {
		predicates = append(predicates, loan.ProviderGT(*i.ProviderGT))
	}
	if i.ProviderGTE != nil {
		predicates = append(predicates, loan.ProviderGTE(*i.ProviderGTE))
	}
	if i.ProviderLT != nil {
		predicates = append(predicates, loan.ProviderLT(*i.ProviderLT))
	}
	if i.ProviderLTE != nil {
		predicates = append(predicates, loan.ProviderLTE(*i.ProviderLTE))
	}
	if i.ProviderContains != nil {
		predicates = append(predicates, loan.ProviderContains(*i.ProviderContains))
	}
	if i.ProviderHasPrefix != nil {
		predicates = append(predicates, loan.ProviderHasPrefix(*i.ProviderHasPrefix))
	}
	if i.ProviderHasSuffix != nil {
		predicates = append(predicates, loan.ProviderHasSuffix(*i.ProviderHasSuffix))
	}
	if i.ProviderEqualFold != nil {
		predicates = append(predicates, loan.ProviderEqualFold(*i.ProviderEqualFold))
	}
	if i.ProviderContainsFold != nil {
		predicates = append(predicates, loan.ProviderContainsFold(*i.ProviderContainsFold))
	}
	if i.StartDate != nil {
		predicates = append(predicates, loan.StartDateEQ(*i.StartDate))
	}
	if i.StartDateNEQ != nil {
		predicates = append(predicates, loan.StartDateNEQ(*i.StartDateNEQ))
	}
	if len(i.StartDateIn) > 0 {
		predicates = append(predicates, loan.StartDateIn(i.StartDateIn...))
	}
	if len(i.StartDateNotIn) > 0 {
		predicates = append(predicates, loan.StartDateNotIn(i.StartDateNotIn...))
	}
	if i.StartDateGT != nil {
		predicates = append(predicates, loan.StartDateGT(*i.StartDateGT))
	}
	if i.StartDateGTE != nil {
		predicates = append(predicates, loan.StartDateGTE(*i.StartDateGTE))
	}
	if i.StartDateLT != nil {
		predicates = append(predicates, loan.StartDateLT(*i.StartDateLT))
	}
	if i.StartDateLTE != nil {
		predicates = append(predicates, loan.StartDateLTE(*i.StartDateLTE))
	}
	if i.Status != nil {
		predicates = append(predicates, loan.StatusEQ(*i.Status))
	}
	if i.StatusNEQ != nil {
		predicates = append(predicates, loan.StatusNEQ(*i.StatusNEQ))
	}
	if len(i.StatusIn) > 0 {
		predicates = append(predicates, loan.StatusIn(i.StatusIn...))
	}
	if len(i.StatusNotIn) > 0 {
		predicates = append(predicates, loan.StatusNotIn(i.StatusNotIn...))
	}

	if i.HasCompany != nil {
		p := loan.HasCompany()
		if !*i.HasCompany {
			p = loan.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasCompanyWith) > 0 {
		with := make([]predicate.Company, 0, len(i.HasCompanyWith))
		for _, w := range i.HasCompanyWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasCompanyWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, loan.HasCompanyWith(with...))
	}
	if i.HasTransactionHistory != nil {
		p := loan.HasTransactionHistory()
		if !*i.HasTransactionHistory {
			p = loan.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasTransactionHistoryWith) > 0 {
		with := make([]predicate.AccountingEntry, 0, len(i.HasTransactionHistoryWith))
		for _, w := range i.HasTransactionHistoryWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasTransactionHistoryWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, loan.HasTransactionHistoryWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyLoanWhereInput
	case 1:
		return predicates[0], nil
	default:
		return loan.And(predicates...), nil
	}
}

// MemberSignupTokenWhereInput represents a where input for filtering MemberSignupToken queries.
type MemberSignupTokenWhereInput struct {
	Predicates []predicate.MemberSignupToken  `json:"-"`
	Not        *MemberSignupTokenWhereInput   `json:"not,omitempty"`
	Or         []*MemberSignupTokenWhereInput `json:"or,omitempty"`
	And        []*MemberSignupTokenWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "createdAt" field predicates.
	CreatedAt      *time.Time  `json:"createdat,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdatNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdatIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdatNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdatGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdatGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdatLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdatLTE,omitempty"`

	// "updatedAt" field predicates.
	UpdatedAt      *time.Time  `json:"updatedat,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedatNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedatIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedatNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedatGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedatGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedatLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedatLTE,omitempty"`

	// "deletedAt" field predicates.
	DeletedAt       *time.Time  `json:"deletedat,omitempty"`
	DeletedAtNEQ    *time.Time  `json:"deletedatNEQ,omitempty"`
	DeletedAtIn     []time.Time `json:"deletedatIn,omitempty"`
	DeletedAtNotIn  []time.Time `json:"deletedatNotIn,omitempty"`
	DeletedAtGT     *time.Time  `json:"deletedatGT,omitempty"`
	DeletedAtGTE    *time.Time  `json:"deletedatGTE,omitempty"`
	DeletedAtLT     *time.Time  `json:"deletedatLT,omitempty"`
	DeletedAtLTE    *time.Time  `json:"deletedatLTE,omitempty"`
	DeletedAtIsNil  bool        `json:"deletedatIsNil,omitempty"`
	DeletedAtNotNil bool        `json:"deletedatNotNil,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "email" field predicates.
	Email             *string  `json:"email,omitempty"`
	EmailNEQ          *string  `json:"emailNEQ,omitempty"`
	EmailIn           []string `json:"emailIn,omitempty"`
	EmailNotIn        []string `json:"emailNotIn,omitempty"`
	EmailGT           *string  `json:"emailGT,omitempty"`
	EmailGTE          *string  `json:"emailGTE,omitempty"`
	EmailLT           *string  `json:"emailLT,omitempty"`
	EmailLTE          *string  `json:"emailLTE,omitempty"`
	EmailContains     *string  `json:"emailContains,omitempty"`
	EmailHasPrefix    *string  `json:"emailHasPrefix,omitempty"`
	EmailHasSuffix    *string  `json:"emailHasSuffix,omitempty"`
	EmailIsNil        bool     `json:"emailIsNil,omitempty"`
	EmailNotNil       bool     `json:"emailNotNil,omitempty"`
	EmailEqualFold    *string  `json:"emailEqualFold,omitempty"`
	EmailContainsFold *string  `json:"emailContainsFold,omitempty"`

	// "token" field predicates.
	Token             *string  `json:"token,omitempty"`
	TokenNEQ          *string  `json:"tokenNEQ,omitempty"`
	TokenIn           []string `json:"tokenIn,omitempty"`
	TokenNotIn        []string `json:"tokenNotIn,omitempty"`
	TokenGT           *string  `json:"tokenGT,omitempty"`
	TokenGTE          *string  `json:"tokenGTE,omitempty"`
	TokenLT           *string  `json:"tokenLT,omitempty"`
	TokenLTE          *string  `json:"tokenLTE,omitempty"`
	TokenContains     *string  `json:"tokenContains,omitempty"`
	TokenHasPrefix    *string  `json:"tokenHasPrefix,omitempty"`
	TokenHasSuffix    *string  `json:"tokenHasSuffix,omitempty"`
	TokenEqualFold    *string  `json:"tokenEqualFold,omitempty"`
	TokenContainsFold *string  `json:"tokenContainsFold,omitempty"`

	// "avatar" field predicates.
	Avatar             *string  `json:"avatar,omitempty"`
	AvatarNEQ          *string  `json:"avatarNEQ,omitempty"`
	AvatarIn           []string `json:"avatarIn,omitempty"`
	AvatarNotIn        []string `json:"avatarNotIn,omitempty"`
	AvatarGT           *string  `json:"avatarGT,omitempty"`
	AvatarGTE          *string  `json:"avatarGTE,omitempty"`
	AvatarLT           *string  `json:"avatarLT,omitempty"`
	AvatarLTE          *string  `json:"avatarLTE,omitempty"`
	AvatarContains     *string  `json:"avatarContains,omitempty"`
	AvatarHasPrefix    *string  `json:"avatarHasPrefix,omitempty"`
	AvatarHasSuffix    *string  `json:"avatarHasSuffix,omitempty"`
	AvatarEqualFold    *string  `json:"avatarEqualFold,omitempty"`
	AvatarContainsFold *string  `json:"avatarContainsFold,omitempty"`

	// "role" field predicates.
	Role      *membersignuptoken.Role  `json:"role,omitempty"`
	RoleNEQ   *membersignuptoken.Role  `json:"roleNEQ,omitempty"`
	RoleIn    []membersignuptoken.Role `json:"roleIn,omitempty"`
	RoleNotIn []membersignuptoken.Role `json:"roleNotIn,omitempty"`

	// "note" field predicates.
	Note             *string  `json:"note,omitempty"`
	NoteNEQ          *string  `json:"noteNEQ,omitempty"`
	NoteIn           []string `json:"noteIn,omitempty"`
	NoteNotIn        []string `json:"noteNotIn,omitempty"`
	NoteGT           *string  `json:"noteGT,omitempty"`
	NoteGTE          *string  `json:"noteGTE,omitempty"`
	NoteLT           *string  `json:"noteLT,omitempty"`
	NoteLTE          *string  `json:"noteLTE,omitempty"`
	NoteContains     *string  `json:"noteContains,omitempty"`
	NoteHasPrefix    *string  `json:"noteHasPrefix,omitempty"`
	NoteHasSuffix    *string  `json:"noteHasSuffix,omitempty"`
	NoteEqualFold    *string  `json:"noteEqualFold,omitempty"`
	NoteContainsFold *string  `json:"noteContainsFold,omitempty"`

	// "numberAccessed" field predicates.
	NumberAccessed      *int  `json:"numberaccessed,omitempty"`
	NumberAccessedNEQ   *int  `json:"numberaccessedNEQ,omitempty"`
	NumberAccessedIn    []int `json:"numberaccessedIn,omitempty"`
	NumberAccessedNotIn []int `json:"numberaccessedNotIn,omitempty"`
	NumberAccessedGT    *int  `json:"numberaccessedGT,omitempty"`
	NumberAccessedGTE   *int  `json:"numberaccessedGTE,omitempty"`
	NumberAccessedLT    *int  `json:"numberaccessedLT,omitempty"`
	NumberAccessedLTE   *int  `json:"numberaccessedLTE,omitempty"`

	// "expiresAt" field predicates.
	ExpiresAt      *time.Time  `json:"expiresat,omitempty"`
	ExpiresAtNEQ   *time.Time  `json:"expiresatNEQ,omitempty"`
	ExpiresAtIn    []time.Time `json:"expiresatIn,omitempty"`
	ExpiresAtNotIn []time.Time `json:"expiresatNotIn,omitempty"`
	ExpiresAtGT    *time.Time  `json:"expiresatGT,omitempty"`
	ExpiresAtGTE   *time.Time  `json:"expiresatGTE,omitempty"`
	ExpiresAtLT    *time.Time  `json:"expiresatLT,omitempty"`
	ExpiresAtLTE   *time.Time  `json:"expiresatLTE,omitempty"`

	// "alreadyUsed" field predicates.
	AlreadyUsed    *bool `json:"alreadyused,omitempty"`
	AlreadyUsedNEQ *bool `json:"alreadyusedNEQ,omitempty"`

	// "company" edge predicates.
	HasCompany     *bool                `json:"hasCompany,omitempty"`
	HasCompanyWith []*CompanyWhereInput `json:"hasCompanyWith,omitempty"`

	// "createdBy" edge predicates.
	HasCreatedBy     *bool             `json:"hasCreatedBy,omitempty"`
	HasCreatedByWith []*UserWhereInput `json:"hasCreatedByWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *MemberSignupTokenWhereInput) AddPredicates(predicates ...predicate.MemberSignupToken) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the MemberSignupTokenWhereInput filter on the MemberSignupTokenQuery builder.
func (i *MemberSignupTokenWhereInput) Filter(q *MemberSignupTokenQuery) (*MemberSignupTokenQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyMemberSignupTokenWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyMemberSignupTokenWhereInput is returned in case the MemberSignupTokenWhereInput is empty.
var ErrEmptyMemberSignupTokenWhereInput = errors.New("generated: empty predicate MemberSignupTokenWhereInput")

// P returns a predicate for filtering membersignuptokens.
// An error is returned if the input is empty or invalid.
func (i *MemberSignupTokenWhereInput) P() (predicate.MemberSignupToken, error) {
	var predicates []predicate.MemberSignupToken
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, membersignuptoken.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.MemberSignupToken, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, membersignuptoken.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.MemberSignupToken, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, membersignuptoken.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, membersignuptoken.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, membersignuptoken.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, membersignuptoken.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, membersignuptoken.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, membersignuptoken.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, membersignuptoken.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, membersignuptoken.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, membersignuptoken.IDLTE(*i.IDLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, membersignuptoken.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, membersignuptoken.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, membersignuptoken.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, membersignuptoken.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, membersignuptoken.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, membersignuptoken.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, membersignuptoken.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, membersignuptoken.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, membersignuptoken.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, membersignuptoken.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, membersignuptoken.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, membersignuptoken.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, membersignuptoken.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, membersignuptoken.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, membersignuptoken.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, membersignuptoken.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.DeletedAt != nil {
		predicates = append(predicates, membersignuptoken.DeletedAtEQ(*i.DeletedAt))
	}
	if i.DeletedAtNEQ != nil {
		predicates = append(predicates, membersignuptoken.DeletedAtNEQ(*i.DeletedAtNEQ))
	}
	if len(i.DeletedAtIn) > 0 {
		predicates = append(predicates, membersignuptoken.DeletedAtIn(i.DeletedAtIn...))
	}
	if len(i.DeletedAtNotIn) > 0 {
		predicates = append(predicates, membersignuptoken.DeletedAtNotIn(i.DeletedAtNotIn...))
	}
	if i.DeletedAtGT != nil {
		predicates = append(predicates, membersignuptoken.DeletedAtGT(*i.DeletedAtGT))
	}
	if i.DeletedAtGTE != nil {
		predicates = append(predicates, membersignuptoken.DeletedAtGTE(*i.DeletedAtGTE))
	}
	if i.DeletedAtLT != nil {
		predicates = append(predicates, membersignuptoken.DeletedAtLT(*i.DeletedAtLT))
	}
	if i.DeletedAtLTE != nil {
		predicates = append(predicates, membersignuptoken.DeletedAtLTE(*i.DeletedAtLTE))
	}
	if i.DeletedAtIsNil {
		predicates = append(predicates, membersignuptoken.DeletedAtIsNil())
	}
	if i.DeletedAtNotNil {
		predicates = append(predicates, membersignuptoken.DeletedAtNotNil())
	}
	if i.Name != nil {
		predicates = append(predicates, membersignuptoken.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, membersignuptoken.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, membersignuptoken.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, membersignuptoken.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, membersignuptoken.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, membersignuptoken.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, membersignuptoken.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, membersignuptoken.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, membersignuptoken.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, membersignuptoken.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, membersignuptoken.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, membersignuptoken.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, membersignuptoken.NameContainsFold(*i.NameContainsFold))
	}
	if i.Email != nil {
		predicates = append(predicates, membersignuptoken.EmailEQ(*i.Email))
	}
	if i.EmailNEQ != nil {
		predicates = append(predicates, membersignuptoken.EmailNEQ(*i.EmailNEQ))
	}
	if len(i.EmailIn) > 0 {
		predicates = append(predicates, membersignuptoken.EmailIn(i.EmailIn...))
	}
	if len(i.EmailNotIn) > 0 {
		predicates = append(predicates, membersignuptoken.EmailNotIn(i.EmailNotIn...))
	}
	if i.EmailGT != nil {
		predicates = append(predicates, membersignuptoken.EmailGT(*i.EmailGT))
	}
	if i.EmailGTE != nil {
		predicates = append(predicates, membersignuptoken.EmailGTE(*i.EmailGTE))
	}
	if i.EmailLT != nil {
		predicates = append(predicates, membersignuptoken.EmailLT(*i.EmailLT))
	}
	if i.EmailLTE != nil {
		predicates = append(predicates, membersignuptoken.EmailLTE(*i.EmailLTE))
	}
	if i.EmailContains != nil {
		predicates = append(predicates, membersignuptoken.EmailContains(*i.EmailContains))
	}
	if i.EmailHasPrefix != nil {
		predicates = append(predicates, membersignuptoken.EmailHasPrefix(*i.EmailHasPrefix))
	}
	if i.EmailHasSuffix != nil {
		predicates = append(predicates, membersignuptoken.EmailHasSuffix(*i.EmailHasSuffix))
	}
	if i.EmailIsNil {
		predicates = append(predicates, membersignuptoken.EmailIsNil())
	}
	if i.EmailNotNil {
		predicates = append(predicates, membersignuptoken.EmailNotNil())
	}
	if i.EmailEqualFold != nil {
		predicates = append(predicates, membersignuptoken.EmailEqualFold(*i.EmailEqualFold))
	}
	if i.EmailContainsFold != nil {
		predicates = append(predicates, membersignuptoken.EmailContainsFold(*i.EmailContainsFold))
	}
	if i.Token != nil {
		predicates = append(predicates, membersignuptoken.TokenEQ(*i.Token))
	}
	if i.TokenNEQ != nil {
		predicates = append(predicates, membersignuptoken.TokenNEQ(*i.TokenNEQ))
	}
	if len(i.TokenIn) > 0 {
		predicates = append(predicates, membersignuptoken.TokenIn(i.TokenIn...))
	}
	if len(i.TokenNotIn) > 0 {
		predicates = append(predicates, membersignuptoken.TokenNotIn(i.TokenNotIn...))
	}
	if i.TokenGT != nil {
		predicates = append(predicates, membersignuptoken.TokenGT(*i.TokenGT))
	}
	if i.TokenGTE != nil {
		predicates = append(predicates, membersignuptoken.TokenGTE(*i.TokenGTE))
	}
	if i.TokenLT != nil {
		predicates = append(predicates, membersignuptoken.TokenLT(*i.TokenLT))
	}
	if i.TokenLTE != nil {
		predicates = append(predicates, membersignuptoken.TokenLTE(*i.TokenLTE))
	}
	if i.TokenContains != nil {
		predicates = append(predicates, membersignuptoken.TokenContains(*i.TokenContains))
	}
	if i.TokenHasPrefix != nil {
		predicates = append(predicates, membersignuptoken.TokenHasPrefix(*i.TokenHasPrefix))
	}
	if i.TokenHasSuffix != nil {
		predicates = append(predicates, membersignuptoken.TokenHasSuffix(*i.TokenHasSuffix))
	}
	if i.TokenEqualFold != nil {
		predicates = append(predicates, membersignuptoken.TokenEqualFold(*i.TokenEqualFold))
	}
	if i.TokenContainsFold != nil {
		predicates = append(predicates, membersignuptoken.TokenContainsFold(*i.TokenContainsFold))
	}
	if i.Avatar != nil {
		predicates = append(predicates, membersignuptoken.AvatarEQ(*i.Avatar))
	}
	if i.AvatarNEQ != nil {
		predicates = append(predicates, membersignuptoken.AvatarNEQ(*i.AvatarNEQ))
	}
	if len(i.AvatarIn) > 0 {
		predicates = append(predicates, membersignuptoken.AvatarIn(i.AvatarIn...))
	}
	if len(i.AvatarNotIn) > 0 {
		predicates = append(predicates, membersignuptoken.AvatarNotIn(i.AvatarNotIn...))
	}
	if i.AvatarGT != nil {
		predicates = append(predicates, membersignuptoken.AvatarGT(*i.AvatarGT))
	}
	if i.AvatarGTE != nil {
		predicates = append(predicates, membersignuptoken.AvatarGTE(*i.AvatarGTE))
	}
	if i.AvatarLT != nil {
		predicates = append(predicates, membersignuptoken.AvatarLT(*i.AvatarLT))
	}
	if i.AvatarLTE != nil {
		predicates = append(predicates, membersignuptoken.AvatarLTE(*i.AvatarLTE))
	}
	if i.AvatarContains != nil {
		predicates = append(predicates, membersignuptoken.AvatarContains(*i.AvatarContains))
	}
	if i.AvatarHasPrefix != nil {
		predicates = append(predicates, membersignuptoken.AvatarHasPrefix(*i.AvatarHasPrefix))
	}
	if i.AvatarHasSuffix != nil {
		predicates = append(predicates, membersignuptoken.AvatarHasSuffix(*i.AvatarHasSuffix))
	}
	if i.AvatarEqualFold != nil {
		predicates = append(predicates, membersignuptoken.AvatarEqualFold(*i.AvatarEqualFold))
	}
	if i.AvatarContainsFold != nil {
		predicates = append(predicates, membersignuptoken.AvatarContainsFold(*i.AvatarContainsFold))
	}
	if i.Role != nil {
		predicates = append(predicates, membersignuptoken.RoleEQ(*i.Role))
	}
	if i.RoleNEQ != nil {
		predicates = append(predicates, membersignuptoken.RoleNEQ(*i.RoleNEQ))
	}
	if len(i.RoleIn) > 0 {
		predicates = append(predicates, membersignuptoken.RoleIn(i.RoleIn...))
	}
	if len(i.RoleNotIn) > 0 {
		predicates = append(predicates, membersignuptoken.RoleNotIn(i.RoleNotIn...))
	}
	if i.Note != nil {
		predicates = append(predicates, membersignuptoken.NoteEQ(*i.Note))
	}
	if i.NoteNEQ != nil {
		predicates = append(predicates, membersignuptoken.NoteNEQ(*i.NoteNEQ))
	}
	if len(i.NoteIn) > 0 {
		predicates = append(predicates, membersignuptoken.NoteIn(i.NoteIn...))
	}
	if len(i.NoteNotIn) > 0 {
		predicates = append(predicates, membersignuptoken.NoteNotIn(i.NoteNotIn...))
	}
	if i.NoteGT != nil {
		predicates = append(predicates, membersignuptoken.NoteGT(*i.NoteGT))
	}
	if i.NoteGTE != nil {
		predicates = append(predicates, membersignuptoken.NoteGTE(*i.NoteGTE))
	}
	if i.NoteLT != nil {
		predicates = append(predicates, membersignuptoken.NoteLT(*i.NoteLT))
	}
	if i.NoteLTE != nil {
		predicates = append(predicates, membersignuptoken.NoteLTE(*i.NoteLTE))
	}
	if i.NoteContains != nil {
		predicates = append(predicates, membersignuptoken.NoteContains(*i.NoteContains))
	}
	if i.NoteHasPrefix != nil {
		predicates = append(predicates, membersignuptoken.NoteHasPrefix(*i.NoteHasPrefix))
	}
	if i.NoteHasSuffix != nil {
		predicates = append(predicates, membersignuptoken.NoteHasSuffix(*i.NoteHasSuffix))
	}
	if i.NoteEqualFold != nil {
		predicates = append(predicates, membersignuptoken.NoteEqualFold(*i.NoteEqualFold))
	}
	if i.NoteContainsFold != nil {
		predicates = append(predicates, membersignuptoken.NoteContainsFold(*i.NoteContainsFold))
	}
	if i.NumberAccessed != nil {
		predicates = append(predicates, membersignuptoken.NumberAccessedEQ(*i.NumberAccessed))
	}
	if i.NumberAccessedNEQ != nil {
		predicates = append(predicates, membersignuptoken.NumberAccessedNEQ(*i.NumberAccessedNEQ))
	}
	if len(i.NumberAccessedIn) > 0 {
		predicates = append(predicates, membersignuptoken.NumberAccessedIn(i.NumberAccessedIn...))
	}
	if len(i.NumberAccessedNotIn) > 0 {
		predicates = append(predicates, membersignuptoken.NumberAccessedNotIn(i.NumberAccessedNotIn...))
	}
	if i.NumberAccessedGT != nil {
		predicates = append(predicates, membersignuptoken.NumberAccessedGT(*i.NumberAccessedGT))
	}
	if i.NumberAccessedGTE != nil {
		predicates = append(predicates, membersignuptoken.NumberAccessedGTE(*i.NumberAccessedGTE))
	}
	if i.NumberAccessedLT != nil {
		predicates = append(predicates, membersignuptoken.NumberAccessedLT(*i.NumberAccessedLT))
	}
	if i.NumberAccessedLTE != nil {
		predicates = append(predicates, membersignuptoken.NumberAccessedLTE(*i.NumberAccessedLTE))
	}
	if i.ExpiresAt != nil {
		predicates = append(predicates, membersignuptoken.ExpiresAtEQ(*i.ExpiresAt))
	}
	if i.ExpiresAtNEQ != nil {
		predicates = append(predicates, membersignuptoken.ExpiresAtNEQ(*i.ExpiresAtNEQ))
	}
	if len(i.ExpiresAtIn) > 0 {
		predicates = append(predicates, membersignuptoken.ExpiresAtIn(i.ExpiresAtIn...))
	}
	if len(i.ExpiresAtNotIn) > 0 {
		predicates = append(predicates, membersignuptoken.ExpiresAtNotIn(i.ExpiresAtNotIn...))
	}
	if i.ExpiresAtGT != nil {
		predicates = append(predicates, membersignuptoken.ExpiresAtGT(*i.ExpiresAtGT))
	}
	if i.ExpiresAtGTE != nil {
		predicates = append(predicates, membersignuptoken.ExpiresAtGTE(*i.ExpiresAtGTE))
	}
	if i.ExpiresAtLT != nil {
		predicates = append(predicates, membersignuptoken.ExpiresAtLT(*i.ExpiresAtLT))
	}
	if i.ExpiresAtLTE != nil {
		predicates = append(predicates, membersignuptoken.ExpiresAtLTE(*i.ExpiresAtLTE))
	}
	if i.AlreadyUsed != nil {
		predicates = append(predicates, membersignuptoken.AlreadyUsedEQ(*i.AlreadyUsed))
	}
	if i.AlreadyUsedNEQ != nil {
		predicates = append(predicates, membersignuptoken.AlreadyUsedNEQ(*i.AlreadyUsedNEQ))
	}

	if i.HasCompany != nil {
		p := membersignuptoken.HasCompany()
		if !*i.HasCompany {
			p = membersignuptoken.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasCompanyWith) > 0 {
		with := make([]predicate.Company, 0, len(i.HasCompanyWith))
		for _, w := range i.HasCompanyWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasCompanyWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, membersignuptoken.HasCompanyWith(with...))
	}
	if i.HasCreatedBy != nil {
		p := membersignuptoken.HasCreatedBy()
		if !*i.HasCreatedBy {
			p = membersignuptoken.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasCreatedByWith) > 0 {
		with := make([]predicate.User, 0, len(i.HasCreatedByWith))
		for _, w := range i.HasCreatedByWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasCreatedByWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, membersignuptoken.HasCreatedByWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyMemberSignupTokenWhereInput
	case 1:
		return predicates[0], nil
	default:
		return membersignuptoken.And(predicates...), nil
	}
}

// PayableWhereInput represents a where input for filtering Payable queries.
type PayableWhereInput struct {
	Predicates []predicate.Payable  `json:"-"`
	Not        *PayableWhereInput   `json:"not,omitempty"`
	Or         []*PayableWhereInput `json:"or,omitempty"`
	And        []*PayableWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "createdAt" field predicates.
	CreatedAt      *time.Time  `json:"createdat,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdatNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdatIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdatNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdatGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdatGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdatLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdatLTE,omitempty"`

	// "updatedAt" field predicates.
	UpdatedAt      *time.Time  `json:"updatedat,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedatNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedatIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedatNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedatGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedatGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedatLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedatLTE,omitempty"`

	// "deletedAt" field predicates.
	DeletedAt       *time.Time  `json:"deletedat,omitempty"`
	DeletedAtNEQ    *time.Time  `json:"deletedatNEQ,omitempty"`
	DeletedAtIn     []time.Time `json:"deletedatIn,omitempty"`
	DeletedAtNotIn  []time.Time `json:"deletedatNotIn,omitempty"`
	DeletedAtGT     *time.Time  `json:"deletedatGT,omitempty"`
	DeletedAtGTE    *time.Time  `json:"deletedatGTE,omitempty"`
	DeletedAtLT     *time.Time  `json:"deletedatLT,omitempty"`
	DeletedAtLTE    *time.Time  `json:"deletedatLTE,omitempty"`
	DeletedAtIsNil  bool        `json:"deletedatIsNil,omitempty"`
	DeletedAtNotNil bool        `json:"deletedatNotNil,omitempty"`

	// "entryGroup" field predicates.
	EntryGroup      *int  `json:"entrygroup,omitempty"`
	EntryGroupNEQ   *int  `json:"entrygroupNEQ,omitempty"`
	EntryGroupIn    []int `json:"entrygroupIn,omitempty"`
	EntryGroupNotIn []int `json:"entrygroupNotIn,omitempty"`
	EntryGroupGT    *int  `json:"entrygroupGT,omitempty"`
	EntryGroupGTE   *int  `json:"entrygroupGTE,omitempty"`
	EntryGroupLT    *int  `json:"entrygroupLT,omitempty"`
	EntryGroupLTE   *int  `json:"entrygroupLTE,omitempty"`

	// "date" field predicates.
	Date      *time.Time  `json:"date,omitempty"`
	DateNEQ   *time.Time  `json:"dateNEQ,omitempty"`
	DateIn    []time.Time `json:"dateIn,omitempty"`
	DateNotIn []time.Time `json:"dateNotIn,omitempty"`
	DateGT    *time.Time  `json:"dateGT,omitempty"`
	DateGTE   *time.Time  `json:"dateGTE,omitempty"`
	DateLT    *time.Time  `json:"dateLT,omitempty"`
	DateLTE   *time.Time  `json:"dateLTE,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "amountInDefault" field predicates.
	AmountInDefault      *float64  `json:"amountindefault,omitempty"`
	AmountInDefaultNEQ   *float64  `json:"amountindefaultNEQ,omitempty"`
	AmountInDefaultIn    []float64 `json:"amountindefaultIn,omitempty"`
	AmountInDefaultNotIn []float64 `json:"amountindefaultNotIn,omitempty"`
	AmountInDefaultGT    *float64  `json:"amountindefaultGT,omitempty"`
	AmountInDefaultGTE   *float64  `json:"amountindefaultGTE,omitempty"`
	AmountInDefaultLT    *float64  `json:"amountindefaultLT,omitempty"`
	AmountInDefaultLTE   *float64  `json:"amountindefaultLTE,omitempty"`

	// "outstandingBalance" field predicates.
	OutstandingBalance      *float64  `json:"outstandingbalance,omitempty"`
	OutstandingBalanceNEQ   *float64  `json:"outstandingbalanceNEQ,omitempty"`
	OutstandingBalanceIn    []float64 `json:"outstandingbalanceIn,omitempty"`
	OutstandingBalanceNotIn []float64 `json:"outstandingbalanceNotIn,omitempty"`
	OutstandingBalanceGT    *float64  `json:"outstandingbalanceGT,omitempty"`
	OutstandingBalanceGTE   *float64  `json:"outstandingbalanceGTE,omitempty"`
	OutstandingBalanceLT    *float64  `json:"outstandingbalanceLT,omitempty"`
	OutstandingBalanceLTE   *float64  `json:"outstandingbalanceLTE,omitempty"`

	// "totalTransaction" field predicates.
	TotalTransaction      *float64  `json:"totaltransaction,omitempty"`
	TotalTransactionNEQ   *float64  `json:"totaltransactionNEQ,omitempty"`
	TotalTransactionIn    []float64 `json:"totaltransactionIn,omitempty"`
	TotalTransactionNotIn []float64 `json:"totaltransactionNotIn,omitempty"`
	TotalTransactionGT    *float64  `json:"totaltransactionGT,omitempty"`
	TotalTransactionGTE   *float64  `json:"totaltransactionGTE,omitempty"`
	TotalTransactionLT    *float64  `json:"totaltransactionLT,omitempty"`
	TotalTransactionLTE   *float64  `json:"totaltransactionLTE,omitempty"`

	// "dueDate" field predicates.
	DueDate      *time.Time  `json:"duedate,omitempty"`
	DueDateNEQ   *time.Time  `json:"duedateNEQ,omitempty"`
	DueDateIn    []time.Time `json:"duedateIn,omitempty"`
	DueDateNotIn []time.Time `json:"duedateNotIn,omitempty"`
	DueDateGT    *time.Time  `json:"duedateGT,omitempty"`
	DueDateGTE   *time.Time  `json:"duedateGTE,omitempty"`
	DueDateLT    *time.Time  `json:"duedateLT,omitempty"`
	DueDateLTE   *time.Time  `json:"duedateLTE,omitempty"`

	// "status" field predicates.
	Status      *payable.Status  `json:"status,omitempty"`
	StatusNEQ   *payable.Status  `json:"statusNEQ,omitempty"`
	StatusIn    []payable.Status `json:"statusIn,omitempty"`
	StatusNotIn []payable.Status `json:"statusNotIn,omitempty"`

	// "company" edge predicates.
	HasCompany     *bool                `json:"hasCompany,omitempty"`
	HasCompanyWith []*CompanyWhereInput `json:"hasCompanyWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *PayableWhereInput) AddPredicates(predicates ...predicate.Payable) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the PayableWhereInput filter on the PayableQuery builder.
func (i *PayableWhereInput) Filter(q *PayableQuery) (*PayableQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyPayableWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyPayableWhereInput is returned in case the PayableWhereInput is empty.
var ErrEmptyPayableWhereInput = errors.New("generated: empty predicate PayableWhereInput")

// P returns a predicate for filtering payables.
// An error is returned if the input is empty or invalid.
func (i *PayableWhereInput) P() (predicate.Payable, error) {
	var predicates []predicate.Payable
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, payable.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Payable, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, payable.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Payable, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, payable.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, payable.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, payable.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, payable.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, payable.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, payable.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, payable.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, payable.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, payable.IDLTE(*i.IDLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, payable.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, payable.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, payable.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, payable.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, payable.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, payable.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, payable.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, payable.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, payable.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, payable.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, payable.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, payable.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, payable.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, payable.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, payable.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, payable.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.DeletedAt != nil {
		predicates = append(predicates, payable.DeletedAtEQ(*i.DeletedAt))
	}
	if i.DeletedAtNEQ != nil {
		predicates = append(predicates, payable.DeletedAtNEQ(*i.DeletedAtNEQ))
	}
	if len(i.DeletedAtIn) > 0 {
		predicates = append(predicates, payable.DeletedAtIn(i.DeletedAtIn...))
	}
	if len(i.DeletedAtNotIn) > 0 {
		predicates = append(predicates, payable.DeletedAtNotIn(i.DeletedAtNotIn...))
	}
	if i.DeletedAtGT != nil {
		predicates = append(predicates, payable.DeletedAtGT(*i.DeletedAtGT))
	}
	if i.DeletedAtGTE != nil {
		predicates = append(predicates, payable.DeletedAtGTE(*i.DeletedAtGTE))
	}
	if i.DeletedAtLT != nil {
		predicates = append(predicates, payable.DeletedAtLT(*i.DeletedAtLT))
	}
	if i.DeletedAtLTE != nil {
		predicates = append(predicates, payable.DeletedAtLTE(*i.DeletedAtLTE))
	}
	if i.DeletedAtIsNil {
		predicates = append(predicates, payable.DeletedAtIsNil())
	}
	if i.DeletedAtNotNil {
		predicates = append(predicates, payable.DeletedAtNotNil())
	}
	if i.EntryGroup != nil {
		predicates = append(predicates, payable.EntryGroupEQ(*i.EntryGroup))
	}
	if i.EntryGroupNEQ != nil {
		predicates = append(predicates, payable.EntryGroupNEQ(*i.EntryGroupNEQ))
	}
	if len(i.EntryGroupIn) > 0 {
		predicates = append(predicates, payable.EntryGroupIn(i.EntryGroupIn...))
	}
	if len(i.EntryGroupNotIn) > 0 {
		predicates = append(predicates, payable.EntryGroupNotIn(i.EntryGroupNotIn...))
	}
	if i.EntryGroupGT != nil {
		predicates = append(predicates, payable.EntryGroupGT(*i.EntryGroupGT))
	}
	if i.EntryGroupGTE != nil {
		predicates = append(predicates, payable.EntryGroupGTE(*i.EntryGroupGTE))
	}
	if i.EntryGroupLT != nil {
		predicates = append(predicates, payable.EntryGroupLT(*i.EntryGroupLT))
	}
	if i.EntryGroupLTE != nil {
		predicates = append(predicates, payable.EntryGroupLTE(*i.EntryGroupLTE))
	}
	if i.Date != nil {
		predicates = append(predicates, payable.DateEQ(*i.Date))
	}
	if i.DateNEQ != nil {
		predicates = append(predicates, payable.DateNEQ(*i.DateNEQ))
	}
	if len(i.DateIn) > 0 {
		predicates = append(predicates, payable.DateIn(i.DateIn...))
	}
	if len(i.DateNotIn) > 0 {
		predicates = append(predicates, payable.DateNotIn(i.DateNotIn...))
	}
	if i.DateGT != nil {
		predicates = append(predicates, payable.DateGT(*i.DateGT))
	}
	if i.DateGTE != nil {
		predicates = append(predicates, payable.DateGTE(*i.DateGTE))
	}
	if i.DateLT != nil {
		predicates = append(predicates, payable.DateLT(*i.DateLT))
	}
	if i.DateLTE != nil {
		predicates = append(predicates, payable.DateLTE(*i.DateLTE))
	}
	if i.Name != nil {
		predicates = append(predicates, payable.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, payable.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, payable.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, payable.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, payable.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, payable.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, payable.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, payable.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, payable.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, payable.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, payable.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, payable.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, payable.NameContainsFold(*i.NameContainsFold))
	}
	if i.AmountInDefault != nil {
		predicates = append(predicates, payable.AmountInDefaultEQ(*i.AmountInDefault))
	}
	if i.AmountInDefaultNEQ != nil {
		predicates = append(predicates, payable.AmountInDefaultNEQ(*i.AmountInDefaultNEQ))
	}
	if len(i.AmountInDefaultIn) > 0 {
		predicates = append(predicates, payable.AmountInDefaultIn(i.AmountInDefaultIn...))
	}
	if len(i.AmountInDefaultNotIn) > 0 {
		predicates = append(predicates, payable.AmountInDefaultNotIn(i.AmountInDefaultNotIn...))
	}
	if i.AmountInDefaultGT != nil {
		predicates = append(predicates, payable.AmountInDefaultGT(*i.AmountInDefaultGT))
	}
	if i.AmountInDefaultGTE != nil {
		predicates = append(predicates, payable.AmountInDefaultGTE(*i.AmountInDefaultGTE))
	}
	if i.AmountInDefaultLT != nil {
		predicates = append(predicates, payable.AmountInDefaultLT(*i.AmountInDefaultLT))
	}
	if i.AmountInDefaultLTE != nil {
		predicates = append(predicates, payable.AmountInDefaultLTE(*i.AmountInDefaultLTE))
	}
	if i.OutstandingBalance != nil {
		predicates = append(predicates, payable.OutstandingBalanceEQ(*i.OutstandingBalance))
	}
	if i.OutstandingBalanceNEQ != nil {
		predicates = append(predicates, payable.OutstandingBalanceNEQ(*i.OutstandingBalanceNEQ))
	}
	if len(i.OutstandingBalanceIn) > 0 {
		predicates = append(predicates, payable.OutstandingBalanceIn(i.OutstandingBalanceIn...))
	}
	if len(i.OutstandingBalanceNotIn) > 0 {
		predicates = append(predicates, payable.OutstandingBalanceNotIn(i.OutstandingBalanceNotIn...))
	}
	if i.OutstandingBalanceGT != nil {
		predicates = append(predicates, payable.OutstandingBalanceGT(*i.OutstandingBalanceGT))
	}
	if i.OutstandingBalanceGTE != nil {
		predicates = append(predicates, payable.OutstandingBalanceGTE(*i.OutstandingBalanceGTE))
	}
	if i.OutstandingBalanceLT != nil {
		predicates = append(predicates, payable.OutstandingBalanceLT(*i.OutstandingBalanceLT))
	}
	if i.OutstandingBalanceLTE != nil {
		predicates = append(predicates, payable.OutstandingBalanceLTE(*i.OutstandingBalanceLTE))
	}
	if i.TotalTransaction != nil {
		predicates = append(predicates, payable.TotalTransactionEQ(*i.TotalTransaction))
	}
	if i.TotalTransactionNEQ != nil {
		predicates = append(predicates, payable.TotalTransactionNEQ(*i.TotalTransactionNEQ))
	}
	if len(i.TotalTransactionIn) > 0 {
		predicates = append(predicates, payable.TotalTransactionIn(i.TotalTransactionIn...))
	}
	if len(i.TotalTransactionNotIn) > 0 {
		predicates = append(predicates, payable.TotalTransactionNotIn(i.TotalTransactionNotIn...))
	}
	if i.TotalTransactionGT != nil {
		predicates = append(predicates, payable.TotalTransactionGT(*i.TotalTransactionGT))
	}
	if i.TotalTransactionGTE != nil {
		predicates = append(predicates, payable.TotalTransactionGTE(*i.TotalTransactionGTE))
	}
	if i.TotalTransactionLT != nil {
		predicates = append(predicates, payable.TotalTransactionLT(*i.TotalTransactionLT))
	}
	if i.TotalTransactionLTE != nil {
		predicates = append(predicates, payable.TotalTransactionLTE(*i.TotalTransactionLTE))
	}
	if i.DueDate != nil {
		predicates = append(predicates, payable.DueDateEQ(*i.DueDate))
	}
	if i.DueDateNEQ != nil {
		predicates = append(predicates, payable.DueDateNEQ(*i.DueDateNEQ))
	}
	if len(i.DueDateIn) > 0 {
		predicates = append(predicates, payable.DueDateIn(i.DueDateIn...))
	}
	if len(i.DueDateNotIn) > 0 {
		predicates = append(predicates, payable.DueDateNotIn(i.DueDateNotIn...))
	}
	if i.DueDateGT != nil {
		predicates = append(predicates, payable.DueDateGT(*i.DueDateGT))
	}
	if i.DueDateGTE != nil {
		predicates = append(predicates, payable.DueDateGTE(*i.DueDateGTE))
	}
	if i.DueDateLT != nil {
		predicates = append(predicates, payable.DueDateLT(*i.DueDateLT))
	}
	if i.DueDateLTE != nil {
		predicates = append(predicates, payable.DueDateLTE(*i.DueDateLTE))
	}
	if i.Status != nil {
		predicates = append(predicates, payable.StatusEQ(*i.Status))
	}
	if i.StatusNEQ != nil {
		predicates = append(predicates, payable.StatusNEQ(*i.StatusNEQ))
	}
	if len(i.StatusIn) > 0 {
		predicates = append(predicates, payable.StatusIn(i.StatusIn...))
	}
	if len(i.StatusNotIn) > 0 {
		predicates = append(predicates, payable.StatusNotIn(i.StatusNotIn...))
	}

	if i.HasCompany != nil {
		p := payable.HasCompany()
		if !*i.HasCompany {
			p = payable.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasCompanyWith) > 0 {
		with := make([]predicate.Company, 0, len(i.HasCompanyWith))
		for _, w := range i.HasCompanyWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasCompanyWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, payable.HasCompanyWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyPayableWhereInput
	case 1:
		return predicates[0], nil
	default:
		return payable.And(predicates...), nil
	}
}

// ProductWhereInput represents a where input for filtering Product queries.
type ProductWhereInput struct {
	Predicates []predicate.Product  `json:"-"`
	Not        *ProductWhereInput   `json:"not,omitempty"`
	Or         []*ProductWhereInput `json:"or,omitempty"`
	And        []*ProductWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "createdAt" field predicates.
	CreatedAt      *time.Time  `json:"createdat,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdatNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdatIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdatNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdatGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdatGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdatLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdatLTE,omitempty"`

	// "updatedAt" field predicates.
	UpdatedAt      *time.Time  `json:"updatedat,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedatNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedatIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedatNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedatGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedatGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedatLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedatLTE,omitempty"`

	// "deletedAt" field predicates.
	DeletedAt       *time.Time  `json:"deletedat,omitempty"`
	DeletedAtNEQ    *time.Time  `json:"deletedatNEQ,omitempty"`
	DeletedAtIn     []time.Time `json:"deletedatIn,omitempty"`
	DeletedAtNotIn  []time.Time `json:"deletedatNotIn,omitempty"`
	DeletedAtGT     *time.Time  `json:"deletedatGT,omitempty"`
	DeletedAtGTE    *time.Time  `json:"deletedatGTE,omitempty"`
	DeletedAtLT     *time.Time  `json:"deletedatLT,omitempty"`
	DeletedAtLTE    *time.Time  `json:"deletedatLTE,omitempty"`
	DeletedAtIsNil  bool        `json:"deletedatIsNil,omitempty"`
	DeletedAtNotNil bool        `json:"deletedatNotNil,omitempty"`

	// "stock" field predicates.
	Stock      *int  `json:"stock,omitempty"`
	StockNEQ   *int  `json:"stockNEQ,omitempty"`
	StockIn    []int `json:"stockIn,omitempty"`
	StockNotIn []int `json:"stockNotIn,omitempty"`
	StockGT    *int  `json:"stockGT,omitempty"`
	StockGTE   *int  `json:"stockGTE,omitempty"`
	StockLT    *int  `json:"stockLT,omitempty"`
	StockLTE   *int  `json:"stockLTE,omitempty"`

	// "company" edge predicates.
	HasCompany     *bool                `json:"hasCompany,omitempty"`
	HasCompanyWith []*CompanyWhereInput `json:"hasCompanyWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *ProductWhereInput) AddPredicates(predicates ...predicate.Product) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the ProductWhereInput filter on the ProductQuery builder.
func (i *ProductWhereInput) Filter(q *ProductQuery) (*ProductQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyProductWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyProductWhereInput is returned in case the ProductWhereInput is empty.
var ErrEmptyProductWhereInput = errors.New("generated: empty predicate ProductWhereInput")

// P returns a predicate for filtering products.
// An error is returned if the input is empty or invalid.
func (i *ProductWhereInput) P() (predicate.Product, error) {
	var predicates []predicate.Product
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, product.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Product, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, product.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Product, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, product.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, product.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, product.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, product.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, product.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, product.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, product.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, product.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, product.IDLTE(*i.IDLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, product.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, product.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, product.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, product.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, product.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, product.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, product.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, product.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, product.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, product.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, product.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, product.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, product.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, product.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, product.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, product.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.DeletedAt != nil {
		predicates = append(predicates, product.DeletedAtEQ(*i.DeletedAt))
	}
	if i.DeletedAtNEQ != nil {
		predicates = append(predicates, product.DeletedAtNEQ(*i.DeletedAtNEQ))
	}
	if len(i.DeletedAtIn) > 0 {
		predicates = append(predicates, product.DeletedAtIn(i.DeletedAtIn...))
	}
	if len(i.DeletedAtNotIn) > 0 {
		predicates = append(predicates, product.DeletedAtNotIn(i.DeletedAtNotIn...))
	}
	if i.DeletedAtGT != nil {
		predicates = append(predicates, product.DeletedAtGT(*i.DeletedAtGT))
	}
	if i.DeletedAtGTE != nil {
		predicates = append(predicates, product.DeletedAtGTE(*i.DeletedAtGTE))
	}
	if i.DeletedAtLT != nil {
		predicates = append(predicates, product.DeletedAtLT(*i.DeletedAtLT))
	}
	if i.DeletedAtLTE != nil {
		predicates = append(predicates, product.DeletedAtLTE(*i.DeletedAtLTE))
	}
	if i.DeletedAtIsNil {
		predicates = append(predicates, product.DeletedAtIsNil())
	}
	if i.DeletedAtNotNil {
		predicates = append(predicates, product.DeletedAtNotNil())
	}
	if i.Stock != nil {
		predicates = append(predicates, product.StockEQ(*i.Stock))
	}
	if i.StockNEQ != nil {
		predicates = append(predicates, product.StockNEQ(*i.StockNEQ))
	}
	if len(i.StockIn) > 0 {
		predicates = append(predicates, product.StockIn(i.StockIn...))
	}
	if len(i.StockNotIn) > 0 {
		predicates = append(predicates, product.StockNotIn(i.StockNotIn...))
	}
	if i.StockGT != nil {
		predicates = append(predicates, product.StockGT(*i.StockGT))
	}
	if i.StockGTE != nil {
		predicates = append(predicates, product.StockGTE(*i.StockGTE))
	}
	if i.StockLT != nil {
		predicates = append(predicates, product.StockLT(*i.StockLT))
	}
	if i.StockLTE != nil {
		predicates = append(predicates, product.StockLTE(*i.StockLTE))
	}

	if i.HasCompany != nil {
		p := product.HasCompany()
		if !*i.HasCompany {
			p = product.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasCompanyWith) > 0 {
		with := make([]predicate.Company, 0, len(i.HasCompanyWith))
		for _, w := range i.HasCompanyWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasCompanyWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, product.HasCompanyWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyProductWhereInput
	case 1:
		return predicates[0], nil
	default:
		return product.And(predicates...), nil
	}
}

// ProjectWhereInput represents a where input for filtering Project queries.
type ProjectWhereInput struct {
	Predicates []predicate.Project  `json:"-"`
	Not        *ProjectWhereInput   `json:"not,omitempty"`
	Or         []*ProjectWhereInput `json:"or,omitempty"`
	And        []*ProjectWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "createdAt" field predicates.
	CreatedAt      *time.Time  `json:"createdat,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdatNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdatIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdatNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdatGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdatGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdatLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdatLTE,omitempty"`

	// "updatedAt" field predicates.
	UpdatedAt      *time.Time  `json:"updatedat,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedatNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedatIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedatNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedatGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedatGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedatLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedatLTE,omitempty"`

	// "deletedAt" field predicates.
	DeletedAt       *time.Time  `json:"deletedat,omitempty"`
	DeletedAtNEQ    *time.Time  `json:"deletedatNEQ,omitempty"`
	DeletedAtIn     []time.Time `json:"deletedatIn,omitempty"`
	DeletedAtNotIn  []time.Time `json:"deletedatNotIn,omitempty"`
	DeletedAtGT     *time.Time  `json:"deletedatGT,omitempty"`
	DeletedAtGTE    *time.Time  `json:"deletedatGTE,omitempty"`
	DeletedAtLT     *time.Time  `json:"deletedatLT,omitempty"`
	DeletedAtLTE    *time.Time  `json:"deletedatLTE,omitempty"`
	DeletedAtIsNil  bool        `json:"deletedatIsNil,omitempty"`
	DeletedAtNotNil bool        `json:"deletedatNotNil,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "description" field predicates.
	Description             *string  `json:"description,omitempty"`
	DescriptionNEQ          *string  `json:"descriptionNEQ,omitempty"`
	DescriptionIn           []string `json:"descriptionIn,omitempty"`
	DescriptionNotIn        []string `json:"descriptionNotIn,omitempty"`
	DescriptionGT           *string  `json:"descriptionGT,omitempty"`
	DescriptionGTE          *string  `json:"descriptionGTE,omitempty"`
	DescriptionLT           *string  `json:"descriptionLT,omitempty"`
	DescriptionLTE          *string  `json:"descriptionLTE,omitempty"`
	DescriptionContains     *string  `json:"descriptionContains,omitempty"`
	DescriptionHasPrefix    *string  `json:"descriptionHasPrefix,omitempty"`
	DescriptionHasSuffix    *string  `json:"descriptionHasSuffix,omitempty"`
	DescriptionEqualFold    *string  `json:"descriptionEqualFold,omitempty"`
	DescriptionContainsFold *string  `json:"descriptionContainsFold,omitempty"`

	// "plannedStartDate" field predicates.
	PlannedStartDate      *time.Time  `json:"plannedstartdate,omitempty"`
	PlannedStartDateNEQ   *time.Time  `json:"plannedstartdateNEQ,omitempty"`
	PlannedStartDateIn    []time.Time `json:"plannedstartdateIn,omitempty"`
	PlannedStartDateNotIn []time.Time `json:"plannedstartdateNotIn,omitempty"`
	PlannedStartDateGT    *time.Time  `json:"plannedstartdateGT,omitempty"`
	PlannedStartDateGTE   *time.Time  `json:"plannedstartdateGTE,omitempty"`
	PlannedStartDateLT    *time.Time  `json:"plannedstartdateLT,omitempty"`
	PlannedStartDateLTE   *time.Time  `json:"plannedstartdateLTE,omitempty"`

	// "actualStartDate" field predicates.
	ActualStartDate       *time.Time  `json:"actualstartdate,omitempty"`
	ActualStartDateNEQ    *time.Time  `json:"actualstartdateNEQ,omitempty"`
	ActualStartDateIn     []time.Time `json:"actualstartdateIn,omitempty"`
	ActualStartDateNotIn  []time.Time `json:"actualstartdateNotIn,omitempty"`
	ActualStartDateGT     *time.Time  `json:"actualstartdateGT,omitempty"`
	ActualStartDateGTE    *time.Time  `json:"actualstartdateGTE,omitempty"`
	ActualStartDateLT     *time.Time  `json:"actualstartdateLT,omitempty"`
	ActualStartDateLTE    *time.Time  `json:"actualstartdateLTE,omitempty"`
	ActualStartDateIsNil  bool        `json:"actualstartdateIsNil,omitempty"`
	ActualStartDateNotNil bool        `json:"actualstartdateNotNil,omitempty"`

	// "plannedEndDate" field predicates.
	PlannedEndDate      *time.Time  `json:"plannedenddate,omitempty"`
	PlannedEndDateNEQ   *time.Time  `json:"plannedenddateNEQ,omitempty"`
	PlannedEndDateIn    []time.Time `json:"plannedenddateIn,omitempty"`
	PlannedEndDateNotIn []time.Time `json:"plannedenddateNotIn,omitempty"`
	PlannedEndDateGT    *time.Time  `json:"plannedenddateGT,omitempty"`
	PlannedEndDateGTE   *time.Time  `json:"plannedenddateGTE,omitempty"`
	PlannedEndDateLT    *time.Time  `json:"plannedenddateLT,omitempty"`
	PlannedEndDateLTE   *time.Time  `json:"plannedenddateLTE,omitempty"`

	// "actualEndDate" field predicates.
	ActualEndDate       *time.Time  `json:"actualenddate,omitempty"`
	ActualEndDateNEQ    *time.Time  `json:"actualenddateNEQ,omitempty"`
	ActualEndDateIn     []time.Time `json:"actualenddateIn,omitempty"`
	ActualEndDateNotIn  []time.Time `json:"actualenddateNotIn,omitempty"`
	ActualEndDateGT     *time.Time  `json:"actualenddateGT,omitempty"`
	ActualEndDateGTE    *time.Time  `json:"actualenddateGTE,omitempty"`
	ActualEndDateLT     *time.Time  `json:"actualenddateLT,omitempty"`
	ActualEndDateLTE    *time.Time  `json:"actualenddateLTE,omitempty"`
	ActualEndDateIsNil  bool        `json:"actualenddateIsNil,omitempty"`
	ActualEndDateNotNil bool        `json:"actualenddateNotNil,omitempty"`

	// "progress" field predicates.
	Progress      *float64  `json:"progress,omitempty"`
	ProgressNEQ   *float64  `json:"progressNEQ,omitempty"`
	ProgressIn    []float64 `json:"progressIn,omitempty"`
	ProgressNotIn []float64 `json:"progressNotIn,omitempty"`
	ProgressGT    *float64  `json:"progressGT,omitempty"`
	ProgressGTE   *float64  `json:"progressGTE,omitempty"`
	ProgressLT    *float64  `json:"progressLT,omitempty"`
	ProgressLTE   *float64  `json:"progressLTE,omitempty"`

	// "status" field predicates.
	Status      *project.Status  `json:"status,omitempty"`
	StatusNEQ   *project.Status  `json:"statusNEQ,omitempty"`
	StatusIn    []project.Status `json:"statusIn,omitempty"`
	StatusNotIn []project.Status `json:"statusNotIn,omitempty"`

	// "company" edge predicates.
	HasCompany     *bool                `json:"hasCompany,omitempty"`
	HasCompanyWith []*CompanyWhereInput `json:"hasCompanyWith,omitempty"`

	// "createdBy" edge predicates.
	HasCreatedBy     *bool             `json:"hasCreatedBy,omitempty"`
	HasCreatedByWith []*UserWhereInput `json:"hasCreatedByWith,omitempty"`

	// "leader" edge predicates.
	HasLeader     *bool             `json:"hasLeader,omitempty"`
	HasLeaderWith []*UserWhereInput `json:"hasLeaderWith,omitempty"`

	// "tasks" edge predicates.
	HasTasks     *bool                    `json:"hasTasks,omitempty"`
	HasTasksWith []*ProjectTaskWhereInput `json:"hasTasksWith,omitempty"`

	// "milestones" edge predicates.
	HasMilestones     *bool                         `json:"hasMilestones,omitempty"`
	HasMilestonesWith []*ProjectMilestoneWhereInput `json:"hasMilestonesWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *ProjectWhereInput) AddPredicates(predicates ...predicate.Project) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the ProjectWhereInput filter on the ProjectQuery builder.
func (i *ProjectWhereInput) Filter(q *ProjectQuery) (*ProjectQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyProjectWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyProjectWhereInput is returned in case the ProjectWhereInput is empty.
var ErrEmptyProjectWhereInput = errors.New("generated: empty predicate ProjectWhereInput")

// P returns a predicate for filtering projects.
// An error is returned if the input is empty or invalid.
func (i *ProjectWhereInput) P() (predicate.Project, error) {
	var predicates []predicate.Project
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, project.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Project, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, project.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Project, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, project.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, project.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, project.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, project.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, project.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, project.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, project.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, project.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, project.IDLTE(*i.IDLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, project.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, project.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, project.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, project.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, project.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, project.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, project.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, project.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, project.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, project.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, project.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, project.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, project.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, project.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, project.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, project.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.DeletedAt != nil {
		predicates = append(predicates, project.DeletedAtEQ(*i.DeletedAt))
	}
	if i.DeletedAtNEQ != nil {
		predicates = append(predicates, project.DeletedAtNEQ(*i.DeletedAtNEQ))
	}
	if len(i.DeletedAtIn) > 0 {
		predicates = append(predicates, project.DeletedAtIn(i.DeletedAtIn...))
	}
	if len(i.DeletedAtNotIn) > 0 {
		predicates = append(predicates, project.DeletedAtNotIn(i.DeletedAtNotIn...))
	}
	if i.DeletedAtGT != nil {
		predicates = append(predicates, project.DeletedAtGT(*i.DeletedAtGT))
	}
	if i.DeletedAtGTE != nil {
		predicates = append(predicates, project.DeletedAtGTE(*i.DeletedAtGTE))
	}
	if i.DeletedAtLT != nil {
		predicates = append(predicates, project.DeletedAtLT(*i.DeletedAtLT))
	}
	if i.DeletedAtLTE != nil {
		predicates = append(predicates, project.DeletedAtLTE(*i.DeletedAtLTE))
	}
	if i.DeletedAtIsNil {
		predicates = append(predicates, project.DeletedAtIsNil())
	}
	if i.DeletedAtNotNil {
		predicates = append(predicates, project.DeletedAtNotNil())
	}
	if i.Name != nil {
		predicates = append(predicates, project.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, project.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, project.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, project.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, project.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, project.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, project.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, project.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, project.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, project.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, project.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, project.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, project.NameContainsFold(*i.NameContainsFold))
	}
	if i.Description != nil {
		predicates = append(predicates, project.DescriptionEQ(*i.Description))
	}
	if i.DescriptionNEQ != nil {
		predicates = append(predicates, project.DescriptionNEQ(*i.DescriptionNEQ))
	}
	if len(i.DescriptionIn) > 0 {
		predicates = append(predicates, project.DescriptionIn(i.DescriptionIn...))
	}
	if len(i.DescriptionNotIn) > 0 {
		predicates = append(predicates, project.DescriptionNotIn(i.DescriptionNotIn...))
	}
	if i.DescriptionGT != nil {
		predicates = append(predicates, project.DescriptionGT(*i.DescriptionGT))
	}
	if i.DescriptionGTE != nil {
		predicates = append(predicates, project.DescriptionGTE(*i.DescriptionGTE))
	}
	if i.DescriptionLT != nil {
		predicates = append(predicates, project.DescriptionLT(*i.DescriptionLT))
	}
	if i.DescriptionLTE != nil {
		predicates = append(predicates, project.DescriptionLTE(*i.DescriptionLTE))
	}
	if i.DescriptionContains != nil {
		predicates = append(predicates, project.DescriptionContains(*i.DescriptionContains))
	}
	if i.DescriptionHasPrefix != nil {
		predicates = append(predicates, project.DescriptionHasPrefix(*i.DescriptionHasPrefix))
	}
	if i.DescriptionHasSuffix != nil {
		predicates = append(predicates, project.DescriptionHasSuffix(*i.DescriptionHasSuffix))
	}
	if i.DescriptionEqualFold != nil {
		predicates = append(predicates, project.DescriptionEqualFold(*i.DescriptionEqualFold))
	}
	if i.DescriptionContainsFold != nil {
		predicates = append(predicates, project.DescriptionContainsFold(*i.DescriptionContainsFold))
	}
	if i.PlannedStartDate != nil {
		predicates = append(predicates, project.PlannedStartDateEQ(*i.PlannedStartDate))
	}
	if i.PlannedStartDateNEQ != nil {
		predicates = append(predicates, project.PlannedStartDateNEQ(*i.PlannedStartDateNEQ))
	}
	if len(i.PlannedStartDateIn) > 0 {
		predicates = append(predicates, project.PlannedStartDateIn(i.PlannedStartDateIn...))
	}
	if len(i.PlannedStartDateNotIn) > 0 {
		predicates = append(predicates, project.PlannedStartDateNotIn(i.PlannedStartDateNotIn...))
	}
	if i.PlannedStartDateGT != nil {
		predicates = append(predicates, project.PlannedStartDateGT(*i.PlannedStartDateGT))
	}
	if i.PlannedStartDateGTE != nil {
		predicates = append(predicates, project.PlannedStartDateGTE(*i.PlannedStartDateGTE))
	}
	if i.PlannedStartDateLT != nil {
		predicates = append(predicates, project.PlannedStartDateLT(*i.PlannedStartDateLT))
	}
	if i.PlannedStartDateLTE != nil {
		predicates = append(predicates, project.PlannedStartDateLTE(*i.PlannedStartDateLTE))
	}
	if i.ActualStartDate != nil {
		predicates = append(predicates, project.ActualStartDateEQ(*i.ActualStartDate))
	}
	if i.ActualStartDateNEQ != nil {
		predicates = append(predicates, project.ActualStartDateNEQ(*i.ActualStartDateNEQ))
	}
	if len(i.ActualStartDateIn) > 0 {
		predicates = append(predicates, project.ActualStartDateIn(i.ActualStartDateIn...))
	}
	if len(i.ActualStartDateNotIn) > 0 {
		predicates = append(predicates, project.ActualStartDateNotIn(i.ActualStartDateNotIn...))
	}
	if i.ActualStartDateGT != nil {
		predicates = append(predicates, project.ActualStartDateGT(*i.ActualStartDateGT))
	}
	if i.ActualStartDateGTE != nil {
		predicates = append(predicates, project.ActualStartDateGTE(*i.ActualStartDateGTE))
	}
	if i.ActualStartDateLT != nil {
		predicates = append(predicates, project.ActualStartDateLT(*i.ActualStartDateLT))
	}
	if i.ActualStartDateLTE != nil {
		predicates = append(predicates, project.ActualStartDateLTE(*i.ActualStartDateLTE))
	}
	if i.ActualStartDateIsNil {
		predicates = append(predicates, project.ActualStartDateIsNil())
	}
	if i.ActualStartDateNotNil {
		predicates = append(predicates, project.ActualStartDateNotNil())
	}
	if i.PlannedEndDate != nil {
		predicates = append(predicates, project.PlannedEndDateEQ(*i.PlannedEndDate))
	}
	if i.PlannedEndDateNEQ != nil {
		predicates = append(predicates, project.PlannedEndDateNEQ(*i.PlannedEndDateNEQ))
	}
	if len(i.PlannedEndDateIn) > 0 {
		predicates = append(predicates, project.PlannedEndDateIn(i.PlannedEndDateIn...))
	}
	if len(i.PlannedEndDateNotIn) > 0 {
		predicates = append(predicates, project.PlannedEndDateNotIn(i.PlannedEndDateNotIn...))
	}
	if i.PlannedEndDateGT != nil {
		predicates = append(predicates, project.PlannedEndDateGT(*i.PlannedEndDateGT))
	}
	if i.PlannedEndDateGTE != nil {
		predicates = append(predicates, project.PlannedEndDateGTE(*i.PlannedEndDateGTE))
	}
	if i.PlannedEndDateLT != nil {
		predicates = append(predicates, project.PlannedEndDateLT(*i.PlannedEndDateLT))
	}
	if i.PlannedEndDateLTE != nil {
		predicates = append(predicates, project.PlannedEndDateLTE(*i.PlannedEndDateLTE))
	}
	if i.ActualEndDate != nil {
		predicates = append(predicates, project.ActualEndDateEQ(*i.ActualEndDate))
	}
	if i.ActualEndDateNEQ != nil {
		predicates = append(predicates, project.ActualEndDateNEQ(*i.ActualEndDateNEQ))
	}
	if len(i.ActualEndDateIn) > 0 {
		predicates = append(predicates, project.ActualEndDateIn(i.ActualEndDateIn...))
	}
	if len(i.ActualEndDateNotIn) > 0 {
		predicates = append(predicates, project.ActualEndDateNotIn(i.ActualEndDateNotIn...))
	}
	if i.ActualEndDateGT != nil {
		predicates = append(predicates, project.ActualEndDateGT(*i.ActualEndDateGT))
	}
	if i.ActualEndDateGTE != nil {
		predicates = append(predicates, project.ActualEndDateGTE(*i.ActualEndDateGTE))
	}
	if i.ActualEndDateLT != nil {
		predicates = append(predicates, project.ActualEndDateLT(*i.ActualEndDateLT))
	}
	if i.ActualEndDateLTE != nil {
		predicates = append(predicates, project.ActualEndDateLTE(*i.ActualEndDateLTE))
	}
	if i.ActualEndDateIsNil {
		predicates = append(predicates, project.ActualEndDateIsNil())
	}
	if i.ActualEndDateNotNil {
		predicates = append(predicates, project.ActualEndDateNotNil())
	}
	if i.Progress != nil {
		predicates = append(predicates, project.ProgressEQ(*i.Progress))
	}
	if i.ProgressNEQ != nil {
		predicates = append(predicates, project.ProgressNEQ(*i.ProgressNEQ))
	}
	if len(i.ProgressIn) > 0 {
		predicates = append(predicates, project.ProgressIn(i.ProgressIn...))
	}
	if len(i.ProgressNotIn) > 0 {
		predicates = append(predicates, project.ProgressNotIn(i.ProgressNotIn...))
	}
	if i.ProgressGT != nil {
		predicates = append(predicates, project.ProgressGT(*i.ProgressGT))
	}
	if i.ProgressGTE != nil {
		predicates = append(predicates, project.ProgressGTE(*i.ProgressGTE))
	}
	if i.ProgressLT != nil {
		predicates = append(predicates, project.ProgressLT(*i.ProgressLT))
	}
	if i.ProgressLTE != nil {
		predicates = append(predicates, project.ProgressLTE(*i.ProgressLTE))
	}
	if i.Status != nil {
		predicates = append(predicates, project.StatusEQ(*i.Status))
	}
	if i.StatusNEQ != nil {
		predicates = append(predicates, project.StatusNEQ(*i.StatusNEQ))
	}
	if len(i.StatusIn) > 0 {
		predicates = append(predicates, project.StatusIn(i.StatusIn...))
	}
	if len(i.StatusNotIn) > 0 {
		predicates = append(predicates, project.StatusNotIn(i.StatusNotIn...))
	}

	if i.HasCompany != nil {
		p := project.HasCompany()
		if !*i.HasCompany {
			p = project.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasCompanyWith) > 0 {
		with := make([]predicate.Company, 0, len(i.HasCompanyWith))
		for _, w := range i.HasCompanyWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasCompanyWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, project.HasCompanyWith(with...))
	}
	if i.HasCreatedBy != nil {
		p := project.HasCreatedBy()
		if !*i.HasCreatedBy {
			p = project.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasCreatedByWith) > 0 {
		with := make([]predicate.User, 0, len(i.HasCreatedByWith))
		for _, w := range i.HasCreatedByWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasCreatedByWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, project.HasCreatedByWith(with...))
	}
	if i.HasLeader != nil {
		p := project.HasLeader()
		if !*i.HasLeader {
			p = project.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasLeaderWith) > 0 {
		with := make([]predicate.User, 0, len(i.HasLeaderWith))
		for _, w := range i.HasLeaderWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasLeaderWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, project.HasLeaderWith(with...))
	}
	if i.HasTasks != nil {
		p := project.HasTasks()
		if !*i.HasTasks {
			p = project.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasTasksWith) > 0 {
		with := make([]predicate.ProjectTask, 0, len(i.HasTasksWith))
		for _, w := range i.HasTasksWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasTasksWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, project.HasTasksWith(with...))
	}
	if i.HasMilestones != nil {
		p := project.HasMilestones()
		if !*i.HasMilestones {
			p = project.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasMilestonesWith) > 0 {
		with := make([]predicate.ProjectMilestone, 0, len(i.HasMilestonesWith))
		for _, w := range i.HasMilestonesWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasMilestonesWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, project.HasMilestonesWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyProjectWhereInput
	case 1:
		return predicates[0], nil
	default:
		return project.And(predicates...), nil
	}
}

// ProjectMilestoneWhereInput represents a where input for filtering ProjectMilestone queries.
type ProjectMilestoneWhereInput struct {
	Predicates []predicate.ProjectMilestone  `json:"-"`
	Not        *ProjectMilestoneWhereInput   `json:"not,omitempty"`
	Or         []*ProjectMilestoneWhereInput `json:"or,omitempty"`
	And        []*ProjectMilestoneWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "dueDate" field predicates.
	DueDate      *time.Time  `json:"duedate,omitempty"`
	DueDateNEQ   *time.Time  `json:"duedateNEQ,omitempty"`
	DueDateIn    []time.Time `json:"duedateIn,omitempty"`
	DueDateNotIn []time.Time `json:"duedateNotIn,omitempty"`
	DueDateGT    *time.Time  `json:"duedateGT,omitempty"`
	DueDateGTE   *time.Time  `json:"duedateGTE,omitempty"`
	DueDateLT    *time.Time  `json:"duedateLT,omitempty"`
	DueDateLTE   *time.Time  `json:"duedateLTE,omitempty"`

	// "project" edge predicates.
	HasProject     *bool                `json:"hasProject,omitempty"`
	HasProjectWith []*ProjectWhereInput `json:"hasProjectWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *ProjectMilestoneWhereInput) AddPredicates(predicates ...predicate.ProjectMilestone) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the ProjectMilestoneWhereInput filter on the ProjectMilestoneQuery builder.
func (i *ProjectMilestoneWhereInput) Filter(q *ProjectMilestoneQuery) (*ProjectMilestoneQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyProjectMilestoneWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyProjectMilestoneWhereInput is returned in case the ProjectMilestoneWhereInput is empty.
var ErrEmptyProjectMilestoneWhereInput = errors.New("generated: empty predicate ProjectMilestoneWhereInput")

// P returns a predicate for filtering projectmilestones.
// An error is returned if the input is empty or invalid.
func (i *ProjectMilestoneWhereInput) P() (predicate.ProjectMilestone, error) {
	var predicates []predicate.ProjectMilestone
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, projectmilestone.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.ProjectMilestone, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, projectmilestone.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.ProjectMilestone, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, projectmilestone.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, projectmilestone.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, projectmilestone.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, projectmilestone.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, projectmilestone.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, projectmilestone.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, projectmilestone.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, projectmilestone.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, projectmilestone.IDLTE(*i.IDLTE))
	}
	if i.Name != nil {
		predicates = append(predicates, projectmilestone.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, projectmilestone.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, projectmilestone.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, projectmilestone.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, projectmilestone.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, projectmilestone.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, projectmilestone.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, projectmilestone.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, projectmilestone.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, projectmilestone.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, projectmilestone.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, projectmilestone.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, projectmilestone.NameContainsFold(*i.NameContainsFold))
	}
	if i.DueDate != nil {
		predicates = append(predicates, projectmilestone.DueDateEQ(*i.DueDate))
	}
	if i.DueDateNEQ != nil {
		predicates = append(predicates, projectmilestone.DueDateNEQ(*i.DueDateNEQ))
	}
	if len(i.DueDateIn) > 0 {
		predicates = append(predicates, projectmilestone.DueDateIn(i.DueDateIn...))
	}
	if len(i.DueDateNotIn) > 0 {
		predicates = append(predicates, projectmilestone.DueDateNotIn(i.DueDateNotIn...))
	}
	if i.DueDateGT != nil {
		predicates = append(predicates, projectmilestone.DueDateGT(*i.DueDateGT))
	}
	if i.DueDateGTE != nil {
		predicates = append(predicates, projectmilestone.DueDateGTE(*i.DueDateGTE))
	}
	if i.DueDateLT != nil {
		predicates = append(predicates, projectmilestone.DueDateLT(*i.DueDateLT))
	}
	if i.DueDateLTE != nil {
		predicates = append(predicates, projectmilestone.DueDateLTE(*i.DueDateLTE))
	}

	if i.HasProject != nil {
		p := projectmilestone.HasProject()
		if !*i.HasProject {
			p = projectmilestone.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasProjectWith) > 0 {
		with := make([]predicate.Project, 0, len(i.HasProjectWith))
		for _, w := range i.HasProjectWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasProjectWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, projectmilestone.HasProjectWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyProjectMilestoneWhereInput
	case 1:
		return predicates[0], nil
	default:
		return projectmilestone.And(predicates...), nil
	}
}

// ProjectTaskWhereInput represents a where input for filtering ProjectTask queries.
type ProjectTaskWhereInput struct {
	Predicates []predicate.ProjectTask  `json:"-"`
	Not        *ProjectTaskWhereInput   `json:"not,omitempty"`
	Or         []*ProjectTaskWhereInput `json:"or,omitempty"`
	And        []*ProjectTaskWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "createdAt" field predicates.
	CreatedAt       *time.Time  `json:"createdat,omitempty"`
	CreatedAtNEQ    *time.Time  `json:"createdatNEQ,omitempty"`
	CreatedAtIn     []time.Time `json:"createdatIn,omitempty"`
	CreatedAtNotIn  []time.Time `json:"createdatNotIn,omitempty"`
	CreatedAtGT     *time.Time  `json:"createdatGT,omitempty"`
	CreatedAtGTE    *time.Time  `json:"createdatGTE,omitempty"`
	CreatedAtLT     *time.Time  `json:"createdatLT,omitempty"`
	CreatedAtLTE    *time.Time  `json:"createdatLTE,omitempty"`
	CreatedAtIsNil  bool        `json:"createdatIsNil,omitempty"`
	CreatedAtNotNil bool        `json:"createdatNotNil,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "assigneeName" field predicates.
	AssigneeName             *string  `json:"assigneename,omitempty"`
	AssigneeNameNEQ          *string  `json:"assigneenameNEQ,omitempty"`
	AssigneeNameIn           []string `json:"assigneenameIn,omitempty"`
	AssigneeNameNotIn        []string `json:"assigneenameNotIn,omitempty"`
	AssigneeNameGT           *string  `json:"assigneenameGT,omitempty"`
	AssigneeNameGTE          *string  `json:"assigneenameGTE,omitempty"`
	AssigneeNameLT           *string  `json:"assigneenameLT,omitempty"`
	AssigneeNameLTE          *string  `json:"assigneenameLTE,omitempty"`
	AssigneeNameContains     *string  `json:"assigneenameContains,omitempty"`
	AssigneeNameHasPrefix    *string  `json:"assigneenameHasPrefix,omitempty"`
	AssigneeNameHasSuffix    *string  `json:"assigneenameHasSuffix,omitempty"`
	AssigneeNameEqualFold    *string  `json:"assigneenameEqualFold,omitempty"`
	AssigneeNameContainsFold *string  `json:"assigneenameContainsFold,omitempty"`

	// "location" field predicates.
	Location             *string  `json:"location,omitempty"`
	LocationNEQ          *string  `json:"locationNEQ,omitempty"`
	LocationIn           []string `json:"locationIn,omitempty"`
	LocationNotIn        []string `json:"locationNotIn,omitempty"`
	LocationGT           *string  `json:"locationGT,omitempty"`
	LocationGTE          *string  `json:"locationGTE,omitempty"`
	LocationLT           *string  `json:"locationLT,omitempty"`
	LocationLTE          *string  `json:"locationLTE,omitempty"`
	LocationContains     *string  `json:"locationContains,omitempty"`
	LocationHasPrefix    *string  `json:"locationHasPrefix,omitempty"`
	LocationHasSuffix    *string  `json:"locationHasSuffix,omitempty"`
	LocationIsNil        bool     `json:"locationIsNil,omitempty"`
	LocationNotNil       bool     `json:"locationNotNil,omitempty"`
	LocationEqualFold    *string  `json:"locationEqualFold,omitempty"`
	LocationContainsFold *string  `json:"locationContainsFold,omitempty"`

	// "dueDate" field predicates.
	DueDate      *time.Time  `json:"duedate,omitempty"`
	DueDateNEQ   *time.Time  `json:"duedateNEQ,omitempty"`
	DueDateIn    []time.Time `json:"duedateIn,omitempty"`
	DueDateNotIn []time.Time `json:"duedateNotIn,omitempty"`
	DueDateGT    *time.Time  `json:"duedateGT,omitempty"`
	DueDateGTE   *time.Time  `json:"duedateGTE,omitempty"`
	DueDateLT    *time.Time  `json:"duedateLT,omitempty"`
	DueDateLTE   *time.Time  `json:"duedateLTE,omitempty"`

	// "startDate" field predicates.
	StartDate      *time.Time  `json:"startdate,omitempty"`
	StartDateNEQ   *time.Time  `json:"startdateNEQ,omitempty"`
	StartDateIn    []time.Time `json:"startdateIn,omitempty"`
	StartDateNotIn []time.Time `json:"startdateNotIn,omitempty"`
	StartDateGT    *time.Time  `json:"startdateGT,omitempty"`
	StartDateGTE   *time.Time  `json:"startdateGTE,omitempty"`
	StartDateLT    *time.Time  `json:"startdateLT,omitempty"`
	StartDateLTE   *time.Time  `json:"startdateLTE,omitempty"`

	// "endDate" field predicates.
	EndDate       *time.Time  `json:"enddate,omitempty"`
	EndDateNEQ    *time.Time  `json:"enddateNEQ,omitempty"`
	EndDateIn     []time.Time `json:"enddateIn,omitempty"`
	EndDateNotIn  []time.Time `json:"enddateNotIn,omitempty"`
	EndDateGT     *time.Time  `json:"enddateGT,omitempty"`
	EndDateGTE    *time.Time  `json:"enddateGTE,omitempty"`
	EndDateLT     *time.Time  `json:"enddateLT,omitempty"`
	EndDateLTE    *time.Time  `json:"enddateLTE,omitempty"`
	EndDateIsNil  bool        `json:"enddateIsNil,omitempty"`
	EndDateNotNil bool        `json:"enddateNotNil,omitempty"`

	// "description" field predicates.
	Description             *string  `json:"description,omitempty"`
	DescriptionNEQ          *string  `json:"descriptionNEQ,omitempty"`
	DescriptionIn           []string `json:"descriptionIn,omitempty"`
	DescriptionNotIn        []string `json:"descriptionNotIn,omitempty"`
	DescriptionGT           *string  `json:"descriptionGT,omitempty"`
	DescriptionGTE          *string  `json:"descriptionGTE,omitempty"`
	DescriptionLT           *string  `json:"descriptionLT,omitempty"`
	DescriptionLTE          *string  `json:"descriptionLTE,omitempty"`
	DescriptionContains     *string  `json:"descriptionContains,omitempty"`
	DescriptionHasPrefix    *string  `json:"descriptionHasPrefix,omitempty"`
	DescriptionHasSuffix    *string  `json:"descriptionHasSuffix,omitempty"`
	DescriptionIsNil        bool     `json:"descriptionIsNil,omitempty"`
	DescriptionNotNil       bool     `json:"descriptionNotNil,omitempty"`
	DescriptionEqualFold    *string  `json:"descriptionEqualFold,omitempty"`
	DescriptionContainsFold *string  `json:"descriptionContainsFold,omitempty"`

	// "status" field predicates.
	Status      *projecttask.Status  `json:"status,omitempty"`
	StatusNEQ   *projecttask.Status  `json:"statusNEQ,omitempty"`
	StatusIn    []projecttask.Status `json:"statusIn,omitempty"`
	StatusNotIn []projecttask.Status `json:"statusNotIn,omitempty"`

	// "project" edge predicates.
	HasProject     *bool                `json:"hasProject,omitempty"`
	HasProjectWith []*ProjectWhereInput `json:"hasProjectWith,omitempty"`

	// "assignee" edge predicates.
	HasAssignee     *bool             `json:"hasAssignee,omitempty"`
	HasAssigneeWith []*UserWhereInput `json:"hasAssigneeWith,omitempty"`

	// "participants" edge predicates.
	HasParticipants     *bool             `json:"hasParticipants,omitempty"`
	HasParticipantsWith []*UserWhereInput `json:"hasParticipantsWith,omitempty"`

	// "createdBy" edge predicates.
	HasCreatedBy     *bool             `json:"hasCreatedBy,omitempty"`
	HasCreatedByWith []*UserWhereInput `json:"hasCreatedByWith,omitempty"`

	// "workShifts" edge predicates.
	HasWorkShifts     *bool                  `json:"hasWorkShifts,omitempty"`
	HasWorkShiftsWith []*WorkshiftWhereInput `json:"hasWorkShiftsWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *ProjectTaskWhereInput) AddPredicates(predicates ...predicate.ProjectTask) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the ProjectTaskWhereInput filter on the ProjectTaskQuery builder.
func (i *ProjectTaskWhereInput) Filter(q *ProjectTaskQuery) (*ProjectTaskQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyProjectTaskWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyProjectTaskWhereInput is returned in case the ProjectTaskWhereInput is empty.
var ErrEmptyProjectTaskWhereInput = errors.New("generated: empty predicate ProjectTaskWhereInput")

// P returns a predicate for filtering projecttasks.
// An error is returned if the input is empty or invalid.
func (i *ProjectTaskWhereInput) P() (predicate.ProjectTask, error) {
	var predicates []predicate.ProjectTask
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, projecttask.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.ProjectTask, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, projecttask.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.ProjectTask, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, projecttask.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, projecttask.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, projecttask.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, projecttask.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, projecttask.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, projecttask.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, projecttask.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, projecttask.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, projecttask.IDLTE(*i.IDLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, projecttask.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, projecttask.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, projecttask.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, projecttask.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, projecttask.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, projecttask.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, projecttask.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, projecttask.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.CreatedAtIsNil {
		predicates = append(predicates, projecttask.CreatedAtIsNil())
	}
	if i.CreatedAtNotNil {
		predicates = append(predicates, projecttask.CreatedAtNotNil())
	}
	if i.Name != nil {
		predicates = append(predicates, projecttask.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, projecttask.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, projecttask.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, projecttask.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, projecttask.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, projecttask.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, projecttask.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, projecttask.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, projecttask.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, projecttask.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, projecttask.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, projecttask.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, projecttask.NameContainsFold(*i.NameContainsFold))
	}
	if i.AssigneeName != nil {
		predicates = append(predicates, projecttask.AssigneeNameEQ(*i.AssigneeName))
	}
	if i.AssigneeNameNEQ != nil {
		predicates = append(predicates, projecttask.AssigneeNameNEQ(*i.AssigneeNameNEQ))
	}
	if len(i.AssigneeNameIn) > 0 {
		predicates = append(predicates, projecttask.AssigneeNameIn(i.AssigneeNameIn...))
	}
	if len(i.AssigneeNameNotIn) > 0 {
		predicates = append(predicates, projecttask.AssigneeNameNotIn(i.AssigneeNameNotIn...))
	}
	if i.AssigneeNameGT != nil {
		predicates = append(predicates, projecttask.AssigneeNameGT(*i.AssigneeNameGT))
	}
	if i.AssigneeNameGTE != nil {
		predicates = append(predicates, projecttask.AssigneeNameGTE(*i.AssigneeNameGTE))
	}
	if i.AssigneeNameLT != nil {
		predicates = append(predicates, projecttask.AssigneeNameLT(*i.AssigneeNameLT))
	}
	if i.AssigneeNameLTE != nil {
		predicates = append(predicates, projecttask.AssigneeNameLTE(*i.AssigneeNameLTE))
	}
	if i.AssigneeNameContains != nil {
		predicates = append(predicates, projecttask.AssigneeNameContains(*i.AssigneeNameContains))
	}
	if i.AssigneeNameHasPrefix != nil {
		predicates = append(predicates, projecttask.AssigneeNameHasPrefix(*i.AssigneeNameHasPrefix))
	}
	if i.AssigneeNameHasSuffix != nil {
		predicates = append(predicates, projecttask.AssigneeNameHasSuffix(*i.AssigneeNameHasSuffix))
	}
	if i.AssigneeNameEqualFold != nil {
		predicates = append(predicates, projecttask.AssigneeNameEqualFold(*i.AssigneeNameEqualFold))
	}
	if i.AssigneeNameContainsFold != nil {
		predicates = append(predicates, projecttask.AssigneeNameContainsFold(*i.AssigneeNameContainsFold))
	}
	if i.Location != nil {
		predicates = append(predicates, projecttask.LocationEQ(*i.Location))
	}
	if i.LocationNEQ != nil {
		predicates = append(predicates, projecttask.LocationNEQ(*i.LocationNEQ))
	}
	if len(i.LocationIn) > 0 {
		predicates = append(predicates, projecttask.LocationIn(i.LocationIn...))
	}
	if len(i.LocationNotIn) > 0 {
		predicates = append(predicates, projecttask.LocationNotIn(i.LocationNotIn...))
	}
	if i.LocationGT != nil {
		predicates = append(predicates, projecttask.LocationGT(*i.LocationGT))
	}
	if i.LocationGTE != nil {
		predicates = append(predicates, projecttask.LocationGTE(*i.LocationGTE))
	}
	if i.LocationLT != nil {
		predicates = append(predicates, projecttask.LocationLT(*i.LocationLT))
	}
	if i.LocationLTE != nil {
		predicates = append(predicates, projecttask.LocationLTE(*i.LocationLTE))
	}
	if i.LocationContains != nil {
		predicates = append(predicates, projecttask.LocationContains(*i.LocationContains))
	}
	if i.LocationHasPrefix != nil {
		predicates = append(predicates, projecttask.LocationHasPrefix(*i.LocationHasPrefix))
	}
	if i.LocationHasSuffix != nil {
		predicates = append(predicates, projecttask.LocationHasSuffix(*i.LocationHasSuffix))
	}
	if i.LocationIsNil {
		predicates = append(predicates, projecttask.LocationIsNil())
	}
	if i.LocationNotNil {
		predicates = append(predicates, projecttask.LocationNotNil())
	}
	if i.LocationEqualFold != nil {
		predicates = append(predicates, projecttask.LocationEqualFold(*i.LocationEqualFold))
	}
	if i.LocationContainsFold != nil {
		predicates = append(predicates, projecttask.LocationContainsFold(*i.LocationContainsFold))
	}
	if i.DueDate != nil {
		predicates = append(predicates, projecttask.DueDateEQ(*i.DueDate))
	}
	if i.DueDateNEQ != nil {
		predicates = append(predicates, projecttask.DueDateNEQ(*i.DueDateNEQ))
	}
	if len(i.DueDateIn) > 0 {
		predicates = append(predicates, projecttask.DueDateIn(i.DueDateIn...))
	}
	if len(i.DueDateNotIn) > 0 {
		predicates = append(predicates, projecttask.DueDateNotIn(i.DueDateNotIn...))
	}
	if i.DueDateGT != nil {
		predicates = append(predicates, projecttask.DueDateGT(*i.DueDateGT))
	}
	if i.DueDateGTE != nil {
		predicates = append(predicates, projecttask.DueDateGTE(*i.DueDateGTE))
	}
	if i.DueDateLT != nil {
		predicates = append(predicates, projecttask.DueDateLT(*i.DueDateLT))
	}
	if i.DueDateLTE != nil {
		predicates = append(predicates, projecttask.DueDateLTE(*i.DueDateLTE))
	}
	if i.StartDate != nil {
		predicates = append(predicates, projecttask.StartDateEQ(*i.StartDate))
	}
	if i.StartDateNEQ != nil {
		predicates = append(predicates, projecttask.StartDateNEQ(*i.StartDateNEQ))
	}
	if len(i.StartDateIn) > 0 {
		predicates = append(predicates, projecttask.StartDateIn(i.StartDateIn...))
	}
	if len(i.StartDateNotIn) > 0 {
		predicates = append(predicates, projecttask.StartDateNotIn(i.StartDateNotIn...))
	}
	if i.StartDateGT != nil {
		predicates = append(predicates, projecttask.StartDateGT(*i.StartDateGT))
	}
	if i.StartDateGTE != nil {
		predicates = append(predicates, projecttask.StartDateGTE(*i.StartDateGTE))
	}
	if i.StartDateLT != nil {
		predicates = append(predicates, projecttask.StartDateLT(*i.StartDateLT))
	}
	if i.StartDateLTE != nil {
		predicates = append(predicates, projecttask.StartDateLTE(*i.StartDateLTE))
	}
	if i.EndDate != nil {
		predicates = append(predicates, projecttask.EndDateEQ(*i.EndDate))
	}
	if i.EndDateNEQ != nil {
		predicates = append(predicates, projecttask.EndDateNEQ(*i.EndDateNEQ))
	}
	if len(i.EndDateIn) > 0 {
		predicates = append(predicates, projecttask.EndDateIn(i.EndDateIn...))
	}
	if len(i.EndDateNotIn) > 0 {
		predicates = append(predicates, projecttask.EndDateNotIn(i.EndDateNotIn...))
	}
	if i.EndDateGT != nil {
		predicates = append(predicates, projecttask.EndDateGT(*i.EndDateGT))
	}
	if i.EndDateGTE != nil {
		predicates = append(predicates, projecttask.EndDateGTE(*i.EndDateGTE))
	}
	if i.EndDateLT != nil {
		predicates = append(predicates, projecttask.EndDateLT(*i.EndDateLT))
	}
	if i.EndDateLTE != nil {
		predicates = append(predicates, projecttask.EndDateLTE(*i.EndDateLTE))
	}
	if i.EndDateIsNil {
		predicates = append(predicates, projecttask.EndDateIsNil())
	}
	if i.EndDateNotNil {
		predicates = append(predicates, projecttask.EndDateNotNil())
	}
	if i.Description != nil {
		predicates = append(predicates, projecttask.DescriptionEQ(*i.Description))
	}
	if i.DescriptionNEQ != nil {
		predicates = append(predicates, projecttask.DescriptionNEQ(*i.DescriptionNEQ))
	}
	if len(i.DescriptionIn) > 0 {
		predicates = append(predicates, projecttask.DescriptionIn(i.DescriptionIn...))
	}
	if len(i.DescriptionNotIn) > 0 {
		predicates = append(predicates, projecttask.DescriptionNotIn(i.DescriptionNotIn...))
	}
	if i.DescriptionGT != nil {
		predicates = append(predicates, projecttask.DescriptionGT(*i.DescriptionGT))
	}
	if i.DescriptionGTE != nil {
		predicates = append(predicates, projecttask.DescriptionGTE(*i.DescriptionGTE))
	}
	if i.DescriptionLT != nil {
		predicates = append(predicates, projecttask.DescriptionLT(*i.DescriptionLT))
	}
	if i.DescriptionLTE != nil {
		predicates = append(predicates, projecttask.DescriptionLTE(*i.DescriptionLTE))
	}
	if i.DescriptionContains != nil {
		predicates = append(predicates, projecttask.DescriptionContains(*i.DescriptionContains))
	}
	if i.DescriptionHasPrefix != nil {
		predicates = append(predicates, projecttask.DescriptionHasPrefix(*i.DescriptionHasPrefix))
	}
	if i.DescriptionHasSuffix != nil {
		predicates = append(predicates, projecttask.DescriptionHasSuffix(*i.DescriptionHasSuffix))
	}
	if i.DescriptionIsNil {
		predicates = append(predicates, projecttask.DescriptionIsNil())
	}
	if i.DescriptionNotNil {
		predicates = append(predicates, projecttask.DescriptionNotNil())
	}
	if i.DescriptionEqualFold != nil {
		predicates = append(predicates, projecttask.DescriptionEqualFold(*i.DescriptionEqualFold))
	}
	if i.DescriptionContainsFold != nil {
		predicates = append(predicates, projecttask.DescriptionContainsFold(*i.DescriptionContainsFold))
	}
	if i.Status != nil {
		predicates = append(predicates, projecttask.StatusEQ(*i.Status))
	}
	if i.StatusNEQ != nil {
		predicates = append(predicates, projecttask.StatusNEQ(*i.StatusNEQ))
	}
	if len(i.StatusIn) > 0 {
		predicates = append(predicates, projecttask.StatusIn(i.StatusIn...))
	}
	if len(i.StatusNotIn) > 0 {
		predicates = append(predicates, projecttask.StatusNotIn(i.StatusNotIn...))
	}

	if i.HasProject != nil {
		p := projecttask.HasProject()
		if !*i.HasProject {
			p = projecttask.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasProjectWith) > 0 {
		with := make([]predicate.Project, 0, len(i.HasProjectWith))
		for _, w := range i.HasProjectWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasProjectWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, projecttask.HasProjectWith(with...))
	}
	if i.HasAssignee != nil {
		p := projecttask.HasAssignee()
		if !*i.HasAssignee {
			p = projecttask.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasAssigneeWith) > 0 {
		with := make([]predicate.User, 0, len(i.HasAssigneeWith))
		for _, w := range i.HasAssigneeWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasAssigneeWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, projecttask.HasAssigneeWith(with...))
	}
	if i.HasParticipants != nil {
		p := projecttask.HasParticipants()
		if !*i.HasParticipants {
			p = projecttask.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasParticipantsWith) > 0 {
		with := make([]predicate.User, 0, len(i.HasParticipantsWith))
		for _, w := range i.HasParticipantsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasParticipantsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, projecttask.HasParticipantsWith(with...))
	}
	if i.HasCreatedBy != nil {
		p := projecttask.HasCreatedBy()
		if !*i.HasCreatedBy {
			p = projecttask.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasCreatedByWith) > 0 {
		with := make([]predicate.User, 0, len(i.HasCreatedByWith))
		for _, w := range i.HasCreatedByWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasCreatedByWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, projecttask.HasCreatedByWith(with...))
	}
	if i.HasWorkShifts != nil {
		p := projecttask.HasWorkShifts()
		if !*i.HasWorkShifts {
			p = projecttask.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasWorkShiftsWith) > 0 {
		with := make([]predicate.Workshift, 0, len(i.HasWorkShiftsWith))
		for _, w := range i.HasWorkShiftsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasWorkShiftsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, projecttask.HasWorkShiftsWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyProjectTaskWhereInput
	case 1:
		return predicates[0], nil
	default:
		return projecttask.And(predicates...), nil
	}
}

// ReceivableWhereInput represents a where input for filtering Receivable queries.
type ReceivableWhereInput struct {
	Predicates []predicate.Receivable  `json:"-"`
	Not        *ReceivableWhereInput   `json:"not,omitempty"`
	Or         []*ReceivableWhereInput `json:"or,omitempty"`
	And        []*ReceivableWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "createdAt" field predicates.
	CreatedAt      *time.Time  `json:"createdat,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdatNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdatIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdatNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdatGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdatGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdatLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdatLTE,omitempty"`

	// "updatedAt" field predicates.
	UpdatedAt      *time.Time  `json:"updatedat,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedatNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedatIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedatNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedatGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedatGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedatLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedatLTE,omitempty"`

	// "deletedAt" field predicates.
	DeletedAt       *time.Time  `json:"deletedat,omitempty"`
	DeletedAtNEQ    *time.Time  `json:"deletedatNEQ,omitempty"`
	DeletedAtIn     []time.Time `json:"deletedatIn,omitempty"`
	DeletedAtNotIn  []time.Time `json:"deletedatNotIn,omitempty"`
	DeletedAtGT     *time.Time  `json:"deletedatGT,omitempty"`
	DeletedAtGTE    *time.Time  `json:"deletedatGTE,omitempty"`
	DeletedAtLT     *time.Time  `json:"deletedatLT,omitempty"`
	DeletedAtLTE    *time.Time  `json:"deletedatLTE,omitempty"`
	DeletedAtIsNil  bool        `json:"deletedatIsNil,omitempty"`
	DeletedAtNotNil bool        `json:"deletedatNotNil,omitempty"`

	// "entryGroup" field predicates.
	EntryGroup      *int  `json:"entrygroup,omitempty"`
	EntryGroupNEQ   *int  `json:"entrygroupNEQ,omitempty"`
	EntryGroupIn    []int `json:"entrygroupIn,omitempty"`
	EntryGroupNotIn []int `json:"entrygroupNotIn,omitempty"`
	EntryGroupGT    *int  `json:"entrygroupGT,omitempty"`
	EntryGroupGTE   *int  `json:"entrygroupGTE,omitempty"`
	EntryGroupLT    *int  `json:"entrygroupLT,omitempty"`
	EntryGroupLTE   *int  `json:"entrygroupLTE,omitempty"`

	// "date" field predicates.
	Date      *time.Time  `json:"date,omitempty"`
	DateNEQ   *time.Time  `json:"dateNEQ,omitempty"`
	DateIn    []time.Time `json:"dateIn,omitempty"`
	DateNotIn []time.Time `json:"dateNotIn,omitempty"`
	DateGT    *time.Time  `json:"dateGT,omitempty"`
	DateGTE   *time.Time  `json:"dateGTE,omitempty"`
	DateLT    *time.Time  `json:"dateLT,omitempty"`
	DateLTE   *time.Time  `json:"dateLTE,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "amountInDefault" field predicates.
	AmountInDefault      *float64  `json:"amountindefault,omitempty"`
	AmountInDefaultNEQ   *float64  `json:"amountindefaultNEQ,omitempty"`
	AmountInDefaultIn    []float64 `json:"amountindefaultIn,omitempty"`
	AmountInDefaultNotIn []float64 `json:"amountindefaultNotIn,omitempty"`
	AmountInDefaultGT    *float64  `json:"amountindefaultGT,omitempty"`
	AmountInDefaultGTE   *float64  `json:"amountindefaultGTE,omitempty"`
	AmountInDefaultLT    *float64  `json:"amountindefaultLT,omitempty"`
	AmountInDefaultLTE   *float64  `json:"amountindefaultLTE,omitempty"`

	// "outstandingBalance" field predicates.
	OutstandingBalance      *float64  `json:"outstandingbalance,omitempty"`
	OutstandingBalanceNEQ   *float64  `json:"outstandingbalanceNEQ,omitempty"`
	OutstandingBalanceIn    []float64 `json:"outstandingbalanceIn,omitempty"`
	OutstandingBalanceNotIn []float64 `json:"outstandingbalanceNotIn,omitempty"`
	OutstandingBalanceGT    *float64  `json:"outstandingbalanceGT,omitempty"`
	OutstandingBalanceGTE   *float64  `json:"outstandingbalanceGTE,omitempty"`
	OutstandingBalanceLT    *float64  `json:"outstandingbalanceLT,omitempty"`
	OutstandingBalanceLTE   *float64  `json:"outstandingbalanceLTE,omitempty"`

	// "totalTransaction" field predicates.
	TotalTransaction      *float64  `json:"totaltransaction,omitempty"`
	TotalTransactionNEQ   *float64  `json:"totaltransactionNEQ,omitempty"`
	TotalTransactionIn    []float64 `json:"totaltransactionIn,omitempty"`
	TotalTransactionNotIn []float64 `json:"totaltransactionNotIn,omitempty"`
	TotalTransactionGT    *float64  `json:"totaltransactionGT,omitempty"`
	TotalTransactionGTE   *float64  `json:"totaltransactionGTE,omitempty"`
	TotalTransactionLT    *float64  `json:"totaltransactionLT,omitempty"`
	TotalTransactionLTE   *float64  `json:"totaltransactionLTE,omitempty"`

	// "dueDate" field predicates.
	DueDate      *time.Time  `json:"duedate,omitempty"`
	DueDateNEQ   *time.Time  `json:"duedateNEQ,omitempty"`
	DueDateIn    []time.Time `json:"duedateIn,omitempty"`
	DueDateNotIn []time.Time `json:"duedateNotIn,omitempty"`
	DueDateGT    *time.Time  `json:"duedateGT,omitempty"`
	DueDateGTE   *time.Time  `json:"duedateGTE,omitempty"`
	DueDateLT    *time.Time  `json:"duedateLT,omitempty"`
	DueDateLTE   *time.Time  `json:"duedateLTE,omitempty"`

	// "status" field predicates.
	Status      *receivable.Status  `json:"status,omitempty"`
	StatusNEQ   *receivable.Status  `json:"statusNEQ,omitempty"`
	StatusIn    []receivable.Status `json:"statusIn,omitempty"`
	StatusNotIn []receivable.Status `json:"statusNotIn,omitempty"`

	// "company" edge predicates.
	HasCompany     *bool                `json:"hasCompany,omitempty"`
	HasCompanyWith []*CompanyWhereInput `json:"hasCompanyWith,omitempty"`

	// "invoice" edge predicates.
	HasInvoice     *bool                `json:"hasInvoice,omitempty"`
	HasInvoiceWith []*InvoiceWhereInput `json:"hasInvoiceWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *ReceivableWhereInput) AddPredicates(predicates ...predicate.Receivable) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the ReceivableWhereInput filter on the ReceivableQuery builder.
func (i *ReceivableWhereInput) Filter(q *ReceivableQuery) (*ReceivableQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyReceivableWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyReceivableWhereInput is returned in case the ReceivableWhereInput is empty.
var ErrEmptyReceivableWhereInput = errors.New("generated: empty predicate ReceivableWhereInput")

// P returns a predicate for filtering receivables.
// An error is returned if the input is empty or invalid.
func (i *ReceivableWhereInput) P() (predicate.Receivable, error) {
	var predicates []predicate.Receivable
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, receivable.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Receivable, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, receivable.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Receivable, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, receivable.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, receivable.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, receivable.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, receivable.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, receivable.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, receivable.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, receivable.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, receivable.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, receivable.IDLTE(*i.IDLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, receivable.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, receivable.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, receivable.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, receivable.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, receivable.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, receivable.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, receivable.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, receivable.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, receivable.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, receivable.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, receivable.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, receivable.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, receivable.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, receivable.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, receivable.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, receivable.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.DeletedAt != nil {
		predicates = append(predicates, receivable.DeletedAtEQ(*i.DeletedAt))
	}
	if i.DeletedAtNEQ != nil {
		predicates = append(predicates, receivable.DeletedAtNEQ(*i.DeletedAtNEQ))
	}
	if len(i.DeletedAtIn) > 0 {
		predicates = append(predicates, receivable.DeletedAtIn(i.DeletedAtIn...))
	}
	if len(i.DeletedAtNotIn) > 0 {
		predicates = append(predicates, receivable.DeletedAtNotIn(i.DeletedAtNotIn...))
	}
	if i.DeletedAtGT != nil {
		predicates = append(predicates, receivable.DeletedAtGT(*i.DeletedAtGT))
	}
	if i.DeletedAtGTE != nil {
		predicates = append(predicates, receivable.DeletedAtGTE(*i.DeletedAtGTE))
	}
	if i.DeletedAtLT != nil {
		predicates = append(predicates, receivable.DeletedAtLT(*i.DeletedAtLT))
	}
	if i.DeletedAtLTE != nil {
		predicates = append(predicates, receivable.DeletedAtLTE(*i.DeletedAtLTE))
	}
	if i.DeletedAtIsNil {
		predicates = append(predicates, receivable.DeletedAtIsNil())
	}
	if i.DeletedAtNotNil {
		predicates = append(predicates, receivable.DeletedAtNotNil())
	}
	if i.EntryGroup != nil {
		predicates = append(predicates, receivable.EntryGroupEQ(*i.EntryGroup))
	}
	if i.EntryGroupNEQ != nil {
		predicates = append(predicates, receivable.EntryGroupNEQ(*i.EntryGroupNEQ))
	}
	if len(i.EntryGroupIn) > 0 {
		predicates = append(predicates, receivable.EntryGroupIn(i.EntryGroupIn...))
	}
	if len(i.EntryGroupNotIn) > 0 {
		predicates = append(predicates, receivable.EntryGroupNotIn(i.EntryGroupNotIn...))
	}
	if i.EntryGroupGT != nil {
		predicates = append(predicates, receivable.EntryGroupGT(*i.EntryGroupGT))
	}
	if i.EntryGroupGTE != nil {
		predicates = append(predicates, receivable.EntryGroupGTE(*i.EntryGroupGTE))
	}
	if i.EntryGroupLT != nil {
		predicates = append(predicates, receivable.EntryGroupLT(*i.EntryGroupLT))
	}
	if i.EntryGroupLTE != nil {
		predicates = append(predicates, receivable.EntryGroupLTE(*i.EntryGroupLTE))
	}
	if i.Date != nil {
		predicates = append(predicates, receivable.DateEQ(*i.Date))
	}
	if i.DateNEQ != nil {
		predicates = append(predicates, receivable.DateNEQ(*i.DateNEQ))
	}
	if len(i.DateIn) > 0 {
		predicates = append(predicates, receivable.DateIn(i.DateIn...))
	}
	if len(i.DateNotIn) > 0 {
		predicates = append(predicates, receivable.DateNotIn(i.DateNotIn...))
	}
	if i.DateGT != nil {
		predicates = append(predicates, receivable.DateGT(*i.DateGT))
	}
	if i.DateGTE != nil {
		predicates = append(predicates, receivable.DateGTE(*i.DateGTE))
	}
	if i.DateLT != nil {
		predicates = append(predicates, receivable.DateLT(*i.DateLT))
	}
	if i.DateLTE != nil {
		predicates = append(predicates, receivable.DateLTE(*i.DateLTE))
	}
	if i.Name != nil {
		predicates = append(predicates, receivable.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, receivable.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, receivable.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, receivable.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, receivable.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, receivable.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, receivable.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, receivable.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, receivable.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, receivable.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, receivable.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, receivable.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, receivable.NameContainsFold(*i.NameContainsFold))
	}
	if i.AmountInDefault != nil {
		predicates = append(predicates, receivable.AmountInDefaultEQ(*i.AmountInDefault))
	}
	if i.AmountInDefaultNEQ != nil {
		predicates = append(predicates, receivable.AmountInDefaultNEQ(*i.AmountInDefaultNEQ))
	}
	if len(i.AmountInDefaultIn) > 0 {
		predicates = append(predicates, receivable.AmountInDefaultIn(i.AmountInDefaultIn...))
	}
	if len(i.AmountInDefaultNotIn) > 0 {
		predicates = append(predicates, receivable.AmountInDefaultNotIn(i.AmountInDefaultNotIn...))
	}
	if i.AmountInDefaultGT != nil {
		predicates = append(predicates, receivable.AmountInDefaultGT(*i.AmountInDefaultGT))
	}
	if i.AmountInDefaultGTE != nil {
		predicates = append(predicates, receivable.AmountInDefaultGTE(*i.AmountInDefaultGTE))
	}
	if i.AmountInDefaultLT != nil {
		predicates = append(predicates, receivable.AmountInDefaultLT(*i.AmountInDefaultLT))
	}
	if i.AmountInDefaultLTE != nil {
		predicates = append(predicates, receivable.AmountInDefaultLTE(*i.AmountInDefaultLTE))
	}
	if i.OutstandingBalance != nil {
		predicates = append(predicates, receivable.OutstandingBalanceEQ(*i.OutstandingBalance))
	}
	if i.OutstandingBalanceNEQ != nil {
		predicates = append(predicates, receivable.OutstandingBalanceNEQ(*i.OutstandingBalanceNEQ))
	}
	if len(i.OutstandingBalanceIn) > 0 {
		predicates = append(predicates, receivable.OutstandingBalanceIn(i.OutstandingBalanceIn...))
	}
	if len(i.OutstandingBalanceNotIn) > 0 {
		predicates = append(predicates, receivable.OutstandingBalanceNotIn(i.OutstandingBalanceNotIn...))
	}
	if i.OutstandingBalanceGT != nil {
		predicates = append(predicates, receivable.OutstandingBalanceGT(*i.OutstandingBalanceGT))
	}
	if i.OutstandingBalanceGTE != nil {
		predicates = append(predicates, receivable.OutstandingBalanceGTE(*i.OutstandingBalanceGTE))
	}
	if i.OutstandingBalanceLT != nil {
		predicates = append(predicates, receivable.OutstandingBalanceLT(*i.OutstandingBalanceLT))
	}
	if i.OutstandingBalanceLTE != nil {
		predicates = append(predicates, receivable.OutstandingBalanceLTE(*i.OutstandingBalanceLTE))
	}
	if i.TotalTransaction != nil {
		predicates = append(predicates, receivable.TotalTransactionEQ(*i.TotalTransaction))
	}
	if i.TotalTransactionNEQ != nil {
		predicates = append(predicates, receivable.TotalTransactionNEQ(*i.TotalTransactionNEQ))
	}
	if len(i.TotalTransactionIn) > 0 {
		predicates = append(predicates, receivable.TotalTransactionIn(i.TotalTransactionIn...))
	}
	if len(i.TotalTransactionNotIn) > 0 {
		predicates = append(predicates, receivable.TotalTransactionNotIn(i.TotalTransactionNotIn...))
	}
	if i.TotalTransactionGT != nil {
		predicates = append(predicates, receivable.TotalTransactionGT(*i.TotalTransactionGT))
	}
	if i.TotalTransactionGTE != nil {
		predicates = append(predicates, receivable.TotalTransactionGTE(*i.TotalTransactionGTE))
	}
	if i.TotalTransactionLT != nil {
		predicates = append(predicates, receivable.TotalTransactionLT(*i.TotalTransactionLT))
	}
	if i.TotalTransactionLTE != nil {
		predicates = append(predicates, receivable.TotalTransactionLTE(*i.TotalTransactionLTE))
	}
	if i.DueDate != nil {
		predicates = append(predicates, receivable.DueDateEQ(*i.DueDate))
	}
	if i.DueDateNEQ != nil {
		predicates = append(predicates, receivable.DueDateNEQ(*i.DueDateNEQ))
	}
	if len(i.DueDateIn) > 0 {
		predicates = append(predicates, receivable.DueDateIn(i.DueDateIn...))
	}
	if len(i.DueDateNotIn) > 0 {
		predicates = append(predicates, receivable.DueDateNotIn(i.DueDateNotIn...))
	}
	if i.DueDateGT != nil {
		predicates = append(predicates, receivable.DueDateGT(*i.DueDateGT))
	}
	if i.DueDateGTE != nil {
		predicates = append(predicates, receivable.DueDateGTE(*i.DueDateGTE))
	}
	if i.DueDateLT != nil {
		predicates = append(predicates, receivable.DueDateLT(*i.DueDateLT))
	}
	if i.DueDateLTE != nil {
		predicates = append(predicates, receivable.DueDateLTE(*i.DueDateLTE))
	}
	if i.Status != nil {
		predicates = append(predicates, receivable.StatusEQ(*i.Status))
	}
	if i.StatusNEQ != nil {
		predicates = append(predicates, receivable.StatusNEQ(*i.StatusNEQ))
	}
	if len(i.StatusIn) > 0 {
		predicates = append(predicates, receivable.StatusIn(i.StatusIn...))
	}
	if len(i.StatusNotIn) > 0 {
		predicates = append(predicates, receivable.StatusNotIn(i.StatusNotIn...))
	}

	if i.HasCompany != nil {
		p := receivable.HasCompany()
		if !*i.HasCompany {
			p = receivable.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasCompanyWith) > 0 {
		with := make([]predicate.Company, 0, len(i.HasCompanyWith))
		for _, w := range i.HasCompanyWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasCompanyWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, receivable.HasCompanyWith(with...))
	}
	if i.HasInvoice != nil {
		p := receivable.HasInvoice()
		if !*i.HasInvoice {
			p = receivable.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasInvoiceWith) > 0 {
		with := make([]predicate.Invoice, 0, len(i.HasInvoiceWith))
		for _, w := range i.HasInvoiceWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasInvoiceWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, receivable.HasInvoiceWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyReceivableWhereInput
	case 1:
		return predicates[0], nil
	default:
		return receivable.And(predicates...), nil
	}
}

// SupplierWhereInput represents a where input for filtering Supplier queries.
type SupplierWhereInput struct {
	Predicates []predicate.Supplier  `json:"-"`
	Not        *SupplierWhereInput   `json:"not,omitempty"`
	Or         []*SupplierWhereInput `json:"or,omitempty"`
	And        []*SupplierWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "createdAt" field predicates.
	CreatedAt      *time.Time  `json:"createdat,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdatNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdatIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdatNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdatGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdatGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdatLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdatLTE,omitempty"`

	// "updatedAt" field predicates.
	UpdatedAt      *time.Time  `json:"updatedat,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedatNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedatIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedatNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedatGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedatGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedatLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedatLTE,omitempty"`

	// "deletedAt" field predicates.
	DeletedAt       *time.Time  `json:"deletedat,omitempty"`
	DeletedAtNEQ    *time.Time  `json:"deletedatNEQ,omitempty"`
	DeletedAtIn     []time.Time `json:"deletedatIn,omitempty"`
	DeletedAtNotIn  []time.Time `json:"deletedatNotIn,omitempty"`
	DeletedAtGT     *time.Time  `json:"deletedatGT,omitempty"`
	DeletedAtGTE    *time.Time  `json:"deletedatGTE,omitempty"`
	DeletedAtLT     *time.Time  `json:"deletedatLT,omitempty"`
	DeletedAtLTE    *time.Time  `json:"deletedatLTE,omitempty"`
	DeletedAtIsNil  bool        `json:"deletedatIsNil,omitempty"`
	DeletedAtNotNil bool        `json:"deletedatNotNil,omitempty"`

	// "address" field predicates.
	Address             *string  `json:"address,omitempty"`
	AddressNEQ          *string  `json:"addressNEQ,omitempty"`
	AddressIn           []string `json:"addressIn,omitempty"`
	AddressNotIn        []string `json:"addressNotIn,omitempty"`
	AddressGT           *string  `json:"addressGT,omitempty"`
	AddressGTE          *string  `json:"addressGTE,omitempty"`
	AddressLT           *string  `json:"addressLT,omitempty"`
	AddressLTE          *string  `json:"addressLTE,omitempty"`
	AddressContains     *string  `json:"addressContains,omitempty"`
	AddressHasPrefix    *string  `json:"addressHasPrefix,omitempty"`
	AddressHasSuffix    *string  `json:"addressHasSuffix,omitempty"`
	AddressEqualFold    *string  `json:"addressEqualFold,omitempty"`
	AddressContainsFold *string  `json:"addressContainsFold,omitempty"`

	// "city" field predicates.
	City             *string  `json:"city,omitempty"`
	CityNEQ          *string  `json:"cityNEQ,omitempty"`
	CityIn           []string `json:"cityIn,omitempty"`
	CityNotIn        []string `json:"cityNotIn,omitempty"`
	CityGT           *string  `json:"cityGT,omitempty"`
	CityGTE          *string  `json:"cityGTE,omitempty"`
	CityLT           *string  `json:"cityLT,omitempty"`
	CityLTE          *string  `json:"cityLTE,omitempty"`
	CityContains     *string  `json:"cityContains,omitempty"`
	CityHasPrefix    *string  `json:"cityHasPrefix,omitempty"`
	CityHasSuffix    *string  `json:"cityHasSuffix,omitempty"`
	CityEqualFold    *string  `json:"cityEqualFold,omitempty"`
	CityContainsFold *string  `json:"cityContainsFold,omitempty"`

	// "country" field predicates.
	Country             *string  `json:"country,omitempty"`
	CountryNEQ          *string  `json:"countryNEQ,omitempty"`
	CountryIn           []string `json:"countryIn,omitempty"`
	CountryNotIn        []string `json:"countryNotIn,omitempty"`
	CountryGT           *string  `json:"countryGT,omitempty"`
	CountryGTE          *string  `json:"countryGTE,omitempty"`
	CountryLT           *string  `json:"countryLT,omitempty"`
	CountryLTE          *string  `json:"countryLTE,omitempty"`
	CountryContains     *string  `json:"countryContains,omitempty"`
	CountryHasPrefix    *string  `json:"countryHasPrefix,omitempty"`
	CountryHasSuffix    *string  `json:"countryHasSuffix,omitempty"`
	CountryEqualFold    *string  `json:"countryEqualFold,omitempty"`
	CountryContainsFold *string  `json:"countryContainsFold,omitempty"`

	// "description" field predicates.
	Description             *string  `json:"description,omitempty"`
	DescriptionNEQ          *string  `json:"descriptionNEQ,omitempty"`
	DescriptionIn           []string `json:"descriptionIn,omitempty"`
	DescriptionNotIn        []string `json:"descriptionNotIn,omitempty"`
	DescriptionGT           *string  `json:"descriptionGT,omitempty"`
	DescriptionGTE          *string  `json:"descriptionGTE,omitempty"`
	DescriptionLT           *string  `json:"descriptionLT,omitempty"`
	DescriptionLTE          *string  `json:"descriptionLTE,omitempty"`
	DescriptionContains     *string  `json:"descriptionContains,omitempty"`
	DescriptionHasPrefix    *string  `json:"descriptionHasPrefix,omitempty"`
	DescriptionHasSuffix    *string  `json:"descriptionHasSuffix,omitempty"`
	DescriptionEqualFold    *string  `json:"descriptionEqualFold,omitempty"`
	DescriptionContainsFold *string  `json:"descriptionContainsFold,omitempty"`

	// "email" field predicates.
	Email             *string  `json:"email,omitempty"`
	EmailNEQ          *string  `json:"emailNEQ,omitempty"`
	EmailIn           []string `json:"emailIn,omitempty"`
	EmailNotIn        []string `json:"emailNotIn,omitempty"`
	EmailGT           *string  `json:"emailGT,omitempty"`
	EmailGTE          *string  `json:"emailGTE,omitempty"`
	EmailLT           *string  `json:"emailLT,omitempty"`
	EmailLTE          *string  `json:"emailLTE,omitempty"`
	EmailContains     *string  `json:"emailContains,omitempty"`
	EmailHasPrefix    *string  `json:"emailHasPrefix,omitempty"`
	EmailHasSuffix    *string  `json:"emailHasSuffix,omitempty"`
	EmailEqualFold    *string  `json:"emailEqualFold,omitempty"`
	EmailContainsFold *string  `json:"emailContainsFold,omitempty"`

	// "isDefault" field predicates.
	IsDefault       *bool `json:"isdefault,omitempty"`
	IsDefaultNEQ    *bool `json:"isdefaultNEQ,omitempty"`
	IsDefaultIsNil  bool  `json:"isdefaultIsNil,omitempty"`
	IsDefaultNotNil bool  `json:"isdefaultNotNil,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "phone" field predicates.
	Phone             *string  `json:"phone,omitempty"`
	PhoneNEQ          *string  `json:"phoneNEQ,omitempty"`
	PhoneIn           []string `json:"phoneIn,omitempty"`
	PhoneNotIn        []string `json:"phoneNotIn,omitempty"`
	PhoneGT           *string  `json:"phoneGT,omitempty"`
	PhoneGTE          *string  `json:"phoneGTE,omitempty"`
	PhoneLT           *string  `json:"phoneLT,omitempty"`
	PhoneLTE          *string  `json:"phoneLTE,omitempty"`
	PhoneContains     *string  `json:"phoneContains,omitempty"`
	PhoneHasPrefix    *string  `json:"phoneHasPrefix,omitempty"`
	PhoneHasSuffix    *string  `json:"phoneHasSuffix,omitempty"`
	PhoneEqualFold    *string  `json:"phoneEqualFold,omitempty"`
	PhoneContainsFold *string  `json:"phoneContainsFold,omitempty"`

	// "taxId" field predicates.
	TaxId             *string  `json:"taxid,omitempty"`
	TaxIdNEQ          *string  `json:"taxidNEQ,omitempty"`
	TaxIdIn           []string `json:"taxidIn,omitempty"`
	TaxIdNotIn        []string `json:"taxidNotIn,omitempty"`
	TaxIdGT           *string  `json:"taxidGT,omitempty"`
	TaxIdGTE          *string  `json:"taxidGTE,omitempty"`
	TaxIdLT           *string  `json:"taxidLT,omitempty"`
	TaxIdLTE          *string  `json:"taxidLTE,omitempty"`
	TaxIdContains     *string  `json:"taxidContains,omitempty"`
	TaxIdHasPrefix    *string  `json:"taxidHasPrefix,omitempty"`
	TaxIdHasSuffix    *string  `json:"taxidHasSuffix,omitempty"`
	TaxIdEqualFold    *string  `json:"taxidEqualFold,omitempty"`
	TaxIdContainsFold *string  `json:"taxidContainsFold,omitempty"`

	// "company" edge predicates.
	HasCompany     *bool                `json:"hasCompany,omitempty"`
	HasCompanyWith []*CompanyWhereInput `json:"hasCompanyWith,omitempty"`

	// "payables" edge predicates.
	HasPayables     *bool                `json:"hasPayables,omitempty"`
	HasPayablesWith []*PayableWhereInput `json:"hasPayablesWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *SupplierWhereInput) AddPredicates(predicates ...predicate.Supplier) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the SupplierWhereInput filter on the SupplierQuery builder.
func (i *SupplierWhereInput) Filter(q *SupplierQuery) (*SupplierQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptySupplierWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptySupplierWhereInput is returned in case the SupplierWhereInput is empty.
var ErrEmptySupplierWhereInput = errors.New("generated: empty predicate SupplierWhereInput")

// P returns a predicate for filtering suppliers.
// An error is returned if the input is empty or invalid.
func (i *SupplierWhereInput) P() (predicate.Supplier, error) {
	var predicates []predicate.Supplier
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, supplier.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Supplier, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, supplier.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Supplier, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, supplier.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, supplier.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, supplier.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, supplier.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, supplier.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, supplier.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, supplier.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, supplier.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, supplier.IDLTE(*i.IDLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, supplier.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, supplier.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, supplier.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, supplier.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, supplier.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, supplier.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, supplier.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, supplier.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, supplier.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, supplier.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, supplier.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, supplier.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, supplier.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, supplier.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, supplier.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, supplier.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.DeletedAt != nil {
		predicates = append(predicates, supplier.DeletedAtEQ(*i.DeletedAt))
	}
	if i.DeletedAtNEQ != nil {
		predicates = append(predicates, supplier.DeletedAtNEQ(*i.DeletedAtNEQ))
	}
	if len(i.DeletedAtIn) > 0 {
		predicates = append(predicates, supplier.DeletedAtIn(i.DeletedAtIn...))
	}
	if len(i.DeletedAtNotIn) > 0 {
		predicates = append(predicates, supplier.DeletedAtNotIn(i.DeletedAtNotIn...))
	}
	if i.DeletedAtGT != nil {
		predicates = append(predicates, supplier.DeletedAtGT(*i.DeletedAtGT))
	}
	if i.DeletedAtGTE != nil {
		predicates = append(predicates, supplier.DeletedAtGTE(*i.DeletedAtGTE))
	}
	if i.DeletedAtLT != nil {
		predicates = append(predicates, supplier.DeletedAtLT(*i.DeletedAtLT))
	}
	if i.DeletedAtLTE != nil {
		predicates = append(predicates, supplier.DeletedAtLTE(*i.DeletedAtLTE))
	}
	if i.DeletedAtIsNil {
		predicates = append(predicates, supplier.DeletedAtIsNil())
	}
	if i.DeletedAtNotNil {
		predicates = append(predicates, supplier.DeletedAtNotNil())
	}
	if i.Address != nil {
		predicates = append(predicates, supplier.AddressEQ(*i.Address))
	}
	if i.AddressNEQ != nil {
		predicates = append(predicates, supplier.AddressNEQ(*i.AddressNEQ))
	}
	if len(i.AddressIn) > 0 {
		predicates = append(predicates, supplier.AddressIn(i.AddressIn...))
	}
	if len(i.AddressNotIn) > 0 {
		predicates = append(predicates, supplier.AddressNotIn(i.AddressNotIn...))
	}
	if i.AddressGT != nil {
		predicates = append(predicates, supplier.AddressGT(*i.AddressGT))
	}
	if i.AddressGTE != nil {
		predicates = append(predicates, supplier.AddressGTE(*i.AddressGTE))
	}
	if i.AddressLT != nil {
		predicates = append(predicates, supplier.AddressLT(*i.AddressLT))
	}
	if i.AddressLTE != nil {
		predicates = append(predicates, supplier.AddressLTE(*i.AddressLTE))
	}
	if i.AddressContains != nil {
		predicates = append(predicates, supplier.AddressContains(*i.AddressContains))
	}
	if i.AddressHasPrefix != nil {
		predicates = append(predicates, supplier.AddressHasPrefix(*i.AddressHasPrefix))
	}
	if i.AddressHasSuffix != nil {
		predicates = append(predicates, supplier.AddressHasSuffix(*i.AddressHasSuffix))
	}
	if i.AddressEqualFold != nil {
		predicates = append(predicates, supplier.AddressEqualFold(*i.AddressEqualFold))
	}
	if i.AddressContainsFold != nil {
		predicates = append(predicates, supplier.AddressContainsFold(*i.AddressContainsFold))
	}
	if i.City != nil {
		predicates = append(predicates, supplier.CityEQ(*i.City))
	}
	if i.CityNEQ != nil {
		predicates = append(predicates, supplier.CityNEQ(*i.CityNEQ))
	}
	if len(i.CityIn) > 0 {
		predicates = append(predicates, supplier.CityIn(i.CityIn...))
	}
	if len(i.CityNotIn) > 0 {
		predicates = append(predicates, supplier.CityNotIn(i.CityNotIn...))
	}
	if i.CityGT != nil {
		predicates = append(predicates, supplier.CityGT(*i.CityGT))
	}
	if i.CityGTE != nil {
		predicates = append(predicates, supplier.CityGTE(*i.CityGTE))
	}
	if i.CityLT != nil {
		predicates = append(predicates, supplier.CityLT(*i.CityLT))
	}
	if i.CityLTE != nil {
		predicates = append(predicates, supplier.CityLTE(*i.CityLTE))
	}
	if i.CityContains != nil {
		predicates = append(predicates, supplier.CityContains(*i.CityContains))
	}
	if i.CityHasPrefix != nil {
		predicates = append(predicates, supplier.CityHasPrefix(*i.CityHasPrefix))
	}
	if i.CityHasSuffix != nil {
		predicates = append(predicates, supplier.CityHasSuffix(*i.CityHasSuffix))
	}
	if i.CityEqualFold != nil {
		predicates = append(predicates, supplier.CityEqualFold(*i.CityEqualFold))
	}
	if i.CityContainsFold != nil {
		predicates = append(predicates, supplier.CityContainsFold(*i.CityContainsFold))
	}
	if i.Country != nil {
		predicates = append(predicates, supplier.CountryEQ(*i.Country))
	}
	if i.CountryNEQ != nil {
		predicates = append(predicates, supplier.CountryNEQ(*i.CountryNEQ))
	}
	if len(i.CountryIn) > 0 {
		predicates = append(predicates, supplier.CountryIn(i.CountryIn...))
	}
	if len(i.CountryNotIn) > 0 {
		predicates = append(predicates, supplier.CountryNotIn(i.CountryNotIn...))
	}
	if i.CountryGT != nil {
		predicates = append(predicates, supplier.CountryGT(*i.CountryGT))
	}
	if i.CountryGTE != nil {
		predicates = append(predicates, supplier.CountryGTE(*i.CountryGTE))
	}
	if i.CountryLT != nil {
		predicates = append(predicates, supplier.CountryLT(*i.CountryLT))
	}
	if i.CountryLTE != nil {
		predicates = append(predicates, supplier.CountryLTE(*i.CountryLTE))
	}
	if i.CountryContains != nil {
		predicates = append(predicates, supplier.CountryContains(*i.CountryContains))
	}
	if i.CountryHasPrefix != nil {
		predicates = append(predicates, supplier.CountryHasPrefix(*i.CountryHasPrefix))
	}
	if i.CountryHasSuffix != nil {
		predicates = append(predicates, supplier.CountryHasSuffix(*i.CountryHasSuffix))
	}
	if i.CountryEqualFold != nil {
		predicates = append(predicates, supplier.CountryEqualFold(*i.CountryEqualFold))
	}
	if i.CountryContainsFold != nil {
		predicates = append(predicates, supplier.CountryContainsFold(*i.CountryContainsFold))
	}
	if i.Description != nil {
		predicates = append(predicates, supplier.DescriptionEQ(*i.Description))
	}
	if i.DescriptionNEQ != nil {
		predicates = append(predicates, supplier.DescriptionNEQ(*i.DescriptionNEQ))
	}
	if len(i.DescriptionIn) > 0 {
		predicates = append(predicates, supplier.DescriptionIn(i.DescriptionIn...))
	}
	if len(i.DescriptionNotIn) > 0 {
		predicates = append(predicates, supplier.DescriptionNotIn(i.DescriptionNotIn...))
	}
	if i.DescriptionGT != nil {
		predicates = append(predicates, supplier.DescriptionGT(*i.DescriptionGT))
	}
	if i.DescriptionGTE != nil {
		predicates = append(predicates, supplier.DescriptionGTE(*i.DescriptionGTE))
	}
	if i.DescriptionLT != nil {
		predicates = append(predicates, supplier.DescriptionLT(*i.DescriptionLT))
	}
	if i.DescriptionLTE != nil {
		predicates = append(predicates, supplier.DescriptionLTE(*i.DescriptionLTE))
	}
	if i.DescriptionContains != nil {
		predicates = append(predicates, supplier.DescriptionContains(*i.DescriptionContains))
	}
	if i.DescriptionHasPrefix != nil {
		predicates = append(predicates, supplier.DescriptionHasPrefix(*i.DescriptionHasPrefix))
	}
	if i.DescriptionHasSuffix != nil {
		predicates = append(predicates, supplier.DescriptionHasSuffix(*i.DescriptionHasSuffix))
	}
	if i.DescriptionEqualFold != nil {
		predicates = append(predicates, supplier.DescriptionEqualFold(*i.DescriptionEqualFold))
	}
	if i.DescriptionContainsFold != nil {
		predicates = append(predicates, supplier.DescriptionContainsFold(*i.DescriptionContainsFold))
	}
	if i.Email != nil {
		predicates = append(predicates, supplier.EmailEQ(*i.Email))
	}
	if i.EmailNEQ != nil {
		predicates = append(predicates, supplier.EmailNEQ(*i.EmailNEQ))
	}
	if len(i.EmailIn) > 0 {
		predicates = append(predicates, supplier.EmailIn(i.EmailIn...))
	}
	if len(i.EmailNotIn) > 0 {
		predicates = append(predicates, supplier.EmailNotIn(i.EmailNotIn...))
	}
	if i.EmailGT != nil {
		predicates = append(predicates, supplier.EmailGT(*i.EmailGT))
	}
	if i.EmailGTE != nil {
		predicates = append(predicates, supplier.EmailGTE(*i.EmailGTE))
	}
	if i.EmailLT != nil {
		predicates = append(predicates, supplier.EmailLT(*i.EmailLT))
	}
	if i.EmailLTE != nil {
		predicates = append(predicates, supplier.EmailLTE(*i.EmailLTE))
	}
	if i.EmailContains != nil {
		predicates = append(predicates, supplier.EmailContains(*i.EmailContains))
	}
	if i.EmailHasPrefix != nil {
		predicates = append(predicates, supplier.EmailHasPrefix(*i.EmailHasPrefix))
	}
	if i.EmailHasSuffix != nil {
		predicates = append(predicates, supplier.EmailHasSuffix(*i.EmailHasSuffix))
	}
	if i.EmailEqualFold != nil {
		predicates = append(predicates, supplier.EmailEqualFold(*i.EmailEqualFold))
	}
	if i.EmailContainsFold != nil {
		predicates = append(predicates, supplier.EmailContainsFold(*i.EmailContainsFold))
	}
	if i.IsDefault != nil {
		predicates = append(predicates, supplier.IsDefaultEQ(*i.IsDefault))
	}
	if i.IsDefaultNEQ != nil {
		predicates = append(predicates, supplier.IsDefaultNEQ(*i.IsDefaultNEQ))
	}
	if i.IsDefaultIsNil {
		predicates = append(predicates, supplier.IsDefaultIsNil())
	}
	if i.IsDefaultNotNil {
		predicates = append(predicates, supplier.IsDefaultNotNil())
	}
	if i.Name != nil {
		predicates = append(predicates, supplier.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, supplier.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, supplier.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, supplier.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, supplier.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, supplier.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, supplier.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, supplier.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, supplier.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, supplier.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, supplier.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, supplier.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, supplier.NameContainsFold(*i.NameContainsFold))
	}
	if i.Phone != nil {
		predicates = append(predicates, supplier.PhoneEQ(*i.Phone))
	}
	if i.PhoneNEQ != nil {
		predicates = append(predicates, supplier.PhoneNEQ(*i.PhoneNEQ))
	}
	if len(i.PhoneIn) > 0 {
		predicates = append(predicates, supplier.PhoneIn(i.PhoneIn...))
	}
	if len(i.PhoneNotIn) > 0 {
		predicates = append(predicates, supplier.PhoneNotIn(i.PhoneNotIn...))
	}
	if i.PhoneGT != nil {
		predicates = append(predicates, supplier.PhoneGT(*i.PhoneGT))
	}
	if i.PhoneGTE != nil {
		predicates = append(predicates, supplier.PhoneGTE(*i.PhoneGTE))
	}
	if i.PhoneLT != nil {
		predicates = append(predicates, supplier.PhoneLT(*i.PhoneLT))
	}
	if i.PhoneLTE != nil {
		predicates = append(predicates, supplier.PhoneLTE(*i.PhoneLTE))
	}
	if i.PhoneContains != nil {
		predicates = append(predicates, supplier.PhoneContains(*i.PhoneContains))
	}
	if i.PhoneHasPrefix != nil {
		predicates = append(predicates, supplier.PhoneHasPrefix(*i.PhoneHasPrefix))
	}
	if i.PhoneHasSuffix != nil {
		predicates = append(predicates, supplier.PhoneHasSuffix(*i.PhoneHasSuffix))
	}
	if i.PhoneEqualFold != nil {
		predicates = append(predicates, supplier.PhoneEqualFold(*i.PhoneEqualFold))
	}
	if i.PhoneContainsFold != nil {
		predicates = append(predicates, supplier.PhoneContainsFold(*i.PhoneContainsFold))
	}
	if i.TaxId != nil {
		predicates = append(predicates, supplier.TaxIdEQ(*i.TaxId))
	}
	if i.TaxIdNEQ != nil {
		predicates = append(predicates, supplier.TaxIdNEQ(*i.TaxIdNEQ))
	}
	if len(i.TaxIdIn) > 0 {
		predicates = append(predicates, supplier.TaxIdIn(i.TaxIdIn...))
	}
	if len(i.TaxIdNotIn) > 0 {
		predicates = append(predicates, supplier.TaxIdNotIn(i.TaxIdNotIn...))
	}
	if i.TaxIdGT != nil {
		predicates = append(predicates, supplier.TaxIdGT(*i.TaxIdGT))
	}
	if i.TaxIdGTE != nil {
		predicates = append(predicates, supplier.TaxIdGTE(*i.TaxIdGTE))
	}
	if i.TaxIdLT != nil {
		predicates = append(predicates, supplier.TaxIdLT(*i.TaxIdLT))
	}
	if i.TaxIdLTE != nil {
		predicates = append(predicates, supplier.TaxIdLTE(*i.TaxIdLTE))
	}
	if i.TaxIdContains != nil {
		predicates = append(predicates, supplier.TaxIdContains(*i.TaxIdContains))
	}
	if i.TaxIdHasPrefix != nil {
		predicates = append(predicates, supplier.TaxIdHasPrefix(*i.TaxIdHasPrefix))
	}
	if i.TaxIdHasSuffix != nil {
		predicates = append(predicates, supplier.TaxIdHasSuffix(*i.TaxIdHasSuffix))
	}
	if i.TaxIdEqualFold != nil {
		predicates = append(predicates, supplier.TaxIdEqualFold(*i.TaxIdEqualFold))
	}
	if i.TaxIdContainsFold != nil {
		predicates = append(predicates, supplier.TaxIdContainsFold(*i.TaxIdContainsFold))
	}

	if i.HasCompany != nil {
		p := supplier.HasCompany()
		if !*i.HasCompany {
			p = supplier.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasCompanyWith) > 0 {
		with := make([]predicate.Company, 0, len(i.HasCompanyWith))
		for _, w := range i.HasCompanyWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasCompanyWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, supplier.HasCompanyWith(with...))
	}
	if i.HasPayables != nil {
		p := supplier.HasPayables()
		if !*i.HasPayables {
			p = supplier.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasPayablesWith) > 0 {
		with := make([]predicate.Payable, 0, len(i.HasPayablesWith))
		for _, w := range i.HasPayablesWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasPayablesWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, supplier.HasPayablesWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptySupplierWhereInput
	case 1:
		return predicates[0], nil
	default:
		return supplier.And(predicates...), nil
	}
}

// TokenWhereInput represents a where input for filtering Token queries.
type TokenWhereInput struct {
	Predicates []predicate.Token  `json:"-"`
	Not        *TokenWhereInput   `json:"not,omitempty"`
	Or         []*TokenWhereInput `json:"or,omitempty"`
	And        []*TokenWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "expiry" field predicates.
	Expiry      *time.Time  `json:"expiry,omitempty"`
	ExpiryNEQ   *time.Time  `json:"expiryNEQ,omitempty"`
	ExpiryIn    []time.Time `json:"expiryIn,omitempty"`
	ExpiryNotIn []time.Time `json:"expiryNotIn,omitempty"`
	ExpiryGT    *time.Time  `json:"expiryGT,omitempty"`
	ExpiryGTE   *time.Time  `json:"expiryGTE,omitempty"`
	ExpiryLT    *time.Time  `json:"expiryLT,omitempty"`
	ExpiryLTE   *time.Time  `json:"expiryLTE,omitempty"`

	// "category" field predicates.
	Category      *token.Category  `json:"category,omitempty"`
	CategoryNEQ   *token.Category  `json:"categoryNEQ,omitempty"`
	CategoryIn    []token.Category `json:"categoryIn,omitempty"`
	CategoryNotIn []token.Category `json:"categoryNotIn,omitempty"`

	// "token" field predicates.
	Token             *string  `json:"token,omitempty"`
	TokenNEQ          *string  `json:"tokenNEQ,omitempty"`
	TokenIn           []string `json:"tokenIn,omitempty"`
	TokenNotIn        []string `json:"tokenNotIn,omitempty"`
	TokenGT           *string  `json:"tokenGT,omitempty"`
	TokenGTE          *string  `json:"tokenGTE,omitempty"`
	TokenLT           *string  `json:"tokenLT,omitempty"`
	TokenLTE          *string  `json:"tokenLTE,omitempty"`
	TokenContains     *string  `json:"tokenContains,omitempty"`
	TokenHasPrefix    *string  `json:"tokenHasPrefix,omitempty"`
	TokenHasSuffix    *string  `json:"tokenHasSuffix,omitempty"`
	TokenEqualFold    *string  `json:"tokenEqualFold,omitempty"`
	TokenContainsFold *string  `json:"tokenContainsFold,omitempty"`

	// "company" edge predicates.
	HasCompany     *bool                `json:"hasCompany,omitempty"`
	HasCompanyWith []*CompanyWhereInput `json:"hasCompanyWith,omitempty"`

	// "user" edge predicates.
	HasUser     *bool             `json:"hasUser,omitempty"`
	HasUserWith []*UserWhereInput `json:"hasUserWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *TokenWhereInput) AddPredicates(predicates ...predicate.Token) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the TokenWhereInput filter on the TokenQuery builder.
func (i *TokenWhereInput) Filter(q *TokenQuery) (*TokenQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyTokenWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyTokenWhereInput is returned in case the TokenWhereInput is empty.
var ErrEmptyTokenWhereInput = errors.New("generated: empty predicate TokenWhereInput")

// P returns a predicate for filtering tokens.
// An error is returned if the input is empty or invalid.
func (i *TokenWhereInput) P() (predicate.Token, error) {
	var predicates []predicate.Token
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, token.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Token, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, token.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Token, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, token.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, token.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, token.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, token.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, token.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, token.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, token.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, token.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, token.IDLTE(*i.IDLTE))
	}
	if i.Expiry != nil {
		predicates = append(predicates, token.ExpiryEQ(*i.Expiry))
	}
	if i.ExpiryNEQ != nil {
		predicates = append(predicates, token.ExpiryNEQ(*i.ExpiryNEQ))
	}
	if len(i.ExpiryIn) > 0 {
		predicates = append(predicates, token.ExpiryIn(i.ExpiryIn...))
	}
	if len(i.ExpiryNotIn) > 0 {
		predicates = append(predicates, token.ExpiryNotIn(i.ExpiryNotIn...))
	}
	if i.ExpiryGT != nil {
		predicates = append(predicates, token.ExpiryGT(*i.ExpiryGT))
	}
	if i.ExpiryGTE != nil {
		predicates = append(predicates, token.ExpiryGTE(*i.ExpiryGTE))
	}
	if i.ExpiryLT != nil {
		predicates = append(predicates, token.ExpiryLT(*i.ExpiryLT))
	}
	if i.ExpiryLTE != nil {
		predicates = append(predicates, token.ExpiryLTE(*i.ExpiryLTE))
	}
	if i.Category != nil {
		predicates = append(predicates, token.CategoryEQ(*i.Category))
	}
	if i.CategoryNEQ != nil {
		predicates = append(predicates, token.CategoryNEQ(*i.CategoryNEQ))
	}
	if len(i.CategoryIn) > 0 {
		predicates = append(predicates, token.CategoryIn(i.CategoryIn...))
	}
	if len(i.CategoryNotIn) > 0 {
		predicates = append(predicates, token.CategoryNotIn(i.CategoryNotIn...))
	}
	if i.Token != nil {
		predicates = append(predicates, token.TokenEQ(*i.Token))
	}
	if i.TokenNEQ != nil {
		predicates = append(predicates, token.TokenNEQ(*i.TokenNEQ))
	}
	if len(i.TokenIn) > 0 {
		predicates = append(predicates, token.TokenIn(i.TokenIn...))
	}
	if len(i.TokenNotIn) > 0 {
		predicates = append(predicates, token.TokenNotIn(i.TokenNotIn...))
	}
	if i.TokenGT != nil {
		predicates = append(predicates, token.TokenGT(*i.TokenGT))
	}
	if i.TokenGTE != nil {
		predicates = append(predicates, token.TokenGTE(*i.TokenGTE))
	}
	if i.TokenLT != nil {
		predicates = append(predicates, token.TokenLT(*i.TokenLT))
	}
	if i.TokenLTE != nil {
		predicates = append(predicates, token.TokenLTE(*i.TokenLTE))
	}
	if i.TokenContains != nil {
		predicates = append(predicates, token.TokenContains(*i.TokenContains))
	}
	if i.TokenHasPrefix != nil {
		predicates = append(predicates, token.TokenHasPrefix(*i.TokenHasPrefix))
	}
	if i.TokenHasSuffix != nil {
		predicates = append(predicates, token.TokenHasSuffix(*i.TokenHasSuffix))
	}
	if i.TokenEqualFold != nil {
		predicates = append(predicates, token.TokenEqualFold(*i.TokenEqualFold))
	}
	if i.TokenContainsFold != nil {
		predicates = append(predicates, token.TokenContainsFold(*i.TokenContainsFold))
	}

	if i.HasCompany != nil {
		p := token.HasCompany()
		if !*i.HasCompany {
			p = token.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasCompanyWith) > 0 {
		with := make([]predicate.Company, 0, len(i.HasCompanyWith))
		for _, w := range i.HasCompanyWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasCompanyWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, token.HasCompanyWith(with...))
	}
	if i.HasUser != nil {
		p := token.HasUser()
		if !*i.HasUser {
			p = token.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasUserWith) > 0 {
		with := make([]predicate.User, 0, len(i.HasUserWith))
		for _, w := range i.HasUserWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasUserWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, token.HasUserWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyTokenWhereInput
	case 1:
		return predicates[0], nil
	default:
		return token.And(predicates...), nil
	}
}

// TreasuryWhereInput represents a where input for filtering Treasury queries.
type TreasuryWhereInput struct {
	Predicates []predicate.Treasury  `json:"-"`
	Not        *TreasuryWhereInput   `json:"not,omitempty"`
	Or         []*TreasuryWhereInput `json:"or,omitempty"`
	And        []*TreasuryWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "createdAt" field predicates.
	CreatedAt      *time.Time  `json:"createdat,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdatNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdatIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdatNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdatGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdatGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdatLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdatLTE,omitempty"`

	// "updatedAt" field predicates.
	UpdatedAt      *time.Time  `json:"updatedat,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedatNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedatIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedatNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedatGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedatGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedatLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedatLTE,omitempty"`

	// "deletedAt" field predicates.
	DeletedAt       *time.Time  `json:"deletedat,omitempty"`
	DeletedAtNEQ    *time.Time  `json:"deletedatNEQ,omitempty"`
	DeletedAtIn     []time.Time `json:"deletedatIn,omitempty"`
	DeletedAtNotIn  []time.Time `json:"deletedatNotIn,omitempty"`
	DeletedAtGT     *time.Time  `json:"deletedatGT,omitempty"`
	DeletedAtGTE    *time.Time  `json:"deletedatGTE,omitempty"`
	DeletedAtLT     *time.Time  `json:"deletedatLT,omitempty"`
	DeletedAtLTE    *time.Time  `json:"deletedatLTE,omitempty"`
	DeletedAtIsNil  bool        `json:"deletedatIsNil,omitempty"`
	DeletedAtNotNil bool        `json:"deletedatNotNil,omitempty"`

	// "balance" field predicates.
	Balance      *float64  `json:"balance,omitempty"`
	BalanceNEQ   *float64  `json:"balanceNEQ,omitempty"`
	BalanceIn    []float64 `json:"balanceIn,omitempty"`
	BalanceNotIn []float64 `json:"balanceNotIn,omitempty"`
	BalanceGT    *float64  `json:"balanceGT,omitempty"`
	BalanceGTE   *float64  `json:"balanceGTE,omitempty"`
	BalanceLT    *float64  `json:"balanceLT,omitempty"`
	BalanceLTE   *float64  `json:"balanceLTE,omitempty"`

	// "company" edge predicates.
	HasCompany     *bool                `json:"hasCompany,omitempty"`
	HasCompanyWith []*CompanyWhereInput `json:"hasCompanyWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *TreasuryWhereInput) AddPredicates(predicates ...predicate.Treasury) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the TreasuryWhereInput filter on the TreasuryQuery builder.
func (i *TreasuryWhereInput) Filter(q *TreasuryQuery) (*TreasuryQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyTreasuryWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyTreasuryWhereInput is returned in case the TreasuryWhereInput is empty.
var ErrEmptyTreasuryWhereInput = errors.New("generated: empty predicate TreasuryWhereInput")

// P returns a predicate for filtering treasuries.
// An error is returned if the input is empty or invalid.
func (i *TreasuryWhereInput) P() (predicate.Treasury, error) {
	var predicates []predicate.Treasury
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, treasury.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Treasury, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, treasury.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Treasury, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, treasury.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, treasury.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, treasury.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, treasury.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, treasury.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, treasury.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, treasury.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, treasury.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, treasury.IDLTE(*i.IDLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, treasury.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, treasury.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, treasury.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, treasury.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, treasury.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, treasury.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, treasury.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, treasury.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, treasury.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, treasury.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, treasury.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, treasury.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, treasury.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, treasury.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, treasury.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, treasury.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.DeletedAt != nil {
		predicates = append(predicates, treasury.DeletedAtEQ(*i.DeletedAt))
	}
	if i.DeletedAtNEQ != nil {
		predicates = append(predicates, treasury.DeletedAtNEQ(*i.DeletedAtNEQ))
	}
	if len(i.DeletedAtIn) > 0 {
		predicates = append(predicates, treasury.DeletedAtIn(i.DeletedAtIn...))
	}
	if len(i.DeletedAtNotIn) > 0 {
		predicates = append(predicates, treasury.DeletedAtNotIn(i.DeletedAtNotIn...))
	}
	if i.DeletedAtGT != nil {
		predicates = append(predicates, treasury.DeletedAtGT(*i.DeletedAtGT))
	}
	if i.DeletedAtGTE != nil {
		predicates = append(predicates, treasury.DeletedAtGTE(*i.DeletedAtGTE))
	}
	if i.DeletedAtLT != nil {
		predicates = append(predicates, treasury.DeletedAtLT(*i.DeletedAtLT))
	}
	if i.DeletedAtLTE != nil {
		predicates = append(predicates, treasury.DeletedAtLTE(*i.DeletedAtLTE))
	}
	if i.DeletedAtIsNil {
		predicates = append(predicates, treasury.DeletedAtIsNil())
	}
	if i.DeletedAtNotNil {
		predicates = append(predicates, treasury.DeletedAtNotNil())
	}
	if i.Balance != nil {
		predicates = append(predicates, treasury.BalanceEQ(*i.Balance))
	}
	if i.BalanceNEQ != nil {
		predicates = append(predicates, treasury.BalanceNEQ(*i.BalanceNEQ))
	}
	if len(i.BalanceIn) > 0 {
		predicates = append(predicates, treasury.BalanceIn(i.BalanceIn...))
	}
	if len(i.BalanceNotIn) > 0 {
		predicates = append(predicates, treasury.BalanceNotIn(i.BalanceNotIn...))
	}
	if i.BalanceGT != nil {
		predicates = append(predicates, treasury.BalanceGT(*i.BalanceGT))
	}
	if i.BalanceGTE != nil {
		predicates = append(predicates, treasury.BalanceGTE(*i.BalanceGTE))
	}
	if i.BalanceLT != nil {
		predicates = append(predicates, treasury.BalanceLT(*i.BalanceLT))
	}
	if i.BalanceLTE != nil {
		predicates = append(predicates, treasury.BalanceLTE(*i.BalanceLTE))
	}

	if i.HasCompany != nil {
		p := treasury.HasCompany()
		if !*i.HasCompany {
			p = treasury.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasCompanyWith) > 0 {
		with := make([]predicate.Company, 0, len(i.HasCompanyWith))
		for _, w := range i.HasCompanyWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasCompanyWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, treasury.HasCompanyWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyTreasuryWhereInput
	case 1:
		return predicates[0], nil
	default:
		return treasury.And(predicates...), nil
	}
}

// UserWhereInput represents a where input for filtering User queries.
type UserWhereInput struct {
	Predicates []predicate.User  `json:"-"`
	Not        *UserWhereInput   `json:"not,omitempty"`
	Or         []*UserWhereInput `json:"or,omitempty"`
	And        []*UserWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "createdAt" field predicates.
	CreatedAt      *time.Time  `json:"createdat,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdatNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdatIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdatNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdatGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdatGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdatLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdatLTE,omitempty"`

	// "updatedAt" field predicates.
	UpdatedAt      *time.Time  `json:"updatedat,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedatNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedatIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedatNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedatGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedatGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedatLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedatLTE,omitempty"`

	// "deletedAt" field predicates.
	DeletedAt       *time.Time  `json:"deletedat,omitempty"`
	DeletedAtNEQ    *time.Time  `json:"deletedatNEQ,omitempty"`
	DeletedAtIn     []time.Time `json:"deletedatIn,omitempty"`
	DeletedAtNotIn  []time.Time `json:"deletedatNotIn,omitempty"`
	DeletedAtGT     *time.Time  `json:"deletedatGT,omitempty"`
	DeletedAtGTE    *time.Time  `json:"deletedatGTE,omitempty"`
	DeletedAtLT     *time.Time  `json:"deletedatLT,omitempty"`
	DeletedAtLTE    *time.Time  `json:"deletedatLTE,omitempty"`
	DeletedAtIsNil  bool        `json:"deletedatIsNil,omitempty"`
	DeletedAtNotNil bool        `json:"deletedatNotNil,omitempty"`

	// "firebaseUID" field predicates.
	FirebaseUID             *string  `json:"firebaseuid,omitempty"`
	FirebaseUIDNEQ          *string  `json:"firebaseuidNEQ,omitempty"`
	FirebaseUIDIn           []string `json:"firebaseuidIn,omitempty"`
	FirebaseUIDNotIn        []string `json:"firebaseuidNotIn,omitempty"`
	FirebaseUIDGT           *string  `json:"firebaseuidGT,omitempty"`
	FirebaseUIDGTE          *string  `json:"firebaseuidGTE,omitempty"`
	FirebaseUIDLT           *string  `json:"firebaseuidLT,omitempty"`
	FirebaseUIDLTE          *string  `json:"firebaseuidLTE,omitempty"`
	FirebaseUIDContains     *string  `json:"firebaseuidContains,omitempty"`
	FirebaseUIDHasPrefix    *string  `json:"firebaseuidHasPrefix,omitempty"`
	FirebaseUIDHasSuffix    *string  `json:"firebaseuidHasSuffix,omitempty"`
	FirebaseUIDEqualFold    *string  `json:"firebaseuidEqualFold,omitempty"`
	FirebaseUIDContainsFold *string  `json:"firebaseuidContainsFold,omitempty"`

	// "fcmToken" field predicates.
	FcmToken             *string  `json:"fcmtoken,omitempty"`
	FcmTokenNEQ          *string  `json:"fcmtokenNEQ,omitempty"`
	FcmTokenIn           []string `json:"fcmtokenIn,omitempty"`
	FcmTokenNotIn        []string `json:"fcmtokenNotIn,omitempty"`
	FcmTokenGT           *string  `json:"fcmtokenGT,omitempty"`
	FcmTokenGTE          *string  `json:"fcmtokenGTE,omitempty"`
	FcmTokenLT           *string  `json:"fcmtokenLT,omitempty"`
	FcmTokenLTE          *string  `json:"fcmtokenLTE,omitempty"`
	FcmTokenContains     *string  `json:"fcmtokenContains,omitempty"`
	FcmTokenHasPrefix    *string  `json:"fcmtokenHasPrefix,omitempty"`
	FcmTokenHasSuffix    *string  `json:"fcmtokenHasSuffix,omitempty"`
	FcmTokenIsNil        bool     `json:"fcmtokenIsNil,omitempty"`
	FcmTokenNotNil       bool     `json:"fcmtokenNotNil,omitempty"`
	FcmTokenEqualFold    *string  `json:"fcmtokenEqualFold,omitempty"`
	FcmTokenContainsFold *string  `json:"fcmtokenContainsFold,omitempty"`

	// "expoPushToken" field predicates.
	ExpoPushToken             *string  `json:"expopushtoken,omitempty"`
	ExpoPushTokenNEQ          *string  `json:"expopushtokenNEQ,omitempty"`
	ExpoPushTokenIn           []string `json:"expopushtokenIn,omitempty"`
	ExpoPushTokenNotIn        []string `json:"expopushtokenNotIn,omitempty"`
	ExpoPushTokenGT           *string  `json:"expopushtokenGT,omitempty"`
	ExpoPushTokenGTE          *string  `json:"expopushtokenGTE,omitempty"`
	ExpoPushTokenLT           *string  `json:"expopushtokenLT,omitempty"`
	ExpoPushTokenLTE          *string  `json:"expopushtokenLTE,omitempty"`
	ExpoPushTokenContains     *string  `json:"expopushtokenContains,omitempty"`
	ExpoPushTokenHasPrefix    *string  `json:"expopushtokenHasPrefix,omitempty"`
	ExpoPushTokenHasSuffix    *string  `json:"expopushtokenHasSuffix,omitempty"`
	ExpoPushTokenIsNil        bool     `json:"expopushtokenIsNil,omitempty"`
	ExpoPushTokenNotNil       bool     `json:"expopushtokenNotNil,omitempty"`
	ExpoPushTokenEqualFold    *string  `json:"expopushtokenEqualFold,omitempty"`
	ExpoPushTokenContainsFold *string  `json:"expopushtokenContainsFold,omitempty"`

	// "email" field predicates.
	Email             *string  `json:"email,omitempty"`
	EmailNEQ          *string  `json:"emailNEQ,omitempty"`
	EmailIn           []string `json:"emailIn,omitempty"`
	EmailNotIn        []string `json:"emailNotIn,omitempty"`
	EmailGT           *string  `json:"emailGT,omitempty"`
	EmailGTE          *string  `json:"emailGTE,omitempty"`
	EmailLT           *string  `json:"emailLT,omitempty"`
	EmailLTE          *string  `json:"emailLTE,omitempty"`
	EmailContains     *string  `json:"emailContains,omitempty"`
	EmailHasPrefix    *string  `json:"emailHasPrefix,omitempty"`
	EmailHasSuffix    *string  `json:"emailHasSuffix,omitempty"`
	EmailEqualFold    *string  `json:"emailEqualFold,omitempty"`
	EmailContainsFold *string  `json:"emailContainsFold,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "address" field predicates.
	Address             *string  `json:"address,omitempty"`
	AddressNEQ          *string  `json:"addressNEQ,omitempty"`
	AddressIn           []string `json:"addressIn,omitempty"`
	AddressNotIn        []string `json:"addressNotIn,omitempty"`
	AddressGT           *string  `json:"addressGT,omitempty"`
	AddressGTE          *string  `json:"addressGTE,omitempty"`
	AddressLT           *string  `json:"addressLT,omitempty"`
	AddressLTE          *string  `json:"addressLTE,omitempty"`
	AddressContains     *string  `json:"addressContains,omitempty"`
	AddressHasPrefix    *string  `json:"addressHasPrefix,omitempty"`
	AddressHasSuffix    *string  `json:"addressHasSuffix,omitempty"`
	AddressIsNil        bool     `json:"addressIsNil,omitempty"`
	AddressNotNil       bool     `json:"addressNotNil,omitempty"`
	AddressEqualFold    *string  `json:"addressEqualFold,omitempty"`
	AddressContainsFold *string  `json:"addressContainsFold,omitempty"`

	// "avatar" field predicates.
	Avatar             *string  `json:"avatar,omitempty"`
	AvatarNEQ          *string  `json:"avatarNEQ,omitempty"`
	AvatarIn           []string `json:"avatarIn,omitempty"`
	AvatarNotIn        []string `json:"avatarNotIn,omitempty"`
	AvatarGT           *string  `json:"avatarGT,omitempty"`
	AvatarGTE          *string  `json:"avatarGTE,omitempty"`
	AvatarLT           *string  `json:"avatarLT,omitempty"`
	AvatarLTE          *string  `json:"avatarLTE,omitempty"`
	AvatarContains     *string  `json:"avatarContains,omitempty"`
	AvatarHasPrefix    *string  `json:"avatarHasPrefix,omitempty"`
	AvatarHasSuffix    *string  `json:"avatarHasSuffix,omitempty"`
	AvatarIsNil        bool     `json:"avatarIsNil,omitempty"`
	AvatarNotNil       bool     `json:"avatarNotNil,omitempty"`
	AvatarEqualFold    *string  `json:"avatarEqualFold,omitempty"`
	AvatarContainsFold *string  `json:"avatarContainsFold,omitempty"`

	// "photoURL" field predicates.
	PhotoURL             *string  `json:"photourl,omitempty"`
	PhotoURLNEQ          *string  `json:"photourlNEQ,omitempty"`
	PhotoURLIn           []string `json:"photourlIn,omitempty"`
	PhotoURLNotIn        []string `json:"photourlNotIn,omitempty"`
	PhotoURLGT           *string  `json:"photourlGT,omitempty"`
	PhotoURLGTE          *string  `json:"photourlGTE,omitempty"`
	PhotoURLLT           *string  `json:"photourlLT,omitempty"`
	PhotoURLLTE          *string  `json:"photourlLTE,omitempty"`
	PhotoURLContains     *string  `json:"photourlContains,omitempty"`
	PhotoURLHasPrefix    *string  `json:"photourlHasPrefix,omitempty"`
	PhotoURLHasSuffix    *string  `json:"photourlHasSuffix,omitempty"`
	PhotoURLIsNil        bool     `json:"photourlIsNil,omitempty"`
	PhotoURLNotNil       bool     `json:"photourlNotNil,omitempty"`
	PhotoURLEqualFold    *string  `json:"photourlEqualFold,omitempty"`
	PhotoURLContainsFold *string  `json:"photourlContainsFold,omitempty"`

	// "department" field predicates.
	Department             *string  `json:"department,omitempty"`
	DepartmentNEQ          *string  `json:"departmentNEQ,omitempty"`
	DepartmentIn           []string `json:"departmentIn,omitempty"`
	DepartmentNotIn        []string `json:"departmentNotIn,omitempty"`
	DepartmentGT           *string  `json:"departmentGT,omitempty"`
	DepartmentGTE          *string  `json:"departmentGTE,omitempty"`
	DepartmentLT           *string  `json:"departmentLT,omitempty"`
	DepartmentLTE          *string  `json:"departmentLTE,omitempty"`
	DepartmentContains     *string  `json:"departmentContains,omitempty"`
	DepartmentHasPrefix    *string  `json:"departmentHasPrefix,omitempty"`
	DepartmentHasSuffix    *string  `json:"departmentHasSuffix,omitempty"`
	DepartmentIsNil        bool     `json:"departmentIsNil,omitempty"`
	DepartmentNotNil       bool     `json:"departmentNotNil,omitempty"`
	DepartmentEqualFold    *string  `json:"departmentEqualFold,omitempty"`
	DepartmentContainsFold *string  `json:"departmentContainsFold,omitempty"`

	// "phone" field predicates.
	Phone             *string  `json:"phone,omitempty"`
	PhoneNEQ          *string  `json:"phoneNEQ,omitempty"`
	PhoneIn           []string `json:"phoneIn,omitempty"`
	PhoneNotIn        []string `json:"phoneNotIn,omitempty"`
	PhoneGT           *string  `json:"phoneGT,omitempty"`
	PhoneGTE          *string  `json:"phoneGTE,omitempty"`
	PhoneLT           *string  `json:"phoneLT,omitempty"`
	PhoneLTE          *string  `json:"phoneLTE,omitempty"`
	PhoneContains     *string  `json:"phoneContains,omitempty"`
	PhoneHasPrefix    *string  `json:"phoneHasPrefix,omitempty"`
	PhoneHasSuffix    *string  `json:"phoneHasSuffix,omitempty"`
	PhoneIsNil        bool     `json:"phoneIsNil,omitempty"`
	PhoneNotNil       bool     `json:"phoneNotNil,omitempty"`
	PhoneEqualFold    *string  `json:"phoneEqualFold,omitempty"`
	PhoneContainsFold *string  `json:"phoneContainsFold,omitempty"`

	// "birthdate" field predicates.
	Birthdate       *time.Time  `json:"birthdate,omitempty"`
	BirthdateNEQ    *time.Time  `json:"birthdateNEQ,omitempty"`
	BirthdateIn     []time.Time `json:"birthdateIn,omitempty"`
	BirthdateNotIn  []time.Time `json:"birthdateNotIn,omitempty"`
	BirthdateGT     *time.Time  `json:"birthdateGT,omitempty"`
	BirthdateGTE    *time.Time  `json:"birthdateGTE,omitempty"`
	BirthdateLT     *time.Time  `json:"birthdateLT,omitempty"`
	BirthdateLTE    *time.Time  `json:"birthdateLTE,omitempty"`
	BirthdateIsNil  bool        `json:"birthdateIsNil,omitempty"`
	BirthdateNotNil bool        `json:"birthdateNotNil,omitempty"`

	// "lastLogin" field predicates.
	LastLogin       *time.Time  `json:"lastlogin,omitempty"`
	LastLoginNEQ    *time.Time  `json:"lastloginNEQ,omitempty"`
	LastLoginIn     []time.Time `json:"lastloginIn,omitempty"`
	LastLoginNotIn  []time.Time `json:"lastloginNotIn,omitempty"`
	LastLoginGT     *time.Time  `json:"lastloginGT,omitempty"`
	LastLoginGTE    *time.Time  `json:"lastloginGTE,omitempty"`
	LastLoginLT     *time.Time  `json:"lastloginLT,omitempty"`
	LastLoginLTE    *time.Time  `json:"lastloginLTE,omitempty"`
	LastLoginIsNil  bool        `json:"lastloginIsNil,omitempty"`
	LastLoginNotNil bool        `json:"lastloginNotNil,omitempty"`

	// "gender" field predicates.
	Gender      *user.Gender  `json:"gender,omitempty"`
	GenderNEQ   *user.Gender  `json:"genderNEQ,omitempty"`
	GenderIn    []user.Gender `json:"genderIn,omitempty"`
	GenderNotIn []user.Gender `json:"genderNotIn,omitempty"`

	// "active" field predicates.
	Active    *bool `json:"active,omitempty"`
	ActiveNEQ *bool `json:"activeNEQ,omitempty"`

	// "accountingEntries" edge predicates.
	HasAccountingEntries     *bool                        `json:"hasAccountingEntries,omitempty"`
	HasAccountingEntriesWith []*AccountingEntryWhereInput `json:"hasAccountingEntriesWith,omitempty"`

	// "company" edge predicates.
	HasCompany     *bool                `json:"hasCompany,omitempty"`
	HasCompanyWith []*CompanyWhereInput `json:"hasCompanyWith,omitempty"`

	// "assignedRoles" edge predicates.
	HasAssignedRoles     *bool                 `json:"hasAssignedRoles,omitempty"`
	HasAssignedRolesWith []*UserRoleWhereInput `json:"hasAssignedRolesWith,omitempty"`

	// "subordinates" edge predicates.
	HasSubordinates     *bool             `json:"hasSubordinates,omitempty"`
	HasSubordinatesWith []*UserWhereInput `json:"hasSubordinatesWith,omitempty"`

	// "leader" edge predicates.
	HasLeader     *bool             `json:"hasLeader,omitempty"`
	HasLeaderWith []*UserWhereInput `json:"hasLeaderWith,omitempty"`

	// "createdMemberSignupTokens" edge predicates.
	HasCreatedMemberSignupTokens     *bool                          `json:"hasCreatedMemberSignupTokens,omitempty"`
	HasCreatedMemberSignupTokensWith []*MemberSignupTokenWhereInput `json:"hasCreatedMemberSignupTokensWith,omitempty"`

	// "employee" edge predicates.
	HasEmployee     *bool                 `json:"hasEmployee,omitempty"`
	HasEmployeeWith []*EmployeeWhereInput `json:"hasEmployeeWith,omitempty"`

	// "issuedInvoices" edge predicates.
	HasIssuedInvoices     *bool                `json:"hasIssuedInvoices,omitempty"`
	HasIssuedInvoicesWith []*InvoiceWhereInput `json:"hasIssuedInvoicesWith,omitempty"`

	// "createdProjects" edge predicates.
	HasCreatedProjects     *bool                `json:"hasCreatedProjects,omitempty"`
	HasCreatedProjectsWith []*ProjectWhereInput `json:"hasCreatedProjectsWith,omitempty"`

	// "leaderedProjects" edge predicates.
	HasLeaderedProjects     *bool                `json:"hasLeaderedProjects,omitempty"`
	HasLeaderedProjectsWith []*ProjectWhereInput `json:"hasLeaderedProjectsWith,omitempty"`

	// "assignedProjectTasks" edge predicates.
	HasAssignedProjectTasks     *bool                    `json:"hasAssignedProjectTasks,omitempty"`
	HasAssignedProjectTasksWith []*ProjectTaskWhereInput `json:"hasAssignedProjectTasksWith,omitempty"`

	// "participatedProjectTasks" edge predicates.
	HasParticipatedProjectTasks     *bool                    `json:"hasParticipatedProjectTasks,omitempty"`
	HasParticipatedProjectTasksWith []*ProjectTaskWhereInput `json:"hasParticipatedProjectTasksWith,omitempty"`

	// "createdTasks" edge predicates.
	HasCreatedTasks     *bool                    `json:"hasCreatedTasks,omitempty"`
	HasCreatedTasksWith []*ProjectTaskWhereInput `json:"hasCreatedTasksWith,omitempty"`

	// "tokens" edge predicates.
	HasTokens     *bool              `json:"hasTokens,omitempty"`
	HasTokensWith []*TokenWhereInput `json:"hasTokensWith,omitempty"`

	// "approvedWorkShifts" edge predicates.
	HasApprovedWorkShifts     *bool                  `json:"hasApprovedWorkShifts,omitempty"`
	HasApprovedWorkShiftsWith []*WorkshiftWhereInput `json:"hasApprovedWorkShiftsWith,omitempty"`

	// "workShifts" edge predicates.
	HasWorkShifts     *bool                  `json:"hasWorkShifts,omitempty"`
	HasWorkShiftsWith []*WorkshiftWhereInput `json:"hasWorkShiftsWith,omitempty"`

	// "uploadedDocuments" edge predicates.
	HasUploadedDocuments     *bool                        `json:"hasUploadedDocuments,omitempty"`
	HasUploadedDocumentsWith []*CompanyDocumentWhereInput `json:"hasUploadedDocumentsWith,omitempty"`

	// "approvedDocuments" edge predicates.
	HasApprovedDocuments     *bool                        `json:"hasApprovedDocuments,omitempty"`
	HasApprovedDocumentsWith []*CompanyDocumentWhereInput `json:"hasApprovedDocumentsWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *UserWhereInput) AddPredicates(predicates ...predicate.User) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the UserWhereInput filter on the UserQuery builder.
func (i *UserWhereInput) Filter(q *UserQuery) (*UserQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyUserWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyUserWhereInput is returned in case the UserWhereInput is empty.
var ErrEmptyUserWhereInput = errors.New("generated: empty predicate UserWhereInput")

// P returns a predicate for filtering users.
// An error is returned if the input is empty or invalid.
func (i *UserWhereInput) P() (predicate.User, error) {
	var predicates []predicate.User
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, user.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.User, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, user.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.User, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, user.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, user.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, user.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, user.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, user.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, user.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, user.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, user.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, user.IDLTE(*i.IDLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, user.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, user.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, user.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, user.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, user.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, user.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, user.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, user.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, user.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, user.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, user.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, user.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, user.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, user.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, user.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, user.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.DeletedAt != nil {
		predicates = append(predicates, user.DeletedAtEQ(*i.DeletedAt))
	}
	if i.DeletedAtNEQ != nil {
		predicates = append(predicates, user.DeletedAtNEQ(*i.DeletedAtNEQ))
	}
	if len(i.DeletedAtIn) > 0 {
		predicates = append(predicates, user.DeletedAtIn(i.DeletedAtIn...))
	}
	if len(i.DeletedAtNotIn) > 0 {
		predicates = append(predicates, user.DeletedAtNotIn(i.DeletedAtNotIn...))
	}
	if i.DeletedAtGT != nil {
		predicates = append(predicates, user.DeletedAtGT(*i.DeletedAtGT))
	}
	if i.DeletedAtGTE != nil {
		predicates = append(predicates, user.DeletedAtGTE(*i.DeletedAtGTE))
	}
	if i.DeletedAtLT != nil {
		predicates = append(predicates, user.DeletedAtLT(*i.DeletedAtLT))
	}
	if i.DeletedAtLTE != nil {
		predicates = append(predicates, user.DeletedAtLTE(*i.DeletedAtLTE))
	}
	if i.DeletedAtIsNil {
		predicates = append(predicates, user.DeletedAtIsNil())
	}
	if i.DeletedAtNotNil {
		predicates = append(predicates, user.DeletedAtNotNil())
	}
	if i.FirebaseUID != nil {
		predicates = append(predicates, user.FirebaseUIDEQ(*i.FirebaseUID))
	}
	if i.FirebaseUIDNEQ != nil {
		predicates = append(predicates, user.FirebaseUIDNEQ(*i.FirebaseUIDNEQ))
	}
	if len(i.FirebaseUIDIn) > 0 {
		predicates = append(predicates, user.FirebaseUIDIn(i.FirebaseUIDIn...))
	}
	if len(i.FirebaseUIDNotIn) > 0 {
		predicates = append(predicates, user.FirebaseUIDNotIn(i.FirebaseUIDNotIn...))
	}
	if i.FirebaseUIDGT != nil {
		predicates = append(predicates, user.FirebaseUIDGT(*i.FirebaseUIDGT))
	}
	if i.FirebaseUIDGTE != nil {
		predicates = append(predicates, user.FirebaseUIDGTE(*i.FirebaseUIDGTE))
	}
	if i.FirebaseUIDLT != nil {
		predicates = append(predicates, user.FirebaseUIDLT(*i.FirebaseUIDLT))
	}
	if i.FirebaseUIDLTE != nil {
		predicates = append(predicates, user.FirebaseUIDLTE(*i.FirebaseUIDLTE))
	}
	if i.FirebaseUIDContains != nil {
		predicates = append(predicates, user.FirebaseUIDContains(*i.FirebaseUIDContains))
	}
	if i.FirebaseUIDHasPrefix != nil {
		predicates = append(predicates, user.FirebaseUIDHasPrefix(*i.FirebaseUIDHasPrefix))
	}
	if i.FirebaseUIDHasSuffix != nil {
		predicates = append(predicates, user.FirebaseUIDHasSuffix(*i.FirebaseUIDHasSuffix))
	}
	if i.FirebaseUIDEqualFold != nil {
		predicates = append(predicates, user.FirebaseUIDEqualFold(*i.FirebaseUIDEqualFold))
	}
	if i.FirebaseUIDContainsFold != nil {
		predicates = append(predicates, user.FirebaseUIDContainsFold(*i.FirebaseUIDContainsFold))
	}
	if i.FcmToken != nil {
		predicates = append(predicates, user.FcmTokenEQ(*i.FcmToken))
	}
	if i.FcmTokenNEQ != nil {
		predicates = append(predicates, user.FcmTokenNEQ(*i.FcmTokenNEQ))
	}
	if len(i.FcmTokenIn) > 0 {
		predicates = append(predicates, user.FcmTokenIn(i.FcmTokenIn...))
	}
	if len(i.FcmTokenNotIn) > 0 {
		predicates = append(predicates, user.FcmTokenNotIn(i.FcmTokenNotIn...))
	}
	if i.FcmTokenGT != nil {
		predicates = append(predicates, user.FcmTokenGT(*i.FcmTokenGT))
	}
	if i.FcmTokenGTE != nil {
		predicates = append(predicates, user.FcmTokenGTE(*i.FcmTokenGTE))
	}
	if i.FcmTokenLT != nil {
		predicates = append(predicates, user.FcmTokenLT(*i.FcmTokenLT))
	}
	if i.FcmTokenLTE != nil {
		predicates = append(predicates, user.FcmTokenLTE(*i.FcmTokenLTE))
	}
	if i.FcmTokenContains != nil {
		predicates = append(predicates, user.FcmTokenContains(*i.FcmTokenContains))
	}
	if i.FcmTokenHasPrefix != nil {
		predicates = append(predicates, user.FcmTokenHasPrefix(*i.FcmTokenHasPrefix))
	}
	if i.FcmTokenHasSuffix != nil {
		predicates = append(predicates, user.FcmTokenHasSuffix(*i.FcmTokenHasSuffix))
	}
	if i.FcmTokenIsNil {
		predicates = append(predicates, user.FcmTokenIsNil())
	}
	if i.FcmTokenNotNil {
		predicates = append(predicates, user.FcmTokenNotNil())
	}
	if i.FcmTokenEqualFold != nil {
		predicates = append(predicates, user.FcmTokenEqualFold(*i.FcmTokenEqualFold))
	}
	if i.FcmTokenContainsFold != nil {
		predicates = append(predicates, user.FcmTokenContainsFold(*i.FcmTokenContainsFold))
	}
	if i.ExpoPushToken != nil {
		predicates = append(predicates, user.ExpoPushTokenEQ(*i.ExpoPushToken))
	}
	if i.ExpoPushTokenNEQ != nil {
		predicates = append(predicates, user.ExpoPushTokenNEQ(*i.ExpoPushTokenNEQ))
	}
	if len(i.ExpoPushTokenIn) > 0 {
		predicates = append(predicates, user.ExpoPushTokenIn(i.ExpoPushTokenIn...))
	}
	if len(i.ExpoPushTokenNotIn) > 0 {
		predicates = append(predicates, user.ExpoPushTokenNotIn(i.ExpoPushTokenNotIn...))
	}
	if i.ExpoPushTokenGT != nil {
		predicates = append(predicates, user.ExpoPushTokenGT(*i.ExpoPushTokenGT))
	}
	if i.ExpoPushTokenGTE != nil {
		predicates = append(predicates, user.ExpoPushTokenGTE(*i.ExpoPushTokenGTE))
	}
	if i.ExpoPushTokenLT != nil {
		predicates = append(predicates, user.ExpoPushTokenLT(*i.ExpoPushTokenLT))
	}
	if i.ExpoPushTokenLTE != nil {
		predicates = append(predicates, user.ExpoPushTokenLTE(*i.ExpoPushTokenLTE))
	}
	if i.ExpoPushTokenContains != nil {
		predicates = append(predicates, user.ExpoPushTokenContains(*i.ExpoPushTokenContains))
	}
	if i.ExpoPushTokenHasPrefix != nil {
		predicates = append(predicates, user.ExpoPushTokenHasPrefix(*i.ExpoPushTokenHasPrefix))
	}
	if i.ExpoPushTokenHasSuffix != nil {
		predicates = append(predicates, user.ExpoPushTokenHasSuffix(*i.ExpoPushTokenHasSuffix))
	}
	if i.ExpoPushTokenIsNil {
		predicates = append(predicates, user.ExpoPushTokenIsNil())
	}
	if i.ExpoPushTokenNotNil {
		predicates = append(predicates, user.ExpoPushTokenNotNil())
	}
	if i.ExpoPushTokenEqualFold != nil {
		predicates = append(predicates, user.ExpoPushTokenEqualFold(*i.ExpoPushTokenEqualFold))
	}
	if i.ExpoPushTokenContainsFold != nil {
		predicates = append(predicates, user.ExpoPushTokenContainsFold(*i.ExpoPushTokenContainsFold))
	}
	if i.Email != nil {
		predicates = append(predicates, user.EmailEQ(*i.Email))
	}
	if i.EmailNEQ != nil {
		predicates = append(predicates, user.EmailNEQ(*i.EmailNEQ))
	}
	if len(i.EmailIn) > 0 {
		predicates = append(predicates, user.EmailIn(i.EmailIn...))
	}
	if len(i.EmailNotIn) > 0 {
		predicates = append(predicates, user.EmailNotIn(i.EmailNotIn...))
	}
	if i.EmailGT != nil {
		predicates = append(predicates, user.EmailGT(*i.EmailGT))
	}
	if i.EmailGTE != nil {
		predicates = append(predicates, user.EmailGTE(*i.EmailGTE))
	}
	if i.EmailLT != nil {
		predicates = append(predicates, user.EmailLT(*i.EmailLT))
	}
	if i.EmailLTE != nil {
		predicates = append(predicates, user.EmailLTE(*i.EmailLTE))
	}
	if i.EmailContains != nil {
		predicates = append(predicates, user.EmailContains(*i.EmailContains))
	}
	if i.EmailHasPrefix != nil {
		predicates = append(predicates, user.EmailHasPrefix(*i.EmailHasPrefix))
	}
	if i.EmailHasSuffix != nil {
		predicates = append(predicates, user.EmailHasSuffix(*i.EmailHasSuffix))
	}
	if i.EmailEqualFold != nil {
		predicates = append(predicates, user.EmailEqualFold(*i.EmailEqualFold))
	}
	if i.EmailContainsFold != nil {
		predicates = append(predicates, user.EmailContainsFold(*i.EmailContainsFold))
	}
	if i.Name != nil {
		predicates = append(predicates, user.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, user.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, user.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, user.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, user.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, user.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, user.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, user.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, user.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, user.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, user.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, user.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, user.NameContainsFold(*i.NameContainsFold))
	}
	if i.Address != nil {
		predicates = append(predicates, user.AddressEQ(*i.Address))
	}
	if i.AddressNEQ != nil {
		predicates = append(predicates, user.AddressNEQ(*i.AddressNEQ))
	}
	if len(i.AddressIn) > 0 {
		predicates = append(predicates, user.AddressIn(i.AddressIn...))
	}
	if len(i.AddressNotIn) > 0 {
		predicates = append(predicates, user.AddressNotIn(i.AddressNotIn...))
	}
	if i.AddressGT != nil {
		predicates = append(predicates, user.AddressGT(*i.AddressGT))
	}
	if i.AddressGTE != nil {
		predicates = append(predicates, user.AddressGTE(*i.AddressGTE))
	}
	if i.AddressLT != nil {
		predicates = append(predicates, user.AddressLT(*i.AddressLT))
	}
	if i.AddressLTE != nil {
		predicates = append(predicates, user.AddressLTE(*i.AddressLTE))
	}
	if i.AddressContains != nil {
		predicates = append(predicates, user.AddressContains(*i.AddressContains))
	}
	if i.AddressHasPrefix != nil {
		predicates = append(predicates, user.AddressHasPrefix(*i.AddressHasPrefix))
	}
	if i.AddressHasSuffix != nil {
		predicates = append(predicates, user.AddressHasSuffix(*i.AddressHasSuffix))
	}
	if i.AddressIsNil {
		predicates = append(predicates, user.AddressIsNil())
	}
	if i.AddressNotNil {
		predicates = append(predicates, user.AddressNotNil())
	}
	if i.AddressEqualFold != nil {
		predicates = append(predicates, user.AddressEqualFold(*i.AddressEqualFold))
	}
	if i.AddressContainsFold != nil {
		predicates = append(predicates, user.AddressContainsFold(*i.AddressContainsFold))
	}
	if i.Avatar != nil {
		predicates = append(predicates, user.AvatarEQ(*i.Avatar))
	}
	if i.AvatarNEQ != nil {
		predicates = append(predicates, user.AvatarNEQ(*i.AvatarNEQ))
	}
	if len(i.AvatarIn) > 0 {
		predicates = append(predicates, user.AvatarIn(i.AvatarIn...))
	}
	if len(i.AvatarNotIn) > 0 {
		predicates = append(predicates, user.AvatarNotIn(i.AvatarNotIn...))
	}
	if i.AvatarGT != nil {
		predicates = append(predicates, user.AvatarGT(*i.AvatarGT))
	}
	if i.AvatarGTE != nil {
		predicates = append(predicates, user.AvatarGTE(*i.AvatarGTE))
	}
	if i.AvatarLT != nil {
		predicates = append(predicates, user.AvatarLT(*i.AvatarLT))
	}
	if i.AvatarLTE != nil {
		predicates = append(predicates, user.AvatarLTE(*i.AvatarLTE))
	}
	if i.AvatarContains != nil {
		predicates = append(predicates, user.AvatarContains(*i.AvatarContains))
	}
	if i.AvatarHasPrefix != nil {
		predicates = append(predicates, user.AvatarHasPrefix(*i.AvatarHasPrefix))
	}
	if i.AvatarHasSuffix != nil {
		predicates = append(predicates, user.AvatarHasSuffix(*i.AvatarHasSuffix))
	}
	if i.AvatarIsNil {
		predicates = append(predicates, user.AvatarIsNil())
	}
	if i.AvatarNotNil {
		predicates = append(predicates, user.AvatarNotNil())
	}
	if i.AvatarEqualFold != nil {
		predicates = append(predicates, user.AvatarEqualFold(*i.AvatarEqualFold))
	}
	if i.AvatarContainsFold != nil {
		predicates = append(predicates, user.AvatarContainsFold(*i.AvatarContainsFold))
	}
	if i.PhotoURL != nil {
		predicates = append(predicates, user.PhotoURLEQ(*i.PhotoURL))
	}
	if i.PhotoURLNEQ != nil {
		predicates = append(predicates, user.PhotoURLNEQ(*i.PhotoURLNEQ))
	}
	if len(i.PhotoURLIn) > 0 {
		predicates = append(predicates, user.PhotoURLIn(i.PhotoURLIn...))
	}
	if len(i.PhotoURLNotIn) > 0 {
		predicates = append(predicates, user.PhotoURLNotIn(i.PhotoURLNotIn...))
	}
	if i.PhotoURLGT != nil {
		predicates = append(predicates, user.PhotoURLGT(*i.PhotoURLGT))
	}
	if i.PhotoURLGTE != nil {
		predicates = append(predicates, user.PhotoURLGTE(*i.PhotoURLGTE))
	}
	if i.PhotoURLLT != nil {
		predicates = append(predicates, user.PhotoURLLT(*i.PhotoURLLT))
	}
	if i.PhotoURLLTE != nil {
		predicates = append(predicates, user.PhotoURLLTE(*i.PhotoURLLTE))
	}
	if i.PhotoURLContains != nil {
		predicates = append(predicates, user.PhotoURLContains(*i.PhotoURLContains))
	}
	if i.PhotoURLHasPrefix != nil {
		predicates = append(predicates, user.PhotoURLHasPrefix(*i.PhotoURLHasPrefix))
	}
	if i.PhotoURLHasSuffix != nil {
		predicates = append(predicates, user.PhotoURLHasSuffix(*i.PhotoURLHasSuffix))
	}
	if i.PhotoURLIsNil {
		predicates = append(predicates, user.PhotoURLIsNil())
	}
	if i.PhotoURLNotNil {
		predicates = append(predicates, user.PhotoURLNotNil())
	}
	if i.PhotoURLEqualFold != nil {
		predicates = append(predicates, user.PhotoURLEqualFold(*i.PhotoURLEqualFold))
	}
	if i.PhotoURLContainsFold != nil {
		predicates = append(predicates, user.PhotoURLContainsFold(*i.PhotoURLContainsFold))
	}
	if i.Department != nil {
		predicates = append(predicates, user.DepartmentEQ(*i.Department))
	}
	if i.DepartmentNEQ != nil {
		predicates = append(predicates, user.DepartmentNEQ(*i.DepartmentNEQ))
	}
	if len(i.DepartmentIn) > 0 {
		predicates = append(predicates, user.DepartmentIn(i.DepartmentIn...))
	}
	if len(i.DepartmentNotIn) > 0 {
		predicates = append(predicates, user.DepartmentNotIn(i.DepartmentNotIn...))
	}
	if i.DepartmentGT != nil {
		predicates = append(predicates, user.DepartmentGT(*i.DepartmentGT))
	}
	if i.DepartmentGTE != nil {
		predicates = append(predicates, user.DepartmentGTE(*i.DepartmentGTE))
	}
	if i.DepartmentLT != nil {
		predicates = append(predicates, user.DepartmentLT(*i.DepartmentLT))
	}
	if i.DepartmentLTE != nil {
		predicates = append(predicates, user.DepartmentLTE(*i.DepartmentLTE))
	}
	if i.DepartmentContains != nil {
		predicates = append(predicates, user.DepartmentContains(*i.DepartmentContains))
	}
	if i.DepartmentHasPrefix != nil {
		predicates = append(predicates, user.DepartmentHasPrefix(*i.DepartmentHasPrefix))
	}
	if i.DepartmentHasSuffix != nil {
		predicates = append(predicates, user.DepartmentHasSuffix(*i.DepartmentHasSuffix))
	}
	if i.DepartmentIsNil {
		predicates = append(predicates, user.DepartmentIsNil())
	}
	if i.DepartmentNotNil {
		predicates = append(predicates, user.DepartmentNotNil())
	}
	if i.DepartmentEqualFold != nil {
		predicates = append(predicates, user.DepartmentEqualFold(*i.DepartmentEqualFold))
	}
	if i.DepartmentContainsFold != nil {
		predicates = append(predicates, user.DepartmentContainsFold(*i.DepartmentContainsFold))
	}
	if i.Phone != nil {
		predicates = append(predicates, user.PhoneEQ(*i.Phone))
	}
	if i.PhoneNEQ != nil {
		predicates = append(predicates, user.PhoneNEQ(*i.PhoneNEQ))
	}
	if len(i.PhoneIn) > 0 {
		predicates = append(predicates, user.PhoneIn(i.PhoneIn...))
	}
	if len(i.PhoneNotIn) > 0 {
		predicates = append(predicates, user.PhoneNotIn(i.PhoneNotIn...))
	}
	if i.PhoneGT != nil {
		predicates = append(predicates, user.PhoneGT(*i.PhoneGT))
	}
	if i.PhoneGTE != nil {
		predicates = append(predicates, user.PhoneGTE(*i.PhoneGTE))
	}
	if i.PhoneLT != nil {
		predicates = append(predicates, user.PhoneLT(*i.PhoneLT))
	}
	if i.PhoneLTE != nil {
		predicates = append(predicates, user.PhoneLTE(*i.PhoneLTE))
	}
	if i.PhoneContains != nil {
		predicates = append(predicates, user.PhoneContains(*i.PhoneContains))
	}
	if i.PhoneHasPrefix != nil {
		predicates = append(predicates, user.PhoneHasPrefix(*i.PhoneHasPrefix))
	}
	if i.PhoneHasSuffix != nil {
		predicates = append(predicates, user.PhoneHasSuffix(*i.PhoneHasSuffix))
	}
	if i.PhoneIsNil {
		predicates = append(predicates, user.PhoneIsNil())
	}
	if i.PhoneNotNil {
		predicates = append(predicates, user.PhoneNotNil())
	}
	if i.PhoneEqualFold != nil {
		predicates = append(predicates, user.PhoneEqualFold(*i.PhoneEqualFold))
	}
	if i.PhoneContainsFold != nil {
		predicates = append(predicates, user.PhoneContainsFold(*i.PhoneContainsFold))
	}
	if i.Birthdate != nil {
		predicates = append(predicates, user.BirthdateEQ(*i.Birthdate))
	}
	if i.BirthdateNEQ != nil {
		predicates = append(predicates, user.BirthdateNEQ(*i.BirthdateNEQ))
	}
	if len(i.BirthdateIn) > 0 {
		predicates = append(predicates, user.BirthdateIn(i.BirthdateIn...))
	}
	if len(i.BirthdateNotIn) > 0 {
		predicates = append(predicates, user.BirthdateNotIn(i.BirthdateNotIn...))
	}
	if i.BirthdateGT != nil {
		predicates = append(predicates, user.BirthdateGT(*i.BirthdateGT))
	}
	if i.BirthdateGTE != nil {
		predicates = append(predicates, user.BirthdateGTE(*i.BirthdateGTE))
	}
	if i.BirthdateLT != nil {
		predicates = append(predicates, user.BirthdateLT(*i.BirthdateLT))
	}
	if i.BirthdateLTE != nil {
		predicates = append(predicates, user.BirthdateLTE(*i.BirthdateLTE))
	}
	if i.BirthdateIsNil {
		predicates = append(predicates, user.BirthdateIsNil())
	}
	if i.BirthdateNotNil {
		predicates = append(predicates, user.BirthdateNotNil())
	}
	if i.LastLogin != nil {
		predicates = append(predicates, user.LastLoginEQ(*i.LastLogin))
	}
	if i.LastLoginNEQ != nil {
		predicates = append(predicates, user.LastLoginNEQ(*i.LastLoginNEQ))
	}
	if len(i.LastLoginIn) > 0 {
		predicates = append(predicates, user.LastLoginIn(i.LastLoginIn...))
	}
	if len(i.LastLoginNotIn) > 0 {
		predicates = append(predicates, user.LastLoginNotIn(i.LastLoginNotIn...))
	}
	if i.LastLoginGT != nil {
		predicates = append(predicates, user.LastLoginGT(*i.LastLoginGT))
	}
	if i.LastLoginGTE != nil {
		predicates = append(predicates, user.LastLoginGTE(*i.LastLoginGTE))
	}
	if i.LastLoginLT != nil {
		predicates = append(predicates, user.LastLoginLT(*i.LastLoginLT))
	}
	if i.LastLoginLTE != nil {
		predicates = append(predicates, user.LastLoginLTE(*i.LastLoginLTE))
	}
	if i.LastLoginIsNil {
		predicates = append(predicates, user.LastLoginIsNil())
	}
	if i.LastLoginNotNil {
		predicates = append(predicates, user.LastLoginNotNil())
	}
	if i.Gender != nil {
		predicates = append(predicates, user.GenderEQ(*i.Gender))
	}
	if i.GenderNEQ != nil {
		predicates = append(predicates, user.GenderNEQ(*i.GenderNEQ))
	}
	if len(i.GenderIn) > 0 {
		predicates = append(predicates, user.GenderIn(i.GenderIn...))
	}
	if len(i.GenderNotIn) > 0 {
		predicates = append(predicates, user.GenderNotIn(i.GenderNotIn...))
	}
	if i.Active != nil {
		predicates = append(predicates, user.ActiveEQ(*i.Active))
	}
	if i.ActiveNEQ != nil {
		predicates = append(predicates, user.ActiveNEQ(*i.ActiveNEQ))
	}

	if i.HasAccountingEntries != nil {
		p := user.HasAccountingEntries()
		if !*i.HasAccountingEntries {
			p = user.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasAccountingEntriesWith) > 0 {
		with := make([]predicate.AccountingEntry, 0, len(i.HasAccountingEntriesWith))
		for _, w := range i.HasAccountingEntriesWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasAccountingEntriesWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, user.HasAccountingEntriesWith(with...))
	}
	if i.HasCompany != nil {
		p := user.HasCompany()
		if !*i.HasCompany {
			p = user.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasCompanyWith) > 0 {
		with := make([]predicate.Company, 0, len(i.HasCompanyWith))
		for _, w := range i.HasCompanyWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasCompanyWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, user.HasCompanyWith(with...))
	}
	if i.HasAssignedRoles != nil {
		p := user.HasAssignedRoles()
		if !*i.HasAssignedRoles {
			p = user.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasAssignedRolesWith) > 0 {
		with := make([]predicate.UserRole, 0, len(i.HasAssignedRolesWith))
		for _, w := range i.HasAssignedRolesWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasAssignedRolesWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, user.HasAssignedRolesWith(with...))
	}
	if i.HasSubordinates != nil {
		p := user.HasSubordinates()
		if !*i.HasSubordinates {
			p = user.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasSubordinatesWith) > 0 {
		with := make([]predicate.User, 0, len(i.HasSubordinatesWith))
		for _, w := range i.HasSubordinatesWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasSubordinatesWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, user.HasSubordinatesWith(with...))
	}
	if i.HasLeader != nil {
		p := user.HasLeader()
		if !*i.HasLeader {
			p = user.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasLeaderWith) > 0 {
		with := make([]predicate.User, 0, len(i.HasLeaderWith))
		for _, w := range i.HasLeaderWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasLeaderWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, user.HasLeaderWith(with...))
	}
	if i.HasCreatedMemberSignupTokens != nil {
		p := user.HasCreatedMemberSignupTokens()
		if !*i.HasCreatedMemberSignupTokens {
			p = user.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasCreatedMemberSignupTokensWith) > 0 {
		with := make([]predicate.MemberSignupToken, 0, len(i.HasCreatedMemberSignupTokensWith))
		for _, w := range i.HasCreatedMemberSignupTokensWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasCreatedMemberSignupTokensWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, user.HasCreatedMemberSignupTokensWith(with...))
	}
	if i.HasEmployee != nil {
		p := user.HasEmployee()
		if !*i.HasEmployee {
			p = user.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasEmployeeWith) > 0 {
		with := make([]predicate.Employee, 0, len(i.HasEmployeeWith))
		for _, w := range i.HasEmployeeWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasEmployeeWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, user.HasEmployeeWith(with...))
	}
	if i.HasIssuedInvoices != nil {
		p := user.HasIssuedInvoices()
		if !*i.HasIssuedInvoices {
			p = user.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasIssuedInvoicesWith) > 0 {
		with := make([]predicate.Invoice, 0, len(i.HasIssuedInvoicesWith))
		for _, w := range i.HasIssuedInvoicesWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasIssuedInvoicesWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, user.HasIssuedInvoicesWith(with...))
	}
	if i.HasCreatedProjects != nil {
		p := user.HasCreatedProjects()
		if !*i.HasCreatedProjects {
			p = user.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasCreatedProjectsWith) > 0 {
		with := make([]predicate.Project, 0, len(i.HasCreatedProjectsWith))
		for _, w := range i.HasCreatedProjectsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasCreatedProjectsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, user.HasCreatedProjectsWith(with...))
	}
	if i.HasLeaderedProjects != nil {
		p := user.HasLeaderedProjects()
		if !*i.HasLeaderedProjects {
			p = user.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasLeaderedProjectsWith) > 0 {
		with := make([]predicate.Project, 0, len(i.HasLeaderedProjectsWith))
		for _, w := range i.HasLeaderedProjectsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasLeaderedProjectsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, user.HasLeaderedProjectsWith(with...))
	}
	if i.HasAssignedProjectTasks != nil {
		p := user.HasAssignedProjectTasks()
		if !*i.HasAssignedProjectTasks {
			p = user.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasAssignedProjectTasksWith) > 0 {
		with := make([]predicate.ProjectTask, 0, len(i.HasAssignedProjectTasksWith))
		for _, w := range i.HasAssignedProjectTasksWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasAssignedProjectTasksWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, user.HasAssignedProjectTasksWith(with...))
	}
	if i.HasParticipatedProjectTasks != nil {
		p := user.HasParticipatedProjectTasks()
		if !*i.HasParticipatedProjectTasks {
			p = user.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasParticipatedProjectTasksWith) > 0 {
		with := make([]predicate.ProjectTask, 0, len(i.HasParticipatedProjectTasksWith))
		for _, w := range i.HasParticipatedProjectTasksWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasParticipatedProjectTasksWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, user.HasParticipatedProjectTasksWith(with...))
	}
	if i.HasCreatedTasks != nil {
		p := user.HasCreatedTasks()
		if !*i.HasCreatedTasks {
			p = user.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasCreatedTasksWith) > 0 {
		with := make([]predicate.ProjectTask, 0, len(i.HasCreatedTasksWith))
		for _, w := range i.HasCreatedTasksWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasCreatedTasksWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, user.HasCreatedTasksWith(with...))
	}
	if i.HasTokens != nil {
		p := user.HasTokens()
		if !*i.HasTokens {
			p = user.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasTokensWith) > 0 {
		with := make([]predicate.Token, 0, len(i.HasTokensWith))
		for _, w := range i.HasTokensWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasTokensWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, user.HasTokensWith(with...))
	}
	if i.HasApprovedWorkShifts != nil {
		p := user.HasApprovedWorkShifts()
		if !*i.HasApprovedWorkShifts {
			p = user.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasApprovedWorkShiftsWith) > 0 {
		with := make([]predicate.Workshift, 0, len(i.HasApprovedWorkShiftsWith))
		for _, w := range i.HasApprovedWorkShiftsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasApprovedWorkShiftsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, user.HasApprovedWorkShiftsWith(with...))
	}
	if i.HasWorkShifts != nil {
		p := user.HasWorkShifts()
		if !*i.HasWorkShifts {
			p = user.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasWorkShiftsWith) > 0 {
		with := make([]predicate.Workshift, 0, len(i.HasWorkShiftsWith))
		for _, w := range i.HasWorkShiftsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasWorkShiftsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, user.HasWorkShiftsWith(with...))
	}
	if i.HasUploadedDocuments != nil {
		p := user.HasUploadedDocuments()
		if !*i.HasUploadedDocuments {
			p = user.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasUploadedDocumentsWith) > 0 {
		with := make([]predicate.CompanyDocument, 0, len(i.HasUploadedDocumentsWith))
		for _, w := range i.HasUploadedDocumentsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasUploadedDocumentsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, user.HasUploadedDocumentsWith(with...))
	}
	if i.HasApprovedDocuments != nil {
		p := user.HasApprovedDocuments()
		if !*i.HasApprovedDocuments {
			p = user.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasApprovedDocumentsWith) > 0 {
		with := make([]predicate.CompanyDocument, 0, len(i.HasApprovedDocumentsWith))
		for _, w := range i.HasApprovedDocumentsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasApprovedDocumentsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, user.HasApprovedDocumentsWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyUserWhereInput
	case 1:
		return predicates[0], nil
	default:
		return user.And(predicates...), nil
	}
}

// UserRoleWhereInput represents a where input for filtering UserRole queries.
type UserRoleWhereInput struct {
	Predicates []predicate.UserRole  `json:"-"`
	Not        *UserRoleWhereInput   `json:"not,omitempty"`
	Or         []*UserRoleWhereInput `json:"or,omitempty"`
	And        []*UserRoleWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "role" field predicates.
	Role      *userrole.Role  `json:"role,omitempty"`
	RoleNEQ   *userrole.Role  `json:"roleNEQ,omitempty"`
	RoleIn    []userrole.Role `json:"roleIn,omitempty"`
	RoleNotIn []userrole.Role `json:"roleNotIn,omitempty"`

	// "notes" field predicates.
	Notes             *string  `json:"notes,omitempty"`
	NotesNEQ          *string  `json:"notesNEQ,omitempty"`
	NotesIn           []string `json:"notesIn,omitempty"`
	NotesNotIn        []string `json:"notesNotIn,omitempty"`
	NotesGT           *string  `json:"notesGT,omitempty"`
	NotesGTE          *string  `json:"notesGTE,omitempty"`
	NotesLT           *string  `json:"notesLT,omitempty"`
	NotesLTE          *string  `json:"notesLTE,omitempty"`
	NotesContains     *string  `json:"notesContains,omitempty"`
	NotesHasPrefix    *string  `json:"notesHasPrefix,omitempty"`
	NotesHasSuffix    *string  `json:"notesHasSuffix,omitempty"`
	NotesEqualFold    *string  `json:"notesEqualFold,omitempty"`
	NotesContainsFold *string  `json:"notesContainsFold,omitempty"`

	// "company" edge predicates.
	HasCompany     *bool                `json:"hasCompany,omitempty"`
	HasCompanyWith []*CompanyWhereInput `json:"hasCompanyWith,omitempty"`

	// "user" edge predicates.
	HasUser     *bool             `json:"hasUser,omitempty"`
	HasUserWith []*UserWhereInput `json:"hasUserWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *UserRoleWhereInput) AddPredicates(predicates ...predicate.UserRole) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the UserRoleWhereInput filter on the UserRoleQuery builder.
func (i *UserRoleWhereInput) Filter(q *UserRoleQuery) (*UserRoleQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyUserRoleWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyUserRoleWhereInput is returned in case the UserRoleWhereInput is empty.
var ErrEmptyUserRoleWhereInput = errors.New("generated: empty predicate UserRoleWhereInput")

// P returns a predicate for filtering userroles.
// An error is returned if the input is empty or invalid.
func (i *UserRoleWhereInput) P() (predicate.UserRole, error) {
	var predicates []predicate.UserRole
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, userrole.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.UserRole, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, userrole.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.UserRole, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, userrole.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, userrole.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, userrole.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, userrole.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, userrole.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, userrole.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, userrole.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, userrole.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, userrole.IDLTE(*i.IDLTE))
	}
	if i.Role != nil {
		predicates = append(predicates, userrole.RoleEQ(*i.Role))
	}
	if i.RoleNEQ != nil {
		predicates = append(predicates, userrole.RoleNEQ(*i.RoleNEQ))
	}
	if len(i.RoleIn) > 0 {
		predicates = append(predicates, userrole.RoleIn(i.RoleIn...))
	}
	if len(i.RoleNotIn) > 0 {
		predicates = append(predicates, userrole.RoleNotIn(i.RoleNotIn...))
	}
	if i.Notes != nil {
		predicates = append(predicates, userrole.NotesEQ(*i.Notes))
	}
	if i.NotesNEQ != nil {
		predicates = append(predicates, userrole.NotesNEQ(*i.NotesNEQ))
	}
	if len(i.NotesIn) > 0 {
		predicates = append(predicates, userrole.NotesIn(i.NotesIn...))
	}
	if len(i.NotesNotIn) > 0 {
		predicates = append(predicates, userrole.NotesNotIn(i.NotesNotIn...))
	}
	if i.NotesGT != nil {
		predicates = append(predicates, userrole.NotesGT(*i.NotesGT))
	}
	if i.NotesGTE != nil {
		predicates = append(predicates, userrole.NotesGTE(*i.NotesGTE))
	}
	if i.NotesLT != nil {
		predicates = append(predicates, userrole.NotesLT(*i.NotesLT))
	}
	if i.NotesLTE != nil {
		predicates = append(predicates, userrole.NotesLTE(*i.NotesLTE))
	}
	if i.NotesContains != nil {
		predicates = append(predicates, userrole.NotesContains(*i.NotesContains))
	}
	if i.NotesHasPrefix != nil {
		predicates = append(predicates, userrole.NotesHasPrefix(*i.NotesHasPrefix))
	}
	if i.NotesHasSuffix != nil {
		predicates = append(predicates, userrole.NotesHasSuffix(*i.NotesHasSuffix))
	}
	if i.NotesEqualFold != nil {
		predicates = append(predicates, userrole.NotesEqualFold(*i.NotesEqualFold))
	}
	if i.NotesContainsFold != nil {
		predicates = append(predicates, userrole.NotesContainsFold(*i.NotesContainsFold))
	}

	if i.HasCompany != nil {
		p := userrole.HasCompany()
		if !*i.HasCompany {
			p = userrole.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasCompanyWith) > 0 {
		with := make([]predicate.Company, 0, len(i.HasCompanyWith))
		for _, w := range i.HasCompanyWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasCompanyWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, userrole.HasCompanyWith(with...))
	}
	if i.HasUser != nil {
		p := userrole.HasUser()
		if !*i.HasUser {
			p = userrole.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasUserWith) > 0 {
		with := make([]predicate.User, 0, len(i.HasUserWith))
		for _, w := range i.HasUserWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasUserWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, userrole.HasUserWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyUserRoleWhereInput
	case 1:
		return predicates[0], nil
	default:
		return userrole.And(predicates...), nil
	}
}

// WorkshiftWhereInput represents a where input for filtering Workshift queries.
type WorkshiftWhereInput struct {
	Predicates []predicate.Workshift  `json:"-"`
	Not        *WorkshiftWhereInput   `json:"not,omitempty"`
	Or         []*WorkshiftWhereInput `json:"or,omitempty"`
	And        []*WorkshiftWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "createdAt" field predicates.
	CreatedAt      *time.Time  `json:"createdat,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdatNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdatIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdatNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdatGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdatGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdatLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdatLTE,omitempty"`

	// "updatedAt" field predicates.
	UpdatedAt      *time.Time  `json:"updatedat,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedatNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedatIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedatNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedatGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedatGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedatLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedatLTE,omitempty"`

	// "deletedAt" field predicates.
	DeletedAt       *time.Time  `json:"deletedat,omitempty"`
	DeletedAtNEQ    *time.Time  `json:"deletedatNEQ,omitempty"`
	DeletedAtIn     []time.Time `json:"deletedatIn,omitempty"`
	DeletedAtNotIn  []time.Time `json:"deletedatNotIn,omitempty"`
	DeletedAtGT     *time.Time  `json:"deletedatGT,omitempty"`
	DeletedAtGTE    *time.Time  `json:"deletedatGTE,omitempty"`
	DeletedAtLT     *time.Time  `json:"deletedatLT,omitempty"`
	DeletedAtLTE    *time.Time  `json:"deletedatLTE,omitempty"`
	DeletedAtIsNil  bool        `json:"deletedatIsNil,omitempty"`
	DeletedAtNotNil bool        `json:"deletedatNotNil,omitempty"`

	// "approvedAt" field predicates.
	ApprovedAt       *time.Time  `json:"approvedat,omitempty"`
	ApprovedAtNEQ    *time.Time  `json:"approvedatNEQ,omitempty"`
	ApprovedAtIn     []time.Time `json:"approvedatIn,omitempty"`
	ApprovedAtNotIn  []time.Time `json:"approvedatNotIn,omitempty"`
	ApprovedAtGT     *time.Time  `json:"approvedatGT,omitempty"`
	ApprovedAtGTE    *time.Time  `json:"approvedatGTE,omitempty"`
	ApprovedAtLT     *time.Time  `json:"approvedatLT,omitempty"`
	ApprovedAtLTE    *time.Time  `json:"approvedatLTE,omitempty"`
	ApprovedAtIsNil  bool        `json:"approvedatIsNil,omitempty"`
	ApprovedAtNotNil bool        `json:"approvedatNotNil,omitempty"`

	// "clockIn" field predicates.
	ClockIn      *time.Time  `json:"clockin,omitempty"`
	ClockInNEQ   *time.Time  `json:"clockinNEQ,omitempty"`
	ClockInIn    []time.Time `json:"clockinIn,omitempty"`
	ClockInNotIn []time.Time `json:"clockinNotIn,omitempty"`
	ClockInGT    *time.Time  `json:"clockinGT,omitempty"`
	ClockInGTE   *time.Time  `json:"clockinGTE,omitempty"`
	ClockInLT    *time.Time  `json:"clockinLT,omitempty"`
	ClockInLTE   *time.Time  `json:"clockinLTE,omitempty"`

	// "clockOut" field predicates.
	ClockOut       *time.Time  `json:"clockout,omitempty"`
	ClockOutNEQ    *time.Time  `json:"clockoutNEQ,omitempty"`
	ClockOutIn     []time.Time `json:"clockoutIn,omitempty"`
	ClockOutNotIn  []time.Time `json:"clockoutNotIn,omitempty"`
	ClockOutGT     *time.Time  `json:"clockoutGT,omitempty"`
	ClockOutGTE    *time.Time  `json:"clockoutGTE,omitempty"`
	ClockOutLT     *time.Time  `json:"clockoutLT,omitempty"`
	ClockOutLTE    *time.Time  `json:"clockoutLTE,omitempty"`
	ClockOutIsNil  bool        `json:"clockoutIsNil,omitempty"`
	ClockOutNotNil bool        `json:"clockoutNotNil,omitempty"`

	// "clockInLocation" field predicates.
	ClockInLocation             *string  `json:"clockinlocation,omitempty"`
	ClockInLocationNEQ          *string  `json:"clockinlocationNEQ,omitempty"`
	ClockInLocationIn           []string `json:"clockinlocationIn,omitempty"`
	ClockInLocationNotIn        []string `json:"clockinlocationNotIn,omitempty"`
	ClockInLocationGT           *string  `json:"clockinlocationGT,omitempty"`
	ClockInLocationGTE          *string  `json:"clockinlocationGTE,omitempty"`
	ClockInLocationLT           *string  `json:"clockinlocationLT,omitempty"`
	ClockInLocationLTE          *string  `json:"clockinlocationLTE,omitempty"`
	ClockInLocationContains     *string  `json:"clockinlocationContains,omitempty"`
	ClockInLocationHasPrefix    *string  `json:"clockinlocationHasPrefix,omitempty"`
	ClockInLocationHasSuffix    *string  `json:"clockinlocationHasSuffix,omitempty"`
	ClockInLocationEqualFold    *string  `json:"clockinlocationEqualFold,omitempty"`
	ClockInLocationContainsFold *string  `json:"clockinlocationContainsFold,omitempty"`

	// "clockOutLocation" field predicates.
	ClockOutLocation             *string  `json:"clockoutlocation,omitempty"`
	ClockOutLocationNEQ          *string  `json:"clockoutlocationNEQ,omitempty"`
	ClockOutLocationIn           []string `json:"clockoutlocationIn,omitempty"`
	ClockOutLocationNotIn        []string `json:"clockoutlocationNotIn,omitempty"`
	ClockOutLocationGT           *string  `json:"clockoutlocationGT,omitempty"`
	ClockOutLocationGTE          *string  `json:"clockoutlocationGTE,omitempty"`
	ClockOutLocationLT           *string  `json:"clockoutlocationLT,omitempty"`
	ClockOutLocationLTE          *string  `json:"clockoutlocationLTE,omitempty"`
	ClockOutLocationContains     *string  `json:"clockoutlocationContains,omitempty"`
	ClockOutLocationHasPrefix    *string  `json:"clockoutlocationHasPrefix,omitempty"`
	ClockOutLocationHasSuffix    *string  `json:"clockoutlocationHasSuffix,omitempty"`
	ClockOutLocationIsNil        bool     `json:"clockoutlocationIsNil,omitempty"`
	ClockOutLocationNotNil       bool     `json:"clockoutlocationNotNil,omitempty"`
	ClockOutLocationEqualFold    *string  `json:"clockoutlocationEqualFold,omitempty"`
	ClockOutLocationContainsFold *string  `json:"clockoutlocationContainsFold,omitempty"`

	// "description" field predicates.
	Description             *string  `json:"description,omitempty"`
	DescriptionNEQ          *string  `json:"descriptionNEQ,omitempty"`
	DescriptionIn           []string `json:"descriptionIn,omitempty"`
	DescriptionNotIn        []string `json:"descriptionNotIn,omitempty"`
	DescriptionGT           *string  `json:"descriptionGT,omitempty"`
	DescriptionGTE          *string  `json:"descriptionGTE,omitempty"`
	DescriptionLT           *string  `json:"descriptionLT,omitempty"`
	DescriptionLTE          *string  `json:"descriptionLTE,omitempty"`
	DescriptionContains     *string  `json:"descriptionContains,omitempty"`
	DescriptionHasPrefix    *string  `json:"descriptionHasPrefix,omitempty"`
	DescriptionHasSuffix    *string  `json:"descriptionHasSuffix,omitempty"`
	DescriptionIsNil        bool     `json:"descriptionIsNil,omitempty"`
	DescriptionNotNil       bool     `json:"descriptionNotNil,omitempty"`
	DescriptionEqualFold    *string  `json:"descriptionEqualFold,omitempty"`
	DescriptionContainsFold *string  `json:"descriptionContainsFold,omitempty"`

	// "note" field predicates.
	Note             *string  `json:"note,omitempty"`
	NoteNEQ          *string  `json:"noteNEQ,omitempty"`
	NoteIn           []string `json:"noteIn,omitempty"`
	NoteNotIn        []string `json:"noteNotIn,omitempty"`
	NoteGT           *string  `json:"noteGT,omitempty"`
	NoteGTE          *string  `json:"noteGTE,omitempty"`
	NoteLT           *string  `json:"noteLT,omitempty"`
	NoteLTE          *string  `json:"noteLTE,omitempty"`
	NoteContains     *string  `json:"noteContains,omitempty"`
	NoteHasPrefix    *string  `json:"noteHasPrefix,omitempty"`
	NoteHasSuffix    *string  `json:"noteHasSuffix,omitempty"`
	NoteIsNil        bool     `json:"noteIsNil,omitempty"`
	NoteNotNil       bool     `json:"noteNotNil,omitempty"`
	NoteEqualFold    *string  `json:"noteEqualFold,omitempty"`
	NoteContainsFold *string  `json:"noteContainsFold,omitempty"`

	// "status" field predicates.
	Status      *workshift.Status  `json:"status,omitempty"`
	StatusNEQ   *workshift.Status  `json:"statusNEQ,omitempty"`
	StatusIn    []workshift.Status `json:"statusIn,omitempty"`
	StatusNotIn []workshift.Status `json:"statusNotIn,omitempty"`

	// "company" edge predicates.
	HasCompany     *bool                `json:"hasCompany,omitempty"`
	HasCompanyWith []*CompanyWhereInput `json:"hasCompanyWith,omitempty"`

	// "user" edge predicates.
	HasUser     *bool             `json:"hasUser,omitempty"`
	HasUserWith []*UserWhereInput `json:"hasUserWith,omitempty"`

	// "approvedBy" edge predicates.
	HasApprovedBy     *bool             `json:"hasApprovedBy,omitempty"`
	HasApprovedByWith []*UserWhereInput `json:"hasApprovedByWith,omitempty"`

	// "task" edge predicates.
	HasTask     *bool                    `json:"hasTask,omitempty"`
	HasTaskWith []*ProjectTaskWhereInput `json:"hasTaskWith,omitempty"`

	// "editRequest" edge predicates.
	HasEditRequest     *bool                  `json:"hasEditRequest,omitempty"`
	HasEditRequestWith []*WorkshiftWhereInput `json:"hasEditRequestWith,omitempty"`

	// "workShift" edge predicates.
	HasWorkShift     *bool                  `json:"hasWorkShift,omitempty"`
	HasWorkShiftWith []*WorkshiftWhereInput `json:"hasWorkShiftWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *WorkshiftWhereInput) AddPredicates(predicates ...predicate.Workshift) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the WorkshiftWhereInput filter on the WorkshiftQuery builder.
func (i *WorkshiftWhereInput) Filter(q *WorkshiftQuery) (*WorkshiftQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyWorkshiftWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyWorkshiftWhereInput is returned in case the WorkshiftWhereInput is empty.
var ErrEmptyWorkshiftWhereInput = errors.New("generated: empty predicate WorkshiftWhereInput")

// P returns a predicate for filtering workshifts.
// An error is returned if the input is empty or invalid.
func (i *WorkshiftWhereInput) P() (predicate.Workshift, error) {
	var predicates []predicate.Workshift
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, workshift.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Workshift, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, workshift.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Workshift, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, workshift.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, workshift.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, workshift.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, workshift.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, workshift.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, workshift.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, workshift.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, workshift.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, workshift.IDLTE(*i.IDLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, workshift.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, workshift.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, workshift.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, workshift.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, workshift.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, workshift.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, workshift.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, workshift.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, workshift.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, workshift.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, workshift.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, workshift.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, workshift.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, workshift.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, workshift.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, workshift.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.DeletedAt != nil {
		predicates = append(predicates, workshift.DeletedAtEQ(*i.DeletedAt))
	}
	if i.DeletedAtNEQ != nil {
		predicates = append(predicates, workshift.DeletedAtNEQ(*i.DeletedAtNEQ))
	}
	if len(i.DeletedAtIn) > 0 {
		predicates = append(predicates, workshift.DeletedAtIn(i.DeletedAtIn...))
	}
	if len(i.DeletedAtNotIn) > 0 {
		predicates = append(predicates, workshift.DeletedAtNotIn(i.DeletedAtNotIn...))
	}
	if i.DeletedAtGT != nil {
		predicates = append(predicates, workshift.DeletedAtGT(*i.DeletedAtGT))
	}
	if i.DeletedAtGTE != nil {
		predicates = append(predicates, workshift.DeletedAtGTE(*i.DeletedAtGTE))
	}
	if i.DeletedAtLT != nil {
		predicates = append(predicates, workshift.DeletedAtLT(*i.DeletedAtLT))
	}
	if i.DeletedAtLTE != nil {
		predicates = append(predicates, workshift.DeletedAtLTE(*i.DeletedAtLTE))
	}
	if i.DeletedAtIsNil {
		predicates = append(predicates, workshift.DeletedAtIsNil())
	}
	if i.DeletedAtNotNil {
		predicates = append(predicates, workshift.DeletedAtNotNil())
	}
	if i.ApprovedAt != nil {
		predicates = append(predicates, workshift.ApprovedAtEQ(*i.ApprovedAt))
	}
	if i.ApprovedAtNEQ != nil {
		predicates = append(predicates, workshift.ApprovedAtNEQ(*i.ApprovedAtNEQ))
	}
	if len(i.ApprovedAtIn) > 0 {
		predicates = append(predicates, workshift.ApprovedAtIn(i.ApprovedAtIn...))
	}
	if len(i.ApprovedAtNotIn) > 0 {
		predicates = append(predicates, workshift.ApprovedAtNotIn(i.ApprovedAtNotIn...))
	}
	if i.ApprovedAtGT != nil {
		predicates = append(predicates, workshift.ApprovedAtGT(*i.ApprovedAtGT))
	}
	if i.ApprovedAtGTE != nil {
		predicates = append(predicates, workshift.ApprovedAtGTE(*i.ApprovedAtGTE))
	}
	if i.ApprovedAtLT != nil {
		predicates = append(predicates, workshift.ApprovedAtLT(*i.ApprovedAtLT))
	}
	if i.ApprovedAtLTE != nil {
		predicates = append(predicates, workshift.ApprovedAtLTE(*i.ApprovedAtLTE))
	}
	if i.ApprovedAtIsNil {
		predicates = append(predicates, workshift.ApprovedAtIsNil())
	}
	if i.ApprovedAtNotNil {
		predicates = append(predicates, workshift.ApprovedAtNotNil())
	}
	if i.ClockIn != nil {
		predicates = append(predicates, workshift.ClockInEQ(*i.ClockIn))
	}
	if i.ClockInNEQ != nil {
		predicates = append(predicates, workshift.ClockInNEQ(*i.ClockInNEQ))
	}
	if len(i.ClockInIn) > 0 {
		predicates = append(predicates, workshift.ClockInIn(i.ClockInIn...))
	}
	if len(i.ClockInNotIn) > 0 {
		predicates = append(predicates, workshift.ClockInNotIn(i.ClockInNotIn...))
	}
	if i.ClockInGT != nil {
		predicates = append(predicates, workshift.ClockInGT(*i.ClockInGT))
	}
	if i.ClockInGTE != nil {
		predicates = append(predicates, workshift.ClockInGTE(*i.ClockInGTE))
	}
	if i.ClockInLT != nil {
		predicates = append(predicates, workshift.ClockInLT(*i.ClockInLT))
	}
	if i.ClockInLTE != nil {
		predicates = append(predicates, workshift.ClockInLTE(*i.ClockInLTE))
	}
	if i.ClockOut != nil {
		predicates = append(predicates, workshift.ClockOutEQ(*i.ClockOut))
	}
	if i.ClockOutNEQ != nil {
		predicates = append(predicates, workshift.ClockOutNEQ(*i.ClockOutNEQ))
	}
	if len(i.ClockOutIn) > 0 {
		predicates = append(predicates, workshift.ClockOutIn(i.ClockOutIn...))
	}
	if len(i.ClockOutNotIn) > 0 {
		predicates = append(predicates, workshift.ClockOutNotIn(i.ClockOutNotIn...))
	}
	if i.ClockOutGT != nil {
		predicates = append(predicates, workshift.ClockOutGT(*i.ClockOutGT))
	}
	if i.ClockOutGTE != nil {
		predicates = append(predicates, workshift.ClockOutGTE(*i.ClockOutGTE))
	}
	if i.ClockOutLT != nil {
		predicates = append(predicates, workshift.ClockOutLT(*i.ClockOutLT))
	}
	if i.ClockOutLTE != nil {
		predicates = append(predicates, workshift.ClockOutLTE(*i.ClockOutLTE))
	}
	if i.ClockOutIsNil {
		predicates = append(predicates, workshift.ClockOutIsNil())
	}
	if i.ClockOutNotNil {
		predicates = append(predicates, workshift.ClockOutNotNil())
	}
	if i.ClockInLocation != nil {
		predicates = append(predicates, workshift.ClockInLocationEQ(*i.ClockInLocation))
	}
	if i.ClockInLocationNEQ != nil {
		predicates = append(predicates, workshift.ClockInLocationNEQ(*i.ClockInLocationNEQ))
	}
	if len(i.ClockInLocationIn) > 0 {
		predicates = append(predicates, workshift.ClockInLocationIn(i.ClockInLocationIn...))
	}
	if len(i.ClockInLocationNotIn) > 0 {
		predicates = append(predicates, workshift.ClockInLocationNotIn(i.ClockInLocationNotIn...))
	}
	if i.ClockInLocationGT != nil {
		predicates = append(predicates, workshift.ClockInLocationGT(*i.ClockInLocationGT))
	}
	if i.ClockInLocationGTE != nil {
		predicates = append(predicates, workshift.ClockInLocationGTE(*i.ClockInLocationGTE))
	}
	if i.ClockInLocationLT != nil {
		predicates = append(predicates, workshift.ClockInLocationLT(*i.ClockInLocationLT))
	}
	if i.ClockInLocationLTE != nil {
		predicates = append(predicates, workshift.ClockInLocationLTE(*i.ClockInLocationLTE))
	}
	if i.ClockInLocationContains != nil {
		predicates = append(predicates, workshift.ClockInLocationContains(*i.ClockInLocationContains))
	}
	if i.ClockInLocationHasPrefix != nil {
		predicates = append(predicates, workshift.ClockInLocationHasPrefix(*i.ClockInLocationHasPrefix))
	}
	if i.ClockInLocationHasSuffix != nil {
		predicates = append(predicates, workshift.ClockInLocationHasSuffix(*i.ClockInLocationHasSuffix))
	}
	if i.ClockInLocationEqualFold != nil {
		predicates = append(predicates, workshift.ClockInLocationEqualFold(*i.ClockInLocationEqualFold))
	}
	if i.ClockInLocationContainsFold != nil {
		predicates = append(predicates, workshift.ClockInLocationContainsFold(*i.ClockInLocationContainsFold))
	}
	if i.ClockOutLocation != nil {
		predicates = append(predicates, workshift.ClockOutLocationEQ(*i.ClockOutLocation))
	}
	if i.ClockOutLocationNEQ != nil {
		predicates = append(predicates, workshift.ClockOutLocationNEQ(*i.ClockOutLocationNEQ))
	}
	if len(i.ClockOutLocationIn) > 0 {
		predicates = append(predicates, workshift.ClockOutLocationIn(i.ClockOutLocationIn...))
	}
	if len(i.ClockOutLocationNotIn) > 0 {
		predicates = append(predicates, workshift.ClockOutLocationNotIn(i.ClockOutLocationNotIn...))
	}
	if i.ClockOutLocationGT != nil {
		predicates = append(predicates, workshift.ClockOutLocationGT(*i.ClockOutLocationGT))
	}
	if i.ClockOutLocationGTE != nil {
		predicates = append(predicates, workshift.ClockOutLocationGTE(*i.ClockOutLocationGTE))
	}
	if i.ClockOutLocationLT != nil {
		predicates = append(predicates, workshift.ClockOutLocationLT(*i.ClockOutLocationLT))
	}
	if i.ClockOutLocationLTE != nil {
		predicates = append(predicates, workshift.ClockOutLocationLTE(*i.ClockOutLocationLTE))
	}
	if i.ClockOutLocationContains != nil {
		predicates = append(predicates, workshift.ClockOutLocationContains(*i.ClockOutLocationContains))
	}
	if i.ClockOutLocationHasPrefix != nil {
		predicates = append(predicates, workshift.ClockOutLocationHasPrefix(*i.ClockOutLocationHasPrefix))
	}
	if i.ClockOutLocationHasSuffix != nil {
		predicates = append(predicates, workshift.ClockOutLocationHasSuffix(*i.ClockOutLocationHasSuffix))
	}
	if i.ClockOutLocationIsNil {
		predicates = append(predicates, workshift.ClockOutLocationIsNil())
	}
	if i.ClockOutLocationNotNil {
		predicates = append(predicates, workshift.ClockOutLocationNotNil())
	}
	if i.ClockOutLocationEqualFold != nil {
		predicates = append(predicates, workshift.ClockOutLocationEqualFold(*i.ClockOutLocationEqualFold))
	}
	if i.ClockOutLocationContainsFold != nil {
		predicates = append(predicates, workshift.ClockOutLocationContainsFold(*i.ClockOutLocationContainsFold))
	}
	if i.Description != nil {
		predicates = append(predicates, workshift.DescriptionEQ(*i.Description))
	}
	if i.DescriptionNEQ != nil {
		predicates = append(predicates, workshift.DescriptionNEQ(*i.DescriptionNEQ))
	}
	if len(i.DescriptionIn) > 0 {
		predicates = append(predicates, workshift.DescriptionIn(i.DescriptionIn...))
	}
	if len(i.DescriptionNotIn) > 0 {
		predicates = append(predicates, workshift.DescriptionNotIn(i.DescriptionNotIn...))
	}
	if i.DescriptionGT != nil {
		predicates = append(predicates, workshift.DescriptionGT(*i.DescriptionGT))
	}
	if i.DescriptionGTE != nil {
		predicates = append(predicates, workshift.DescriptionGTE(*i.DescriptionGTE))
	}
	if i.DescriptionLT != nil {
		predicates = append(predicates, workshift.DescriptionLT(*i.DescriptionLT))
	}
	if i.DescriptionLTE != nil {
		predicates = append(predicates, workshift.DescriptionLTE(*i.DescriptionLTE))
	}
	if i.DescriptionContains != nil {
		predicates = append(predicates, workshift.DescriptionContains(*i.DescriptionContains))
	}
	if i.DescriptionHasPrefix != nil {
		predicates = append(predicates, workshift.DescriptionHasPrefix(*i.DescriptionHasPrefix))
	}
	if i.DescriptionHasSuffix != nil {
		predicates = append(predicates, workshift.DescriptionHasSuffix(*i.DescriptionHasSuffix))
	}
	if i.DescriptionIsNil {
		predicates = append(predicates, workshift.DescriptionIsNil())
	}
	if i.DescriptionNotNil {
		predicates = append(predicates, workshift.DescriptionNotNil())
	}
	if i.DescriptionEqualFold != nil {
		predicates = append(predicates, workshift.DescriptionEqualFold(*i.DescriptionEqualFold))
	}
	if i.DescriptionContainsFold != nil {
		predicates = append(predicates, workshift.DescriptionContainsFold(*i.DescriptionContainsFold))
	}
	if i.Note != nil {
		predicates = append(predicates, workshift.NoteEQ(*i.Note))
	}
	if i.NoteNEQ != nil {
		predicates = append(predicates, workshift.NoteNEQ(*i.NoteNEQ))
	}
	if len(i.NoteIn) > 0 {
		predicates = append(predicates, workshift.NoteIn(i.NoteIn...))
	}
	if len(i.NoteNotIn) > 0 {
		predicates = append(predicates, workshift.NoteNotIn(i.NoteNotIn...))
	}
	if i.NoteGT != nil {
		predicates = append(predicates, workshift.NoteGT(*i.NoteGT))
	}
	if i.NoteGTE != nil {
		predicates = append(predicates, workshift.NoteGTE(*i.NoteGTE))
	}
	if i.NoteLT != nil {
		predicates = append(predicates, workshift.NoteLT(*i.NoteLT))
	}
	if i.NoteLTE != nil {
		predicates = append(predicates, workshift.NoteLTE(*i.NoteLTE))
	}
	if i.NoteContains != nil {
		predicates = append(predicates, workshift.NoteContains(*i.NoteContains))
	}
	if i.NoteHasPrefix != nil {
		predicates = append(predicates, workshift.NoteHasPrefix(*i.NoteHasPrefix))
	}
	if i.NoteHasSuffix != nil {
		predicates = append(predicates, workshift.NoteHasSuffix(*i.NoteHasSuffix))
	}
	if i.NoteIsNil {
		predicates = append(predicates, workshift.NoteIsNil())
	}
	if i.NoteNotNil {
		predicates = append(predicates, workshift.NoteNotNil())
	}
	if i.NoteEqualFold != nil {
		predicates = append(predicates, workshift.NoteEqualFold(*i.NoteEqualFold))
	}
	if i.NoteContainsFold != nil {
		predicates = append(predicates, workshift.NoteContainsFold(*i.NoteContainsFold))
	}
	if i.Status != nil {
		predicates = append(predicates, workshift.StatusEQ(*i.Status))
	}
	if i.StatusNEQ != nil {
		predicates = append(predicates, workshift.StatusNEQ(*i.StatusNEQ))
	}
	if len(i.StatusIn) > 0 {
		predicates = append(predicates, workshift.StatusIn(i.StatusIn...))
	}
	if len(i.StatusNotIn) > 0 {
		predicates = append(predicates, workshift.StatusNotIn(i.StatusNotIn...))
	}

	if i.HasCompany != nil {
		p := workshift.HasCompany()
		if !*i.HasCompany {
			p = workshift.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasCompanyWith) > 0 {
		with := make([]predicate.Company, 0, len(i.HasCompanyWith))
		for _, w := range i.HasCompanyWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasCompanyWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, workshift.HasCompanyWith(with...))
	}
	if i.HasUser != nil {
		p := workshift.HasUser()
		if !*i.HasUser {
			p = workshift.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasUserWith) > 0 {
		with := make([]predicate.User, 0, len(i.HasUserWith))
		for _, w := range i.HasUserWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasUserWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, workshift.HasUserWith(with...))
	}
	if i.HasApprovedBy != nil {
		p := workshift.HasApprovedBy()
		if !*i.HasApprovedBy {
			p = workshift.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasApprovedByWith) > 0 {
		with := make([]predicate.User, 0, len(i.HasApprovedByWith))
		for _, w := range i.HasApprovedByWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasApprovedByWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, workshift.HasApprovedByWith(with...))
	}
	if i.HasTask != nil {
		p := workshift.HasTask()
		if !*i.HasTask {
			p = workshift.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasTaskWith) > 0 {
		with := make([]predicate.ProjectTask, 0, len(i.HasTaskWith))
		for _, w := range i.HasTaskWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasTaskWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, workshift.HasTaskWith(with...))
	}
	if i.HasEditRequest != nil {
		p := workshift.HasEditRequest()
		if !*i.HasEditRequest {
			p = workshift.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasEditRequestWith) > 0 {
		with := make([]predicate.Workshift, 0, len(i.HasEditRequestWith))
		for _, w := range i.HasEditRequestWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasEditRequestWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, workshift.HasEditRequestWith(with...))
	}
	if i.HasWorkShift != nil {
		p := workshift.HasWorkShift()
		if !*i.HasWorkShift {
			p = workshift.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasWorkShiftWith) > 0 {
		with := make([]predicate.Workshift, 0, len(i.HasWorkShiftWith))
		for _, w := range i.HasWorkShiftWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasWorkShiftWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, workshift.HasWorkShiftWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyWorkshiftWhereInput
	case 1:
		return predicates[0], nil
	default:
		return workshift.And(predicates...), nil
	}
}
