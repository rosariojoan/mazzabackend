// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"mazza/ent/accountingentry"
	"mazza/ent/cashmovement"
	"mazza/ent/company"
	"mazza/ent/customer"
	"mazza/ent/employee"
	"mazza/ent/file"
	"mazza/ent/payable"
	"mazza/ent/predicate"
	"mazza/ent/product"
	"mazza/ent/productmovement"
	"mazza/ent/receivable"
	"mazza/ent/supplier"
	"mazza/ent/token"
	"mazza/ent/treasury"
	"mazza/ent/user"
	"mazza/ent/userrole"
	"mazza/ent/workshift"
	"mazza/ent/worktag"
	"mazza/ent/worktask"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeAccountingEntry = "AccountingEntry"
	TypeCashMovement    = "CashMovement"
	TypeCompany         = "Company"
	TypeCustomer        = "Customer"
	TypeEmployee        = "Employee"
	TypeFile            = "File"
	TypePayable         = "Payable"
	TypeProduct         = "Product"
	TypeProductMovement = "ProductMovement"
	TypeReceivable      = "Receivable"
	TypeSupplier        = "Supplier"
	TypeToken           = "Token"
	TypeTreasury        = "Treasury"
	TypeUser            = "User"
	TypeUserRole        = "UserRole"
	TypeWorkshift       = "Workshift"
	TypeWorktag         = "Worktag"
	TypeWorktask        = "Worktask"
)

// AccountingEntryMutation represents an operation that mutates the AccountingEntry nodes in the graph.
type AccountingEntryMutation struct {
	config
	op             Op
	typ            string
	id             *int
	createdAt      *time.Time
	updatedAt      *time.Time
	deletedAt      *time.Time
	number         *int
	addnumber      *int
	group          *int
	addgroup       *int
	date           *time.Time
	account        *string
	label          *string
	amount         *float64
	addamount      *float64
	description    *string
	accountType    *accountingentry.AccountType
	isDebit        *bool
	isReversal     *bool
	reversed       *bool
	clearedFields  map[string]struct{}
	company        *int
	clearedcompany bool
	user           *int
	cleareduser    bool
	done           bool
	oldValue       func(context.Context) (*AccountingEntry, error)
	predicates     []predicate.AccountingEntry
}

var _ ent.Mutation = (*AccountingEntryMutation)(nil)

// accountingentryOption allows management of the mutation configuration using functional options.
type accountingentryOption func(*AccountingEntryMutation)

// newAccountingEntryMutation creates new mutation for the AccountingEntry entity.
func newAccountingEntryMutation(c config, op Op, opts ...accountingentryOption) *AccountingEntryMutation {
	m := &AccountingEntryMutation{
		config:        c,
		op:            op,
		typ:           TypeAccountingEntry,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAccountingEntryID sets the ID field of the mutation.
func withAccountingEntryID(id int) accountingentryOption {
	return func(m *AccountingEntryMutation) {
		var (
			err   error
			once  sync.Once
			value *AccountingEntry
		)
		m.oldValue = func(ctx context.Context) (*AccountingEntry, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AccountingEntry.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAccountingEntry sets the old AccountingEntry of the mutation.
func withAccountingEntry(node *AccountingEntry) accountingentryOption {
	return func(m *AccountingEntryMutation) {
		m.oldValue = func(context.Context) (*AccountingEntry, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AccountingEntryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AccountingEntryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AccountingEntryMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AccountingEntryMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AccountingEntry.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "createdAt" field.
func (m *AccountingEntryMutation) SetCreatedAt(t time.Time) {
	m.createdAt = &t
}

// CreatedAt returns the value of the "createdAt" field in the mutation.
func (m *AccountingEntryMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.createdAt
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "createdAt" field's value of the AccountingEntry entity.
// If the AccountingEntry object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountingEntryMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "createdAt" field.
func (m *AccountingEntryMutation) ResetCreatedAt() {
	m.createdAt = nil
}

// SetUpdatedAt sets the "updatedAt" field.
func (m *AccountingEntryMutation) SetUpdatedAt(t time.Time) {
	m.updatedAt = &t
}

// UpdatedAt returns the value of the "updatedAt" field in the mutation.
func (m *AccountingEntryMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updatedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updatedAt" field's value of the AccountingEntry entity.
// If the AccountingEntry object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountingEntryMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updatedAt" field.
func (m *AccountingEntryMutation) ResetUpdatedAt() {
	m.updatedAt = nil
}

// SetDeletedAt sets the "deletedAt" field.
func (m *AccountingEntryMutation) SetDeletedAt(t time.Time) {
	m.deletedAt = &t
}

// DeletedAt returns the value of the "deletedAt" field in the mutation.
func (m *AccountingEntryMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deletedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deletedAt" field's value of the AccountingEntry entity.
// If the AccountingEntry object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountingEntryMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deletedAt" field.
func (m *AccountingEntryMutation) ClearDeletedAt() {
	m.deletedAt = nil
	m.clearedFields[accountingentry.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deletedAt" field was cleared in this mutation.
func (m *AccountingEntryMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[accountingentry.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deletedAt" field.
func (m *AccountingEntryMutation) ResetDeletedAt() {
	m.deletedAt = nil
	delete(m.clearedFields, accountingentry.FieldDeletedAt)
}

// SetNumber sets the "number" field.
func (m *AccountingEntryMutation) SetNumber(i int) {
	m.number = &i
	m.addnumber = nil
}

// Number returns the value of the "number" field in the mutation.
func (m *AccountingEntryMutation) Number() (r int, exists bool) {
	v := m.number
	if v == nil {
		return
	}
	return *v, true
}

// OldNumber returns the old "number" field's value of the AccountingEntry entity.
// If the AccountingEntry object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountingEntryMutation) OldNumber(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNumber: %w", err)
	}
	return oldValue.Number, nil
}

// AddNumber adds i to the "number" field.
func (m *AccountingEntryMutation) AddNumber(i int) {
	if m.addnumber != nil {
		*m.addnumber += i
	} else {
		m.addnumber = &i
	}
}

// AddedNumber returns the value that was added to the "number" field in this mutation.
func (m *AccountingEntryMutation) AddedNumber() (r int, exists bool) {
	v := m.addnumber
	if v == nil {
		return
	}
	return *v, true
}

// ResetNumber resets all changes to the "number" field.
func (m *AccountingEntryMutation) ResetNumber() {
	m.number = nil
	m.addnumber = nil
}

// SetGroup sets the "group" field.
func (m *AccountingEntryMutation) SetGroup(i int) {
	m.group = &i
	m.addgroup = nil
}

// Group returns the value of the "group" field in the mutation.
func (m *AccountingEntryMutation) Group() (r int, exists bool) {
	v := m.group
	if v == nil {
		return
	}
	return *v, true
}

// OldGroup returns the old "group" field's value of the AccountingEntry entity.
// If the AccountingEntry object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountingEntryMutation) OldGroup(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGroup is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGroup requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGroup: %w", err)
	}
	return oldValue.Group, nil
}

// AddGroup adds i to the "group" field.
func (m *AccountingEntryMutation) AddGroup(i int) {
	if m.addgroup != nil {
		*m.addgroup += i
	} else {
		m.addgroup = &i
	}
}

// AddedGroup returns the value that was added to the "group" field in this mutation.
func (m *AccountingEntryMutation) AddedGroup() (r int, exists bool) {
	v := m.addgroup
	if v == nil {
		return
	}
	return *v, true
}

// ResetGroup resets all changes to the "group" field.
func (m *AccountingEntryMutation) ResetGroup() {
	m.group = nil
	m.addgroup = nil
}

// SetDate sets the "date" field.
func (m *AccountingEntryMutation) SetDate(t time.Time) {
	m.date = &t
}

// Date returns the value of the "date" field in the mutation.
func (m *AccountingEntryMutation) Date() (r time.Time, exists bool) {
	v := m.date
	if v == nil {
		return
	}
	return *v, true
}

// OldDate returns the old "date" field's value of the AccountingEntry entity.
// If the AccountingEntry object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountingEntryMutation) OldDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDate: %w", err)
	}
	return oldValue.Date, nil
}

// ResetDate resets all changes to the "date" field.
func (m *AccountingEntryMutation) ResetDate() {
	m.date = nil
}

// SetAccount sets the "account" field.
func (m *AccountingEntryMutation) SetAccount(s string) {
	m.account = &s
}

// Account returns the value of the "account" field in the mutation.
func (m *AccountingEntryMutation) Account() (r string, exists bool) {
	v := m.account
	if v == nil {
		return
	}
	return *v, true
}

// OldAccount returns the old "account" field's value of the AccountingEntry entity.
// If the AccountingEntry object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountingEntryMutation) OldAccount(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAccount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAccount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAccount: %w", err)
	}
	return oldValue.Account, nil
}

// ResetAccount resets all changes to the "account" field.
func (m *AccountingEntryMutation) ResetAccount() {
	m.account = nil
}

// SetLabel sets the "label" field.
func (m *AccountingEntryMutation) SetLabel(s string) {
	m.label = &s
}

// Label returns the value of the "label" field in the mutation.
func (m *AccountingEntryMutation) Label() (r string, exists bool) {
	v := m.label
	if v == nil {
		return
	}
	return *v, true
}

// OldLabel returns the old "label" field's value of the AccountingEntry entity.
// If the AccountingEntry object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountingEntryMutation) OldLabel(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLabel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLabel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLabel: %w", err)
	}
	return oldValue.Label, nil
}

// ResetLabel resets all changes to the "label" field.
func (m *AccountingEntryMutation) ResetLabel() {
	m.label = nil
}

// SetAmount sets the "amount" field.
func (m *AccountingEntryMutation) SetAmount(f float64) {
	m.amount = &f
	m.addamount = nil
}

// Amount returns the value of the "amount" field in the mutation.
func (m *AccountingEntryMutation) Amount() (r float64, exists bool) {
	v := m.amount
	if v == nil {
		return
	}
	return *v, true
}

// OldAmount returns the old "amount" field's value of the AccountingEntry entity.
// If the AccountingEntry object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountingEntryMutation) OldAmount(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAmount: %w", err)
	}
	return oldValue.Amount, nil
}

// AddAmount adds f to the "amount" field.
func (m *AccountingEntryMutation) AddAmount(f float64) {
	if m.addamount != nil {
		*m.addamount += f
	} else {
		m.addamount = &f
	}
}

// AddedAmount returns the value that was added to the "amount" field in this mutation.
func (m *AccountingEntryMutation) AddedAmount() (r float64, exists bool) {
	v := m.addamount
	if v == nil {
		return
	}
	return *v, true
}

// ResetAmount resets all changes to the "amount" field.
func (m *AccountingEntryMutation) ResetAmount() {
	m.amount = nil
	m.addamount = nil
}

// SetDescription sets the "description" field.
func (m *AccountingEntryMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *AccountingEntryMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the AccountingEntry entity.
// If the AccountingEntry object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountingEntryMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *AccountingEntryMutation) ResetDescription() {
	m.description = nil
}

// SetAccountType sets the "accountType" field.
func (m *AccountingEntryMutation) SetAccountType(at accountingentry.AccountType) {
	m.accountType = &at
}

// AccountType returns the value of the "accountType" field in the mutation.
func (m *AccountingEntryMutation) AccountType() (r accountingentry.AccountType, exists bool) {
	v := m.accountType
	if v == nil {
		return
	}
	return *v, true
}

// OldAccountType returns the old "accountType" field's value of the AccountingEntry entity.
// If the AccountingEntry object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountingEntryMutation) OldAccountType(ctx context.Context) (v accountingentry.AccountType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAccountType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAccountType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAccountType: %w", err)
	}
	return oldValue.AccountType, nil
}

// ResetAccountType resets all changes to the "accountType" field.
func (m *AccountingEntryMutation) ResetAccountType() {
	m.accountType = nil
}

// SetIsDebit sets the "isDebit" field.
func (m *AccountingEntryMutation) SetIsDebit(b bool) {
	m.isDebit = &b
}

// IsDebit returns the value of the "isDebit" field in the mutation.
func (m *AccountingEntryMutation) IsDebit() (r bool, exists bool) {
	v := m.isDebit
	if v == nil {
		return
	}
	return *v, true
}

// OldIsDebit returns the old "isDebit" field's value of the AccountingEntry entity.
// If the AccountingEntry object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountingEntryMutation) OldIsDebit(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsDebit is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsDebit requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsDebit: %w", err)
	}
	return oldValue.IsDebit, nil
}

// ResetIsDebit resets all changes to the "isDebit" field.
func (m *AccountingEntryMutation) ResetIsDebit() {
	m.isDebit = nil
}

// SetIsReversal sets the "isReversal" field.
func (m *AccountingEntryMutation) SetIsReversal(b bool) {
	m.isReversal = &b
}

// IsReversal returns the value of the "isReversal" field in the mutation.
func (m *AccountingEntryMutation) IsReversal() (r bool, exists bool) {
	v := m.isReversal
	if v == nil {
		return
	}
	return *v, true
}

// OldIsReversal returns the old "isReversal" field's value of the AccountingEntry entity.
// If the AccountingEntry object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountingEntryMutation) OldIsReversal(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsReversal is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsReversal requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsReversal: %w", err)
	}
	return oldValue.IsReversal, nil
}

// ResetIsReversal resets all changes to the "isReversal" field.
func (m *AccountingEntryMutation) ResetIsReversal() {
	m.isReversal = nil
}

// SetReversed sets the "reversed" field.
func (m *AccountingEntryMutation) SetReversed(b bool) {
	m.reversed = &b
}

// Reversed returns the value of the "reversed" field in the mutation.
func (m *AccountingEntryMutation) Reversed() (r bool, exists bool) {
	v := m.reversed
	if v == nil {
		return
	}
	return *v, true
}

// OldReversed returns the old "reversed" field's value of the AccountingEntry entity.
// If the AccountingEntry object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountingEntryMutation) OldReversed(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReversed is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReversed requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReversed: %w", err)
	}
	return oldValue.Reversed, nil
}

// ResetReversed resets all changes to the "reversed" field.
func (m *AccountingEntryMutation) ResetReversed() {
	m.reversed = nil
}

// SetCompanyID sets the "company" edge to the Company entity by id.
func (m *AccountingEntryMutation) SetCompanyID(id int) {
	m.company = &id
}

// ClearCompany clears the "company" edge to the Company entity.
func (m *AccountingEntryMutation) ClearCompany() {
	m.clearedcompany = true
}

// CompanyCleared reports if the "company" edge to the Company entity was cleared.
func (m *AccountingEntryMutation) CompanyCleared() bool {
	return m.clearedcompany
}

// CompanyID returns the "company" edge ID in the mutation.
func (m *AccountingEntryMutation) CompanyID() (id int, exists bool) {
	if m.company != nil {
		return *m.company, true
	}
	return
}

// CompanyIDs returns the "company" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CompanyID instead. It exists only for internal usage by the builders.
func (m *AccountingEntryMutation) CompanyIDs() (ids []int) {
	if id := m.company; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCompany resets all changes to the "company" edge.
func (m *AccountingEntryMutation) ResetCompany() {
	m.company = nil
	m.clearedcompany = false
}

// SetUserID sets the "user" edge to the User entity by id.
func (m *AccountingEntryMutation) SetUserID(id int) {
	m.user = &id
}

// ClearUser clears the "user" edge to the User entity.
func (m *AccountingEntryMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *AccountingEntryMutation) UserCleared() bool {
	return m.cleareduser
}

// UserID returns the "user" edge ID in the mutation.
func (m *AccountingEntryMutation) UserID() (id int, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *AccountingEntryMutation) UserIDs() (ids []int) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *AccountingEntryMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the AccountingEntryMutation builder.
func (m *AccountingEntryMutation) Where(ps ...predicate.AccountingEntry) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AccountingEntryMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AccountingEntryMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.AccountingEntry, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AccountingEntryMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AccountingEntryMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (AccountingEntry).
func (m *AccountingEntryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AccountingEntryMutation) Fields() []string {
	fields := make([]string, 0, 14)
	if m.createdAt != nil {
		fields = append(fields, accountingentry.FieldCreatedAt)
	}
	if m.updatedAt != nil {
		fields = append(fields, accountingentry.FieldUpdatedAt)
	}
	if m.deletedAt != nil {
		fields = append(fields, accountingentry.FieldDeletedAt)
	}
	if m.number != nil {
		fields = append(fields, accountingentry.FieldNumber)
	}
	if m.group != nil {
		fields = append(fields, accountingentry.FieldGroup)
	}
	if m.date != nil {
		fields = append(fields, accountingentry.FieldDate)
	}
	if m.account != nil {
		fields = append(fields, accountingentry.FieldAccount)
	}
	if m.label != nil {
		fields = append(fields, accountingentry.FieldLabel)
	}
	if m.amount != nil {
		fields = append(fields, accountingentry.FieldAmount)
	}
	if m.description != nil {
		fields = append(fields, accountingentry.FieldDescription)
	}
	if m.accountType != nil {
		fields = append(fields, accountingentry.FieldAccountType)
	}
	if m.isDebit != nil {
		fields = append(fields, accountingentry.FieldIsDebit)
	}
	if m.isReversal != nil {
		fields = append(fields, accountingentry.FieldIsReversal)
	}
	if m.reversed != nil {
		fields = append(fields, accountingentry.FieldReversed)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AccountingEntryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case accountingentry.FieldCreatedAt:
		return m.CreatedAt()
	case accountingentry.FieldUpdatedAt:
		return m.UpdatedAt()
	case accountingentry.FieldDeletedAt:
		return m.DeletedAt()
	case accountingentry.FieldNumber:
		return m.Number()
	case accountingentry.FieldGroup:
		return m.Group()
	case accountingentry.FieldDate:
		return m.Date()
	case accountingentry.FieldAccount:
		return m.Account()
	case accountingentry.FieldLabel:
		return m.Label()
	case accountingentry.FieldAmount:
		return m.Amount()
	case accountingentry.FieldDescription:
		return m.Description()
	case accountingentry.FieldAccountType:
		return m.AccountType()
	case accountingentry.FieldIsDebit:
		return m.IsDebit()
	case accountingentry.FieldIsReversal:
		return m.IsReversal()
	case accountingentry.FieldReversed:
		return m.Reversed()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AccountingEntryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case accountingentry.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case accountingentry.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case accountingentry.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case accountingentry.FieldNumber:
		return m.OldNumber(ctx)
	case accountingentry.FieldGroup:
		return m.OldGroup(ctx)
	case accountingentry.FieldDate:
		return m.OldDate(ctx)
	case accountingentry.FieldAccount:
		return m.OldAccount(ctx)
	case accountingentry.FieldLabel:
		return m.OldLabel(ctx)
	case accountingentry.FieldAmount:
		return m.OldAmount(ctx)
	case accountingentry.FieldDescription:
		return m.OldDescription(ctx)
	case accountingentry.FieldAccountType:
		return m.OldAccountType(ctx)
	case accountingentry.FieldIsDebit:
		return m.OldIsDebit(ctx)
	case accountingentry.FieldIsReversal:
		return m.OldIsReversal(ctx)
	case accountingentry.FieldReversed:
		return m.OldReversed(ctx)
	}
	return nil, fmt.Errorf("unknown AccountingEntry field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AccountingEntryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case accountingentry.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case accountingentry.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case accountingentry.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case accountingentry.FieldNumber:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNumber(v)
		return nil
	case accountingentry.FieldGroup:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGroup(v)
		return nil
	case accountingentry.FieldDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDate(v)
		return nil
	case accountingentry.FieldAccount:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAccount(v)
		return nil
	case accountingentry.FieldLabel:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLabel(v)
		return nil
	case accountingentry.FieldAmount:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAmount(v)
		return nil
	case accountingentry.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case accountingentry.FieldAccountType:
		v, ok := value.(accountingentry.AccountType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAccountType(v)
		return nil
	case accountingentry.FieldIsDebit:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsDebit(v)
		return nil
	case accountingentry.FieldIsReversal:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsReversal(v)
		return nil
	case accountingentry.FieldReversed:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReversed(v)
		return nil
	}
	return fmt.Errorf("unknown AccountingEntry field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AccountingEntryMutation) AddedFields() []string {
	var fields []string
	if m.addnumber != nil {
		fields = append(fields, accountingentry.FieldNumber)
	}
	if m.addgroup != nil {
		fields = append(fields, accountingentry.FieldGroup)
	}
	if m.addamount != nil {
		fields = append(fields, accountingentry.FieldAmount)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AccountingEntryMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case accountingentry.FieldNumber:
		return m.AddedNumber()
	case accountingentry.FieldGroup:
		return m.AddedGroup()
	case accountingentry.FieldAmount:
		return m.AddedAmount()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AccountingEntryMutation) AddField(name string, value ent.Value) error {
	switch name {
	case accountingentry.FieldNumber:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddNumber(v)
		return nil
	case accountingentry.FieldGroup:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddGroup(v)
		return nil
	case accountingentry.FieldAmount:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAmount(v)
		return nil
	}
	return fmt.Errorf("unknown AccountingEntry numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AccountingEntryMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(accountingentry.FieldDeletedAt) {
		fields = append(fields, accountingentry.FieldDeletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AccountingEntryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AccountingEntryMutation) ClearField(name string) error {
	switch name {
	case accountingentry.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown AccountingEntry nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AccountingEntryMutation) ResetField(name string) error {
	switch name {
	case accountingentry.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case accountingentry.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case accountingentry.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case accountingentry.FieldNumber:
		m.ResetNumber()
		return nil
	case accountingentry.FieldGroup:
		m.ResetGroup()
		return nil
	case accountingentry.FieldDate:
		m.ResetDate()
		return nil
	case accountingentry.FieldAccount:
		m.ResetAccount()
		return nil
	case accountingentry.FieldLabel:
		m.ResetLabel()
		return nil
	case accountingentry.FieldAmount:
		m.ResetAmount()
		return nil
	case accountingentry.FieldDescription:
		m.ResetDescription()
		return nil
	case accountingentry.FieldAccountType:
		m.ResetAccountType()
		return nil
	case accountingentry.FieldIsDebit:
		m.ResetIsDebit()
		return nil
	case accountingentry.FieldIsReversal:
		m.ResetIsReversal()
		return nil
	case accountingentry.FieldReversed:
		m.ResetReversed()
		return nil
	}
	return fmt.Errorf("unknown AccountingEntry field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AccountingEntryMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.company != nil {
		edges = append(edges, accountingentry.EdgeCompany)
	}
	if m.user != nil {
		edges = append(edges, accountingentry.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AccountingEntryMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case accountingentry.EdgeCompany:
		if id := m.company; id != nil {
			return []ent.Value{*id}
		}
	case accountingentry.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AccountingEntryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AccountingEntryMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AccountingEntryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedcompany {
		edges = append(edges, accountingentry.EdgeCompany)
	}
	if m.cleareduser {
		edges = append(edges, accountingentry.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AccountingEntryMutation) EdgeCleared(name string) bool {
	switch name {
	case accountingentry.EdgeCompany:
		return m.clearedcompany
	case accountingentry.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AccountingEntryMutation) ClearEdge(name string) error {
	switch name {
	case accountingentry.EdgeCompany:
		m.ClearCompany()
		return nil
	case accountingentry.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown AccountingEntry unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AccountingEntryMutation) ResetEdge(name string) error {
	switch name {
	case accountingentry.EdgeCompany:
		m.ResetCompany()
		return nil
	case accountingentry.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown AccountingEntry edge %s", name)
}

// CashMovementMutation represents an operation that mutates the CashMovement nodes in the graph.
type CashMovementMutation struct {
	config
	op              Op
	typ             string
	id              *int
	createdAt       *time.Time
	updatedAt       *time.Time
	deletedAt       *time.Time
	amount          *float64
	addamount       *float64
	date            *time.Time
	entryGroup      *int
	addentryGroup   *int
	clearedFields   map[string]struct{}
	treasury        *int
	clearedtreasury bool
	done            bool
	oldValue        func(context.Context) (*CashMovement, error)
	predicates      []predicate.CashMovement
}

var _ ent.Mutation = (*CashMovementMutation)(nil)

// cashmovementOption allows management of the mutation configuration using functional options.
type cashmovementOption func(*CashMovementMutation)

// newCashMovementMutation creates new mutation for the CashMovement entity.
func newCashMovementMutation(c config, op Op, opts ...cashmovementOption) *CashMovementMutation {
	m := &CashMovementMutation{
		config:        c,
		op:            op,
		typ:           TypeCashMovement,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCashMovementID sets the ID field of the mutation.
func withCashMovementID(id int) cashmovementOption {
	return func(m *CashMovementMutation) {
		var (
			err   error
			once  sync.Once
			value *CashMovement
		)
		m.oldValue = func(ctx context.Context) (*CashMovement, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().CashMovement.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCashMovement sets the old CashMovement of the mutation.
func withCashMovement(node *CashMovement) cashmovementOption {
	return func(m *CashMovementMutation) {
		m.oldValue = func(context.Context) (*CashMovement, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CashMovementMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CashMovementMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CashMovementMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CashMovementMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().CashMovement.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "createdAt" field.
func (m *CashMovementMutation) SetCreatedAt(t time.Time) {
	m.createdAt = &t
}

// CreatedAt returns the value of the "createdAt" field in the mutation.
func (m *CashMovementMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.createdAt
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "createdAt" field's value of the CashMovement entity.
// If the CashMovement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CashMovementMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "createdAt" field.
func (m *CashMovementMutation) ResetCreatedAt() {
	m.createdAt = nil
}

// SetUpdatedAt sets the "updatedAt" field.
func (m *CashMovementMutation) SetUpdatedAt(t time.Time) {
	m.updatedAt = &t
}

// UpdatedAt returns the value of the "updatedAt" field in the mutation.
func (m *CashMovementMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updatedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updatedAt" field's value of the CashMovement entity.
// If the CashMovement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CashMovementMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updatedAt" field.
func (m *CashMovementMutation) ResetUpdatedAt() {
	m.updatedAt = nil
}

// SetDeletedAt sets the "deletedAt" field.
func (m *CashMovementMutation) SetDeletedAt(t time.Time) {
	m.deletedAt = &t
}

// DeletedAt returns the value of the "deletedAt" field in the mutation.
func (m *CashMovementMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deletedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deletedAt" field's value of the CashMovement entity.
// If the CashMovement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CashMovementMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deletedAt" field.
func (m *CashMovementMutation) ClearDeletedAt() {
	m.deletedAt = nil
	m.clearedFields[cashmovement.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deletedAt" field was cleared in this mutation.
func (m *CashMovementMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[cashmovement.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deletedAt" field.
func (m *CashMovementMutation) ResetDeletedAt() {
	m.deletedAt = nil
	delete(m.clearedFields, cashmovement.FieldDeletedAt)
}

// SetAmount sets the "amount" field.
func (m *CashMovementMutation) SetAmount(f float64) {
	m.amount = &f
	m.addamount = nil
}

// Amount returns the value of the "amount" field in the mutation.
func (m *CashMovementMutation) Amount() (r float64, exists bool) {
	v := m.amount
	if v == nil {
		return
	}
	return *v, true
}

// OldAmount returns the old "amount" field's value of the CashMovement entity.
// If the CashMovement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CashMovementMutation) OldAmount(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAmount: %w", err)
	}
	return oldValue.Amount, nil
}

// AddAmount adds f to the "amount" field.
func (m *CashMovementMutation) AddAmount(f float64) {
	if m.addamount != nil {
		*m.addamount += f
	} else {
		m.addamount = &f
	}
}

// AddedAmount returns the value that was added to the "amount" field in this mutation.
func (m *CashMovementMutation) AddedAmount() (r float64, exists bool) {
	v := m.addamount
	if v == nil {
		return
	}
	return *v, true
}

// ResetAmount resets all changes to the "amount" field.
func (m *CashMovementMutation) ResetAmount() {
	m.amount = nil
	m.addamount = nil
}

// SetDate sets the "date" field.
func (m *CashMovementMutation) SetDate(t time.Time) {
	m.date = &t
}

// Date returns the value of the "date" field in the mutation.
func (m *CashMovementMutation) Date() (r time.Time, exists bool) {
	v := m.date
	if v == nil {
		return
	}
	return *v, true
}

// OldDate returns the old "date" field's value of the CashMovement entity.
// If the CashMovement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CashMovementMutation) OldDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDate: %w", err)
	}
	return oldValue.Date, nil
}

// ResetDate resets all changes to the "date" field.
func (m *CashMovementMutation) ResetDate() {
	m.date = nil
}

// SetEntryGroup sets the "entryGroup" field.
func (m *CashMovementMutation) SetEntryGroup(i int) {
	m.entryGroup = &i
	m.addentryGroup = nil
}

// EntryGroup returns the value of the "entryGroup" field in the mutation.
func (m *CashMovementMutation) EntryGroup() (r int, exists bool) {
	v := m.entryGroup
	if v == nil {
		return
	}
	return *v, true
}

// OldEntryGroup returns the old "entryGroup" field's value of the CashMovement entity.
// If the CashMovement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CashMovementMutation) OldEntryGroup(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEntryGroup is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEntryGroup requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEntryGroup: %w", err)
	}
	return oldValue.EntryGroup, nil
}

// AddEntryGroup adds i to the "entryGroup" field.
func (m *CashMovementMutation) AddEntryGroup(i int) {
	if m.addentryGroup != nil {
		*m.addentryGroup += i
	} else {
		m.addentryGroup = &i
	}
}

// AddedEntryGroup returns the value that was added to the "entryGroup" field in this mutation.
func (m *CashMovementMutation) AddedEntryGroup() (r int, exists bool) {
	v := m.addentryGroup
	if v == nil {
		return
	}
	return *v, true
}

// ResetEntryGroup resets all changes to the "entryGroup" field.
func (m *CashMovementMutation) ResetEntryGroup() {
	m.entryGroup = nil
	m.addentryGroup = nil
}

// SetTreasuryID sets the "treasury" edge to the Treasury entity by id.
func (m *CashMovementMutation) SetTreasuryID(id int) {
	m.treasury = &id
}

// ClearTreasury clears the "treasury" edge to the Treasury entity.
func (m *CashMovementMutation) ClearTreasury() {
	m.clearedtreasury = true
}

// TreasuryCleared reports if the "treasury" edge to the Treasury entity was cleared.
func (m *CashMovementMutation) TreasuryCleared() bool {
	return m.clearedtreasury
}

// TreasuryID returns the "treasury" edge ID in the mutation.
func (m *CashMovementMutation) TreasuryID() (id int, exists bool) {
	if m.treasury != nil {
		return *m.treasury, true
	}
	return
}

// TreasuryIDs returns the "treasury" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TreasuryID instead. It exists only for internal usage by the builders.
func (m *CashMovementMutation) TreasuryIDs() (ids []int) {
	if id := m.treasury; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTreasury resets all changes to the "treasury" edge.
func (m *CashMovementMutation) ResetTreasury() {
	m.treasury = nil
	m.clearedtreasury = false
}

// Where appends a list predicates to the CashMovementMutation builder.
func (m *CashMovementMutation) Where(ps ...predicate.CashMovement) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CashMovementMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CashMovementMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.CashMovement, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CashMovementMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CashMovementMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (CashMovement).
func (m *CashMovementMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CashMovementMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.createdAt != nil {
		fields = append(fields, cashmovement.FieldCreatedAt)
	}
	if m.updatedAt != nil {
		fields = append(fields, cashmovement.FieldUpdatedAt)
	}
	if m.deletedAt != nil {
		fields = append(fields, cashmovement.FieldDeletedAt)
	}
	if m.amount != nil {
		fields = append(fields, cashmovement.FieldAmount)
	}
	if m.date != nil {
		fields = append(fields, cashmovement.FieldDate)
	}
	if m.entryGroup != nil {
		fields = append(fields, cashmovement.FieldEntryGroup)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CashMovementMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case cashmovement.FieldCreatedAt:
		return m.CreatedAt()
	case cashmovement.FieldUpdatedAt:
		return m.UpdatedAt()
	case cashmovement.FieldDeletedAt:
		return m.DeletedAt()
	case cashmovement.FieldAmount:
		return m.Amount()
	case cashmovement.FieldDate:
		return m.Date()
	case cashmovement.FieldEntryGroup:
		return m.EntryGroup()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CashMovementMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case cashmovement.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case cashmovement.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case cashmovement.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case cashmovement.FieldAmount:
		return m.OldAmount(ctx)
	case cashmovement.FieldDate:
		return m.OldDate(ctx)
	case cashmovement.FieldEntryGroup:
		return m.OldEntryGroup(ctx)
	}
	return nil, fmt.Errorf("unknown CashMovement field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CashMovementMutation) SetField(name string, value ent.Value) error {
	switch name {
	case cashmovement.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case cashmovement.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case cashmovement.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case cashmovement.FieldAmount:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAmount(v)
		return nil
	case cashmovement.FieldDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDate(v)
		return nil
	case cashmovement.FieldEntryGroup:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEntryGroup(v)
		return nil
	}
	return fmt.Errorf("unknown CashMovement field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CashMovementMutation) AddedFields() []string {
	var fields []string
	if m.addamount != nil {
		fields = append(fields, cashmovement.FieldAmount)
	}
	if m.addentryGroup != nil {
		fields = append(fields, cashmovement.FieldEntryGroup)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CashMovementMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case cashmovement.FieldAmount:
		return m.AddedAmount()
	case cashmovement.FieldEntryGroup:
		return m.AddedEntryGroup()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CashMovementMutation) AddField(name string, value ent.Value) error {
	switch name {
	case cashmovement.FieldAmount:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAmount(v)
		return nil
	case cashmovement.FieldEntryGroup:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddEntryGroup(v)
		return nil
	}
	return fmt.Errorf("unknown CashMovement numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CashMovementMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(cashmovement.FieldDeletedAt) {
		fields = append(fields, cashmovement.FieldDeletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CashMovementMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CashMovementMutation) ClearField(name string) error {
	switch name {
	case cashmovement.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown CashMovement nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CashMovementMutation) ResetField(name string) error {
	switch name {
	case cashmovement.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case cashmovement.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case cashmovement.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case cashmovement.FieldAmount:
		m.ResetAmount()
		return nil
	case cashmovement.FieldDate:
		m.ResetDate()
		return nil
	case cashmovement.FieldEntryGroup:
		m.ResetEntryGroup()
		return nil
	}
	return fmt.Errorf("unknown CashMovement field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CashMovementMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.treasury != nil {
		edges = append(edges, cashmovement.EdgeTreasury)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CashMovementMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case cashmovement.EdgeTreasury:
		if id := m.treasury; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CashMovementMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CashMovementMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CashMovementMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedtreasury {
		edges = append(edges, cashmovement.EdgeTreasury)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CashMovementMutation) EdgeCleared(name string) bool {
	switch name {
	case cashmovement.EdgeTreasury:
		return m.clearedtreasury
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CashMovementMutation) ClearEdge(name string) error {
	switch name {
	case cashmovement.EdgeTreasury:
		m.ClearTreasury()
		return nil
	}
	return fmt.Errorf("unknown CashMovement unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CashMovementMutation) ResetEdge(name string) error {
	switch name {
	case cashmovement.EdgeTreasury:
		m.ResetTreasury()
		return nil
	}
	return fmt.Errorf("unknown CashMovement edge %s", name)
}

// CompanyMutation represents an operation that mutates the Company nodes in the graph.
type CompanyMutation struct {
	config
	op                       Op
	typ                      string
	id                       *int
	createdAt                *time.Time
	updatedAt                *time.Time
	deletedAt                *time.Time
	address                  *string
	baseCurrency             *string
	ceoName                  *string
	city                     *string
	country                  *string
	establishedAt            *time.Time
	description              *string
	email                    *string
	lastEntryDate            *time.Time
	lastInvoiceNumber        *int32
	addlastInvoiceNumber     *int32
	logo                     *string
	name                     *string
	numberOfEmployees        *int32
	addnumberOfEmployees     *int32
	phone                    *string
	sector                   *string
	taxId                    *string
	vatRate                  *float64
	addvatRate               *float64
	website                  *string
	clearedFields            map[string]struct{}
	availableRoles           map[int]struct{}
	removedavailableRoles    map[int]struct{}
	clearedavailableRoles    bool
	accountingEntries        map[int]struct{}
	removedaccountingEntries map[int]struct{}
	clearedaccountingEntries bool
	customers                map[int]struct{}
	removedcustomers         map[int]struct{}
	clearedcustomers         bool
	employees                map[int]struct{}
	removedemployees         map[int]struct{}
	clearedemployees         bool
	files                    map[int]struct{}
	removedfiles             map[int]struct{}
	clearedfiles             bool
	products                 map[int]struct{}
	removedproducts          map[int]struct{}
	clearedproducts          bool
	suppliers                map[int]struct{}
	removedsuppliers         map[int]struct{}
	clearedsuppliers         bool
	tokens                   map[int]struct{}
	removedtokens            map[int]struct{}
	clearedtokens            bool
	treasuries               map[int]struct{}
	removedtreasuries        map[int]struct{}
	clearedtreasuries        bool
	workShifts               map[int]struct{}
	removedworkShifts        map[int]struct{}
	clearedworkShifts        bool
	workTasks                map[int]struct{}
	removedworkTasks         map[int]struct{}
	clearedworkTasks         bool
	workTags                 map[int]struct{}
	removedworkTags          map[int]struct{}
	clearedworkTags          bool
	users                    map[int]struct{}
	removedusers             map[int]struct{}
	clearedusers             bool
	daughterCompanies        map[int]struct{}
	removeddaughterCompanies map[int]struct{}
	cleareddaughterCompanies bool
	parentCompany            *int
	clearedparentCompany     bool
	done                     bool
	oldValue                 func(context.Context) (*Company, error)
	predicates               []predicate.Company
}

var _ ent.Mutation = (*CompanyMutation)(nil)

// companyOption allows management of the mutation configuration using functional options.
type companyOption func(*CompanyMutation)

// newCompanyMutation creates new mutation for the Company entity.
func newCompanyMutation(c config, op Op, opts ...companyOption) *CompanyMutation {
	m := &CompanyMutation{
		config:        c,
		op:            op,
		typ:           TypeCompany,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCompanyID sets the ID field of the mutation.
func withCompanyID(id int) companyOption {
	return func(m *CompanyMutation) {
		var (
			err   error
			once  sync.Once
			value *Company
		)
		m.oldValue = func(ctx context.Context) (*Company, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Company.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCompany sets the old Company of the mutation.
func withCompany(node *Company) companyOption {
	return func(m *CompanyMutation) {
		m.oldValue = func(context.Context) (*Company, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CompanyMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CompanyMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CompanyMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CompanyMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Company.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "createdAt" field.
func (m *CompanyMutation) SetCreatedAt(t time.Time) {
	m.createdAt = &t
}

// CreatedAt returns the value of the "createdAt" field in the mutation.
func (m *CompanyMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.createdAt
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "createdAt" field's value of the Company entity.
// If the Company object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CompanyMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "createdAt" field.
func (m *CompanyMutation) ResetCreatedAt() {
	m.createdAt = nil
}

// SetUpdatedAt sets the "updatedAt" field.
func (m *CompanyMutation) SetUpdatedAt(t time.Time) {
	m.updatedAt = &t
}

// UpdatedAt returns the value of the "updatedAt" field in the mutation.
func (m *CompanyMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updatedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updatedAt" field's value of the Company entity.
// If the Company object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CompanyMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updatedAt" field.
func (m *CompanyMutation) ResetUpdatedAt() {
	m.updatedAt = nil
}

// SetDeletedAt sets the "deletedAt" field.
func (m *CompanyMutation) SetDeletedAt(t time.Time) {
	m.deletedAt = &t
}

// DeletedAt returns the value of the "deletedAt" field in the mutation.
func (m *CompanyMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deletedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deletedAt" field's value of the Company entity.
// If the Company object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CompanyMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deletedAt" field.
func (m *CompanyMutation) ClearDeletedAt() {
	m.deletedAt = nil
	m.clearedFields[company.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deletedAt" field was cleared in this mutation.
func (m *CompanyMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[company.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deletedAt" field.
func (m *CompanyMutation) ResetDeletedAt() {
	m.deletedAt = nil
	delete(m.clearedFields, company.FieldDeletedAt)
}

// SetAddress sets the "address" field.
func (m *CompanyMutation) SetAddress(s string) {
	m.address = &s
}

// Address returns the value of the "address" field in the mutation.
func (m *CompanyMutation) Address() (r string, exists bool) {
	v := m.address
	if v == nil {
		return
	}
	return *v, true
}

// OldAddress returns the old "address" field's value of the Company entity.
// If the Company object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CompanyMutation) OldAddress(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAddress: %w", err)
	}
	return oldValue.Address, nil
}

// ClearAddress clears the value of the "address" field.
func (m *CompanyMutation) ClearAddress() {
	m.address = nil
	m.clearedFields[company.FieldAddress] = struct{}{}
}

// AddressCleared returns if the "address" field was cleared in this mutation.
func (m *CompanyMutation) AddressCleared() bool {
	_, ok := m.clearedFields[company.FieldAddress]
	return ok
}

// ResetAddress resets all changes to the "address" field.
func (m *CompanyMutation) ResetAddress() {
	m.address = nil
	delete(m.clearedFields, company.FieldAddress)
}

// SetBaseCurrency sets the "baseCurrency" field.
func (m *CompanyMutation) SetBaseCurrency(s string) {
	m.baseCurrency = &s
}

// BaseCurrency returns the value of the "baseCurrency" field in the mutation.
func (m *CompanyMutation) BaseCurrency() (r string, exists bool) {
	v := m.baseCurrency
	if v == nil {
		return
	}
	return *v, true
}

// OldBaseCurrency returns the old "baseCurrency" field's value of the Company entity.
// If the Company object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CompanyMutation) OldBaseCurrency(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBaseCurrency is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBaseCurrency requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBaseCurrency: %w", err)
	}
	return oldValue.BaseCurrency, nil
}

// ResetBaseCurrency resets all changes to the "baseCurrency" field.
func (m *CompanyMutation) ResetBaseCurrency() {
	m.baseCurrency = nil
}

// SetCeoName sets the "ceoName" field.
func (m *CompanyMutation) SetCeoName(s string) {
	m.ceoName = &s
}

// CeoName returns the value of the "ceoName" field in the mutation.
func (m *CompanyMutation) CeoName() (r string, exists bool) {
	v := m.ceoName
	if v == nil {
		return
	}
	return *v, true
}

// OldCeoName returns the old "ceoName" field's value of the Company entity.
// If the Company object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CompanyMutation) OldCeoName(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCeoName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCeoName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCeoName: %w", err)
	}
	return oldValue.CeoName, nil
}

// ClearCeoName clears the value of the "ceoName" field.
func (m *CompanyMutation) ClearCeoName() {
	m.ceoName = nil
	m.clearedFields[company.FieldCeoName] = struct{}{}
}

// CeoNameCleared returns if the "ceoName" field was cleared in this mutation.
func (m *CompanyMutation) CeoNameCleared() bool {
	_, ok := m.clearedFields[company.FieldCeoName]
	return ok
}

// ResetCeoName resets all changes to the "ceoName" field.
func (m *CompanyMutation) ResetCeoName() {
	m.ceoName = nil
	delete(m.clearedFields, company.FieldCeoName)
}

// SetCity sets the "city" field.
func (m *CompanyMutation) SetCity(s string) {
	m.city = &s
}

// City returns the value of the "city" field in the mutation.
func (m *CompanyMutation) City() (r string, exists bool) {
	v := m.city
	if v == nil {
		return
	}
	return *v, true
}

// OldCity returns the old "city" field's value of the Company entity.
// If the Company object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CompanyMutation) OldCity(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCity: %w", err)
	}
	return oldValue.City, nil
}

// ResetCity resets all changes to the "city" field.
func (m *CompanyMutation) ResetCity() {
	m.city = nil
}

// SetCountry sets the "country" field.
func (m *CompanyMutation) SetCountry(s string) {
	m.country = &s
}

// Country returns the value of the "country" field in the mutation.
func (m *CompanyMutation) Country() (r string, exists bool) {
	v := m.country
	if v == nil {
		return
	}
	return *v, true
}

// OldCountry returns the old "country" field's value of the Company entity.
// If the Company object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CompanyMutation) OldCountry(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCountry is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCountry requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCountry: %w", err)
	}
	return oldValue.Country, nil
}

// ResetCountry resets all changes to the "country" field.
func (m *CompanyMutation) ResetCountry() {
	m.country = nil
}

// SetEstablishedAt sets the "establishedAt" field.
func (m *CompanyMutation) SetEstablishedAt(t time.Time) {
	m.establishedAt = &t
}

// EstablishedAt returns the value of the "establishedAt" field in the mutation.
func (m *CompanyMutation) EstablishedAt() (r time.Time, exists bool) {
	v := m.establishedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldEstablishedAt returns the old "establishedAt" field's value of the Company entity.
// If the Company object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CompanyMutation) OldEstablishedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEstablishedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEstablishedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEstablishedAt: %w", err)
	}
	return oldValue.EstablishedAt, nil
}

// ResetEstablishedAt resets all changes to the "establishedAt" field.
func (m *CompanyMutation) ResetEstablishedAt() {
	m.establishedAt = nil
}

// SetDescription sets the "description" field.
func (m *CompanyMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *CompanyMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Company entity.
// If the Company object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CompanyMutation) OldDescription(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *CompanyMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[company.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *CompanyMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[company.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *CompanyMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, company.FieldDescription)
}

// SetEmail sets the "email" field.
func (m *CompanyMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *CompanyMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the Company entity.
// If the Company object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CompanyMutation) OldEmail(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ClearEmail clears the value of the "email" field.
func (m *CompanyMutation) ClearEmail() {
	m.email = nil
	m.clearedFields[company.FieldEmail] = struct{}{}
}

// EmailCleared returns if the "email" field was cleared in this mutation.
func (m *CompanyMutation) EmailCleared() bool {
	_, ok := m.clearedFields[company.FieldEmail]
	return ok
}

// ResetEmail resets all changes to the "email" field.
func (m *CompanyMutation) ResetEmail() {
	m.email = nil
	delete(m.clearedFields, company.FieldEmail)
}

// SetLastEntryDate sets the "lastEntryDate" field.
func (m *CompanyMutation) SetLastEntryDate(t time.Time) {
	m.lastEntryDate = &t
}

// LastEntryDate returns the value of the "lastEntryDate" field in the mutation.
func (m *CompanyMutation) LastEntryDate() (r time.Time, exists bool) {
	v := m.lastEntryDate
	if v == nil {
		return
	}
	return *v, true
}

// OldLastEntryDate returns the old "lastEntryDate" field's value of the Company entity.
// If the Company object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CompanyMutation) OldLastEntryDate(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastEntryDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastEntryDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastEntryDate: %w", err)
	}
	return oldValue.LastEntryDate, nil
}

// ResetLastEntryDate resets all changes to the "lastEntryDate" field.
func (m *CompanyMutation) ResetLastEntryDate() {
	m.lastEntryDate = nil
}

// SetLastInvoiceNumber sets the "lastInvoiceNumber" field.
func (m *CompanyMutation) SetLastInvoiceNumber(i int32) {
	m.lastInvoiceNumber = &i
	m.addlastInvoiceNumber = nil
}

// LastInvoiceNumber returns the value of the "lastInvoiceNumber" field in the mutation.
func (m *CompanyMutation) LastInvoiceNumber() (r int32, exists bool) {
	v := m.lastInvoiceNumber
	if v == nil {
		return
	}
	return *v, true
}

// OldLastInvoiceNumber returns the old "lastInvoiceNumber" field's value of the Company entity.
// If the Company object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CompanyMutation) OldLastInvoiceNumber(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastInvoiceNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastInvoiceNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastInvoiceNumber: %w", err)
	}
	return oldValue.LastInvoiceNumber, nil
}

// AddLastInvoiceNumber adds i to the "lastInvoiceNumber" field.
func (m *CompanyMutation) AddLastInvoiceNumber(i int32) {
	if m.addlastInvoiceNumber != nil {
		*m.addlastInvoiceNumber += i
	} else {
		m.addlastInvoiceNumber = &i
	}
}

// AddedLastInvoiceNumber returns the value that was added to the "lastInvoiceNumber" field in this mutation.
func (m *CompanyMutation) AddedLastInvoiceNumber() (r int32, exists bool) {
	v := m.addlastInvoiceNumber
	if v == nil {
		return
	}
	return *v, true
}

// ClearLastInvoiceNumber clears the value of the "lastInvoiceNumber" field.
func (m *CompanyMutation) ClearLastInvoiceNumber() {
	m.lastInvoiceNumber = nil
	m.addlastInvoiceNumber = nil
	m.clearedFields[company.FieldLastInvoiceNumber] = struct{}{}
}

// LastInvoiceNumberCleared returns if the "lastInvoiceNumber" field was cleared in this mutation.
func (m *CompanyMutation) LastInvoiceNumberCleared() bool {
	_, ok := m.clearedFields[company.FieldLastInvoiceNumber]
	return ok
}

// ResetLastInvoiceNumber resets all changes to the "lastInvoiceNumber" field.
func (m *CompanyMutation) ResetLastInvoiceNumber() {
	m.lastInvoiceNumber = nil
	m.addlastInvoiceNumber = nil
	delete(m.clearedFields, company.FieldLastInvoiceNumber)
}

// SetLogo sets the "logo" field.
func (m *CompanyMutation) SetLogo(s string) {
	m.logo = &s
}

// Logo returns the value of the "logo" field in the mutation.
func (m *CompanyMutation) Logo() (r string, exists bool) {
	v := m.logo
	if v == nil {
		return
	}
	return *v, true
}

// OldLogo returns the old "logo" field's value of the Company entity.
// If the Company object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CompanyMutation) OldLogo(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLogo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLogo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLogo: %w", err)
	}
	return oldValue.Logo, nil
}

// ClearLogo clears the value of the "logo" field.
func (m *CompanyMutation) ClearLogo() {
	m.logo = nil
	m.clearedFields[company.FieldLogo] = struct{}{}
}

// LogoCleared returns if the "logo" field was cleared in this mutation.
func (m *CompanyMutation) LogoCleared() bool {
	_, ok := m.clearedFields[company.FieldLogo]
	return ok
}

// ResetLogo resets all changes to the "logo" field.
func (m *CompanyMutation) ResetLogo() {
	m.logo = nil
	delete(m.clearedFields, company.FieldLogo)
}

// SetName sets the "name" field.
func (m *CompanyMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *CompanyMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Company entity.
// If the Company object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CompanyMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *CompanyMutation) ResetName() {
	m.name = nil
}

// SetNumberOfEmployees sets the "numberOfEmployees" field.
func (m *CompanyMutation) SetNumberOfEmployees(i int32) {
	m.numberOfEmployees = &i
	m.addnumberOfEmployees = nil
}

// NumberOfEmployees returns the value of the "numberOfEmployees" field in the mutation.
func (m *CompanyMutation) NumberOfEmployees() (r int32, exists bool) {
	v := m.numberOfEmployees
	if v == nil {
		return
	}
	return *v, true
}

// OldNumberOfEmployees returns the old "numberOfEmployees" field's value of the Company entity.
// If the Company object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CompanyMutation) OldNumberOfEmployees(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNumberOfEmployees is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNumberOfEmployees requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNumberOfEmployees: %w", err)
	}
	return oldValue.NumberOfEmployees, nil
}

// AddNumberOfEmployees adds i to the "numberOfEmployees" field.
func (m *CompanyMutation) AddNumberOfEmployees(i int32) {
	if m.addnumberOfEmployees != nil {
		*m.addnumberOfEmployees += i
	} else {
		m.addnumberOfEmployees = &i
	}
}

// AddedNumberOfEmployees returns the value that was added to the "numberOfEmployees" field in this mutation.
func (m *CompanyMutation) AddedNumberOfEmployees() (r int32, exists bool) {
	v := m.addnumberOfEmployees
	if v == nil {
		return
	}
	return *v, true
}

// ResetNumberOfEmployees resets all changes to the "numberOfEmployees" field.
func (m *CompanyMutation) ResetNumberOfEmployees() {
	m.numberOfEmployees = nil
	m.addnumberOfEmployees = nil
}

// SetPhone sets the "phone" field.
func (m *CompanyMutation) SetPhone(s string) {
	m.phone = &s
}

// Phone returns the value of the "phone" field in the mutation.
func (m *CompanyMutation) Phone() (r string, exists bool) {
	v := m.phone
	if v == nil {
		return
	}
	return *v, true
}

// OldPhone returns the old "phone" field's value of the Company entity.
// If the Company object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CompanyMutation) OldPhone(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPhone is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPhone requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPhone: %w", err)
	}
	return oldValue.Phone, nil
}

// ClearPhone clears the value of the "phone" field.
func (m *CompanyMutation) ClearPhone() {
	m.phone = nil
	m.clearedFields[company.FieldPhone] = struct{}{}
}

// PhoneCleared returns if the "phone" field was cleared in this mutation.
func (m *CompanyMutation) PhoneCleared() bool {
	_, ok := m.clearedFields[company.FieldPhone]
	return ok
}

// ResetPhone resets all changes to the "phone" field.
func (m *CompanyMutation) ResetPhone() {
	m.phone = nil
	delete(m.clearedFields, company.FieldPhone)
}

// SetSector sets the "sector" field.
func (m *CompanyMutation) SetSector(s string) {
	m.sector = &s
}

// Sector returns the value of the "sector" field in the mutation.
func (m *CompanyMutation) Sector() (r string, exists bool) {
	v := m.sector
	if v == nil {
		return
	}
	return *v, true
}

// OldSector returns the old "sector" field's value of the Company entity.
// If the Company object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CompanyMutation) OldSector(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSector is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSector requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSector: %w", err)
	}
	return oldValue.Sector, nil
}

// ClearSector clears the value of the "sector" field.
func (m *CompanyMutation) ClearSector() {
	m.sector = nil
	m.clearedFields[company.FieldSector] = struct{}{}
}

// SectorCleared returns if the "sector" field was cleared in this mutation.
func (m *CompanyMutation) SectorCleared() bool {
	_, ok := m.clearedFields[company.FieldSector]
	return ok
}

// ResetSector resets all changes to the "sector" field.
func (m *CompanyMutation) ResetSector() {
	m.sector = nil
	delete(m.clearedFields, company.FieldSector)
}

// SetTaxId sets the "taxId" field.
func (m *CompanyMutation) SetTaxId(s string) {
	m.taxId = &s
}

// TaxId returns the value of the "taxId" field in the mutation.
func (m *CompanyMutation) TaxId() (r string, exists bool) {
	v := m.taxId
	if v == nil {
		return
	}
	return *v, true
}

// OldTaxId returns the old "taxId" field's value of the Company entity.
// If the Company object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CompanyMutation) OldTaxId(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTaxId is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTaxId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTaxId: %w", err)
	}
	return oldValue.TaxId, nil
}

// ResetTaxId resets all changes to the "taxId" field.
func (m *CompanyMutation) ResetTaxId() {
	m.taxId = nil
}

// SetVatRate sets the "vatRate" field.
func (m *CompanyMutation) SetVatRate(f float64) {
	m.vatRate = &f
	m.addvatRate = nil
}

// VatRate returns the value of the "vatRate" field in the mutation.
func (m *CompanyMutation) VatRate() (r float64, exists bool) {
	v := m.vatRate
	if v == nil {
		return
	}
	return *v, true
}

// OldVatRate returns the old "vatRate" field's value of the Company entity.
// If the Company object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CompanyMutation) OldVatRate(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVatRate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVatRate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVatRate: %w", err)
	}
	return oldValue.VatRate, nil
}

// AddVatRate adds f to the "vatRate" field.
func (m *CompanyMutation) AddVatRate(f float64) {
	if m.addvatRate != nil {
		*m.addvatRate += f
	} else {
		m.addvatRate = &f
	}
}

// AddedVatRate returns the value that was added to the "vatRate" field in this mutation.
func (m *CompanyMutation) AddedVatRate() (r float64, exists bool) {
	v := m.addvatRate
	if v == nil {
		return
	}
	return *v, true
}

// ResetVatRate resets all changes to the "vatRate" field.
func (m *CompanyMutation) ResetVatRate() {
	m.vatRate = nil
	m.addvatRate = nil
}

// SetWebsite sets the "website" field.
func (m *CompanyMutation) SetWebsite(s string) {
	m.website = &s
}

// Website returns the value of the "website" field in the mutation.
func (m *CompanyMutation) Website() (r string, exists bool) {
	v := m.website
	if v == nil {
		return
	}
	return *v, true
}

// OldWebsite returns the old "website" field's value of the Company entity.
// If the Company object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CompanyMutation) OldWebsite(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWebsite is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWebsite requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWebsite: %w", err)
	}
	return oldValue.Website, nil
}

// ClearWebsite clears the value of the "website" field.
func (m *CompanyMutation) ClearWebsite() {
	m.website = nil
	m.clearedFields[company.FieldWebsite] = struct{}{}
}

// WebsiteCleared returns if the "website" field was cleared in this mutation.
func (m *CompanyMutation) WebsiteCleared() bool {
	_, ok := m.clearedFields[company.FieldWebsite]
	return ok
}

// ResetWebsite resets all changes to the "website" field.
func (m *CompanyMutation) ResetWebsite() {
	m.website = nil
	delete(m.clearedFields, company.FieldWebsite)
}

// AddAvailableRoleIDs adds the "availableRoles" edge to the UserRole entity by ids.
func (m *CompanyMutation) AddAvailableRoleIDs(ids ...int) {
	if m.availableRoles == nil {
		m.availableRoles = make(map[int]struct{})
	}
	for i := range ids {
		m.availableRoles[ids[i]] = struct{}{}
	}
}

// ClearAvailableRoles clears the "availableRoles" edge to the UserRole entity.
func (m *CompanyMutation) ClearAvailableRoles() {
	m.clearedavailableRoles = true
}

// AvailableRolesCleared reports if the "availableRoles" edge to the UserRole entity was cleared.
func (m *CompanyMutation) AvailableRolesCleared() bool {
	return m.clearedavailableRoles
}

// RemoveAvailableRoleIDs removes the "availableRoles" edge to the UserRole entity by IDs.
func (m *CompanyMutation) RemoveAvailableRoleIDs(ids ...int) {
	if m.removedavailableRoles == nil {
		m.removedavailableRoles = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.availableRoles, ids[i])
		m.removedavailableRoles[ids[i]] = struct{}{}
	}
}

// RemovedAvailableRoles returns the removed IDs of the "availableRoles" edge to the UserRole entity.
func (m *CompanyMutation) RemovedAvailableRolesIDs() (ids []int) {
	for id := range m.removedavailableRoles {
		ids = append(ids, id)
	}
	return
}

// AvailableRolesIDs returns the "availableRoles" edge IDs in the mutation.
func (m *CompanyMutation) AvailableRolesIDs() (ids []int) {
	for id := range m.availableRoles {
		ids = append(ids, id)
	}
	return
}

// ResetAvailableRoles resets all changes to the "availableRoles" edge.
func (m *CompanyMutation) ResetAvailableRoles() {
	m.availableRoles = nil
	m.clearedavailableRoles = false
	m.removedavailableRoles = nil
}

// AddAccountingEntryIDs adds the "accountingEntries" edge to the AccountingEntry entity by ids.
func (m *CompanyMutation) AddAccountingEntryIDs(ids ...int) {
	if m.accountingEntries == nil {
		m.accountingEntries = make(map[int]struct{})
	}
	for i := range ids {
		m.accountingEntries[ids[i]] = struct{}{}
	}
}

// ClearAccountingEntries clears the "accountingEntries" edge to the AccountingEntry entity.
func (m *CompanyMutation) ClearAccountingEntries() {
	m.clearedaccountingEntries = true
}

// AccountingEntriesCleared reports if the "accountingEntries" edge to the AccountingEntry entity was cleared.
func (m *CompanyMutation) AccountingEntriesCleared() bool {
	return m.clearedaccountingEntries
}

// RemoveAccountingEntryIDs removes the "accountingEntries" edge to the AccountingEntry entity by IDs.
func (m *CompanyMutation) RemoveAccountingEntryIDs(ids ...int) {
	if m.removedaccountingEntries == nil {
		m.removedaccountingEntries = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.accountingEntries, ids[i])
		m.removedaccountingEntries[ids[i]] = struct{}{}
	}
}

// RemovedAccountingEntries returns the removed IDs of the "accountingEntries" edge to the AccountingEntry entity.
func (m *CompanyMutation) RemovedAccountingEntriesIDs() (ids []int) {
	for id := range m.removedaccountingEntries {
		ids = append(ids, id)
	}
	return
}

// AccountingEntriesIDs returns the "accountingEntries" edge IDs in the mutation.
func (m *CompanyMutation) AccountingEntriesIDs() (ids []int) {
	for id := range m.accountingEntries {
		ids = append(ids, id)
	}
	return
}

// ResetAccountingEntries resets all changes to the "accountingEntries" edge.
func (m *CompanyMutation) ResetAccountingEntries() {
	m.accountingEntries = nil
	m.clearedaccountingEntries = false
	m.removedaccountingEntries = nil
}

// AddCustomerIDs adds the "customers" edge to the Customer entity by ids.
func (m *CompanyMutation) AddCustomerIDs(ids ...int) {
	if m.customers == nil {
		m.customers = make(map[int]struct{})
	}
	for i := range ids {
		m.customers[ids[i]] = struct{}{}
	}
}

// ClearCustomers clears the "customers" edge to the Customer entity.
func (m *CompanyMutation) ClearCustomers() {
	m.clearedcustomers = true
}

// CustomersCleared reports if the "customers" edge to the Customer entity was cleared.
func (m *CompanyMutation) CustomersCleared() bool {
	return m.clearedcustomers
}

// RemoveCustomerIDs removes the "customers" edge to the Customer entity by IDs.
func (m *CompanyMutation) RemoveCustomerIDs(ids ...int) {
	if m.removedcustomers == nil {
		m.removedcustomers = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.customers, ids[i])
		m.removedcustomers[ids[i]] = struct{}{}
	}
}

// RemovedCustomers returns the removed IDs of the "customers" edge to the Customer entity.
func (m *CompanyMutation) RemovedCustomersIDs() (ids []int) {
	for id := range m.removedcustomers {
		ids = append(ids, id)
	}
	return
}

// CustomersIDs returns the "customers" edge IDs in the mutation.
func (m *CompanyMutation) CustomersIDs() (ids []int) {
	for id := range m.customers {
		ids = append(ids, id)
	}
	return
}

// ResetCustomers resets all changes to the "customers" edge.
func (m *CompanyMutation) ResetCustomers() {
	m.customers = nil
	m.clearedcustomers = false
	m.removedcustomers = nil
}

// AddEmployeeIDs adds the "employees" edge to the Employee entity by ids.
func (m *CompanyMutation) AddEmployeeIDs(ids ...int) {
	if m.employees == nil {
		m.employees = make(map[int]struct{})
	}
	for i := range ids {
		m.employees[ids[i]] = struct{}{}
	}
}

// ClearEmployees clears the "employees" edge to the Employee entity.
func (m *CompanyMutation) ClearEmployees() {
	m.clearedemployees = true
}

// EmployeesCleared reports if the "employees" edge to the Employee entity was cleared.
func (m *CompanyMutation) EmployeesCleared() bool {
	return m.clearedemployees
}

// RemoveEmployeeIDs removes the "employees" edge to the Employee entity by IDs.
func (m *CompanyMutation) RemoveEmployeeIDs(ids ...int) {
	if m.removedemployees == nil {
		m.removedemployees = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.employees, ids[i])
		m.removedemployees[ids[i]] = struct{}{}
	}
}

// RemovedEmployees returns the removed IDs of the "employees" edge to the Employee entity.
func (m *CompanyMutation) RemovedEmployeesIDs() (ids []int) {
	for id := range m.removedemployees {
		ids = append(ids, id)
	}
	return
}

// EmployeesIDs returns the "employees" edge IDs in the mutation.
func (m *CompanyMutation) EmployeesIDs() (ids []int) {
	for id := range m.employees {
		ids = append(ids, id)
	}
	return
}

// ResetEmployees resets all changes to the "employees" edge.
func (m *CompanyMutation) ResetEmployees() {
	m.employees = nil
	m.clearedemployees = false
	m.removedemployees = nil
}

// AddFileIDs adds the "files" edge to the File entity by ids.
func (m *CompanyMutation) AddFileIDs(ids ...int) {
	if m.files == nil {
		m.files = make(map[int]struct{})
	}
	for i := range ids {
		m.files[ids[i]] = struct{}{}
	}
}

// ClearFiles clears the "files" edge to the File entity.
func (m *CompanyMutation) ClearFiles() {
	m.clearedfiles = true
}

// FilesCleared reports if the "files" edge to the File entity was cleared.
func (m *CompanyMutation) FilesCleared() bool {
	return m.clearedfiles
}

// RemoveFileIDs removes the "files" edge to the File entity by IDs.
func (m *CompanyMutation) RemoveFileIDs(ids ...int) {
	if m.removedfiles == nil {
		m.removedfiles = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.files, ids[i])
		m.removedfiles[ids[i]] = struct{}{}
	}
}

// RemovedFiles returns the removed IDs of the "files" edge to the File entity.
func (m *CompanyMutation) RemovedFilesIDs() (ids []int) {
	for id := range m.removedfiles {
		ids = append(ids, id)
	}
	return
}

// FilesIDs returns the "files" edge IDs in the mutation.
func (m *CompanyMutation) FilesIDs() (ids []int) {
	for id := range m.files {
		ids = append(ids, id)
	}
	return
}

// ResetFiles resets all changes to the "files" edge.
func (m *CompanyMutation) ResetFiles() {
	m.files = nil
	m.clearedfiles = false
	m.removedfiles = nil
}

// AddProductIDs adds the "products" edge to the Product entity by ids.
func (m *CompanyMutation) AddProductIDs(ids ...int) {
	if m.products == nil {
		m.products = make(map[int]struct{})
	}
	for i := range ids {
		m.products[ids[i]] = struct{}{}
	}
}

// ClearProducts clears the "products" edge to the Product entity.
func (m *CompanyMutation) ClearProducts() {
	m.clearedproducts = true
}

// ProductsCleared reports if the "products" edge to the Product entity was cleared.
func (m *CompanyMutation) ProductsCleared() bool {
	return m.clearedproducts
}

// RemoveProductIDs removes the "products" edge to the Product entity by IDs.
func (m *CompanyMutation) RemoveProductIDs(ids ...int) {
	if m.removedproducts == nil {
		m.removedproducts = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.products, ids[i])
		m.removedproducts[ids[i]] = struct{}{}
	}
}

// RemovedProducts returns the removed IDs of the "products" edge to the Product entity.
func (m *CompanyMutation) RemovedProductsIDs() (ids []int) {
	for id := range m.removedproducts {
		ids = append(ids, id)
	}
	return
}

// ProductsIDs returns the "products" edge IDs in the mutation.
func (m *CompanyMutation) ProductsIDs() (ids []int) {
	for id := range m.products {
		ids = append(ids, id)
	}
	return
}

// ResetProducts resets all changes to the "products" edge.
func (m *CompanyMutation) ResetProducts() {
	m.products = nil
	m.clearedproducts = false
	m.removedproducts = nil
}

// AddSupplierIDs adds the "suppliers" edge to the Supplier entity by ids.
func (m *CompanyMutation) AddSupplierIDs(ids ...int) {
	if m.suppliers == nil {
		m.suppliers = make(map[int]struct{})
	}
	for i := range ids {
		m.suppliers[ids[i]] = struct{}{}
	}
}

// ClearSuppliers clears the "suppliers" edge to the Supplier entity.
func (m *CompanyMutation) ClearSuppliers() {
	m.clearedsuppliers = true
}

// SuppliersCleared reports if the "suppliers" edge to the Supplier entity was cleared.
func (m *CompanyMutation) SuppliersCleared() bool {
	return m.clearedsuppliers
}

// RemoveSupplierIDs removes the "suppliers" edge to the Supplier entity by IDs.
func (m *CompanyMutation) RemoveSupplierIDs(ids ...int) {
	if m.removedsuppliers == nil {
		m.removedsuppliers = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.suppliers, ids[i])
		m.removedsuppliers[ids[i]] = struct{}{}
	}
}

// RemovedSuppliers returns the removed IDs of the "suppliers" edge to the Supplier entity.
func (m *CompanyMutation) RemovedSuppliersIDs() (ids []int) {
	for id := range m.removedsuppliers {
		ids = append(ids, id)
	}
	return
}

// SuppliersIDs returns the "suppliers" edge IDs in the mutation.
func (m *CompanyMutation) SuppliersIDs() (ids []int) {
	for id := range m.suppliers {
		ids = append(ids, id)
	}
	return
}

// ResetSuppliers resets all changes to the "suppliers" edge.
func (m *CompanyMutation) ResetSuppliers() {
	m.suppliers = nil
	m.clearedsuppliers = false
	m.removedsuppliers = nil
}

// AddTokenIDs adds the "tokens" edge to the Token entity by ids.
func (m *CompanyMutation) AddTokenIDs(ids ...int) {
	if m.tokens == nil {
		m.tokens = make(map[int]struct{})
	}
	for i := range ids {
		m.tokens[ids[i]] = struct{}{}
	}
}

// ClearTokens clears the "tokens" edge to the Token entity.
func (m *CompanyMutation) ClearTokens() {
	m.clearedtokens = true
}

// TokensCleared reports if the "tokens" edge to the Token entity was cleared.
func (m *CompanyMutation) TokensCleared() bool {
	return m.clearedtokens
}

// RemoveTokenIDs removes the "tokens" edge to the Token entity by IDs.
func (m *CompanyMutation) RemoveTokenIDs(ids ...int) {
	if m.removedtokens == nil {
		m.removedtokens = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.tokens, ids[i])
		m.removedtokens[ids[i]] = struct{}{}
	}
}

// RemovedTokens returns the removed IDs of the "tokens" edge to the Token entity.
func (m *CompanyMutation) RemovedTokensIDs() (ids []int) {
	for id := range m.removedtokens {
		ids = append(ids, id)
	}
	return
}

// TokensIDs returns the "tokens" edge IDs in the mutation.
func (m *CompanyMutation) TokensIDs() (ids []int) {
	for id := range m.tokens {
		ids = append(ids, id)
	}
	return
}

// ResetTokens resets all changes to the "tokens" edge.
func (m *CompanyMutation) ResetTokens() {
	m.tokens = nil
	m.clearedtokens = false
	m.removedtokens = nil
}

// AddTreasuryIDs adds the "treasuries" edge to the Treasury entity by ids.
func (m *CompanyMutation) AddTreasuryIDs(ids ...int) {
	if m.treasuries == nil {
		m.treasuries = make(map[int]struct{})
	}
	for i := range ids {
		m.treasuries[ids[i]] = struct{}{}
	}
}

// ClearTreasuries clears the "treasuries" edge to the Treasury entity.
func (m *CompanyMutation) ClearTreasuries() {
	m.clearedtreasuries = true
}

// TreasuriesCleared reports if the "treasuries" edge to the Treasury entity was cleared.
func (m *CompanyMutation) TreasuriesCleared() bool {
	return m.clearedtreasuries
}

// RemoveTreasuryIDs removes the "treasuries" edge to the Treasury entity by IDs.
func (m *CompanyMutation) RemoveTreasuryIDs(ids ...int) {
	if m.removedtreasuries == nil {
		m.removedtreasuries = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.treasuries, ids[i])
		m.removedtreasuries[ids[i]] = struct{}{}
	}
}

// RemovedTreasuries returns the removed IDs of the "treasuries" edge to the Treasury entity.
func (m *CompanyMutation) RemovedTreasuriesIDs() (ids []int) {
	for id := range m.removedtreasuries {
		ids = append(ids, id)
	}
	return
}

// TreasuriesIDs returns the "treasuries" edge IDs in the mutation.
func (m *CompanyMutation) TreasuriesIDs() (ids []int) {
	for id := range m.treasuries {
		ids = append(ids, id)
	}
	return
}

// ResetTreasuries resets all changes to the "treasuries" edge.
func (m *CompanyMutation) ResetTreasuries() {
	m.treasuries = nil
	m.clearedtreasuries = false
	m.removedtreasuries = nil
}

// AddWorkShiftIDs adds the "workShifts" edge to the Workshift entity by ids.
func (m *CompanyMutation) AddWorkShiftIDs(ids ...int) {
	if m.workShifts == nil {
		m.workShifts = make(map[int]struct{})
	}
	for i := range ids {
		m.workShifts[ids[i]] = struct{}{}
	}
}

// ClearWorkShifts clears the "workShifts" edge to the Workshift entity.
func (m *CompanyMutation) ClearWorkShifts() {
	m.clearedworkShifts = true
}

// WorkShiftsCleared reports if the "workShifts" edge to the Workshift entity was cleared.
func (m *CompanyMutation) WorkShiftsCleared() bool {
	return m.clearedworkShifts
}

// RemoveWorkShiftIDs removes the "workShifts" edge to the Workshift entity by IDs.
func (m *CompanyMutation) RemoveWorkShiftIDs(ids ...int) {
	if m.removedworkShifts == nil {
		m.removedworkShifts = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.workShifts, ids[i])
		m.removedworkShifts[ids[i]] = struct{}{}
	}
}

// RemovedWorkShifts returns the removed IDs of the "workShifts" edge to the Workshift entity.
func (m *CompanyMutation) RemovedWorkShiftsIDs() (ids []int) {
	for id := range m.removedworkShifts {
		ids = append(ids, id)
	}
	return
}

// WorkShiftsIDs returns the "workShifts" edge IDs in the mutation.
func (m *CompanyMutation) WorkShiftsIDs() (ids []int) {
	for id := range m.workShifts {
		ids = append(ids, id)
	}
	return
}

// ResetWorkShifts resets all changes to the "workShifts" edge.
func (m *CompanyMutation) ResetWorkShifts() {
	m.workShifts = nil
	m.clearedworkShifts = false
	m.removedworkShifts = nil
}

// AddWorkTaskIDs adds the "workTasks" edge to the Worktask entity by ids.
func (m *CompanyMutation) AddWorkTaskIDs(ids ...int) {
	if m.workTasks == nil {
		m.workTasks = make(map[int]struct{})
	}
	for i := range ids {
		m.workTasks[ids[i]] = struct{}{}
	}
}

// ClearWorkTasks clears the "workTasks" edge to the Worktask entity.
func (m *CompanyMutation) ClearWorkTasks() {
	m.clearedworkTasks = true
}

// WorkTasksCleared reports if the "workTasks" edge to the Worktask entity was cleared.
func (m *CompanyMutation) WorkTasksCleared() bool {
	return m.clearedworkTasks
}

// RemoveWorkTaskIDs removes the "workTasks" edge to the Worktask entity by IDs.
func (m *CompanyMutation) RemoveWorkTaskIDs(ids ...int) {
	if m.removedworkTasks == nil {
		m.removedworkTasks = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.workTasks, ids[i])
		m.removedworkTasks[ids[i]] = struct{}{}
	}
}

// RemovedWorkTasks returns the removed IDs of the "workTasks" edge to the Worktask entity.
func (m *CompanyMutation) RemovedWorkTasksIDs() (ids []int) {
	for id := range m.removedworkTasks {
		ids = append(ids, id)
	}
	return
}

// WorkTasksIDs returns the "workTasks" edge IDs in the mutation.
func (m *CompanyMutation) WorkTasksIDs() (ids []int) {
	for id := range m.workTasks {
		ids = append(ids, id)
	}
	return
}

// ResetWorkTasks resets all changes to the "workTasks" edge.
func (m *CompanyMutation) ResetWorkTasks() {
	m.workTasks = nil
	m.clearedworkTasks = false
	m.removedworkTasks = nil
}

// AddWorkTagIDs adds the "workTags" edge to the Worktag entity by ids.
func (m *CompanyMutation) AddWorkTagIDs(ids ...int) {
	if m.workTags == nil {
		m.workTags = make(map[int]struct{})
	}
	for i := range ids {
		m.workTags[ids[i]] = struct{}{}
	}
}

// ClearWorkTags clears the "workTags" edge to the Worktag entity.
func (m *CompanyMutation) ClearWorkTags() {
	m.clearedworkTags = true
}

// WorkTagsCleared reports if the "workTags" edge to the Worktag entity was cleared.
func (m *CompanyMutation) WorkTagsCleared() bool {
	return m.clearedworkTags
}

// RemoveWorkTagIDs removes the "workTags" edge to the Worktag entity by IDs.
func (m *CompanyMutation) RemoveWorkTagIDs(ids ...int) {
	if m.removedworkTags == nil {
		m.removedworkTags = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.workTags, ids[i])
		m.removedworkTags[ids[i]] = struct{}{}
	}
}

// RemovedWorkTags returns the removed IDs of the "workTags" edge to the Worktag entity.
func (m *CompanyMutation) RemovedWorkTagsIDs() (ids []int) {
	for id := range m.removedworkTags {
		ids = append(ids, id)
	}
	return
}

// WorkTagsIDs returns the "workTags" edge IDs in the mutation.
func (m *CompanyMutation) WorkTagsIDs() (ids []int) {
	for id := range m.workTags {
		ids = append(ids, id)
	}
	return
}

// ResetWorkTags resets all changes to the "workTags" edge.
func (m *CompanyMutation) ResetWorkTags() {
	m.workTags = nil
	m.clearedworkTags = false
	m.removedworkTags = nil
}

// AddUserIDs adds the "users" edge to the User entity by ids.
func (m *CompanyMutation) AddUserIDs(ids ...int) {
	if m.users == nil {
		m.users = make(map[int]struct{})
	}
	for i := range ids {
		m.users[ids[i]] = struct{}{}
	}
}

// ClearUsers clears the "users" edge to the User entity.
func (m *CompanyMutation) ClearUsers() {
	m.clearedusers = true
}

// UsersCleared reports if the "users" edge to the User entity was cleared.
func (m *CompanyMutation) UsersCleared() bool {
	return m.clearedusers
}

// RemoveUserIDs removes the "users" edge to the User entity by IDs.
func (m *CompanyMutation) RemoveUserIDs(ids ...int) {
	if m.removedusers == nil {
		m.removedusers = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.users, ids[i])
		m.removedusers[ids[i]] = struct{}{}
	}
}

// RemovedUsers returns the removed IDs of the "users" edge to the User entity.
func (m *CompanyMutation) RemovedUsersIDs() (ids []int) {
	for id := range m.removedusers {
		ids = append(ids, id)
	}
	return
}

// UsersIDs returns the "users" edge IDs in the mutation.
func (m *CompanyMutation) UsersIDs() (ids []int) {
	for id := range m.users {
		ids = append(ids, id)
	}
	return
}

// ResetUsers resets all changes to the "users" edge.
func (m *CompanyMutation) ResetUsers() {
	m.users = nil
	m.clearedusers = false
	m.removedusers = nil
}

// AddDaughterCompanyIDs adds the "daughterCompanies" edge to the Company entity by ids.
func (m *CompanyMutation) AddDaughterCompanyIDs(ids ...int) {
	if m.daughterCompanies == nil {
		m.daughterCompanies = make(map[int]struct{})
	}
	for i := range ids {
		m.daughterCompanies[ids[i]] = struct{}{}
	}
}

// ClearDaughterCompanies clears the "daughterCompanies" edge to the Company entity.
func (m *CompanyMutation) ClearDaughterCompanies() {
	m.cleareddaughterCompanies = true
}

// DaughterCompaniesCleared reports if the "daughterCompanies" edge to the Company entity was cleared.
func (m *CompanyMutation) DaughterCompaniesCleared() bool {
	return m.cleareddaughterCompanies
}

// RemoveDaughterCompanyIDs removes the "daughterCompanies" edge to the Company entity by IDs.
func (m *CompanyMutation) RemoveDaughterCompanyIDs(ids ...int) {
	if m.removeddaughterCompanies == nil {
		m.removeddaughterCompanies = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.daughterCompanies, ids[i])
		m.removeddaughterCompanies[ids[i]] = struct{}{}
	}
}

// RemovedDaughterCompanies returns the removed IDs of the "daughterCompanies" edge to the Company entity.
func (m *CompanyMutation) RemovedDaughterCompaniesIDs() (ids []int) {
	for id := range m.removeddaughterCompanies {
		ids = append(ids, id)
	}
	return
}

// DaughterCompaniesIDs returns the "daughterCompanies" edge IDs in the mutation.
func (m *CompanyMutation) DaughterCompaniesIDs() (ids []int) {
	for id := range m.daughterCompanies {
		ids = append(ids, id)
	}
	return
}

// ResetDaughterCompanies resets all changes to the "daughterCompanies" edge.
func (m *CompanyMutation) ResetDaughterCompanies() {
	m.daughterCompanies = nil
	m.cleareddaughterCompanies = false
	m.removeddaughterCompanies = nil
}

// SetParentCompanyID sets the "parentCompany" edge to the Company entity by id.
func (m *CompanyMutation) SetParentCompanyID(id int) {
	m.parentCompany = &id
}

// ClearParentCompany clears the "parentCompany" edge to the Company entity.
func (m *CompanyMutation) ClearParentCompany() {
	m.clearedparentCompany = true
}

// ParentCompanyCleared reports if the "parentCompany" edge to the Company entity was cleared.
func (m *CompanyMutation) ParentCompanyCleared() bool {
	return m.clearedparentCompany
}

// ParentCompanyID returns the "parentCompany" edge ID in the mutation.
func (m *CompanyMutation) ParentCompanyID() (id int, exists bool) {
	if m.parentCompany != nil {
		return *m.parentCompany, true
	}
	return
}

// ParentCompanyIDs returns the "parentCompany" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ParentCompanyID instead. It exists only for internal usage by the builders.
func (m *CompanyMutation) ParentCompanyIDs() (ids []int) {
	if id := m.parentCompany; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetParentCompany resets all changes to the "parentCompany" edge.
func (m *CompanyMutation) ResetParentCompany() {
	m.parentCompany = nil
	m.clearedparentCompany = false
}

// Where appends a list predicates to the CompanyMutation builder.
func (m *CompanyMutation) Where(ps ...predicate.Company) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CompanyMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CompanyMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Company, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CompanyMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CompanyMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Company).
func (m *CompanyMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CompanyMutation) Fields() []string {
	fields := make([]string, 0, 21)
	if m.createdAt != nil {
		fields = append(fields, company.FieldCreatedAt)
	}
	if m.updatedAt != nil {
		fields = append(fields, company.FieldUpdatedAt)
	}
	if m.deletedAt != nil {
		fields = append(fields, company.FieldDeletedAt)
	}
	if m.address != nil {
		fields = append(fields, company.FieldAddress)
	}
	if m.baseCurrency != nil {
		fields = append(fields, company.FieldBaseCurrency)
	}
	if m.ceoName != nil {
		fields = append(fields, company.FieldCeoName)
	}
	if m.city != nil {
		fields = append(fields, company.FieldCity)
	}
	if m.country != nil {
		fields = append(fields, company.FieldCountry)
	}
	if m.establishedAt != nil {
		fields = append(fields, company.FieldEstablishedAt)
	}
	if m.description != nil {
		fields = append(fields, company.FieldDescription)
	}
	if m.email != nil {
		fields = append(fields, company.FieldEmail)
	}
	if m.lastEntryDate != nil {
		fields = append(fields, company.FieldLastEntryDate)
	}
	if m.lastInvoiceNumber != nil {
		fields = append(fields, company.FieldLastInvoiceNumber)
	}
	if m.logo != nil {
		fields = append(fields, company.FieldLogo)
	}
	if m.name != nil {
		fields = append(fields, company.FieldName)
	}
	if m.numberOfEmployees != nil {
		fields = append(fields, company.FieldNumberOfEmployees)
	}
	if m.phone != nil {
		fields = append(fields, company.FieldPhone)
	}
	if m.sector != nil {
		fields = append(fields, company.FieldSector)
	}
	if m.taxId != nil {
		fields = append(fields, company.FieldTaxId)
	}
	if m.vatRate != nil {
		fields = append(fields, company.FieldVatRate)
	}
	if m.website != nil {
		fields = append(fields, company.FieldWebsite)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CompanyMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case company.FieldCreatedAt:
		return m.CreatedAt()
	case company.FieldUpdatedAt:
		return m.UpdatedAt()
	case company.FieldDeletedAt:
		return m.DeletedAt()
	case company.FieldAddress:
		return m.Address()
	case company.FieldBaseCurrency:
		return m.BaseCurrency()
	case company.FieldCeoName:
		return m.CeoName()
	case company.FieldCity:
		return m.City()
	case company.FieldCountry:
		return m.Country()
	case company.FieldEstablishedAt:
		return m.EstablishedAt()
	case company.FieldDescription:
		return m.Description()
	case company.FieldEmail:
		return m.Email()
	case company.FieldLastEntryDate:
		return m.LastEntryDate()
	case company.FieldLastInvoiceNumber:
		return m.LastInvoiceNumber()
	case company.FieldLogo:
		return m.Logo()
	case company.FieldName:
		return m.Name()
	case company.FieldNumberOfEmployees:
		return m.NumberOfEmployees()
	case company.FieldPhone:
		return m.Phone()
	case company.FieldSector:
		return m.Sector()
	case company.FieldTaxId:
		return m.TaxId()
	case company.FieldVatRate:
		return m.VatRate()
	case company.FieldWebsite:
		return m.Website()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CompanyMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case company.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case company.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case company.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case company.FieldAddress:
		return m.OldAddress(ctx)
	case company.FieldBaseCurrency:
		return m.OldBaseCurrency(ctx)
	case company.FieldCeoName:
		return m.OldCeoName(ctx)
	case company.FieldCity:
		return m.OldCity(ctx)
	case company.FieldCountry:
		return m.OldCountry(ctx)
	case company.FieldEstablishedAt:
		return m.OldEstablishedAt(ctx)
	case company.FieldDescription:
		return m.OldDescription(ctx)
	case company.FieldEmail:
		return m.OldEmail(ctx)
	case company.FieldLastEntryDate:
		return m.OldLastEntryDate(ctx)
	case company.FieldLastInvoiceNumber:
		return m.OldLastInvoiceNumber(ctx)
	case company.FieldLogo:
		return m.OldLogo(ctx)
	case company.FieldName:
		return m.OldName(ctx)
	case company.FieldNumberOfEmployees:
		return m.OldNumberOfEmployees(ctx)
	case company.FieldPhone:
		return m.OldPhone(ctx)
	case company.FieldSector:
		return m.OldSector(ctx)
	case company.FieldTaxId:
		return m.OldTaxId(ctx)
	case company.FieldVatRate:
		return m.OldVatRate(ctx)
	case company.FieldWebsite:
		return m.OldWebsite(ctx)
	}
	return nil, fmt.Errorf("unknown Company field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CompanyMutation) SetField(name string, value ent.Value) error {
	switch name {
	case company.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case company.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case company.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case company.FieldAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAddress(v)
		return nil
	case company.FieldBaseCurrency:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBaseCurrency(v)
		return nil
	case company.FieldCeoName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCeoName(v)
		return nil
	case company.FieldCity:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCity(v)
		return nil
	case company.FieldCountry:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCountry(v)
		return nil
	case company.FieldEstablishedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEstablishedAt(v)
		return nil
	case company.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case company.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case company.FieldLastEntryDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastEntryDate(v)
		return nil
	case company.FieldLastInvoiceNumber:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastInvoiceNumber(v)
		return nil
	case company.FieldLogo:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLogo(v)
		return nil
	case company.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case company.FieldNumberOfEmployees:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNumberOfEmployees(v)
		return nil
	case company.FieldPhone:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPhone(v)
		return nil
	case company.FieldSector:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSector(v)
		return nil
	case company.FieldTaxId:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTaxId(v)
		return nil
	case company.FieldVatRate:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVatRate(v)
		return nil
	case company.FieldWebsite:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWebsite(v)
		return nil
	}
	return fmt.Errorf("unknown Company field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CompanyMutation) AddedFields() []string {
	var fields []string
	if m.addlastInvoiceNumber != nil {
		fields = append(fields, company.FieldLastInvoiceNumber)
	}
	if m.addnumberOfEmployees != nil {
		fields = append(fields, company.FieldNumberOfEmployees)
	}
	if m.addvatRate != nil {
		fields = append(fields, company.FieldVatRate)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CompanyMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case company.FieldLastInvoiceNumber:
		return m.AddedLastInvoiceNumber()
	case company.FieldNumberOfEmployees:
		return m.AddedNumberOfEmployees()
	case company.FieldVatRate:
		return m.AddedVatRate()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CompanyMutation) AddField(name string, value ent.Value) error {
	switch name {
	case company.FieldLastInvoiceNumber:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLastInvoiceNumber(v)
		return nil
	case company.FieldNumberOfEmployees:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddNumberOfEmployees(v)
		return nil
	case company.FieldVatRate:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddVatRate(v)
		return nil
	}
	return fmt.Errorf("unknown Company numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CompanyMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(company.FieldDeletedAt) {
		fields = append(fields, company.FieldDeletedAt)
	}
	if m.FieldCleared(company.FieldAddress) {
		fields = append(fields, company.FieldAddress)
	}
	if m.FieldCleared(company.FieldCeoName) {
		fields = append(fields, company.FieldCeoName)
	}
	if m.FieldCleared(company.FieldDescription) {
		fields = append(fields, company.FieldDescription)
	}
	if m.FieldCleared(company.FieldEmail) {
		fields = append(fields, company.FieldEmail)
	}
	if m.FieldCleared(company.FieldLastInvoiceNumber) {
		fields = append(fields, company.FieldLastInvoiceNumber)
	}
	if m.FieldCleared(company.FieldLogo) {
		fields = append(fields, company.FieldLogo)
	}
	if m.FieldCleared(company.FieldPhone) {
		fields = append(fields, company.FieldPhone)
	}
	if m.FieldCleared(company.FieldSector) {
		fields = append(fields, company.FieldSector)
	}
	if m.FieldCleared(company.FieldWebsite) {
		fields = append(fields, company.FieldWebsite)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CompanyMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CompanyMutation) ClearField(name string) error {
	switch name {
	case company.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case company.FieldAddress:
		m.ClearAddress()
		return nil
	case company.FieldCeoName:
		m.ClearCeoName()
		return nil
	case company.FieldDescription:
		m.ClearDescription()
		return nil
	case company.FieldEmail:
		m.ClearEmail()
		return nil
	case company.FieldLastInvoiceNumber:
		m.ClearLastInvoiceNumber()
		return nil
	case company.FieldLogo:
		m.ClearLogo()
		return nil
	case company.FieldPhone:
		m.ClearPhone()
		return nil
	case company.FieldSector:
		m.ClearSector()
		return nil
	case company.FieldWebsite:
		m.ClearWebsite()
		return nil
	}
	return fmt.Errorf("unknown Company nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CompanyMutation) ResetField(name string) error {
	switch name {
	case company.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case company.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case company.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case company.FieldAddress:
		m.ResetAddress()
		return nil
	case company.FieldBaseCurrency:
		m.ResetBaseCurrency()
		return nil
	case company.FieldCeoName:
		m.ResetCeoName()
		return nil
	case company.FieldCity:
		m.ResetCity()
		return nil
	case company.FieldCountry:
		m.ResetCountry()
		return nil
	case company.FieldEstablishedAt:
		m.ResetEstablishedAt()
		return nil
	case company.FieldDescription:
		m.ResetDescription()
		return nil
	case company.FieldEmail:
		m.ResetEmail()
		return nil
	case company.FieldLastEntryDate:
		m.ResetLastEntryDate()
		return nil
	case company.FieldLastInvoiceNumber:
		m.ResetLastInvoiceNumber()
		return nil
	case company.FieldLogo:
		m.ResetLogo()
		return nil
	case company.FieldName:
		m.ResetName()
		return nil
	case company.FieldNumberOfEmployees:
		m.ResetNumberOfEmployees()
		return nil
	case company.FieldPhone:
		m.ResetPhone()
		return nil
	case company.FieldSector:
		m.ResetSector()
		return nil
	case company.FieldTaxId:
		m.ResetTaxId()
		return nil
	case company.FieldVatRate:
		m.ResetVatRate()
		return nil
	case company.FieldWebsite:
		m.ResetWebsite()
		return nil
	}
	return fmt.Errorf("unknown Company field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CompanyMutation) AddedEdges() []string {
	edges := make([]string, 0, 15)
	if m.availableRoles != nil {
		edges = append(edges, company.EdgeAvailableRoles)
	}
	if m.accountingEntries != nil {
		edges = append(edges, company.EdgeAccountingEntries)
	}
	if m.customers != nil {
		edges = append(edges, company.EdgeCustomers)
	}
	if m.employees != nil {
		edges = append(edges, company.EdgeEmployees)
	}
	if m.files != nil {
		edges = append(edges, company.EdgeFiles)
	}
	if m.products != nil {
		edges = append(edges, company.EdgeProducts)
	}
	if m.suppliers != nil {
		edges = append(edges, company.EdgeSuppliers)
	}
	if m.tokens != nil {
		edges = append(edges, company.EdgeTokens)
	}
	if m.treasuries != nil {
		edges = append(edges, company.EdgeTreasuries)
	}
	if m.workShifts != nil {
		edges = append(edges, company.EdgeWorkShifts)
	}
	if m.workTasks != nil {
		edges = append(edges, company.EdgeWorkTasks)
	}
	if m.workTags != nil {
		edges = append(edges, company.EdgeWorkTags)
	}
	if m.users != nil {
		edges = append(edges, company.EdgeUsers)
	}
	if m.daughterCompanies != nil {
		edges = append(edges, company.EdgeDaughterCompanies)
	}
	if m.parentCompany != nil {
		edges = append(edges, company.EdgeParentCompany)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CompanyMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case company.EdgeAvailableRoles:
		ids := make([]ent.Value, 0, len(m.availableRoles))
		for id := range m.availableRoles {
			ids = append(ids, id)
		}
		return ids
	case company.EdgeAccountingEntries:
		ids := make([]ent.Value, 0, len(m.accountingEntries))
		for id := range m.accountingEntries {
			ids = append(ids, id)
		}
		return ids
	case company.EdgeCustomers:
		ids := make([]ent.Value, 0, len(m.customers))
		for id := range m.customers {
			ids = append(ids, id)
		}
		return ids
	case company.EdgeEmployees:
		ids := make([]ent.Value, 0, len(m.employees))
		for id := range m.employees {
			ids = append(ids, id)
		}
		return ids
	case company.EdgeFiles:
		ids := make([]ent.Value, 0, len(m.files))
		for id := range m.files {
			ids = append(ids, id)
		}
		return ids
	case company.EdgeProducts:
		ids := make([]ent.Value, 0, len(m.products))
		for id := range m.products {
			ids = append(ids, id)
		}
		return ids
	case company.EdgeSuppliers:
		ids := make([]ent.Value, 0, len(m.suppliers))
		for id := range m.suppliers {
			ids = append(ids, id)
		}
		return ids
	case company.EdgeTokens:
		ids := make([]ent.Value, 0, len(m.tokens))
		for id := range m.tokens {
			ids = append(ids, id)
		}
		return ids
	case company.EdgeTreasuries:
		ids := make([]ent.Value, 0, len(m.treasuries))
		for id := range m.treasuries {
			ids = append(ids, id)
		}
		return ids
	case company.EdgeWorkShifts:
		ids := make([]ent.Value, 0, len(m.workShifts))
		for id := range m.workShifts {
			ids = append(ids, id)
		}
		return ids
	case company.EdgeWorkTasks:
		ids := make([]ent.Value, 0, len(m.workTasks))
		for id := range m.workTasks {
			ids = append(ids, id)
		}
		return ids
	case company.EdgeWorkTags:
		ids := make([]ent.Value, 0, len(m.workTags))
		for id := range m.workTags {
			ids = append(ids, id)
		}
		return ids
	case company.EdgeUsers:
		ids := make([]ent.Value, 0, len(m.users))
		for id := range m.users {
			ids = append(ids, id)
		}
		return ids
	case company.EdgeDaughterCompanies:
		ids := make([]ent.Value, 0, len(m.daughterCompanies))
		for id := range m.daughterCompanies {
			ids = append(ids, id)
		}
		return ids
	case company.EdgeParentCompany:
		if id := m.parentCompany; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CompanyMutation) RemovedEdges() []string {
	edges := make([]string, 0, 15)
	if m.removedavailableRoles != nil {
		edges = append(edges, company.EdgeAvailableRoles)
	}
	if m.removedaccountingEntries != nil {
		edges = append(edges, company.EdgeAccountingEntries)
	}
	if m.removedcustomers != nil {
		edges = append(edges, company.EdgeCustomers)
	}
	if m.removedemployees != nil {
		edges = append(edges, company.EdgeEmployees)
	}
	if m.removedfiles != nil {
		edges = append(edges, company.EdgeFiles)
	}
	if m.removedproducts != nil {
		edges = append(edges, company.EdgeProducts)
	}
	if m.removedsuppliers != nil {
		edges = append(edges, company.EdgeSuppliers)
	}
	if m.removedtokens != nil {
		edges = append(edges, company.EdgeTokens)
	}
	if m.removedtreasuries != nil {
		edges = append(edges, company.EdgeTreasuries)
	}
	if m.removedworkShifts != nil {
		edges = append(edges, company.EdgeWorkShifts)
	}
	if m.removedworkTasks != nil {
		edges = append(edges, company.EdgeWorkTasks)
	}
	if m.removedworkTags != nil {
		edges = append(edges, company.EdgeWorkTags)
	}
	if m.removedusers != nil {
		edges = append(edges, company.EdgeUsers)
	}
	if m.removeddaughterCompanies != nil {
		edges = append(edges, company.EdgeDaughterCompanies)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CompanyMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case company.EdgeAvailableRoles:
		ids := make([]ent.Value, 0, len(m.removedavailableRoles))
		for id := range m.removedavailableRoles {
			ids = append(ids, id)
		}
		return ids
	case company.EdgeAccountingEntries:
		ids := make([]ent.Value, 0, len(m.removedaccountingEntries))
		for id := range m.removedaccountingEntries {
			ids = append(ids, id)
		}
		return ids
	case company.EdgeCustomers:
		ids := make([]ent.Value, 0, len(m.removedcustomers))
		for id := range m.removedcustomers {
			ids = append(ids, id)
		}
		return ids
	case company.EdgeEmployees:
		ids := make([]ent.Value, 0, len(m.removedemployees))
		for id := range m.removedemployees {
			ids = append(ids, id)
		}
		return ids
	case company.EdgeFiles:
		ids := make([]ent.Value, 0, len(m.removedfiles))
		for id := range m.removedfiles {
			ids = append(ids, id)
		}
		return ids
	case company.EdgeProducts:
		ids := make([]ent.Value, 0, len(m.removedproducts))
		for id := range m.removedproducts {
			ids = append(ids, id)
		}
		return ids
	case company.EdgeSuppliers:
		ids := make([]ent.Value, 0, len(m.removedsuppliers))
		for id := range m.removedsuppliers {
			ids = append(ids, id)
		}
		return ids
	case company.EdgeTokens:
		ids := make([]ent.Value, 0, len(m.removedtokens))
		for id := range m.removedtokens {
			ids = append(ids, id)
		}
		return ids
	case company.EdgeTreasuries:
		ids := make([]ent.Value, 0, len(m.removedtreasuries))
		for id := range m.removedtreasuries {
			ids = append(ids, id)
		}
		return ids
	case company.EdgeWorkShifts:
		ids := make([]ent.Value, 0, len(m.removedworkShifts))
		for id := range m.removedworkShifts {
			ids = append(ids, id)
		}
		return ids
	case company.EdgeWorkTasks:
		ids := make([]ent.Value, 0, len(m.removedworkTasks))
		for id := range m.removedworkTasks {
			ids = append(ids, id)
		}
		return ids
	case company.EdgeWorkTags:
		ids := make([]ent.Value, 0, len(m.removedworkTags))
		for id := range m.removedworkTags {
			ids = append(ids, id)
		}
		return ids
	case company.EdgeUsers:
		ids := make([]ent.Value, 0, len(m.removedusers))
		for id := range m.removedusers {
			ids = append(ids, id)
		}
		return ids
	case company.EdgeDaughterCompanies:
		ids := make([]ent.Value, 0, len(m.removeddaughterCompanies))
		for id := range m.removeddaughterCompanies {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CompanyMutation) ClearedEdges() []string {
	edges := make([]string, 0, 15)
	if m.clearedavailableRoles {
		edges = append(edges, company.EdgeAvailableRoles)
	}
	if m.clearedaccountingEntries {
		edges = append(edges, company.EdgeAccountingEntries)
	}
	if m.clearedcustomers {
		edges = append(edges, company.EdgeCustomers)
	}
	if m.clearedemployees {
		edges = append(edges, company.EdgeEmployees)
	}
	if m.clearedfiles {
		edges = append(edges, company.EdgeFiles)
	}
	if m.clearedproducts {
		edges = append(edges, company.EdgeProducts)
	}
	if m.clearedsuppliers {
		edges = append(edges, company.EdgeSuppliers)
	}
	if m.clearedtokens {
		edges = append(edges, company.EdgeTokens)
	}
	if m.clearedtreasuries {
		edges = append(edges, company.EdgeTreasuries)
	}
	if m.clearedworkShifts {
		edges = append(edges, company.EdgeWorkShifts)
	}
	if m.clearedworkTasks {
		edges = append(edges, company.EdgeWorkTasks)
	}
	if m.clearedworkTags {
		edges = append(edges, company.EdgeWorkTags)
	}
	if m.clearedusers {
		edges = append(edges, company.EdgeUsers)
	}
	if m.cleareddaughterCompanies {
		edges = append(edges, company.EdgeDaughterCompanies)
	}
	if m.clearedparentCompany {
		edges = append(edges, company.EdgeParentCompany)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CompanyMutation) EdgeCleared(name string) bool {
	switch name {
	case company.EdgeAvailableRoles:
		return m.clearedavailableRoles
	case company.EdgeAccountingEntries:
		return m.clearedaccountingEntries
	case company.EdgeCustomers:
		return m.clearedcustomers
	case company.EdgeEmployees:
		return m.clearedemployees
	case company.EdgeFiles:
		return m.clearedfiles
	case company.EdgeProducts:
		return m.clearedproducts
	case company.EdgeSuppliers:
		return m.clearedsuppliers
	case company.EdgeTokens:
		return m.clearedtokens
	case company.EdgeTreasuries:
		return m.clearedtreasuries
	case company.EdgeWorkShifts:
		return m.clearedworkShifts
	case company.EdgeWorkTasks:
		return m.clearedworkTasks
	case company.EdgeWorkTags:
		return m.clearedworkTags
	case company.EdgeUsers:
		return m.clearedusers
	case company.EdgeDaughterCompanies:
		return m.cleareddaughterCompanies
	case company.EdgeParentCompany:
		return m.clearedparentCompany
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CompanyMutation) ClearEdge(name string) error {
	switch name {
	case company.EdgeParentCompany:
		m.ClearParentCompany()
		return nil
	}
	return fmt.Errorf("unknown Company unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CompanyMutation) ResetEdge(name string) error {
	switch name {
	case company.EdgeAvailableRoles:
		m.ResetAvailableRoles()
		return nil
	case company.EdgeAccountingEntries:
		m.ResetAccountingEntries()
		return nil
	case company.EdgeCustomers:
		m.ResetCustomers()
		return nil
	case company.EdgeEmployees:
		m.ResetEmployees()
		return nil
	case company.EdgeFiles:
		m.ResetFiles()
		return nil
	case company.EdgeProducts:
		m.ResetProducts()
		return nil
	case company.EdgeSuppliers:
		m.ResetSuppliers()
		return nil
	case company.EdgeTokens:
		m.ResetTokens()
		return nil
	case company.EdgeTreasuries:
		m.ResetTreasuries()
		return nil
	case company.EdgeWorkShifts:
		m.ResetWorkShifts()
		return nil
	case company.EdgeWorkTasks:
		m.ResetWorkTasks()
		return nil
	case company.EdgeWorkTags:
		m.ResetWorkTags()
		return nil
	case company.EdgeUsers:
		m.ResetUsers()
		return nil
	case company.EdgeDaughterCompanies:
		m.ResetDaughterCompanies()
		return nil
	case company.EdgeParentCompany:
		m.ResetParentCompany()
		return nil
	}
	return fmt.Errorf("unknown Company edge %s", name)
}

// CustomerMutation represents an operation that mutates the Customer nodes in the graph.
type CustomerMutation struct {
	config
	op                 Op
	typ                string
	id                 *int
	createdAt          *time.Time
	updatedAt          *time.Time
	deletedAt          *time.Time
	address            *string
	city               *string
	country            *string
	description        *string
	email              *string
	isDefault          *bool
	name               *string
	phone              *string
	taxId              *string
	clearedFields      map[string]struct{}
	company            *int
	clearedcompany     bool
	receivables        map[int]struct{}
	removedreceivables map[int]struct{}
	clearedreceivables bool
	done               bool
	oldValue           func(context.Context) (*Customer, error)
	predicates         []predicate.Customer
}

var _ ent.Mutation = (*CustomerMutation)(nil)

// customerOption allows management of the mutation configuration using functional options.
type customerOption func(*CustomerMutation)

// newCustomerMutation creates new mutation for the Customer entity.
func newCustomerMutation(c config, op Op, opts ...customerOption) *CustomerMutation {
	m := &CustomerMutation{
		config:        c,
		op:            op,
		typ:           TypeCustomer,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCustomerID sets the ID field of the mutation.
func withCustomerID(id int) customerOption {
	return func(m *CustomerMutation) {
		var (
			err   error
			once  sync.Once
			value *Customer
		)
		m.oldValue = func(ctx context.Context) (*Customer, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Customer.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCustomer sets the old Customer of the mutation.
func withCustomer(node *Customer) customerOption {
	return func(m *CustomerMutation) {
		m.oldValue = func(context.Context) (*Customer, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CustomerMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CustomerMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CustomerMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CustomerMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Customer.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "createdAt" field.
func (m *CustomerMutation) SetCreatedAt(t time.Time) {
	m.createdAt = &t
}

// CreatedAt returns the value of the "createdAt" field in the mutation.
func (m *CustomerMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.createdAt
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "createdAt" field's value of the Customer entity.
// If the Customer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "createdAt" field.
func (m *CustomerMutation) ResetCreatedAt() {
	m.createdAt = nil
}

// SetUpdatedAt sets the "updatedAt" field.
func (m *CustomerMutation) SetUpdatedAt(t time.Time) {
	m.updatedAt = &t
}

// UpdatedAt returns the value of the "updatedAt" field in the mutation.
func (m *CustomerMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updatedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updatedAt" field's value of the Customer entity.
// If the Customer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updatedAt" field.
func (m *CustomerMutation) ResetUpdatedAt() {
	m.updatedAt = nil
}

// SetDeletedAt sets the "deletedAt" field.
func (m *CustomerMutation) SetDeletedAt(t time.Time) {
	m.deletedAt = &t
}

// DeletedAt returns the value of the "deletedAt" field in the mutation.
func (m *CustomerMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deletedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deletedAt" field's value of the Customer entity.
// If the Customer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deletedAt" field.
func (m *CustomerMutation) ClearDeletedAt() {
	m.deletedAt = nil
	m.clearedFields[customer.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deletedAt" field was cleared in this mutation.
func (m *CustomerMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[customer.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deletedAt" field.
func (m *CustomerMutation) ResetDeletedAt() {
	m.deletedAt = nil
	delete(m.clearedFields, customer.FieldDeletedAt)
}

// SetAddress sets the "address" field.
func (m *CustomerMutation) SetAddress(s string) {
	m.address = &s
}

// Address returns the value of the "address" field in the mutation.
func (m *CustomerMutation) Address() (r string, exists bool) {
	v := m.address
	if v == nil {
		return
	}
	return *v, true
}

// OldAddress returns the old "address" field's value of the Customer entity.
// If the Customer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerMutation) OldAddress(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAddress: %w", err)
	}
	return oldValue.Address, nil
}

// ResetAddress resets all changes to the "address" field.
func (m *CustomerMutation) ResetAddress() {
	m.address = nil
}

// SetCity sets the "city" field.
func (m *CustomerMutation) SetCity(s string) {
	m.city = &s
}

// City returns the value of the "city" field in the mutation.
func (m *CustomerMutation) City() (r string, exists bool) {
	v := m.city
	if v == nil {
		return
	}
	return *v, true
}

// OldCity returns the old "city" field's value of the Customer entity.
// If the Customer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerMutation) OldCity(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCity: %w", err)
	}
	return oldValue.City, nil
}

// ResetCity resets all changes to the "city" field.
func (m *CustomerMutation) ResetCity() {
	m.city = nil
}

// SetCountry sets the "country" field.
func (m *CustomerMutation) SetCountry(s string) {
	m.country = &s
}

// Country returns the value of the "country" field in the mutation.
func (m *CustomerMutation) Country() (r string, exists bool) {
	v := m.country
	if v == nil {
		return
	}
	return *v, true
}

// OldCountry returns the old "country" field's value of the Customer entity.
// If the Customer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerMutation) OldCountry(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCountry is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCountry requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCountry: %w", err)
	}
	return oldValue.Country, nil
}

// ResetCountry resets all changes to the "country" field.
func (m *CustomerMutation) ResetCountry() {
	m.country = nil
}

// SetDescription sets the "description" field.
func (m *CustomerMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *CustomerMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Customer entity.
// If the Customer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *CustomerMutation) ResetDescription() {
	m.description = nil
}

// SetEmail sets the "email" field.
func (m *CustomerMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *CustomerMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the Customer entity.
// If the Customer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ResetEmail resets all changes to the "email" field.
func (m *CustomerMutation) ResetEmail() {
	m.email = nil
}

// SetIsDefault sets the "isDefault" field.
func (m *CustomerMutation) SetIsDefault(b bool) {
	m.isDefault = &b
}

// IsDefault returns the value of the "isDefault" field in the mutation.
func (m *CustomerMutation) IsDefault() (r bool, exists bool) {
	v := m.isDefault
	if v == nil {
		return
	}
	return *v, true
}

// OldIsDefault returns the old "isDefault" field's value of the Customer entity.
// If the Customer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerMutation) OldIsDefault(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsDefault is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsDefault requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsDefault: %w", err)
	}
	return oldValue.IsDefault, nil
}

// ClearIsDefault clears the value of the "isDefault" field.
func (m *CustomerMutation) ClearIsDefault() {
	m.isDefault = nil
	m.clearedFields[customer.FieldIsDefault] = struct{}{}
}

// IsDefaultCleared returns if the "isDefault" field was cleared in this mutation.
func (m *CustomerMutation) IsDefaultCleared() bool {
	_, ok := m.clearedFields[customer.FieldIsDefault]
	return ok
}

// ResetIsDefault resets all changes to the "isDefault" field.
func (m *CustomerMutation) ResetIsDefault() {
	m.isDefault = nil
	delete(m.clearedFields, customer.FieldIsDefault)
}

// SetName sets the "name" field.
func (m *CustomerMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *CustomerMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Customer entity.
// If the Customer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *CustomerMutation) ResetName() {
	m.name = nil
}

// SetPhone sets the "phone" field.
func (m *CustomerMutation) SetPhone(s string) {
	m.phone = &s
}

// Phone returns the value of the "phone" field in the mutation.
func (m *CustomerMutation) Phone() (r string, exists bool) {
	v := m.phone
	if v == nil {
		return
	}
	return *v, true
}

// OldPhone returns the old "phone" field's value of the Customer entity.
// If the Customer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerMutation) OldPhone(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPhone is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPhone requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPhone: %w", err)
	}
	return oldValue.Phone, nil
}

// ResetPhone resets all changes to the "phone" field.
func (m *CustomerMutation) ResetPhone() {
	m.phone = nil
}

// SetTaxId sets the "taxId" field.
func (m *CustomerMutation) SetTaxId(s string) {
	m.taxId = &s
}

// TaxId returns the value of the "taxId" field in the mutation.
func (m *CustomerMutation) TaxId() (r string, exists bool) {
	v := m.taxId
	if v == nil {
		return
	}
	return *v, true
}

// OldTaxId returns the old "taxId" field's value of the Customer entity.
// If the Customer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerMutation) OldTaxId(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTaxId is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTaxId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTaxId: %w", err)
	}
	return oldValue.TaxId, nil
}

// ResetTaxId resets all changes to the "taxId" field.
func (m *CustomerMutation) ResetTaxId() {
	m.taxId = nil
}

// SetCompanyID sets the "company" edge to the Company entity by id.
func (m *CustomerMutation) SetCompanyID(id int) {
	m.company = &id
}

// ClearCompany clears the "company" edge to the Company entity.
func (m *CustomerMutation) ClearCompany() {
	m.clearedcompany = true
}

// CompanyCleared reports if the "company" edge to the Company entity was cleared.
func (m *CustomerMutation) CompanyCleared() bool {
	return m.clearedcompany
}

// CompanyID returns the "company" edge ID in the mutation.
func (m *CustomerMutation) CompanyID() (id int, exists bool) {
	if m.company != nil {
		return *m.company, true
	}
	return
}

// CompanyIDs returns the "company" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CompanyID instead. It exists only for internal usage by the builders.
func (m *CustomerMutation) CompanyIDs() (ids []int) {
	if id := m.company; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCompany resets all changes to the "company" edge.
func (m *CustomerMutation) ResetCompany() {
	m.company = nil
	m.clearedcompany = false
}

// AddReceivableIDs adds the "receivables" edge to the Receivable entity by ids.
func (m *CustomerMutation) AddReceivableIDs(ids ...int) {
	if m.receivables == nil {
		m.receivables = make(map[int]struct{})
	}
	for i := range ids {
		m.receivables[ids[i]] = struct{}{}
	}
}

// ClearReceivables clears the "receivables" edge to the Receivable entity.
func (m *CustomerMutation) ClearReceivables() {
	m.clearedreceivables = true
}

// ReceivablesCleared reports if the "receivables" edge to the Receivable entity was cleared.
func (m *CustomerMutation) ReceivablesCleared() bool {
	return m.clearedreceivables
}

// RemoveReceivableIDs removes the "receivables" edge to the Receivable entity by IDs.
func (m *CustomerMutation) RemoveReceivableIDs(ids ...int) {
	if m.removedreceivables == nil {
		m.removedreceivables = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.receivables, ids[i])
		m.removedreceivables[ids[i]] = struct{}{}
	}
}

// RemovedReceivables returns the removed IDs of the "receivables" edge to the Receivable entity.
func (m *CustomerMutation) RemovedReceivablesIDs() (ids []int) {
	for id := range m.removedreceivables {
		ids = append(ids, id)
	}
	return
}

// ReceivablesIDs returns the "receivables" edge IDs in the mutation.
func (m *CustomerMutation) ReceivablesIDs() (ids []int) {
	for id := range m.receivables {
		ids = append(ids, id)
	}
	return
}

// ResetReceivables resets all changes to the "receivables" edge.
func (m *CustomerMutation) ResetReceivables() {
	m.receivables = nil
	m.clearedreceivables = false
	m.removedreceivables = nil
}

// Where appends a list predicates to the CustomerMutation builder.
func (m *CustomerMutation) Where(ps ...predicate.Customer) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CustomerMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CustomerMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Customer, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CustomerMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CustomerMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Customer).
func (m *CustomerMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CustomerMutation) Fields() []string {
	fields := make([]string, 0, 12)
	if m.createdAt != nil {
		fields = append(fields, customer.FieldCreatedAt)
	}
	if m.updatedAt != nil {
		fields = append(fields, customer.FieldUpdatedAt)
	}
	if m.deletedAt != nil {
		fields = append(fields, customer.FieldDeletedAt)
	}
	if m.address != nil {
		fields = append(fields, customer.FieldAddress)
	}
	if m.city != nil {
		fields = append(fields, customer.FieldCity)
	}
	if m.country != nil {
		fields = append(fields, customer.FieldCountry)
	}
	if m.description != nil {
		fields = append(fields, customer.FieldDescription)
	}
	if m.email != nil {
		fields = append(fields, customer.FieldEmail)
	}
	if m.isDefault != nil {
		fields = append(fields, customer.FieldIsDefault)
	}
	if m.name != nil {
		fields = append(fields, customer.FieldName)
	}
	if m.phone != nil {
		fields = append(fields, customer.FieldPhone)
	}
	if m.taxId != nil {
		fields = append(fields, customer.FieldTaxId)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CustomerMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case customer.FieldCreatedAt:
		return m.CreatedAt()
	case customer.FieldUpdatedAt:
		return m.UpdatedAt()
	case customer.FieldDeletedAt:
		return m.DeletedAt()
	case customer.FieldAddress:
		return m.Address()
	case customer.FieldCity:
		return m.City()
	case customer.FieldCountry:
		return m.Country()
	case customer.FieldDescription:
		return m.Description()
	case customer.FieldEmail:
		return m.Email()
	case customer.FieldIsDefault:
		return m.IsDefault()
	case customer.FieldName:
		return m.Name()
	case customer.FieldPhone:
		return m.Phone()
	case customer.FieldTaxId:
		return m.TaxId()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CustomerMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case customer.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case customer.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case customer.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case customer.FieldAddress:
		return m.OldAddress(ctx)
	case customer.FieldCity:
		return m.OldCity(ctx)
	case customer.FieldCountry:
		return m.OldCountry(ctx)
	case customer.FieldDescription:
		return m.OldDescription(ctx)
	case customer.FieldEmail:
		return m.OldEmail(ctx)
	case customer.FieldIsDefault:
		return m.OldIsDefault(ctx)
	case customer.FieldName:
		return m.OldName(ctx)
	case customer.FieldPhone:
		return m.OldPhone(ctx)
	case customer.FieldTaxId:
		return m.OldTaxId(ctx)
	}
	return nil, fmt.Errorf("unknown Customer field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CustomerMutation) SetField(name string, value ent.Value) error {
	switch name {
	case customer.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case customer.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case customer.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case customer.FieldAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAddress(v)
		return nil
	case customer.FieldCity:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCity(v)
		return nil
	case customer.FieldCountry:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCountry(v)
		return nil
	case customer.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case customer.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case customer.FieldIsDefault:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsDefault(v)
		return nil
	case customer.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case customer.FieldPhone:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPhone(v)
		return nil
	case customer.FieldTaxId:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTaxId(v)
		return nil
	}
	return fmt.Errorf("unknown Customer field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CustomerMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CustomerMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CustomerMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Customer numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CustomerMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(customer.FieldDeletedAt) {
		fields = append(fields, customer.FieldDeletedAt)
	}
	if m.FieldCleared(customer.FieldIsDefault) {
		fields = append(fields, customer.FieldIsDefault)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CustomerMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CustomerMutation) ClearField(name string) error {
	switch name {
	case customer.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case customer.FieldIsDefault:
		m.ClearIsDefault()
		return nil
	}
	return fmt.Errorf("unknown Customer nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CustomerMutation) ResetField(name string) error {
	switch name {
	case customer.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case customer.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case customer.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case customer.FieldAddress:
		m.ResetAddress()
		return nil
	case customer.FieldCity:
		m.ResetCity()
		return nil
	case customer.FieldCountry:
		m.ResetCountry()
		return nil
	case customer.FieldDescription:
		m.ResetDescription()
		return nil
	case customer.FieldEmail:
		m.ResetEmail()
		return nil
	case customer.FieldIsDefault:
		m.ResetIsDefault()
		return nil
	case customer.FieldName:
		m.ResetName()
		return nil
	case customer.FieldPhone:
		m.ResetPhone()
		return nil
	case customer.FieldTaxId:
		m.ResetTaxId()
		return nil
	}
	return fmt.Errorf("unknown Customer field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CustomerMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.company != nil {
		edges = append(edges, customer.EdgeCompany)
	}
	if m.receivables != nil {
		edges = append(edges, customer.EdgeReceivables)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CustomerMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case customer.EdgeCompany:
		if id := m.company; id != nil {
			return []ent.Value{*id}
		}
	case customer.EdgeReceivables:
		ids := make([]ent.Value, 0, len(m.receivables))
		for id := range m.receivables {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CustomerMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedreceivables != nil {
		edges = append(edges, customer.EdgeReceivables)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CustomerMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case customer.EdgeReceivables:
		ids := make([]ent.Value, 0, len(m.removedreceivables))
		for id := range m.removedreceivables {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CustomerMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedcompany {
		edges = append(edges, customer.EdgeCompany)
	}
	if m.clearedreceivables {
		edges = append(edges, customer.EdgeReceivables)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CustomerMutation) EdgeCleared(name string) bool {
	switch name {
	case customer.EdgeCompany:
		return m.clearedcompany
	case customer.EdgeReceivables:
		return m.clearedreceivables
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CustomerMutation) ClearEdge(name string) error {
	switch name {
	case customer.EdgeCompany:
		m.ClearCompany()
		return nil
	}
	return fmt.Errorf("unknown Customer unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CustomerMutation) ResetEdge(name string) error {
	switch name {
	case customer.EdgeCompany:
		m.ResetCompany()
		return nil
	case customer.EdgeReceivables:
		m.ResetReceivables()
		return nil
	}
	return fmt.Errorf("unknown Customer edge %s", name)
}

// EmployeeMutation represents an operation that mutates the Employee nodes in the graph.
type EmployeeMutation struct {
	config
	op                        Op
	typ                       string
	id                        *int
	createdAt                 *time.Time
	updatedAt                 *time.Time
	deletedAt                 *time.Time
	name                      *string
	gender                    *employee.Gender
	position                  *string
	email                     *string
	phone                     *string
	clearedFields             map[string]struct{}
	company                   *int
	clearedcompany            bool
	user                      *int
	cleareduser               bool
	subordinates              map[int]struct{}
	removedsubordinates       map[int]struct{}
	clearedsubordinates       bool
	leader                    *int
	clearedleader             bool
	workShifts                map[int]struct{}
	removedworkShifts         map[int]struct{}
	clearedworkShifts         bool
	approvedWorkShifts        map[int]struct{}
	removedapprovedWorkShifts map[int]struct{}
	clearedapprovedWorkShifts bool
	assignedTasks             map[int]struct{}
	removedassignedTasks      map[int]struct{}
	clearedassignedTasks      bool
	done                      bool
	oldValue                  func(context.Context) (*Employee, error)
	predicates                []predicate.Employee
}

var _ ent.Mutation = (*EmployeeMutation)(nil)

// employeeOption allows management of the mutation configuration using functional options.
type employeeOption func(*EmployeeMutation)

// newEmployeeMutation creates new mutation for the Employee entity.
func newEmployeeMutation(c config, op Op, opts ...employeeOption) *EmployeeMutation {
	m := &EmployeeMutation{
		config:        c,
		op:            op,
		typ:           TypeEmployee,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withEmployeeID sets the ID field of the mutation.
func withEmployeeID(id int) employeeOption {
	return func(m *EmployeeMutation) {
		var (
			err   error
			once  sync.Once
			value *Employee
		)
		m.oldValue = func(ctx context.Context) (*Employee, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Employee.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withEmployee sets the old Employee of the mutation.
func withEmployee(node *Employee) employeeOption {
	return func(m *EmployeeMutation) {
		m.oldValue = func(context.Context) (*Employee, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m EmployeeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m EmployeeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *EmployeeMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *EmployeeMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Employee.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "createdAt" field.
func (m *EmployeeMutation) SetCreatedAt(t time.Time) {
	m.createdAt = &t
}

// CreatedAt returns the value of the "createdAt" field in the mutation.
func (m *EmployeeMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.createdAt
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "createdAt" field's value of the Employee entity.
// If the Employee object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeeMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "createdAt" field.
func (m *EmployeeMutation) ResetCreatedAt() {
	m.createdAt = nil
}

// SetUpdatedAt sets the "updatedAt" field.
func (m *EmployeeMutation) SetUpdatedAt(t time.Time) {
	m.updatedAt = &t
}

// UpdatedAt returns the value of the "updatedAt" field in the mutation.
func (m *EmployeeMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updatedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updatedAt" field's value of the Employee entity.
// If the Employee object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeeMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updatedAt" field.
func (m *EmployeeMutation) ResetUpdatedAt() {
	m.updatedAt = nil
}

// SetDeletedAt sets the "deletedAt" field.
func (m *EmployeeMutation) SetDeletedAt(t time.Time) {
	m.deletedAt = &t
}

// DeletedAt returns the value of the "deletedAt" field in the mutation.
func (m *EmployeeMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deletedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deletedAt" field's value of the Employee entity.
// If the Employee object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeeMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deletedAt" field.
func (m *EmployeeMutation) ClearDeletedAt() {
	m.deletedAt = nil
	m.clearedFields[employee.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deletedAt" field was cleared in this mutation.
func (m *EmployeeMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[employee.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deletedAt" field.
func (m *EmployeeMutation) ResetDeletedAt() {
	m.deletedAt = nil
	delete(m.clearedFields, employee.FieldDeletedAt)
}

// SetName sets the "name" field.
func (m *EmployeeMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *EmployeeMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Employee entity.
// If the Employee object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeeMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *EmployeeMutation) ResetName() {
	m.name = nil
}

// SetGender sets the "gender" field.
func (m *EmployeeMutation) SetGender(e employee.Gender) {
	m.gender = &e
}

// Gender returns the value of the "gender" field in the mutation.
func (m *EmployeeMutation) Gender() (r employee.Gender, exists bool) {
	v := m.gender
	if v == nil {
		return
	}
	return *v, true
}

// OldGender returns the old "gender" field's value of the Employee entity.
// If the Employee object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeeMutation) OldGender(ctx context.Context) (v employee.Gender, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGender is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGender requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGender: %w", err)
	}
	return oldValue.Gender, nil
}

// ResetGender resets all changes to the "gender" field.
func (m *EmployeeMutation) ResetGender() {
	m.gender = nil
}

// SetPosition sets the "position" field.
func (m *EmployeeMutation) SetPosition(s string) {
	m.position = &s
}

// Position returns the value of the "position" field in the mutation.
func (m *EmployeeMutation) Position() (r string, exists bool) {
	v := m.position
	if v == nil {
		return
	}
	return *v, true
}

// OldPosition returns the old "position" field's value of the Employee entity.
// If the Employee object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeeMutation) OldPosition(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPosition is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPosition requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPosition: %w", err)
	}
	return oldValue.Position, nil
}

// ClearPosition clears the value of the "position" field.
func (m *EmployeeMutation) ClearPosition() {
	m.position = nil
	m.clearedFields[employee.FieldPosition] = struct{}{}
}

// PositionCleared returns if the "position" field was cleared in this mutation.
func (m *EmployeeMutation) PositionCleared() bool {
	_, ok := m.clearedFields[employee.FieldPosition]
	return ok
}

// ResetPosition resets all changes to the "position" field.
func (m *EmployeeMutation) ResetPosition() {
	m.position = nil
	delete(m.clearedFields, employee.FieldPosition)
}

// SetEmail sets the "email" field.
func (m *EmployeeMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *EmployeeMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the Employee entity.
// If the Employee object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeeMutation) OldEmail(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ClearEmail clears the value of the "email" field.
func (m *EmployeeMutation) ClearEmail() {
	m.email = nil
	m.clearedFields[employee.FieldEmail] = struct{}{}
}

// EmailCleared returns if the "email" field was cleared in this mutation.
func (m *EmployeeMutation) EmailCleared() bool {
	_, ok := m.clearedFields[employee.FieldEmail]
	return ok
}

// ResetEmail resets all changes to the "email" field.
func (m *EmployeeMutation) ResetEmail() {
	m.email = nil
	delete(m.clearedFields, employee.FieldEmail)
}

// SetPhone sets the "phone" field.
func (m *EmployeeMutation) SetPhone(s string) {
	m.phone = &s
}

// Phone returns the value of the "phone" field in the mutation.
func (m *EmployeeMutation) Phone() (r string, exists bool) {
	v := m.phone
	if v == nil {
		return
	}
	return *v, true
}

// OldPhone returns the old "phone" field's value of the Employee entity.
// If the Employee object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeeMutation) OldPhone(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPhone is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPhone requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPhone: %w", err)
	}
	return oldValue.Phone, nil
}

// ResetPhone resets all changes to the "phone" field.
func (m *EmployeeMutation) ResetPhone() {
	m.phone = nil
}

// SetCompanyID sets the "company" edge to the Company entity by id.
func (m *EmployeeMutation) SetCompanyID(id int) {
	m.company = &id
}

// ClearCompany clears the "company" edge to the Company entity.
func (m *EmployeeMutation) ClearCompany() {
	m.clearedcompany = true
}

// CompanyCleared reports if the "company" edge to the Company entity was cleared.
func (m *EmployeeMutation) CompanyCleared() bool {
	return m.clearedcompany
}

// CompanyID returns the "company" edge ID in the mutation.
func (m *EmployeeMutation) CompanyID() (id int, exists bool) {
	if m.company != nil {
		return *m.company, true
	}
	return
}

// CompanyIDs returns the "company" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CompanyID instead. It exists only for internal usage by the builders.
func (m *EmployeeMutation) CompanyIDs() (ids []int) {
	if id := m.company; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCompany resets all changes to the "company" edge.
func (m *EmployeeMutation) ResetCompany() {
	m.company = nil
	m.clearedcompany = false
}

// SetUserID sets the "user" edge to the User entity by id.
func (m *EmployeeMutation) SetUserID(id int) {
	m.user = &id
}

// ClearUser clears the "user" edge to the User entity.
func (m *EmployeeMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *EmployeeMutation) UserCleared() bool {
	return m.cleareduser
}

// UserID returns the "user" edge ID in the mutation.
func (m *EmployeeMutation) UserID() (id int, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *EmployeeMutation) UserIDs() (ids []int) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *EmployeeMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// AddSubordinateIDs adds the "subordinates" edge to the Employee entity by ids.
func (m *EmployeeMutation) AddSubordinateIDs(ids ...int) {
	if m.subordinates == nil {
		m.subordinates = make(map[int]struct{})
	}
	for i := range ids {
		m.subordinates[ids[i]] = struct{}{}
	}
}

// ClearSubordinates clears the "subordinates" edge to the Employee entity.
func (m *EmployeeMutation) ClearSubordinates() {
	m.clearedsubordinates = true
}

// SubordinatesCleared reports if the "subordinates" edge to the Employee entity was cleared.
func (m *EmployeeMutation) SubordinatesCleared() bool {
	return m.clearedsubordinates
}

// RemoveSubordinateIDs removes the "subordinates" edge to the Employee entity by IDs.
func (m *EmployeeMutation) RemoveSubordinateIDs(ids ...int) {
	if m.removedsubordinates == nil {
		m.removedsubordinates = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.subordinates, ids[i])
		m.removedsubordinates[ids[i]] = struct{}{}
	}
}

// RemovedSubordinates returns the removed IDs of the "subordinates" edge to the Employee entity.
func (m *EmployeeMutation) RemovedSubordinatesIDs() (ids []int) {
	for id := range m.removedsubordinates {
		ids = append(ids, id)
	}
	return
}

// SubordinatesIDs returns the "subordinates" edge IDs in the mutation.
func (m *EmployeeMutation) SubordinatesIDs() (ids []int) {
	for id := range m.subordinates {
		ids = append(ids, id)
	}
	return
}

// ResetSubordinates resets all changes to the "subordinates" edge.
func (m *EmployeeMutation) ResetSubordinates() {
	m.subordinates = nil
	m.clearedsubordinates = false
	m.removedsubordinates = nil
}

// SetLeaderID sets the "leader" edge to the Employee entity by id.
func (m *EmployeeMutation) SetLeaderID(id int) {
	m.leader = &id
}

// ClearLeader clears the "leader" edge to the Employee entity.
func (m *EmployeeMutation) ClearLeader() {
	m.clearedleader = true
}

// LeaderCleared reports if the "leader" edge to the Employee entity was cleared.
func (m *EmployeeMutation) LeaderCleared() bool {
	return m.clearedleader
}

// LeaderID returns the "leader" edge ID in the mutation.
func (m *EmployeeMutation) LeaderID() (id int, exists bool) {
	if m.leader != nil {
		return *m.leader, true
	}
	return
}

// LeaderIDs returns the "leader" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// LeaderID instead. It exists only for internal usage by the builders.
func (m *EmployeeMutation) LeaderIDs() (ids []int) {
	if id := m.leader; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetLeader resets all changes to the "leader" edge.
func (m *EmployeeMutation) ResetLeader() {
	m.leader = nil
	m.clearedleader = false
}

// AddWorkShiftIDs adds the "workShifts" edge to the Workshift entity by ids.
func (m *EmployeeMutation) AddWorkShiftIDs(ids ...int) {
	if m.workShifts == nil {
		m.workShifts = make(map[int]struct{})
	}
	for i := range ids {
		m.workShifts[ids[i]] = struct{}{}
	}
}

// ClearWorkShifts clears the "workShifts" edge to the Workshift entity.
func (m *EmployeeMutation) ClearWorkShifts() {
	m.clearedworkShifts = true
}

// WorkShiftsCleared reports if the "workShifts" edge to the Workshift entity was cleared.
func (m *EmployeeMutation) WorkShiftsCleared() bool {
	return m.clearedworkShifts
}

// RemoveWorkShiftIDs removes the "workShifts" edge to the Workshift entity by IDs.
func (m *EmployeeMutation) RemoveWorkShiftIDs(ids ...int) {
	if m.removedworkShifts == nil {
		m.removedworkShifts = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.workShifts, ids[i])
		m.removedworkShifts[ids[i]] = struct{}{}
	}
}

// RemovedWorkShifts returns the removed IDs of the "workShifts" edge to the Workshift entity.
func (m *EmployeeMutation) RemovedWorkShiftsIDs() (ids []int) {
	for id := range m.removedworkShifts {
		ids = append(ids, id)
	}
	return
}

// WorkShiftsIDs returns the "workShifts" edge IDs in the mutation.
func (m *EmployeeMutation) WorkShiftsIDs() (ids []int) {
	for id := range m.workShifts {
		ids = append(ids, id)
	}
	return
}

// ResetWorkShifts resets all changes to the "workShifts" edge.
func (m *EmployeeMutation) ResetWorkShifts() {
	m.workShifts = nil
	m.clearedworkShifts = false
	m.removedworkShifts = nil
}

// AddApprovedWorkShiftIDs adds the "approvedWorkShifts" edge to the Workshift entity by ids.
func (m *EmployeeMutation) AddApprovedWorkShiftIDs(ids ...int) {
	if m.approvedWorkShifts == nil {
		m.approvedWorkShifts = make(map[int]struct{})
	}
	for i := range ids {
		m.approvedWorkShifts[ids[i]] = struct{}{}
	}
}

// ClearApprovedWorkShifts clears the "approvedWorkShifts" edge to the Workshift entity.
func (m *EmployeeMutation) ClearApprovedWorkShifts() {
	m.clearedapprovedWorkShifts = true
}

// ApprovedWorkShiftsCleared reports if the "approvedWorkShifts" edge to the Workshift entity was cleared.
func (m *EmployeeMutation) ApprovedWorkShiftsCleared() bool {
	return m.clearedapprovedWorkShifts
}

// RemoveApprovedWorkShiftIDs removes the "approvedWorkShifts" edge to the Workshift entity by IDs.
func (m *EmployeeMutation) RemoveApprovedWorkShiftIDs(ids ...int) {
	if m.removedapprovedWorkShifts == nil {
		m.removedapprovedWorkShifts = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.approvedWorkShifts, ids[i])
		m.removedapprovedWorkShifts[ids[i]] = struct{}{}
	}
}

// RemovedApprovedWorkShifts returns the removed IDs of the "approvedWorkShifts" edge to the Workshift entity.
func (m *EmployeeMutation) RemovedApprovedWorkShiftsIDs() (ids []int) {
	for id := range m.removedapprovedWorkShifts {
		ids = append(ids, id)
	}
	return
}

// ApprovedWorkShiftsIDs returns the "approvedWorkShifts" edge IDs in the mutation.
func (m *EmployeeMutation) ApprovedWorkShiftsIDs() (ids []int) {
	for id := range m.approvedWorkShifts {
		ids = append(ids, id)
	}
	return
}

// ResetApprovedWorkShifts resets all changes to the "approvedWorkShifts" edge.
func (m *EmployeeMutation) ResetApprovedWorkShifts() {
	m.approvedWorkShifts = nil
	m.clearedapprovedWorkShifts = false
	m.removedapprovedWorkShifts = nil
}

// AddAssignedTaskIDs adds the "assignedTasks" edge to the Worktask entity by ids.
func (m *EmployeeMutation) AddAssignedTaskIDs(ids ...int) {
	if m.assignedTasks == nil {
		m.assignedTasks = make(map[int]struct{})
	}
	for i := range ids {
		m.assignedTasks[ids[i]] = struct{}{}
	}
}

// ClearAssignedTasks clears the "assignedTasks" edge to the Worktask entity.
func (m *EmployeeMutation) ClearAssignedTasks() {
	m.clearedassignedTasks = true
}

// AssignedTasksCleared reports if the "assignedTasks" edge to the Worktask entity was cleared.
func (m *EmployeeMutation) AssignedTasksCleared() bool {
	return m.clearedassignedTasks
}

// RemoveAssignedTaskIDs removes the "assignedTasks" edge to the Worktask entity by IDs.
func (m *EmployeeMutation) RemoveAssignedTaskIDs(ids ...int) {
	if m.removedassignedTasks == nil {
		m.removedassignedTasks = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.assignedTasks, ids[i])
		m.removedassignedTasks[ids[i]] = struct{}{}
	}
}

// RemovedAssignedTasks returns the removed IDs of the "assignedTasks" edge to the Worktask entity.
func (m *EmployeeMutation) RemovedAssignedTasksIDs() (ids []int) {
	for id := range m.removedassignedTasks {
		ids = append(ids, id)
	}
	return
}

// AssignedTasksIDs returns the "assignedTasks" edge IDs in the mutation.
func (m *EmployeeMutation) AssignedTasksIDs() (ids []int) {
	for id := range m.assignedTasks {
		ids = append(ids, id)
	}
	return
}

// ResetAssignedTasks resets all changes to the "assignedTasks" edge.
func (m *EmployeeMutation) ResetAssignedTasks() {
	m.assignedTasks = nil
	m.clearedassignedTasks = false
	m.removedassignedTasks = nil
}

// Where appends a list predicates to the EmployeeMutation builder.
func (m *EmployeeMutation) Where(ps ...predicate.Employee) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the EmployeeMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *EmployeeMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Employee, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *EmployeeMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *EmployeeMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Employee).
func (m *EmployeeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *EmployeeMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.createdAt != nil {
		fields = append(fields, employee.FieldCreatedAt)
	}
	if m.updatedAt != nil {
		fields = append(fields, employee.FieldUpdatedAt)
	}
	if m.deletedAt != nil {
		fields = append(fields, employee.FieldDeletedAt)
	}
	if m.name != nil {
		fields = append(fields, employee.FieldName)
	}
	if m.gender != nil {
		fields = append(fields, employee.FieldGender)
	}
	if m.position != nil {
		fields = append(fields, employee.FieldPosition)
	}
	if m.email != nil {
		fields = append(fields, employee.FieldEmail)
	}
	if m.phone != nil {
		fields = append(fields, employee.FieldPhone)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *EmployeeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case employee.FieldCreatedAt:
		return m.CreatedAt()
	case employee.FieldUpdatedAt:
		return m.UpdatedAt()
	case employee.FieldDeletedAt:
		return m.DeletedAt()
	case employee.FieldName:
		return m.Name()
	case employee.FieldGender:
		return m.Gender()
	case employee.FieldPosition:
		return m.Position()
	case employee.FieldEmail:
		return m.Email()
	case employee.FieldPhone:
		return m.Phone()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *EmployeeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case employee.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case employee.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case employee.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case employee.FieldName:
		return m.OldName(ctx)
	case employee.FieldGender:
		return m.OldGender(ctx)
	case employee.FieldPosition:
		return m.OldPosition(ctx)
	case employee.FieldEmail:
		return m.OldEmail(ctx)
	case employee.FieldPhone:
		return m.OldPhone(ctx)
	}
	return nil, fmt.Errorf("unknown Employee field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EmployeeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case employee.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case employee.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case employee.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case employee.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case employee.FieldGender:
		v, ok := value.(employee.Gender)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGender(v)
		return nil
	case employee.FieldPosition:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPosition(v)
		return nil
	case employee.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case employee.FieldPhone:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPhone(v)
		return nil
	}
	return fmt.Errorf("unknown Employee field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *EmployeeMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *EmployeeMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EmployeeMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Employee numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *EmployeeMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(employee.FieldDeletedAt) {
		fields = append(fields, employee.FieldDeletedAt)
	}
	if m.FieldCleared(employee.FieldPosition) {
		fields = append(fields, employee.FieldPosition)
	}
	if m.FieldCleared(employee.FieldEmail) {
		fields = append(fields, employee.FieldEmail)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *EmployeeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *EmployeeMutation) ClearField(name string) error {
	switch name {
	case employee.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case employee.FieldPosition:
		m.ClearPosition()
		return nil
	case employee.FieldEmail:
		m.ClearEmail()
		return nil
	}
	return fmt.Errorf("unknown Employee nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *EmployeeMutation) ResetField(name string) error {
	switch name {
	case employee.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case employee.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case employee.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case employee.FieldName:
		m.ResetName()
		return nil
	case employee.FieldGender:
		m.ResetGender()
		return nil
	case employee.FieldPosition:
		m.ResetPosition()
		return nil
	case employee.FieldEmail:
		m.ResetEmail()
		return nil
	case employee.FieldPhone:
		m.ResetPhone()
		return nil
	}
	return fmt.Errorf("unknown Employee field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *EmployeeMutation) AddedEdges() []string {
	edges := make([]string, 0, 7)
	if m.company != nil {
		edges = append(edges, employee.EdgeCompany)
	}
	if m.user != nil {
		edges = append(edges, employee.EdgeUser)
	}
	if m.subordinates != nil {
		edges = append(edges, employee.EdgeSubordinates)
	}
	if m.leader != nil {
		edges = append(edges, employee.EdgeLeader)
	}
	if m.workShifts != nil {
		edges = append(edges, employee.EdgeWorkShifts)
	}
	if m.approvedWorkShifts != nil {
		edges = append(edges, employee.EdgeApprovedWorkShifts)
	}
	if m.assignedTasks != nil {
		edges = append(edges, employee.EdgeAssignedTasks)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *EmployeeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case employee.EdgeCompany:
		if id := m.company; id != nil {
			return []ent.Value{*id}
		}
	case employee.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case employee.EdgeSubordinates:
		ids := make([]ent.Value, 0, len(m.subordinates))
		for id := range m.subordinates {
			ids = append(ids, id)
		}
		return ids
	case employee.EdgeLeader:
		if id := m.leader; id != nil {
			return []ent.Value{*id}
		}
	case employee.EdgeWorkShifts:
		ids := make([]ent.Value, 0, len(m.workShifts))
		for id := range m.workShifts {
			ids = append(ids, id)
		}
		return ids
	case employee.EdgeApprovedWorkShifts:
		ids := make([]ent.Value, 0, len(m.approvedWorkShifts))
		for id := range m.approvedWorkShifts {
			ids = append(ids, id)
		}
		return ids
	case employee.EdgeAssignedTasks:
		ids := make([]ent.Value, 0, len(m.assignedTasks))
		for id := range m.assignedTasks {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *EmployeeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 7)
	if m.removedsubordinates != nil {
		edges = append(edges, employee.EdgeSubordinates)
	}
	if m.removedworkShifts != nil {
		edges = append(edges, employee.EdgeWorkShifts)
	}
	if m.removedapprovedWorkShifts != nil {
		edges = append(edges, employee.EdgeApprovedWorkShifts)
	}
	if m.removedassignedTasks != nil {
		edges = append(edges, employee.EdgeAssignedTasks)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *EmployeeMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case employee.EdgeSubordinates:
		ids := make([]ent.Value, 0, len(m.removedsubordinates))
		for id := range m.removedsubordinates {
			ids = append(ids, id)
		}
		return ids
	case employee.EdgeWorkShifts:
		ids := make([]ent.Value, 0, len(m.removedworkShifts))
		for id := range m.removedworkShifts {
			ids = append(ids, id)
		}
		return ids
	case employee.EdgeApprovedWorkShifts:
		ids := make([]ent.Value, 0, len(m.removedapprovedWorkShifts))
		for id := range m.removedapprovedWorkShifts {
			ids = append(ids, id)
		}
		return ids
	case employee.EdgeAssignedTasks:
		ids := make([]ent.Value, 0, len(m.removedassignedTasks))
		for id := range m.removedassignedTasks {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *EmployeeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 7)
	if m.clearedcompany {
		edges = append(edges, employee.EdgeCompany)
	}
	if m.cleareduser {
		edges = append(edges, employee.EdgeUser)
	}
	if m.clearedsubordinates {
		edges = append(edges, employee.EdgeSubordinates)
	}
	if m.clearedleader {
		edges = append(edges, employee.EdgeLeader)
	}
	if m.clearedworkShifts {
		edges = append(edges, employee.EdgeWorkShifts)
	}
	if m.clearedapprovedWorkShifts {
		edges = append(edges, employee.EdgeApprovedWorkShifts)
	}
	if m.clearedassignedTasks {
		edges = append(edges, employee.EdgeAssignedTasks)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *EmployeeMutation) EdgeCleared(name string) bool {
	switch name {
	case employee.EdgeCompany:
		return m.clearedcompany
	case employee.EdgeUser:
		return m.cleareduser
	case employee.EdgeSubordinates:
		return m.clearedsubordinates
	case employee.EdgeLeader:
		return m.clearedleader
	case employee.EdgeWorkShifts:
		return m.clearedworkShifts
	case employee.EdgeApprovedWorkShifts:
		return m.clearedapprovedWorkShifts
	case employee.EdgeAssignedTasks:
		return m.clearedassignedTasks
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *EmployeeMutation) ClearEdge(name string) error {
	switch name {
	case employee.EdgeCompany:
		m.ClearCompany()
		return nil
	case employee.EdgeUser:
		m.ClearUser()
		return nil
	case employee.EdgeLeader:
		m.ClearLeader()
		return nil
	}
	return fmt.Errorf("unknown Employee unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *EmployeeMutation) ResetEdge(name string) error {
	switch name {
	case employee.EdgeCompany:
		m.ResetCompany()
		return nil
	case employee.EdgeUser:
		m.ResetUser()
		return nil
	case employee.EdgeSubordinates:
		m.ResetSubordinates()
		return nil
	case employee.EdgeLeader:
		m.ResetLeader()
		return nil
	case employee.EdgeWorkShifts:
		m.ResetWorkShifts()
		return nil
	case employee.EdgeApprovedWorkShifts:
		m.ResetApprovedWorkShifts()
		return nil
	case employee.EdgeAssignedTasks:
		m.ResetAssignedTasks()
		return nil
	}
	return fmt.Errorf("unknown Employee edge %s", name)
}

// FileMutation represents an operation that mutates the File nodes in the graph.
type FileMutation struct {
	config
	op             Op
	typ            string
	id             *int
	createdAt      *time.Time
	updatedAt      *time.Time
	deletedAt      *time.Time
	category       *file.Category
	extension      *string
	size           *string
	url            *string
	description    *string
	clearedFields  map[string]struct{}
	company        *int
	clearedcompany bool
	product        *int
	clearedproduct bool
	done           bool
	oldValue       func(context.Context) (*File, error)
	predicates     []predicate.File
}

var _ ent.Mutation = (*FileMutation)(nil)

// fileOption allows management of the mutation configuration using functional options.
type fileOption func(*FileMutation)

// newFileMutation creates new mutation for the File entity.
func newFileMutation(c config, op Op, opts ...fileOption) *FileMutation {
	m := &FileMutation{
		config:        c,
		op:            op,
		typ:           TypeFile,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withFileID sets the ID field of the mutation.
func withFileID(id int) fileOption {
	return func(m *FileMutation) {
		var (
			err   error
			once  sync.Once
			value *File
		)
		m.oldValue = func(ctx context.Context) (*File, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().File.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withFile sets the old File of the mutation.
func withFile(node *File) fileOption {
	return func(m *FileMutation) {
		m.oldValue = func(context.Context) (*File, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m FileMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m FileMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *FileMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *FileMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().File.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "createdAt" field.
func (m *FileMutation) SetCreatedAt(t time.Time) {
	m.createdAt = &t
}

// CreatedAt returns the value of the "createdAt" field in the mutation.
func (m *FileMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.createdAt
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "createdAt" field's value of the File entity.
// If the File object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "createdAt" field.
func (m *FileMutation) ResetCreatedAt() {
	m.createdAt = nil
}

// SetUpdatedAt sets the "updatedAt" field.
func (m *FileMutation) SetUpdatedAt(t time.Time) {
	m.updatedAt = &t
}

// UpdatedAt returns the value of the "updatedAt" field in the mutation.
func (m *FileMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updatedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updatedAt" field's value of the File entity.
// If the File object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updatedAt" field.
func (m *FileMutation) ResetUpdatedAt() {
	m.updatedAt = nil
}

// SetDeletedAt sets the "deletedAt" field.
func (m *FileMutation) SetDeletedAt(t time.Time) {
	m.deletedAt = &t
}

// DeletedAt returns the value of the "deletedAt" field in the mutation.
func (m *FileMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deletedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deletedAt" field's value of the File entity.
// If the File object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deletedAt" field.
func (m *FileMutation) ClearDeletedAt() {
	m.deletedAt = nil
	m.clearedFields[file.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deletedAt" field was cleared in this mutation.
func (m *FileMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[file.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deletedAt" field.
func (m *FileMutation) ResetDeletedAt() {
	m.deletedAt = nil
	delete(m.clearedFields, file.FieldDeletedAt)
}

// SetCategory sets the "category" field.
func (m *FileMutation) SetCategory(f file.Category) {
	m.category = &f
}

// Category returns the value of the "category" field in the mutation.
func (m *FileMutation) Category() (r file.Category, exists bool) {
	v := m.category
	if v == nil {
		return
	}
	return *v, true
}

// OldCategory returns the old "category" field's value of the File entity.
// If the File object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileMutation) OldCategory(ctx context.Context) (v file.Category, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCategory is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCategory requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCategory: %w", err)
	}
	return oldValue.Category, nil
}

// ResetCategory resets all changes to the "category" field.
func (m *FileMutation) ResetCategory() {
	m.category = nil
}

// SetExtension sets the "extension" field.
func (m *FileMutation) SetExtension(s string) {
	m.extension = &s
}

// Extension returns the value of the "extension" field in the mutation.
func (m *FileMutation) Extension() (r string, exists bool) {
	v := m.extension
	if v == nil {
		return
	}
	return *v, true
}

// OldExtension returns the old "extension" field's value of the File entity.
// If the File object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileMutation) OldExtension(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExtension is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExtension requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExtension: %w", err)
	}
	return oldValue.Extension, nil
}

// ResetExtension resets all changes to the "extension" field.
func (m *FileMutation) ResetExtension() {
	m.extension = nil
}

// SetSize sets the "size" field.
func (m *FileMutation) SetSize(s string) {
	m.size = &s
}

// Size returns the value of the "size" field in the mutation.
func (m *FileMutation) Size() (r string, exists bool) {
	v := m.size
	if v == nil {
		return
	}
	return *v, true
}

// OldSize returns the old "size" field's value of the File entity.
// If the File object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileMutation) OldSize(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSize is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSize requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSize: %w", err)
	}
	return oldValue.Size, nil
}

// ResetSize resets all changes to the "size" field.
func (m *FileMutation) ResetSize() {
	m.size = nil
}

// SetURL sets the "url" field.
func (m *FileMutation) SetURL(s string) {
	m.url = &s
}

// URL returns the value of the "url" field in the mutation.
func (m *FileMutation) URL() (r string, exists bool) {
	v := m.url
	if v == nil {
		return
	}
	return *v, true
}

// OldURL returns the old "url" field's value of the File entity.
// If the File object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileMutation) OldURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldURL: %w", err)
	}
	return oldValue.URL, nil
}

// ResetURL resets all changes to the "url" field.
func (m *FileMutation) ResetURL() {
	m.url = nil
}

// SetDescription sets the "description" field.
func (m *FileMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *FileMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the File entity.
// If the File object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *FileMutation) ResetDescription() {
	m.description = nil
}

// SetCompanyID sets the "company" edge to the Company entity by id.
func (m *FileMutation) SetCompanyID(id int) {
	m.company = &id
}

// ClearCompany clears the "company" edge to the Company entity.
func (m *FileMutation) ClearCompany() {
	m.clearedcompany = true
}

// CompanyCleared reports if the "company" edge to the Company entity was cleared.
func (m *FileMutation) CompanyCleared() bool {
	return m.clearedcompany
}

// CompanyID returns the "company" edge ID in the mutation.
func (m *FileMutation) CompanyID() (id int, exists bool) {
	if m.company != nil {
		return *m.company, true
	}
	return
}

// CompanyIDs returns the "company" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CompanyID instead. It exists only for internal usage by the builders.
func (m *FileMutation) CompanyIDs() (ids []int) {
	if id := m.company; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCompany resets all changes to the "company" edge.
func (m *FileMutation) ResetCompany() {
	m.company = nil
	m.clearedcompany = false
}

// SetProductID sets the "product" edge to the Product entity by id.
func (m *FileMutation) SetProductID(id int) {
	m.product = &id
}

// ClearProduct clears the "product" edge to the Product entity.
func (m *FileMutation) ClearProduct() {
	m.clearedproduct = true
}

// ProductCleared reports if the "product" edge to the Product entity was cleared.
func (m *FileMutation) ProductCleared() bool {
	return m.clearedproduct
}

// ProductID returns the "product" edge ID in the mutation.
func (m *FileMutation) ProductID() (id int, exists bool) {
	if m.product != nil {
		return *m.product, true
	}
	return
}

// ProductIDs returns the "product" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProductID instead. It exists only for internal usage by the builders.
func (m *FileMutation) ProductIDs() (ids []int) {
	if id := m.product; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProduct resets all changes to the "product" edge.
func (m *FileMutation) ResetProduct() {
	m.product = nil
	m.clearedproduct = false
}

// Where appends a list predicates to the FileMutation builder.
func (m *FileMutation) Where(ps ...predicate.File) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the FileMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *FileMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.File, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *FileMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *FileMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (File).
func (m *FileMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *FileMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.createdAt != nil {
		fields = append(fields, file.FieldCreatedAt)
	}
	if m.updatedAt != nil {
		fields = append(fields, file.FieldUpdatedAt)
	}
	if m.deletedAt != nil {
		fields = append(fields, file.FieldDeletedAt)
	}
	if m.category != nil {
		fields = append(fields, file.FieldCategory)
	}
	if m.extension != nil {
		fields = append(fields, file.FieldExtension)
	}
	if m.size != nil {
		fields = append(fields, file.FieldSize)
	}
	if m.url != nil {
		fields = append(fields, file.FieldURL)
	}
	if m.description != nil {
		fields = append(fields, file.FieldDescription)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *FileMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case file.FieldCreatedAt:
		return m.CreatedAt()
	case file.FieldUpdatedAt:
		return m.UpdatedAt()
	case file.FieldDeletedAt:
		return m.DeletedAt()
	case file.FieldCategory:
		return m.Category()
	case file.FieldExtension:
		return m.Extension()
	case file.FieldSize:
		return m.Size()
	case file.FieldURL:
		return m.URL()
	case file.FieldDescription:
		return m.Description()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *FileMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case file.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case file.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case file.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case file.FieldCategory:
		return m.OldCategory(ctx)
	case file.FieldExtension:
		return m.OldExtension(ctx)
	case file.FieldSize:
		return m.OldSize(ctx)
	case file.FieldURL:
		return m.OldURL(ctx)
	case file.FieldDescription:
		return m.OldDescription(ctx)
	}
	return nil, fmt.Errorf("unknown File field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FileMutation) SetField(name string, value ent.Value) error {
	switch name {
	case file.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case file.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case file.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case file.FieldCategory:
		v, ok := value.(file.Category)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCategory(v)
		return nil
	case file.FieldExtension:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExtension(v)
		return nil
	case file.FieldSize:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSize(v)
		return nil
	case file.FieldURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetURL(v)
		return nil
	case file.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	}
	return fmt.Errorf("unknown File field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *FileMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *FileMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FileMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown File numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *FileMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(file.FieldDeletedAt) {
		fields = append(fields, file.FieldDeletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *FileMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *FileMutation) ClearField(name string) error {
	switch name {
	case file.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown File nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *FileMutation) ResetField(name string) error {
	switch name {
	case file.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case file.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case file.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case file.FieldCategory:
		m.ResetCategory()
		return nil
	case file.FieldExtension:
		m.ResetExtension()
		return nil
	case file.FieldSize:
		m.ResetSize()
		return nil
	case file.FieldURL:
		m.ResetURL()
		return nil
	case file.FieldDescription:
		m.ResetDescription()
		return nil
	}
	return fmt.Errorf("unknown File field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *FileMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.company != nil {
		edges = append(edges, file.EdgeCompany)
	}
	if m.product != nil {
		edges = append(edges, file.EdgeProduct)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *FileMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case file.EdgeCompany:
		if id := m.company; id != nil {
			return []ent.Value{*id}
		}
	case file.EdgeProduct:
		if id := m.product; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *FileMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *FileMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *FileMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedcompany {
		edges = append(edges, file.EdgeCompany)
	}
	if m.clearedproduct {
		edges = append(edges, file.EdgeProduct)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *FileMutation) EdgeCleared(name string) bool {
	switch name {
	case file.EdgeCompany:
		return m.clearedcompany
	case file.EdgeProduct:
		return m.clearedproduct
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *FileMutation) ClearEdge(name string) error {
	switch name {
	case file.EdgeCompany:
		m.ClearCompany()
		return nil
	case file.EdgeProduct:
		m.ClearProduct()
		return nil
	}
	return fmt.Errorf("unknown File unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *FileMutation) ResetEdge(name string) error {
	switch name {
	case file.EdgeCompany:
		m.ResetCompany()
		return nil
	case file.EdgeProduct:
		m.ResetProduct()
		return nil
	}
	return fmt.Errorf("unknown File edge %s", name)
}

// PayableMutation represents an operation that mutates the Payable nodes in the graph.
type PayableMutation struct {
	config
	op                    Op
	typ                   string
	id                    *int
	createdAt             *time.Time
	updatedAt             *time.Time
	deletedAt             *time.Time
	entryGroup            *int
	addentryGroup         *int
	date                  *time.Time
	outstandingBalance    *float64
	addoutstandingBalance *float64
	totalTransaction      *float64
	addtotalTransaction   *float64
	daysDue               *int
	adddaysDue            *int
	status                *payable.Status
	clearedFields         map[string]struct{}
	supplier              *int
	clearedsupplier       bool
	done                  bool
	oldValue              func(context.Context) (*Payable, error)
	predicates            []predicate.Payable
}

var _ ent.Mutation = (*PayableMutation)(nil)

// payableOption allows management of the mutation configuration using functional options.
type payableOption func(*PayableMutation)

// newPayableMutation creates new mutation for the Payable entity.
func newPayableMutation(c config, op Op, opts ...payableOption) *PayableMutation {
	m := &PayableMutation{
		config:        c,
		op:            op,
		typ:           TypePayable,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPayableID sets the ID field of the mutation.
func withPayableID(id int) payableOption {
	return func(m *PayableMutation) {
		var (
			err   error
			once  sync.Once
			value *Payable
		)
		m.oldValue = func(ctx context.Context) (*Payable, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Payable.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPayable sets the old Payable of the mutation.
func withPayable(node *Payable) payableOption {
	return func(m *PayableMutation) {
		m.oldValue = func(context.Context) (*Payable, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PayableMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PayableMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PayableMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PayableMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Payable.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "createdAt" field.
func (m *PayableMutation) SetCreatedAt(t time.Time) {
	m.createdAt = &t
}

// CreatedAt returns the value of the "createdAt" field in the mutation.
func (m *PayableMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.createdAt
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "createdAt" field's value of the Payable entity.
// If the Payable object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PayableMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "createdAt" field.
func (m *PayableMutation) ResetCreatedAt() {
	m.createdAt = nil
}

// SetUpdatedAt sets the "updatedAt" field.
func (m *PayableMutation) SetUpdatedAt(t time.Time) {
	m.updatedAt = &t
}

// UpdatedAt returns the value of the "updatedAt" field in the mutation.
func (m *PayableMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updatedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updatedAt" field's value of the Payable entity.
// If the Payable object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PayableMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updatedAt" field.
func (m *PayableMutation) ResetUpdatedAt() {
	m.updatedAt = nil
}

// SetDeletedAt sets the "deletedAt" field.
func (m *PayableMutation) SetDeletedAt(t time.Time) {
	m.deletedAt = &t
}

// DeletedAt returns the value of the "deletedAt" field in the mutation.
func (m *PayableMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deletedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deletedAt" field's value of the Payable entity.
// If the Payable object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PayableMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deletedAt" field.
func (m *PayableMutation) ClearDeletedAt() {
	m.deletedAt = nil
	m.clearedFields[payable.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deletedAt" field was cleared in this mutation.
func (m *PayableMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[payable.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deletedAt" field.
func (m *PayableMutation) ResetDeletedAt() {
	m.deletedAt = nil
	delete(m.clearedFields, payable.FieldDeletedAt)
}

// SetEntryGroup sets the "entryGroup" field.
func (m *PayableMutation) SetEntryGroup(i int) {
	m.entryGroup = &i
	m.addentryGroup = nil
}

// EntryGroup returns the value of the "entryGroup" field in the mutation.
func (m *PayableMutation) EntryGroup() (r int, exists bool) {
	v := m.entryGroup
	if v == nil {
		return
	}
	return *v, true
}

// OldEntryGroup returns the old "entryGroup" field's value of the Payable entity.
// If the Payable object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PayableMutation) OldEntryGroup(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEntryGroup is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEntryGroup requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEntryGroup: %w", err)
	}
	return oldValue.EntryGroup, nil
}

// AddEntryGroup adds i to the "entryGroup" field.
func (m *PayableMutation) AddEntryGroup(i int) {
	if m.addentryGroup != nil {
		*m.addentryGroup += i
	} else {
		m.addentryGroup = &i
	}
}

// AddedEntryGroup returns the value that was added to the "entryGroup" field in this mutation.
func (m *PayableMutation) AddedEntryGroup() (r int, exists bool) {
	v := m.addentryGroup
	if v == nil {
		return
	}
	return *v, true
}

// ResetEntryGroup resets all changes to the "entryGroup" field.
func (m *PayableMutation) ResetEntryGroup() {
	m.entryGroup = nil
	m.addentryGroup = nil
}

// SetDate sets the "date" field.
func (m *PayableMutation) SetDate(t time.Time) {
	m.date = &t
}

// Date returns the value of the "date" field in the mutation.
func (m *PayableMutation) Date() (r time.Time, exists bool) {
	v := m.date
	if v == nil {
		return
	}
	return *v, true
}

// OldDate returns the old "date" field's value of the Payable entity.
// If the Payable object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PayableMutation) OldDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDate: %w", err)
	}
	return oldValue.Date, nil
}

// ResetDate resets all changes to the "date" field.
func (m *PayableMutation) ResetDate() {
	m.date = nil
}

// SetOutstandingBalance sets the "outstandingBalance" field.
func (m *PayableMutation) SetOutstandingBalance(f float64) {
	m.outstandingBalance = &f
	m.addoutstandingBalance = nil
}

// OutstandingBalance returns the value of the "outstandingBalance" field in the mutation.
func (m *PayableMutation) OutstandingBalance() (r float64, exists bool) {
	v := m.outstandingBalance
	if v == nil {
		return
	}
	return *v, true
}

// OldOutstandingBalance returns the old "outstandingBalance" field's value of the Payable entity.
// If the Payable object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PayableMutation) OldOutstandingBalance(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOutstandingBalance is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOutstandingBalance requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOutstandingBalance: %w", err)
	}
	return oldValue.OutstandingBalance, nil
}

// AddOutstandingBalance adds f to the "outstandingBalance" field.
func (m *PayableMutation) AddOutstandingBalance(f float64) {
	if m.addoutstandingBalance != nil {
		*m.addoutstandingBalance += f
	} else {
		m.addoutstandingBalance = &f
	}
}

// AddedOutstandingBalance returns the value that was added to the "outstandingBalance" field in this mutation.
func (m *PayableMutation) AddedOutstandingBalance() (r float64, exists bool) {
	v := m.addoutstandingBalance
	if v == nil {
		return
	}
	return *v, true
}

// ResetOutstandingBalance resets all changes to the "outstandingBalance" field.
func (m *PayableMutation) ResetOutstandingBalance() {
	m.outstandingBalance = nil
	m.addoutstandingBalance = nil
}

// SetTotalTransaction sets the "totalTransaction" field.
func (m *PayableMutation) SetTotalTransaction(f float64) {
	m.totalTransaction = &f
	m.addtotalTransaction = nil
}

// TotalTransaction returns the value of the "totalTransaction" field in the mutation.
func (m *PayableMutation) TotalTransaction() (r float64, exists bool) {
	v := m.totalTransaction
	if v == nil {
		return
	}
	return *v, true
}

// OldTotalTransaction returns the old "totalTransaction" field's value of the Payable entity.
// If the Payable object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PayableMutation) OldTotalTransaction(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTotalTransaction is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTotalTransaction requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTotalTransaction: %w", err)
	}
	return oldValue.TotalTransaction, nil
}

// AddTotalTransaction adds f to the "totalTransaction" field.
func (m *PayableMutation) AddTotalTransaction(f float64) {
	if m.addtotalTransaction != nil {
		*m.addtotalTransaction += f
	} else {
		m.addtotalTransaction = &f
	}
}

// AddedTotalTransaction returns the value that was added to the "totalTransaction" field in this mutation.
func (m *PayableMutation) AddedTotalTransaction() (r float64, exists bool) {
	v := m.addtotalTransaction
	if v == nil {
		return
	}
	return *v, true
}

// ResetTotalTransaction resets all changes to the "totalTransaction" field.
func (m *PayableMutation) ResetTotalTransaction() {
	m.totalTransaction = nil
	m.addtotalTransaction = nil
}

// SetDaysDue sets the "daysDue" field.
func (m *PayableMutation) SetDaysDue(i int) {
	m.daysDue = &i
	m.adddaysDue = nil
}

// DaysDue returns the value of the "daysDue" field in the mutation.
func (m *PayableMutation) DaysDue() (r int, exists bool) {
	v := m.daysDue
	if v == nil {
		return
	}
	return *v, true
}

// OldDaysDue returns the old "daysDue" field's value of the Payable entity.
// If the Payable object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PayableMutation) OldDaysDue(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDaysDue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDaysDue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDaysDue: %w", err)
	}
	return oldValue.DaysDue, nil
}

// AddDaysDue adds i to the "daysDue" field.
func (m *PayableMutation) AddDaysDue(i int) {
	if m.adddaysDue != nil {
		*m.adddaysDue += i
	} else {
		m.adddaysDue = &i
	}
}

// AddedDaysDue returns the value that was added to the "daysDue" field in this mutation.
func (m *PayableMutation) AddedDaysDue() (r int, exists bool) {
	v := m.adddaysDue
	if v == nil {
		return
	}
	return *v, true
}

// ResetDaysDue resets all changes to the "daysDue" field.
func (m *PayableMutation) ResetDaysDue() {
	m.daysDue = nil
	m.adddaysDue = nil
}

// SetStatus sets the "status" field.
func (m *PayableMutation) SetStatus(pa payable.Status) {
	m.status = &pa
}

// Status returns the value of the "status" field in the mutation.
func (m *PayableMutation) Status() (r payable.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Payable entity.
// If the Payable object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PayableMutation) OldStatus(ctx context.Context) (v payable.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *PayableMutation) ResetStatus() {
	m.status = nil
}

// SetSupplierID sets the "supplier" edge to the Supplier entity by id.
func (m *PayableMutation) SetSupplierID(id int) {
	m.supplier = &id
}

// ClearSupplier clears the "supplier" edge to the Supplier entity.
func (m *PayableMutation) ClearSupplier() {
	m.clearedsupplier = true
}

// SupplierCleared reports if the "supplier" edge to the Supplier entity was cleared.
func (m *PayableMutation) SupplierCleared() bool {
	return m.clearedsupplier
}

// SupplierID returns the "supplier" edge ID in the mutation.
func (m *PayableMutation) SupplierID() (id int, exists bool) {
	if m.supplier != nil {
		return *m.supplier, true
	}
	return
}

// SupplierIDs returns the "supplier" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SupplierID instead. It exists only for internal usage by the builders.
func (m *PayableMutation) SupplierIDs() (ids []int) {
	if id := m.supplier; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSupplier resets all changes to the "supplier" edge.
func (m *PayableMutation) ResetSupplier() {
	m.supplier = nil
	m.clearedsupplier = false
}

// Where appends a list predicates to the PayableMutation builder.
func (m *PayableMutation) Where(ps ...predicate.Payable) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PayableMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PayableMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Payable, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PayableMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PayableMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Payable).
func (m *PayableMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PayableMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.createdAt != nil {
		fields = append(fields, payable.FieldCreatedAt)
	}
	if m.updatedAt != nil {
		fields = append(fields, payable.FieldUpdatedAt)
	}
	if m.deletedAt != nil {
		fields = append(fields, payable.FieldDeletedAt)
	}
	if m.entryGroup != nil {
		fields = append(fields, payable.FieldEntryGroup)
	}
	if m.date != nil {
		fields = append(fields, payable.FieldDate)
	}
	if m.outstandingBalance != nil {
		fields = append(fields, payable.FieldOutstandingBalance)
	}
	if m.totalTransaction != nil {
		fields = append(fields, payable.FieldTotalTransaction)
	}
	if m.daysDue != nil {
		fields = append(fields, payable.FieldDaysDue)
	}
	if m.status != nil {
		fields = append(fields, payable.FieldStatus)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PayableMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case payable.FieldCreatedAt:
		return m.CreatedAt()
	case payable.FieldUpdatedAt:
		return m.UpdatedAt()
	case payable.FieldDeletedAt:
		return m.DeletedAt()
	case payable.FieldEntryGroup:
		return m.EntryGroup()
	case payable.FieldDate:
		return m.Date()
	case payable.FieldOutstandingBalance:
		return m.OutstandingBalance()
	case payable.FieldTotalTransaction:
		return m.TotalTransaction()
	case payable.FieldDaysDue:
		return m.DaysDue()
	case payable.FieldStatus:
		return m.Status()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PayableMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case payable.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case payable.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case payable.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case payable.FieldEntryGroup:
		return m.OldEntryGroup(ctx)
	case payable.FieldDate:
		return m.OldDate(ctx)
	case payable.FieldOutstandingBalance:
		return m.OldOutstandingBalance(ctx)
	case payable.FieldTotalTransaction:
		return m.OldTotalTransaction(ctx)
	case payable.FieldDaysDue:
		return m.OldDaysDue(ctx)
	case payable.FieldStatus:
		return m.OldStatus(ctx)
	}
	return nil, fmt.Errorf("unknown Payable field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PayableMutation) SetField(name string, value ent.Value) error {
	switch name {
	case payable.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case payable.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case payable.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case payable.FieldEntryGroup:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEntryGroup(v)
		return nil
	case payable.FieldDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDate(v)
		return nil
	case payable.FieldOutstandingBalance:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOutstandingBalance(v)
		return nil
	case payable.FieldTotalTransaction:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTotalTransaction(v)
		return nil
	case payable.FieldDaysDue:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDaysDue(v)
		return nil
	case payable.FieldStatus:
		v, ok := value.(payable.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	}
	return fmt.Errorf("unknown Payable field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PayableMutation) AddedFields() []string {
	var fields []string
	if m.addentryGroup != nil {
		fields = append(fields, payable.FieldEntryGroup)
	}
	if m.addoutstandingBalance != nil {
		fields = append(fields, payable.FieldOutstandingBalance)
	}
	if m.addtotalTransaction != nil {
		fields = append(fields, payable.FieldTotalTransaction)
	}
	if m.adddaysDue != nil {
		fields = append(fields, payable.FieldDaysDue)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PayableMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case payable.FieldEntryGroup:
		return m.AddedEntryGroup()
	case payable.FieldOutstandingBalance:
		return m.AddedOutstandingBalance()
	case payable.FieldTotalTransaction:
		return m.AddedTotalTransaction()
	case payable.FieldDaysDue:
		return m.AddedDaysDue()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PayableMutation) AddField(name string, value ent.Value) error {
	switch name {
	case payable.FieldEntryGroup:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddEntryGroup(v)
		return nil
	case payable.FieldOutstandingBalance:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOutstandingBalance(v)
		return nil
	case payable.FieldTotalTransaction:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTotalTransaction(v)
		return nil
	case payable.FieldDaysDue:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDaysDue(v)
		return nil
	}
	return fmt.Errorf("unknown Payable numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PayableMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(payable.FieldDeletedAt) {
		fields = append(fields, payable.FieldDeletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PayableMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PayableMutation) ClearField(name string) error {
	switch name {
	case payable.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown Payable nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PayableMutation) ResetField(name string) error {
	switch name {
	case payable.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case payable.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case payable.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case payable.FieldEntryGroup:
		m.ResetEntryGroup()
		return nil
	case payable.FieldDate:
		m.ResetDate()
		return nil
	case payable.FieldOutstandingBalance:
		m.ResetOutstandingBalance()
		return nil
	case payable.FieldTotalTransaction:
		m.ResetTotalTransaction()
		return nil
	case payable.FieldDaysDue:
		m.ResetDaysDue()
		return nil
	case payable.FieldStatus:
		m.ResetStatus()
		return nil
	}
	return fmt.Errorf("unknown Payable field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PayableMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.supplier != nil {
		edges = append(edges, payable.EdgeSupplier)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PayableMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case payable.EdgeSupplier:
		if id := m.supplier; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PayableMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PayableMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PayableMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedsupplier {
		edges = append(edges, payable.EdgeSupplier)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PayableMutation) EdgeCleared(name string) bool {
	switch name {
	case payable.EdgeSupplier:
		return m.clearedsupplier
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PayableMutation) ClearEdge(name string) error {
	switch name {
	case payable.EdgeSupplier:
		m.ClearSupplier()
		return nil
	}
	return fmt.Errorf("unknown Payable unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PayableMutation) ResetEdge(name string) error {
	switch name {
	case payable.EdgeSupplier:
		m.ResetSupplier()
		return nil
	}
	return fmt.Errorf("unknown Payable edge %s", name)
}

// ProductMutation represents an operation that mutates the Product nodes in the graph.
type ProductMutation struct {
	config
	op                      Op
	typ                     string
	id                      *int
	createdAt               *time.Time
	updatedAt               *time.Time
	deletedAt               *time.Time
	description             *string
	isDefault               *bool
	minimumStock            *int
	addminimumStock         *int
	name                    *string
	price                   *int
	addprice                *int
	sku                     *string
	stock                   *float64
	addstock                *float64
	category                *product.Category
	unitCost                *float64
	addunitCost             *float64
	clearedFields           map[string]struct{}
	company                 *int
	clearedcompany          bool
	pictures                map[int]struct{}
	removedpictures         map[int]struct{}
	clearedpictures         bool
	productMovements        map[int]struct{}
	removedproductMovements map[int]struct{}
	clearedproductMovements bool
	done                    bool
	oldValue                func(context.Context) (*Product, error)
	predicates              []predicate.Product
}

var _ ent.Mutation = (*ProductMutation)(nil)

// productOption allows management of the mutation configuration using functional options.
type productOption func(*ProductMutation)

// newProductMutation creates new mutation for the Product entity.
func newProductMutation(c config, op Op, opts ...productOption) *ProductMutation {
	m := &ProductMutation{
		config:        c,
		op:            op,
		typ:           TypeProduct,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withProductID sets the ID field of the mutation.
func withProductID(id int) productOption {
	return func(m *ProductMutation) {
		var (
			err   error
			once  sync.Once
			value *Product
		)
		m.oldValue = func(ctx context.Context) (*Product, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Product.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withProduct sets the old Product of the mutation.
func withProduct(node *Product) productOption {
	return func(m *ProductMutation) {
		m.oldValue = func(context.Context) (*Product, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ProductMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ProductMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ProductMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ProductMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Product.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "createdAt" field.
func (m *ProductMutation) SetCreatedAt(t time.Time) {
	m.createdAt = &t
}

// CreatedAt returns the value of the "createdAt" field in the mutation.
func (m *ProductMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.createdAt
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "createdAt" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "createdAt" field.
func (m *ProductMutation) ResetCreatedAt() {
	m.createdAt = nil
}

// SetUpdatedAt sets the "updatedAt" field.
func (m *ProductMutation) SetUpdatedAt(t time.Time) {
	m.updatedAt = &t
}

// UpdatedAt returns the value of the "updatedAt" field in the mutation.
func (m *ProductMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updatedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updatedAt" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updatedAt" field.
func (m *ProductMutation) ResetUpdatedAt() {
	m.updatedAt = nil
}

// SetDeletedAt sets the "deletedAt" field.
func (m *ProductMutation) SetDeletedAt(t time.Time) {
	m.deletedAt = &t
}

// DeletedAt returns the value of the "deletedAt" field in the mutation.
func (m *ProductMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deletedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deletedAt" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deletedAt" field.
func (m *ProductMutation) ClearDeletedAt() {
	m.deletedAt = nil
	m.clearedFields[product.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deletedAt" field was cleared in this mutation.
func (m *ProductMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[product.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deletedAt" field.
func (m *ProductMutation) ResetDeletedAt() {
	m.deletedAt = nil
	delete(m.clearedFields, product.FieldDeletedAt)
}

// SetDescription sets the "description" field.
func (m *ProductMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *ProductMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *ProductMutation) ResetDescription() {
	m.description = nil
}

// SetIsDefault sets the "isDefault" field.
func (m *ProductMutation) SetIsDefault(b bool) {
	m.isDefault = &b
}

// IsDefault returns the value of the "isDefault" field in the mutation.
func (m *ProductMutation) IsDefault() (r bool, exists bool) {
	v := m.isDefault
	if v == nil {
		return
	}
	return *v, true
}

// OldIsDefault returns the old "isDefault" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldIsDefault(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsDefault is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsDefault requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsDefault: %w", err)
	}
	return oldValue.IsDefault, nil
}

// ResetIsDefault resets all changes to the "isDefault" field.
func (m *ProductMutation) ResetIsDefault() {
	m.isDefault = nil
}

// SetMinimumStock sets the "minimumStock" field.
func (m *ProductMutation) SetMinimumStock(i int) {
	m.minimumStock = &i
	m.addminimumStock = nil
}

// MinimumStock returns the value of the "minimumStock" field in the mutation.
func (m *ProductMutation) MinimumStock() (r int, exists bool) {
	v := m.minimumStock
	if v == nil {
		return
	}
	return *v, true
}

// OldMinimumStock returns the old "minimumStock" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldMinimumStock(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMinimumStock is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMinimumStock requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMinimumStock: %w", err)
	}
	return oldValue.MinimumStock, nil
}

// AddMinimumStock adds i to the "minimumStock" field.
func (m *ProductMutation) AddMinimumStock(i int) {
	if m.addminimumStock != nil {
		*m.addminimumStock += i
	} else {
		m.addminimumStock = &i
	}
}

// AddedMinimumStock returns the value that was added to the "minimumStock" field in this mutation.
func (m *ProductMutation) AddedMinimumStock() (r int, exists bool) {
	v := m.addminimumStock
	if v == nil {
		return
	}
	return *v, true
}

// ResetMinimumStock resets all changes to the "minimumStock" field.
func (m *ProductMutation) ResetMinimumStock() {
	m.minimumStock = nil
	m.addminimumStock = nil
}

// SetName sets the "name" field.
func (m *ProductMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ProductMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ProductMutation) ResetName() {
	m.name = nil
}

// SetPrice sets the "price" field.
func (m *ProductMutation) SetPrice(i int) {
	m.price = &i
	m.addprice = nil
}

// Price returns the value of the "price" field in the mutation.
func (m *ProductMutation) Price() (r int, exists bool) {
	v := m.price
	if v == nil {
		return
	}
	return *v, true
}

// OldPrice returns the old "price" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldPrice(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPrice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPrice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPrice: %w", err)
	}
	return oldValue.Price, nil
}

// AddPrice adds i to the "price" field.
func (m *ProductMutation) AddPrice(i int) {
	if m.addprice != nil {
		*m.addprice += i
	} else {
		m.addprice = &i
	}
}

// AddedPrice returns the value that was added to the "price" field in this mutation.
func (m *ProductMutation) AddedPrice() (r int, exists bool) {
	v := m.addprice
	if v == nil {
		return
	}
	return *v, true
}

// ResetPrice resets all changes to the "price" field.
func (m *ProductMutation) ResetPrice() {
	m.price = nil
	m.addprice = nil
}

// SetSku sets the "sku" field.
func (m *ProductMutation) SetSku(s string) {
	m.sku = &s
}

// Sku returns the value of the "sku" field in the mutation.
func (m *ProductMutation) Sku() (r string, exists bool) {
	v := m.sku
	if v == nil {
		return
	}
	return *v, true
}

// OldSku returns the old "sku" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldSku(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSku is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSku requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSku: %w", err)
	}
	return oldValue.Sku, nil
}

// ResetSku resets all changes to the "sku" field.
func (m *ProductMutation) ResetSku() {
	m.sku = nil
}

// SetStock sets the "stock" field.
func (m *ProductMutation) SetStock(f float64) {
	m.stock = &f
	m.addstock = nil
}

// Stock returns the value of the "stock" field in the mutation.
func (m *ProductMutation) Stock() (r float64, exists bool) {
	v := m.stock
	if v == nil {
		return
	}
	return *v, true
}

// OldStock returns the old "stock" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldStock(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStock is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStock requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStock: %w", err)
	}
	return oldValue.Stock, nil
}

// AddStock adds f to the "stock" field.
func (m *ProductMutation) AddStock(f float64) {
	if m.addstock != nil {
		*m.addstock += f
	} else {
		m.addstock = &f
	}
}

// AddedStock returns the value that was added to the "stock" field in this mutation.
func (m *ProductMutation) AddedStock() (r float64, exists bool) {
	v := m.addstock
	if v == nil {
		return
	}
	return *v, true
}

// ResetStock resets all changes to the "stock" field.
func (m *ProductMutation) ResetStock() {
	m.stock = nil
	m.addstock = nil
}

// SetCategory sets the "category" field.
func (m *ProductMutation) SetCategory(pr product.Category) {
	m.category = &pr
}

// Category returns the value of the "category" field in the mutation.
func (m *ProductMutation) Category() (r product.Category, exists bool) {
	v := m.category
	if v == nil {
		return
	}
	return *v, true
}

// OldCategory returns the old "category" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldCategory(ctx context.Context) (v product.Category, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCategory is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCategory requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCategory: %w", err)
	}
	return oldValue.Category, nil
}

// ResetCategory resets all changes to the "category" field.
func (m *ProductMutation) ResetCategory() {
	m.category = nil
}

// SetUnitCost sets the "unitCost" field.
func (m *ProductMutation) SetUnitCost(f float64) {
	m.unitCost = &f
	m.addunitCost = nil
}

// UnitCost returns the value of the "unitCost" field in the mutation.
func (m *ProductMutation) UnitCost() (r float64, exists bool) {
	v := m.unitCost
	if v == nil {
		return
	}
	return *v, true
}

// OldUnitCost returns the old "unitCost" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldUnitCost(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUnitCost is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUnitCost requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUnitCost: %w", err)
	}
	return oldValue.UnitCost, nil
}

// AddUnitCost adds f to the "unitCost" field.
func (m *ProductMutation) AddUnitCost(f float64) {
	if m.addunitCost != nil {
		*m.addunitCost += f
	} else {
		m.addunitCost = &f
	}
}

// AddedUnitCost returns the value that was added to the "unitCost" field in this mutation.
func (m *ProductMutation) AddedUnitCost() (r float64, exists bool) {
	v := m.addunitCost
	if v == nil {
		return
	}
	return *v, true
}

// ResetUnitCost resets all changes to the "unitCost" field.
func (m *ProductMutation) ResetUnitCost() {
	m.unitCost = nil
	m.addunitCost = nil
}

// SetCompanyID sets the "company" edge to the Company entity by id.
func (m *ProductMutation) SetCompanyID(id int) {
	m.company = &id
}

// ClearCompany clears the "company" edge to the Company entity.
func (m *ProductMutation) ClearCompany() {
	m.clearedcompany = true
}

// CompanyCleared reports if the "company" edge to the Company entity was cleared.
func (m *ProductMutation) CompanyCleared() bool {
	return m.clearedcompany
}

// CompanyID returns the "company" edge ID in the mutation.
func (m *ProductMutation) CompanyID() (id int, exists bool) {
	if m.company != nil {
		return *m.company, true
	}
	return
}

// CompanyIDs returns the "company" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CompanyID instead. It exists only for internal usage by the builders.
func (m *ProductMutation) CompanyIDs() (ids []int) {
	if id := m.company; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCompany resets all changes to the "company" edge.
func (m *ProductMutation) ResetCompany() {
	m.company = nil
	m.clearedcompany = false
}

// AddPictureIDs adds the "pictures" edge to the File entity by ids.
func (m *ProductMutation) AddPictureIDs(ids ...int) {
	if m.pictures == nil {
		m.pictures = make(map[int]struct{})
	}
	for i := range ids {
		m.pictures[ids[i]] = struct{}{}
	}
}

// ClearPictures clears the "pictures" edge to the File entity.
func (m *ProductMutation) ClearPictures() {
	m.clearedpictures = true
}

// PicturesCleared reports if the "pictures" edge to the File entity was cleared.
func (m *ProductMutation) PicturesCleared() bool {
	return m.clearedpictures
}

// RemovePictureIDs removes the "pictures" edge to the File entity by IDs.
func (m *ProductMutation) RemovePictureIDs(ids ...int) {
	if m.removedpictures == nil {
		m.removedpictures = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.pictures, ids[i])
		m.removedpictures[ids[i]] = struct{}{}
	}
}

// RemovedPictures returns the removed IDs of the "pictures" edge to the File entity.
func (m *ProductMutation) RemovedPicturesIDs() (ids []int) {
	for id := range m.removedpictures {
		ids = append(ids, id)
	}
	return
}

// PicturesIDs returns the "pictures" edge IDs in the mutation.
func (m *ProductMutation) PicturesIDs() (ids []int) {
	for id := range m.pictures {
		ids = append(ids, id)
	}
	return
}

// ResetPictures resets all changes to the "pictures" edge.
func (m *ProductMutation) ResetPictures() {
	m.pictures = nil
	m.clearedpictures = false
	m.removedpictures = nil
}

// AddProductMovementIDs adds the "productMovements" edge to the ProductMovement entity by ids.
func (m *ProductMutation) AddProductMovementIDs(ids ...int) {
	if m.productMovements == nil {
		m.productMovements = make(map[int]struct{})
	}
	for i := range ids {
		m.productMovements[ids[i]] = struct{}{}
	}
}

// ClearProductMovements clears the "productMovements" edge to the ProductMovement entity.
func (m *ProductMutation) ClearProductMovements() {
	m.clearedproductMovements = true
}

// ProductMovementsCleared reports if the "productMovements" edge to the ProductMovement entity was cleared.
func (m *ProductMutation) ProductMovementsCleared() bool {
	return m.clearedproductMovements
}

// RemoveProductMovementIDs removes the "productMovements" edge to the ProductMovement entity by IDs.
func (m *ProductMutation) RemoveProductMovementIDs(ids ...int) {
	if m.removedproductMovements == nil {
		m.removedproductMovements = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.productMovements, ids[i])
		m.removedproductMovements[ids[i]] = struct{}{}
	}
}

// RemovedProductMovements returns the removed IDs of the "productMovements" edge to the ProductMovement entity.
func (m *ProductMutation) RemovedProductMovementsIDs() (ids []int) {
	for id := range m.removedproductMovements {
		ids = append(ids, id)
	}
	return
}

// ProductMovementsIDs returns the "productMovements" edge IDs in the mutation.
func (m *ProductMutation) ProductMovementsIDs() (ids []int) {
	for id := range m.productMovements {
		ids = append(ids, id)
	}
	return
}

// ResetProductMovements resets all changes to the "productMovements" edge.
func (m *ProductMutation) ResetProductMovements() {
	m.productMovements = nil
	m.clearedproductMovements = false
	m.removedproductMovements = nil
}

// Where appends a list predicates to the ProductMutation builder.
func (m *ProductMutation) Where(ps ...predicate.Product) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ProductMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ProductMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Product, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ProductMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ProductMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Product).
func (m *ProductMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ProductMutation) Fields() []string {
	fields := make([]string, 0, 12)
	if m.createdAt != nil {
		fields = append(fields, product.FieldCreatedAt)
	}
	if m.updatedAt != nil {
		fields = append(fields, product.FieldUpdatedAt)
	}
	if m.deletedAt != nil {
		fields = append(fields, product.FieldDeletedAt)
	}
	if m.description != nil {
		fields = append(fields, product.FieldDescription)
	}
	if m.isDefault != nil {
		fields = append(fields, product.FieldIsDefault)
	}
	if m.minimumStock != nil {
		fields = append(fields, product.FieldMinimumStock)
	}
	if m.name != nil {
		fields = append(fields, product.FieldName)
	}
	if m.price != nil {
		fields = append(fields, product.FieldPrice)
	}
	if m.sku != nil {
		fields = append(fields, product.FieldSku)
	}
	if m.stock != nil {
		fields = append(fields, product.FieldStock)
	}
	if m.category != nil {
		fields = append(fields, product.FieldCategory)
	}
	if m.unitCost != nil {
		fields = append(fields, product.FieldUnitCost)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ProductMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case product.FieldCreatedAt:
		return m.CreatedAt()
	case product.FieldUpdatedAt:
		return m.UpdatedAt()
	case product.FieldDeletedAt:
		return m.DeletedAt()
	case product.FieldDescription:
		return m.Description()
	case product.FieldIsDefault:
		return m.IsDefault()
	case product.FieldMinimumStock:
		return m.MinimumStock()
	case product.FieldName:
		return m.Name()
	case product.FieldPrice:
		return m.Price()
	case product.FieldSku:
		return m.Sku()
	case product.FieldStock:
		return m.Stock()
	case product.FieldCategory:
		return m.Category()
	case product.FieldUnitCost:
		return m.UnitCost()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ProductMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case product.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case product.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case product.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case product.FieldDescription:
		return m.OldDescription(ctx)
	case product.FieldIsDefault:
		return m.OldIsDefault(ctx)
	case product.FieldMinimumStock:
		return m.OldMinimumStock(ctx)
	case product.FieldName:
		return m.OldName(ctx)
	case product.FieldPrice:
		return m.OldPrice(ctx)
	case product.FieldSku:
		return m.OldSku(ctx)
	case product.FieldStock:
		return m.OldStock(ctx)
	case product.FieldCategory:
		return m.OldCategory(ctx)
	case product.FieldUnitCost:
		return m.OldUnitCost(ctx)
	}
	return nil, fmt.Errorf("unknown Product field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProductMutation) SetField(name string, value ent.Value) error {
	switch name {
	case product.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case product.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case product.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case product.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case product.FieldIsDefault:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsDefault(v)
		return nil
	case product.FieldMinimumStock:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMinimumStock(v)
		return nil
	case product.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case product.FieldPrice:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrice(v)
		return nil
	case product.FieldSku:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSku(v)
		return nil
	case product.FieldStock:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStock(v)
		return nil
	case product.FieldCategory:
		v, ok := value.(product.Category)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCategory(v)
		return nil
	case product.FieldUnitCost:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUnitCost(v)
		return nil
	}
	return fmt.Errorf("unknown Product field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ProductMutation) AddedFields() []string {
	var fields []string
	if m.addminimumStock != nil {
		fields = append(fields, product.FieldMinimumStock)
	}
	if m.addprice != nil {
		fields = append(fields, product.FieldPrice)
	}
	if m.addstock != nil {
		fields = append(fields, product.FieldStock)
	}
	if m.addunitCost != nil {
		fields = append(fields, product.FieldUnitCost)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ProductMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case product.FieldMinimumStock:
		return m.AddedMinimumStock()
	case product.FieldPrice:
		return m.AddedPrice()
	case product.FieldStock:
		return m.AddedStock()
	case product.FieldUnitCost:
		return m.AddedUnitCost()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProductMutation) AddField(name string, value ent.Value) error {
	switch name {
	case product.FieldMinimumStock:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMinimumStock(v)
		return nil
	case product.FieldPrice:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPrice(v)
		return nil
	case product.FieldStock:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStock(v)
		return nil
	case product.FieldUnitCost:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUnitCost(v)
		return nil
	}
	return fmt.Errorf("unknown Product numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ProductMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(product.FieldDeletedAt) {
		fields = append(fields, product.FieldDeletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ProductMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ProductMutation) ClearField(name string) error {
	switch name {
	case product.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown Product nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ProductMutation) ResetField(name string) error {
	switch name {
	case product.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case product.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case product.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case product.FieldDescription:
		m.ResetDescription()
		return nil
	case product.FieldIsDefault:
		m.ResetIsDefault()
		return nil
	case product.FieldMinimumStock:
		m.ResetMinimumStock()
		return nil
	case product.FieldName:
		m.ResetName()
		return nil
	case product.FieldPrice:
		m.ResetPrice()
		return nil
	case product.FieldSku:
		m.ResetSku()
		return nil
	case product.FieldStock:
		m.ResetStock()
		return nil
	case product.FieldCategory:
		m.ResetCategory()
		return nil
	case product.FieldUnitCost:
		m.ResetUnitCost()
		return nil
	}
	return fmt.Errorf("unknown Product field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ProductMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.company != nil {
		edges = append(edges, product.EdgeCompany)
	}
	if m.pictures != nil {
		edges = append(edges, product.EdgePictures)
	}
	if m.productMovements != nil {
		edges = append(edges, product.EdgeProductMovements)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ProductMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case product.EdgeCompany:
		if id := m.company; id != nil {
			return []ent.Value{*id}
		}
	case product.EdgePictures:
		ids := make([]ent.Value, 0, len(m.pictures))
		for id := range m.pictures {
			ids = append(ids, id)
		}
		return ids
	case product.EdgeProductMovements:
		ids := make([]ent.Value, 0, len(m.productMovements))
		for id := range m.productMovements {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ProductMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedpictures != nil {
		edges = append(edges, product.EdgePictures)
	}
	if m.removedproductMovements != nil {
		edges = append(edges, product.EdgeProductMovements)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ProductMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case product.EdgePictures:
		ids := make([]ent.Value, 0, len(m.removedpictures))
		for id := range m.removedpictures {
			ids = append(ids, id)
		}
		return ids
	case product.EdgeProductMovements:
		ids := make([]ent.Value, 0, len(m.removedproductMovements))
		for id := range m.removedproductMovements {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ProductMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedcompany {
		edges = append(edges, product.EdgeCompany)
	}
	if m.clearedpictures {
		edges = append(edges, product.EdgePictures)
	}
	if m.clearedproductMovements {
		edges = append(edges, product.EdgeProductMovements)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ProductMutation) EdgeCleared(name string) bool {
	switch name {
	case product.EdgeCompany:
		return m.clearedcompany
	case product.EdgePictures:
		return m.clearedpictures
	case product.EdgeProductMovements:
		return m.clearedproductMovements
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ProductMutation) ClearEdge(name string) error {
	switch name {
	case product.EdgeCompany:
		m.ClearCompany()
		return nil
	}
	return fmt.Errorf("unknown Product unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ProductMutation) ResetEdge(name string) error {
	switch name {
	case product.EdgeCompany:
		m.ResetCompany()
		return nil
	case product.EdgePictures:
		m.ResetPictures()
		return nil
	case product.EdgeProductMovements:
		m.ResetProductMovements()
		return nil
	}
	return fmt.Errorf("unknown Product edge %s", name)
}

// ProductMovementMutation represents an operation that mutates the ProductMovement nodes in the graph.
type ProductMovementMutation struct {
	config
	op             Op
	typ            string
	id             *int
	createdAt      *time.Time
	updatedAt      *time.Time
	deletedAt      *time.Time
	entryGroup     *int
	addentryGroup  *int
	averageCost    *float64
	addaverageCost *float64
	unitCost       *float64
	addunitCost    *float64
	price          *float64
	addprice       *float64
	quantity       *int
	addquantity    *int
	clearedFields  map[string]struct{}
	product        *int
	clearedproduct bool
	done           bool
	oldValue       func(context.Context) (*ProductMovement, error)
	predicates     []predicate.ProductMovement
}

var _ ent.Mutation = (*ProductMovementMutation)(nil)

// productmovementOption allows management of the mutation configuration using functional options.
type productmovementOption func(*ProductMovementMutation)

// newProductMovementMutation creates new mutation for the ProductMovement entity.
func newProductMovementMutation(c config, op Op, opts ...productmovementOption) *ProductMovementMutation {
	m := &ProductMovementMutation{
		config:        c,
		op:            op,
		typ:           TypeProductMovement,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withProductMovementID sets the ID field of the mutation.
func withProductMovementID(id int) productmovementOption {
	return func(m *ProductMovementMutation) {
		var (
			err   error
			once  sync.Once
			value *ProductMovement
		)
		m.oldValue = func(ctx context.Context) (*ProductMovement, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ProductMovement.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withProductMovement sets the old ProductMovement of the mutation.
func withProductMovement(node *ProductMovement) productmovementOption {
	return func(m *ProductMovementMutation) {
		m.oldValue = func(context.Context) (*ProductMovement, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ProductMovementMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ProductMovementMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ProductMovementMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ProductMovementMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ProductMovement.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "createdAt" field.
func (m *ProductMovementMutation) SetCreatedAt(t time.Time) {
	m.createdAt = &t
}

// CreatedAt returns the value of the "createdAt" field in the mutation.
func (m *ProductMovementMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.createdAt
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "createdAt" field's value of the ProductMovement entity.
// If the ProductMovement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMovementMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "createdAt" field.
func (m *ProductMovementMutation) ResetCreatedAt() {
	m.createdAt = nil
}

// SetUpdatedAt sets the "updatedAt" field.
func (m *ProductMovementMutation) SetUpdatedAt(t time.Time) {
	m.updatedAt = &t
}

// UpdatedAt returns the value of the "updatedAt" field in the mutation.
func (m *ProductMovementMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updatedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updatedAt" field's value of the ProductMovement entity.
// If the ProductMovement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMovementMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updatedAt" field.
func (m *ProductMovementMutation) ResetUpdatedAt() {
	m.updatedAt = nil
}

// SetDeletedAt sets the "deletedAt" field.
func (m *ProductMovementMutation) SetDeletedAt(t time.Time) {
	m.deletedAt = &t
}

// DeletedAt returns the value of the "deletedAt" field in the mutation.
func (m *ProductMovementMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deletedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deletedAt" field's value of the ProductMovement entity.
// If the ProductMovement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMovementMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deletedAt" field.
func (m *ProductMovementMutation) ClearDeletedAt() {
	m.deletedAt = nil
	m.clearedFields[productmovement.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deletedAt" field was cleared in this mutation.
func (m *ProductMovementMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[productmovement.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deletedAt" field.
func (m *ProductMovementMutation) ResetDeletedAt() {
	m.deletedAt = nil
	delete(m.clearedFields, productmovement.FieldDeletedAt)
}

// SetEntryGroup sets the "entryGroup" field.
func (m *ProductMovementMutation) SetEntryGroup(i int) {
	m.entryGroup = &i
	m.addentryGroup = nil
}

// EntryGroup returns the value of the "entryGroup" field in the mutation.
func (m *ProductMovementMutation) EntryGroup() (r int, exists bool) {
	v := m.entryGroup
	if v == nil {
		return
	}
	return *v, true
}

// OldEntryGroup returns the old "entryGroup" field's value of the ProductMovement entity.
// If the ProductMovement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMovementMutation) OldEntryGroup(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEntryGroup is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEntryGroup requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEntryGroup: %w", err)
	}
	return oldValue.EntryGroup, nil
}

// AddEntryGroup adds i to the "entryGroup" field.
func (m *ProductMovementMutation) AddEntryGroup(i int) {
	if m.addentryGroup != nil {
		*m.addentryGroup += i
	} else {
		m.addentryGroup = &i
	}
}

// AddedEntryGroup returns the value that was added to the "entryGroup" field in this mutation.
func (m *ProductMovementMutation) AddedEntryGroup() (r int, exists bool) {
	v := m.addentryGroup
	if v == nil {
		return
	}
	return *v, true
}

// ResetEntryGroup resets all changes to the "entryGroup" field.
func (m *ProductMovementMutation) ResetEntryGroup() {
	m.entryGroup = nil
	m.addentryGroup = nil
}

// SetAverageCost sets the "averageCost" field.
func (m *ProductMovementMutation) SetAverageCost(f float64) {
	m.averageCost = &f
	m.addaverageCost = nil
}

// AverageCost returns the value of the "averageCost" field in the mutation.
func (m *ProductMovementMutation) AverageCost() (r float64, exists bool) {
	v := m.averageCost
	if v == nil {
		return
	}
	return *v, true
}

// OldAverageCost returns the old "averageCost" field's value of the ProductMovement entity.
// If the ProductMovement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMovementMutation) OldAverageCost(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAverageCost is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAverageCost requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAverageCost: %w", err)
	}
	return oldValue.AverageCost, nil
}

// AddAverageCost adds f to the "averageCost" field.
func (m *ProductMovementMutation) AddAverageCost(f float64) {
	if m.addaverageCost != nil {
		*m.addaverageCost += f
	} else {
		m.addaverageCost = &f
	}
}

// AddedAverageCost returns the value that was added to the "averageCost" field in this mutation.
func (m *ProductMovementMutation) AddedAverageCost() (r float64, exists bool) {
	v := m.addaverageCost
	if v == nil {
		return
	}
	return *v, true
}

// ResetAverageCost resets all changes to the "averageCost" field.
func (m *ProductMovementMutation) ResetAverageCost() {
	m.averageCost = nil
	m.addaverageCost = nil
}

// SetUnitCost sets the "unitCost" field.
func (m *ProductMovementMutation) SetUnitCost(f float64) {
	m.unitCost = &f
	m.addunitCost = nil
}

// UnitCost returns the value of the "unitCost" field in the mutation.
func (m *ProductMovementMutation) UnitCost() (r float64, exists bool) {
	v := m.unitCost
	if v == nil {
		return
	}
	return *v, true
}

// OldUnitCost returns the old "unitCost" field's value of the ProductMovement entity.
// If the ProductMovement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMovementMutation) OldUnitCost(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUnitCost is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUnitCost requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUnitCost: %w", err)
	}
	return oldValue.UnitCost, nil
}

// AddUnitCost adds f to the "unitCost" field.
func (m *ProductMovementMutation) AddUnitCost(f float64) {
	if m.addunitCost != nil {
		*m.addunitCost += f
	} else {
		m.addunitCost = &f
	}
}

// AddedUnitCost returns the value that was added to the "unitCost" field in this mutation.
func (m *ProductMovementMutation) AddedUnitCost() (r float64, exists bool) {
	v := m.addunitCost
	if v == nil {
		return
	}
	return *v, true
}

// ResetUnitCost resets all changes to the "unitCost" field.
func (m *ProductMovementMutation) ResetUnitCost() {
	m.unitCost = nil
	m.addunitCost = nil
}

// SetPrice sets the "price" field.
func (m *ProductMovementMutation) SetPrice(f float64) {
	m.price = &f
	m.addprice = nil
}

// Price returns the value of the "price" field in the mutation.
func (m *ProductMovementMutation) Price() (r float64, exists bool) {
	v := m.price
	if v == nil {
		return
	}
	return *v, true
}

// OldPrice returns the old "price" field's value of the ProductMovement entity.
// If the ProductMovement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMovementMutation) OldPrice(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPrice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPrice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPrice: %w", err)
	}
	return oldValue.Price, nil
}

// AddPrice adds f to the "price" field.
func (m *ProductMovementMutation) AddPrice(f float64) {
	if m.addprice != nil {
		*m.addprice += f
	} else {
		m.addprice = &f
	}
}

// AddedPrice returns the value that was added to the "price" field in this mutation.
func (m *ProductMovementMutation) AddedPrice() (r float64, exists bool) {
	v := m.addprice
	if v == nil {
		return
	}
	return *v, true
}

// ResetPrice resets all changes to the "price" field.
func (m *ProductMovementMutation) ResetPrice() {
	m.price = nil
	m.addprice = nil
}

// SetQuantity sets the "quantity" field.
func (m *ProductMovementMutation) SetQuantity(i int) {
	m.quantity = &i
	m.addquantity = nil
}

// Quantity returns the value of the "quantity" field in the mutation.
func (m *ProductMovementMutation) Quantity() (r int, exists bool) {
	v := m.quantity
	if v == nil {
		return
	}
	return *v, true
}

// OldQuantity returns the old "quantity" field's value of the ProductMovement entity.
// If the ProductMovement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMovementMutation) OldQuantity(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldQuantity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldQuantity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldQuantity: %w", err)
	}
	return oldValue.Quantity, nil
}

// AddQuantity adds i to the "quantity" field.
func (m *ProductMovementMutation) AddQuantity(i int) {
	if m.addquantity != nil {
		*m.addquantity += i
	} else {
		m.addquantity = &i
	}
}

// AddedQuantity returns the value that was added to the "quantity" field in this mutation.
func (m *ProductMovementMutation) AddedQuantity() (r int, exists bool) {
	v := m.addquantity
	if v == nil {
		return
	}
	return *v, true
}

// ResetQuantity resets all changes to the "quantity" field.
func (m *ProductMovementMutation) ResetQuantity() {
	m.quantity = nil
	m.addquantity = nil
}

// SetProductID sets the "product" edge to the Product entity by id.
func (m *ProductMovementMutation) SetProductID(id int) {
	m.product = &id
}

// ClearProduct clears the "product" edge to the Product entity.
func (m *ProductMovementMutation) ClearProduct() {
	m.clearedproduct = true
}

// ProductCleared reports if the "product" edge to the Product entity was cleared.
func (m *ProductMovementMutation) ProductCleared() bool {
	return m.clearedproduct
}

// ProductID returns the "product" edge ID in the mutation.
func (m *ProductMovementMutation) ProductID() (id int, exists bool) {
	if m.product != nil {
		return *m.product, true
	}
	return
}

// ProductIDs returns the "product" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProductID instead. It exists only for internal usage by the builders.
func (m *ProductMovementMutation) ProductIDs() (ids []int) {
	if id := m.product; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProduct resets all changes to the "product" edge.
func (m *ProductMovementMutation) ResetProduct() {
	m.product = nil
	m.clearedproduct = false
}

// Where appends a list predicates to the ProductMovementMutation builder.
func (m *ProductMovementMutation) Where(ps ...predicate.ProductMovement) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ProductMovementMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ProductMovementMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ProductMovement, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ProductMovementMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ProductMovementMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ProductMovement).
func (m *ProductMovementMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ProductMovementMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.createdAt != nil {
		fields = append(fields, productmovement.FieldCreatedAt)
	}
	if m.updatedAt != nil {
		fields = append(fields, productmovement.FieldUpdatedAt)
	}
	if m.deletedAt != nil {
		fields = append(fields, productmovement.FieldDeletedAt)
	}
	if m.entryGroup != nil {
		fields = append(fields, productmovement.FieldEntryGroup)
	}
	if m.averageCost != nil {
		fields = append(fields, productmovement.FieldAverageCost)
	}
	if m.unitCost != nil {
		fields = append(fields, productmovement.FieldUnitCost)
	}
	if m.price != nil {
		fields = append(fields, productmovement.FieldPrice)
	}
	if m.quantity != nil {
		fields = append(fields, productmovement.FieldQuantity)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ProductMovementMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case productmovement.FieldCreatedAt:
		return m.CreatedAt()
	case productmovement.FieldUpdatedAt:
		return m.UpdatedAt()
	case productmovement.FieldDeletedAt:
		return m.DeletedAt()
	case productmovement.FieldEntryGroup:
		return m.EntryGroup()
	case productmovement.FieldAverageCost:
		return m.AverageCost()
	case productmovement.FieldUnitCost:
		return m.UnitCost()
	case productmovement.FieldPrice:
		return m.Price()
	case productmovement.FieldQuantity:
		return m.Quantity()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ProductMovementMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case productmovement.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case productmovement.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case productmovement.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case productmovement.FieldEntryGroup:
		return m.OldEntryGroup(ctx)
	case productmovement.FieldAverageCost:
		return m.OldAverageCost(ctx)
	case productmovement.FieldUnitCost:
		return m.OldUnitCost(ctx)
	case productmovement.FieldPrice:
		return m.OldPrice(ctx)
	case productmovement.FieldQuantity:
		return m.OldQuantity(ctx)
	}
	return nil, fmt.Errorf("unknown ProductMovement field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProductMovementMutation) SetField(name string, value ent.Value) error {
	switch name {
	case productmovement.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case productmovement.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case productmovement.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case productmovement.FieldEntryGroup:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEntryGroup(v)
		return nil
	case productmovement.FieldAverageCost:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAverageCost(v)
		return nil
	case productmovement.FieldUnitCost:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUnitCost(v)
		return nil
	case productmovement.FieldPrice:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrice(v)
		return nil
	case productmovement.FieldQuantity:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetQuantity(v)
		return nil
	}
	return fmt.Errorf("unknown ProductMovement field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ProductMovementMutation) AddedFields() []string {
	var fields []string
	if m.addentryGroup != nil {
		fields = append(fields, productmovement.FieldEntryGroup)
	}
	if m.addaverageCost != nil {
		fields = append(fields, productmovement.FieldAverageCost)
	}
	if m.addunitCost != nil {
		fields = append(fields, productmovement.FieldUnitCost)
	}
	if m.addprice != nil {
		fields = append(fields, productmovement.FieldPrice)
	}
	if m.addquantity != nil {
		fields = append(fields, productmovement.FieldQuantity)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ProductMovementMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case productmovement.FieldEntryGroup:
		return m.AddedEntryGroup()
	case productmovement.FieldAverageCost:
		return m.AddedAverageCost()
	case productmovement.FieldUnitCost:
		return m.AddedUnitCost()
	case productmovement.FieldPrice:
		return m.AddedPrice()
	case productmovement.FieldQuantity:
		return m.AddedQuantity()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProductMovementMutation) AddField(name string, value ent.Value) error {
	switch name {
	case productmovement.FieldEntryGroup:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddEntryGroup(v)
		return nil
	case productmovement.FieldAverageCost:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAverageCost(v)
		return nil
	case productmovement.FieldUnitCost:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUnitCost(v)
		return nil
	case productmovement.FieldPrice:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPrice(v)
		return nil
	case productmovement.FieldQuantity:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddQuantity(v)
		return nil
	}
	return fmt.Errorf("unknown ProductMovement numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ProductMovementMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(productmovement.FieldDeletedAt) {
		fields = append(fields, productmovement.FieldDeletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ProductMovementMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ProductMovementMutation) ClearField(name string) error {
	switch name {
	case productmovement.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown ProductMovement nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ProductMovementMutation) ResetField(name string) error {
	switch name {
	case productmovement.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case productmovement.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case productmovement.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case productmovement.FieldEntryGroup:
		m.ResetEntryGroup()
		return nil
	case productmovement.FieldAverageCost:
		m.ResetAverageCost()
		return nil
	case productmovement.FieldUnitCost:
		m.ResetUnitCost()
		return nil
	case productmovement.FieldPrice:
		m.ResetPrice()
		return nil
	case productmovement.FieldQuantity:
		m.ResetQuantity()
		return nil
	}
	return fmt.Errorf("unknown ProductMovement field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ProductMovementMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.product != nil {
		edges = append(edges, productmovement.EdgeProduct)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ProductMovementMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case productmovement.EdgeProduct:
		if id := m.product; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ProductMovementMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ProductMovementMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ProductMovementMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedproduct {
		edges = append(edges, productmovement.EdgeProduct)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ProductMovementMutation) EdgeCleared(name string) bool {
	switch name {
	case productmovement.EdgeProduct:
		return m.clearedproduct
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ProductMovementMutation) ClearEdge(name string) error {
	switch name {
	case productmovement.EdgeProduct:
		m.ClearProduct()
		return nil
	}
	return fmt.Errorf("unknown ProductMovement unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ProductMovementMutation) ResetEdge(name string) error {
	switch name {
	case productmovement.EdgeProduct:
		m.ResetProduct()
		return nil
	}
	return fmt.Errorf("unknown ProductMovement edge %s", name)
}

// ReceivableMutation represents an operation that mutates the Receivable nodes in the graph.
type ReceivableMutation struct {
	config
	op                    Op
	typ                   string
	id                    *int
	createdAt             *time.Time
	updatedAt             *time.Time
	deletedAt             *time.Time
	entryGroup            *int
	addentryGroup         *int
	date                  *time.Time
	outstandingBalance    *float64
	addoutstandingBalance *float64
	totalTransaction      *float64
	addtotalTransaction   *float64
	daysDue               *int
	adddaysDue            *int
	status                *receivable.Status
	clearedFields         map[string]struct{}
	customer              *int
	clearedcustomer       bool
	done                  bool
	oldValue              func(context.Context) (*Receivable, error)
	predicates            []predicate.Receivable
}

var _ ent.Mutation = (*ReceivableMutation)(nil)

// receivableOption allows management of the mutation configuration using functional options.
type receivableOption func(*ReceivableMutation)

// newReceivableMutation creates new mutation for the Receivable entity.
func newReceivableMutation(c config, op Op, opts ...receivableOption) *ReceivableMutation {
	m := &ReceivableMutation{
		config:        c,
		op:            op,
		typ:           TypeReceivable,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withReceivableID sets the ID field of the mutation.
func withReceivableID(id int) receivableOption {
	return func(m *ReceivableMutation) {
		var (
			err   error
			once  sync.Once
			value *Receivable
		)
		m.oldValue = func(ctx context.Context) (*Receivable, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Receivable.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withReceivable sets the old Receivable of the mutation.
func withReceivable(node *Receivable) receivableOption {
	return func(m *ReceivableMutation) {
		m.oldValue = func(context.Context) (*Receivable, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ReceivableMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ReceivableMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ReceivableMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ReceivableMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Receivable.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "createdAt" field.
func (m *ReceivableMutation) SetCreatedAt(t time.Time) {
	m.createdAt = &t
}

// CreatedAt returns the value of the "createdAt" field in the mutation.
func (m *ReceivableMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.createdAt
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "createdAt" field's value of the Receivable entity.
// If the Receivable object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReceivableMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "createdAt" field.
func (m *ReceivableMutation) ResetCreatedAt() {
	m.createdAt = nil
}

// SetUpdatedAt sets the "updatedAt" field.
func (m *ReceivableMutation) SetUpdatedAt(t time.Time) {
	m.updatedAt = &t
}

// UpdatedAt returns the value of the "updatedAt" field in the mutation.
func (m *ReceivableMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updatedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updatedAt" field's value of the Receivable entity.
// If the Receivable object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReceivableMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updatedAt" field.
func (m *ReceivableMutation) ResetUpdatedAt() {
	m.updatedAt = nil
}

// SetDeletedAt sets the "deletedAt" field.
func (m *ReceivableMutation) SetDeletedAt(t time.Time) {
	m.deletedAt = &t
}

// DeletedAt returns the value of the "deletedAt" field in the mutation.
func (m *ReceivableMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deletedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deletedAt" field's value of the Receivable entity.
// If the Receivable object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReceivableMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deletedAt" field.
func (m *ReceivableMutation) ClearDeletedAt() {
	m.deletedAt = nil
	m.clearedFields[receivable.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deletedAt" field was cleared in this mutation.
func (m *ReceivableMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[receivable.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deletedAt" field.
func (m *ReceivableMutation) ResetDeletedAt() {
	m.deletedAt = nil
	delete(m.clearedFields, receivable.FieldDeletedAt)
}

// SetEntryGroup sets the "entryGroup" field.
func (m *ReceivableMutation) SetEntryGroup(i int) {
	m.entryGroup = &i
	m.addentryGroup = nil
}

// EntryGroup returns the value of the "entryGroup" field in the mutation.
func (m *ReceivableMutation) EntryGroup() (r int, exists bool) {
	v := m.entryGroup
	if v == nil {
		return
	}
	return *v, true
}

// OldEntryGroup returns the old "entryGroup" field's value of the Receivable entity.
// If the Receivable object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReceivableMutation) OldEntryGroup(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEntryGroup is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEntryGroup requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEntryGroup: %w", err)
	}
	return oldValue.EntryGroup, nil
}

// AddEntryGroup adds i to the "entryGroup" field.
func (m *ReceivableMutation) AddEntryGroup(i int) {
	if m.addentryGroup != nil {
		*m.addentryGroup += i
	} else {
		m.addentryGroup = &i
	}
}

// AddedEntryGroup returns the value that was added to the "entryGroup" field in this mutation.
func (m *ReceivableMutation) AddedEntryGroup() (r int, exists bool) {
	v := m.addentryGroup
	if v == nil {
		return
	}
	return *v, true
}

// ResetEntryGroup resets all changes to the "entryGroup" field.
func (m *ReceivableMutation) ResetEntryGroup() {
	m.entryGroup = nil
	m.addentryGroup = nil
}

// SetDate sets the "date" field.
func (m *ReceivableMutation) SetDate(t time.Time) {
	m.date = &t
}

// Date returns the value of the "date" field in the mutation.
func (m *ReceivableMutation) Date() (r time.Time, exists bool) {
	v := m.date
	if v == nil {
		return
	}
	return *v, true
}

// OldDate returns the old "date" field's value of the Receivable entity.
// If the Receivable object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReceivableMutation) OldDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDate: %w", err)
	}
	return oldValue.Date, nil
}

// ResetDate resets all changes to the "date" field.
func (m *ReceivableMutation) ResetDate() {
	m.date = nil
}

// SetOutstandingBalance sets the "outstandingBalance" field.
func (m *ReceivableMutation) SetOutstandingBalance(f float64) {
	m.outstandingBalance = &f
	m.addoutstandingBalance = nil
}

// OutstandingBalance returns the value of the "outstandingBalance" field in the mutation.
func (m *ReceivableMutation) OutstandingBalance() (r float64, exists bool) {
	v := m.outstandingBalance
	if v == nil {
		return
	}
	return *v, true
}

// OldOutstandingBalance returns the old "outstandingBalance" field's value of the Receivable entity.
// If the Receivable object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReceivableMutation) OldOutstandingBalance(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOutstandingBalance is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOutstandingBalance requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOutstandingBalance: %w", err)
	}
	return oldValue.OutstandingBalance, nil
}

// AddOutstandingBalance adds f to the "outstandingBalance" field.
func (m *ReceivableMutation) AddOutstandingBalance(f float64) {
	if m.addoutstandingBalance != nil {
		*m.addoutstandingBalance += f
	} else {
		m.addoutstandingBalance = &f
	}
}

// AddedOutstandingBalance returns the value that was added to the "outstandingBalance" field in this mutation.
func (m *ReceivableMutation) AddedOutstandingBalance() (r float64, exists bool) {
	v := m.addoutstandingBalance
	if v == nil {
		return
	}
	return *v, true
}

// ResetOutstandingBalance resets all changes to the "outstandingBalance" field.
func (m *ReceivableMutation) ResetOutstandingBalance() {
	m.outstandingBalance = nil
	m.addoutstandingBalance = nil
}

// SetTotalTransaction sets the "totalTransaction" field.
func (m *ReceivableMutation) SetTotalTransaction(f float64) {
	m.totalTransaction = &f
	m.addtotalTransaction = nil
}

// TotalTransaction returns the value of the "totalTransaction" field in the mutation.
func (m *ReceivableMutation) TotalTransaction() (r float64, exists bool) {
	v := m.totalTransaction
	if v == nil {
		return
	}
	return *v, true
}

// OldTotalTransaction returns the old "totalTransaction" field's value of the Receivable entity.
// If the Receivable object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReceivableMutation) OldTotalTransaction(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTotalTransaction is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTotalTransaction requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTotalTransaction: %w", err)
	}
	return oldValue.TotalTransaction, nil
}

// AddTotalTransaction adds f to the "totalTransaction" field.
func (m *ReceivableMutation) AddTotalTransaction(f float64) {
	if m.addtotalTransaction != nil {
		*m.addtotalTransaction += f
	} else {
		m.addtotalTransaction = &f
	}
}

// AddedTotalTransaction returns the value that was added to the "totalTransaction" field in this mutation.
func (m *ReceivableMutation) AddedTotalTransaction() (r float64, exists bool) {
	v := m.addtotalTransaction
	if v == nil {
		return
	}
	return *v, true
}

// ResetTotalTransaction resets all changes to the "totalTransaction" field.
func (m *ReceivableMutation) ResetTotalTransaction() {
	m.totalTransaction = nil
	m.addtotalTransaction = nil
}

// SetDaysDue sets the "daysDue" field.
func (m *ReceivableMutation) SetDaysDue(i int) {
	m.daysDue = &i
	m.adddaysDue = nil
}

// DaysDue returns the value of the "daysDue" field in the mutation.
func (m *ReceivableMutation) DaysDue() (r int, exists bool) {
	v := m.daysDue
	if v == nil {
		return
	}
	return *v, true
}

// OldDaysDue returns the old "daysDue" field's value of the Receivable entity.
// If the Receivable object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReceivableMutation) OldDaysDue(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDaysDue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDaysDue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDaysDue: %w", err)
	}
	return oldValue.DaysDue, nil
}

// AddDaysDue adds i to the "daysDue" field.
func (m *ReceivableMutation) AddDaysDue(i int) {
	if m.adddaysDue != nil {
		*m.adddaysDue += i
	} else {
		m.adddaysDue = &i
	}
}

// AddedDaysDue returns the value that was added to the "daysDue" field in this mutation.
func (m *ReceivableMutation) AddedDaysDue() (r int, exists bool) {
	v := m.adddaysDue
	if v == nil {
		return
	}
	return *v, true
}

// ResetDaysDue resets all changes to the "daysDue" field.
func (m *ReceivableMutation) ResetDaysDue() {
	m.daysDue = nil
	m.adddaysDue = nil
}

// SetStatus sets the "status" field.
func (m *ReceivableMutation) SetStatus(r receivable.Status) {
	m.status = &r
}

// Status returns the value of the "status" field in the mutation.
func (m *ReceivableMutation) Status() (r receivable.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Receivable entity.
// If the Receivable object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReceivableMutation) OldStatus(ctx context.Context) (v receivable.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *ReceivableMutation) ResetStatus() {
	m.status = nil
}

// SetCustomerID sets the "customer" edge to the Customer entity by id.
func (m *ReceivableMutation) SetCustomerID(id int) {
	m.customer = &id
}

// ClearCustomer clears the "customer" edge to the Customer entity.
func (m *ReceivableMutation) ClearCustomer() {
	m.clearedcustomer = true
}

// CustomerCleared reports if the "customer" edge to the Customer entity was cleared.
func (m *ReceivableMutation) CustomerCleared() bool {
	return m.clearedcustomer
}

// CustomerID returns the "customer" edge ID in the mutation.
func (m *ReceivableMutation) CustomerID() (id int, exists bool) {
	if m.customer != nil {
		return *m.customer, true
	}
	return
}

// CustomerIDs returns the "customer" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CustomerID instead. It exists only for internal usage by the builders.
func (m *ReceivableMutation) CustomerIDs() (ids []int) {
	if id := m.customer; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCustomer resets all changes to the "customer" edge.
func (m *ReceivableMutation) ResetCustomer() {
	m.customer = nil
	m.clearedcustomer = false
}

// Where appends a list predicates to the ReceivableMutation builder.
func (m *ReceivableMutation) Where(ps ...predicate.Receivable) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ReceivableMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ReceivableMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Receivable, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ReceivableMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ReceivableMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Receivable).
func (m *ReceivableMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ReceivableMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.createdAt != nil {
		fields = append(fields, receivable.FieldCreatedAt)
	}
	if m.updatedAt != nil {
		fields = append(fields, receivable.FieldUpdatedAt)
	}
	if m.deletedAt != nil {
		fields = append(fields, receivable.FieldDeletedAt)
	}
	if m.entryGroup != nil {
		fields = append(fields, receivable.FieldEntryGroup)
	}
	if m.date != nil {
		fields = append(fields, receivable.FieldDate)
	}
	if m.outstandingBalance != nil {
		fields = append(fields, receivable.FieldOutstandingBalance)
	}
	if m.totalTransaction != nil {
		fields = append(fields, receivable.FieldTotalTransaction)
	}
	if m.daysDue != nil {
		fields = append(fields, receivable.FieldDaysDue)
	}
	if m.status != nil {
		fields = append(fields, receivable.FieldStatus)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ReceivableMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case receivable.FieldCreatedAt:
		return m.CreatedAt()
	case receivable.FieldUpdatedAt:
		return m.UpdatedAt()
	case receivable.FieldDeletedAt:
		return m.DeletedAt()
	case receivable.FieldEntryGroup:
		return m.EntryGroup()
	case receivable.FieldDate:
		return m.Date()
	case receivable.FieldOutstandingBalance:
		return m.OutstandingBalance()
	case receivable.FieldTotalTransaction:
		return m.TotalTransaction()
	case receivable.FieldDaysDue:
		return m.DaysDue()
	case receivable.FieldStatus:
		return m.Status()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ReceivableMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case receivable.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case receivable.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case receivable.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case receivable.FieldEntryGroup:
		return m.OldEntryGroup(ctx)
	case receivable.FieldDate:
		return m.OldDate(ctx)
	case receivable.FieldOutstandingBalance:
		return m.OldOutstandingBalance(ctx)
	case receivable.FieldTotalTransaction:
		return m.OldTotalTransaction(ctx)
	case receivable.FieldDaysDue:
		return m.OldDaysDue(ctx)
	case receivable.FieldStatus:
		return m.OldStatus(ctx)
	}
	return nil, fmt.Errorf("unknown Receivable field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ReceivableMutation) SetField(name string, value ent.Value) error {
	switch name {
	case receivable.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case receivable.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case receivable.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case receivable.FieldEntryGroup:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEntryGroup(v)
		return nil
	case receivable.FieldDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDate(v)
		return nil
	case receivable.FieldOutstandingBalance:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOutstandingBalance(v)
		return nil
	case receivable.FieldTotalTransaction:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTotalTransaction(v)
		return nil
	case receivable.FieldDaysDue:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDaysDue(v)
		return nil
	case receivable.FieldStatus:
		v, ok := value.(receivable.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	}
	return fmt.Errorf("unknown Receivable field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ReceivableMutation) AddedFields() []string {
	var fields []string
	if m.addentryGroup != nil {
		fields = append(fields, receivable.FieldEntryGroup)
	}
	if m.addoutstandingBalance != nil {
		fields = append(fields, receivable.FieldOutstandingBalance)
	}
	if m.addtotalTransaction != nil {
		fields = append(fields, receivable.FieldTotalTransaction)
	}
	if m.adddaysDue != nil {
		fields = append(fields, receivable.FieldDaysDue)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ReceivableMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case receivable.FieldEntryGroup:
		return m.AddedEntryGroup()
	case receivable.FieldOutstandingBalance:
		return m.AddedOutstandingBalance()
	case receivable.FieldTotalTransaction:
		return m.AddedTotalTransaction()
	case receivable.FieldDaysDue:
		return m.AddedDaysDue()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ReceivableMutation) AddField(name string, value ent.Value) error {
	switch name {
	case receivable.FieldEntryGroup:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddEntryGroup(v)
		return nil
	case receivable.FieldOutstandingBalance:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOutstandingBalance(v)
		return nil
	case receivable.FieldTotalTransaction:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTotalTransaction(v)
		return nil
	case receivable.FieldDaysDue:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDaysDue(v)
		return nil
	}
	return fmt.Errorf("unknown Receivable numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ReceivableMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(receivable.FieldDeletedAt) {
		fields = append(fields, receivable.FieldDeletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ReceivableMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ReceivableMutation) ClearField(name string) error {
	switch name {
	case receivable.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown Receivable nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ReceivableMutation) ResetField(name string) error {
	switch name {
	case receivable.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case receivable.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case receivable.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case receivable.FieldEntryGroup:
		m.ResetEntryGroup()
		return nil
	case receivable.FieldDate:
		m.ResetDate()
		return nil
	case receivable.FieldOutstandingBalance:
		m.ResetOutstandingBalance()
		return nil
	case receivable.FieldTotalTransaction:
		m.ResetTotalTransaction()
		return nil
	case receivable.FieldDaysDue:
		m.ResetDaysDue()
		return nil
	case receivable.FieldStatus:
		m.ResetStatus()
		return nil
	}
	return fmt.Errorf("unknown Receivable field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ReceivableMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.customer != nil {
		edges = append(edges, receivable.EdgeCustomer)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ReceivableMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case receivable.EdgeCustomer:
		if id := m.customer; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ReceivableMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ReceivableMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ReceivableMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedcustomer {
		edges = append(edges, receivable.EdgeCustomer)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ReceivableMutation) EdgeCleared(name string) bool {
	switch name {
	case receivable.EdgeCustomer:
		return m.clearedcustomer
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ReceivableMutation) ClearEdge(name string) error {
	switch name {
	case receivable.EdgeCustomer:
		m.ClearCustomer()
		return nil
	}
	return fmt.Errorf("unknown Receivable unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ReceivableMutation) ResetEdge(name string) error {
	switch name {
	case receivable.EdgeCustomer:
		m.ResetCustomer()
		return nil
	}
	return fmt.Errorf("unknown Receivable edge %s", name)
}

// SupplierMutation represents an operation that mutates the Supplier nodes in the graph.
type SupplierMutation struct {
	config
	op              Op
	typ             string
	id              *int
	createdAt       *time.Time
	updatedAt       *time.Time
	deletedAt       *time.Time
	address         *string
	city            *string
	country         *string
	description     *string
	email           *string
	isDefault       *bool
	name            *string
	phone           *string
	taxId           *string
	clearedFields   map[string]struct{}
	company         *int
	clearedcompany  bool
	payables        map[int]struct{}
	removedpayables map[int]struct{}
	clearedpayables bool
	done            bool
	oldValue        func(context.Context) (*Supplier, error)
	predicates      []predicate.Supplier
}

var _ ent.Mutation = (*SupplierMutation)(nil)

// supplierOption allows management of the mutation configuration using functional options.
type supplierOption func(*SupplierMutation)

// newSupplierMutation creates new mutation for the Supplier entity.
func newSupplierMutation(c config, op Op, opts ...supplierOption) *SupplierMutation {
	m := &SupplierMutation{
		config:        c,
		op:            op,
		typ:           TypeSupplier,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSupplierID sets the ID field of the mutation.
func withSupplierID(id int) supplierOption {
	return func(m *SupplierMutation) {
		var (
			err   error
			once  sync.Once
			value *Supplier
		)
		m.oldValue = func(ctx context.Context) (*Supplier, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Supplier.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSupplier sets the old Supplier of the mutation.
func withSupplier(node *Supplier) supplierOption {
	return func(m *SupplierMutation) {
		m.oldValue = func(context.Context) (*Supplier, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SupplierMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SupplierMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SupplierMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SupplierMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Supplier.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "createdAt" field.
func (m *SupplierMutation) SetCreatedAt(t time.Time) {
	m.createdAt = &t
}

// CreatedAt returns the value of the "createdAt" field in the mutation.
func (m *SupplierMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.createdAt
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "createdAt" field's value of the Supplier entity.
// If the Supplier object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SupplierMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "createdAt" field.
func (m *SupplierMutation) ResetCreatedAt() {
	m.createdAt = nil
}

// SetUpdatedAt sets the "updatedAt" field.
func (m *SupplierMutation) SetUpdatedAt(t time.Time) {
	m.updatedAt = &t
}

// UpdatedAt returns the value of the "updatedAt" field in the mutation.
func (m *SupplierMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updatedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updatedAt" field's value of the Supplier entity.
// If the Supplier object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SupplierMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updatedAt" field.
func (m *SupplierMutation) ResetUpdatedAt() {
	m.updatedAt = nil
}

// SetDeletedAt sets the "deletedAt" field.
func (m *SupplierMutation) SetDeletedAt(t time.Time) {
	m.deletedAt = &t
}

// DeletedAt returns the value of the "deletedAt" field in the mutation.
func (m *SupplierMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deletedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deletedAt" field's value of the Supplier entity.
// If the Supplier object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SupplierMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deletedAt" field.
func (m *SupplierMutation) ClearDeletedAt() {
	m.deletedAt = nil
	m.clearedFields[supplier.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deletedAt" field was cleared in this mutation.
func (m *SupplierMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[supplier.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deletedAt" field.
func (m *SupplierMutation) ResetDeletedAt() {
	m.deletedAt = nil
	delete(m.clearedFields, supplier.FieldDeletedAt)
}

// SetAddress sets the "address" field.
func (m *SupplierMutation) SetAddress(s string) {
	m.address = &s
}

// Address returns the value of the "address" field in the mutation.
func (m *SupplierMutation) Address() (r string, exists bool) {
	v := m.address
	if v == nil {
		return
	}
	return *v, true
}

// OldAddress returns the old "address" field's value of the Supplier entity.
// If the Supplier object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SupplierMutation) OldAddress(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAddress: %w", err)
	}
	return oldValue.Address, nil
}

// ResetAddress resets all changes to the "address" field.
func (m *SupplierMutation) ResetAddress() {
	m.address = nil
}

// SetCity sets the "city" field.
func (m *SupplierMutation) SetCity(s string) {
	m.city = &s
}

// City returns the value of the "city" field in the mutation.
func (m *SupplierMutation) City() (r string, exists bool) {
	v := m.city
	if v == nil {
		return
	}
	return *v, true
}

// OldCity returns the old "city" field's value of the Supplier entity.
// If the Supplier object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SupplierMutation) OldCity(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCity: %w", err)
	}
	return oldValue.City, nil
}

// ResetCity resets all changes to the "city" field.
func (m *SupplierMutation) ResetCity() {
	m.city = nil
}

// SetCountry sets the "country" field.
func (m *SupplierMutation) SetCountry(s string) {
	m.country = &s
}

// Country returns the value of the "country" field in the mutation.
func (m *SupplierMutation) Country() (r string, exists bool) {
	v := m.country
	if v == nil {
		return
	}
	return *v, true
}

// OldCountry returns the old "country" field's value of the Supplier entity.
// If the Supplier object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SupplierMutation) OldCountry(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCountry is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCountry requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCountry: %w", err)
	}
	return oldValue.Country, nil
}

// ResetCountry resets all changes to the "country" field.
func (m *SupplierMutation) ResetCountry() {
	m.country = nil
}

// SetDescription sets the "description" field.
func (m *SupplierMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *SupplierMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Supplier entity.
// If the Supplier object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SupplierMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *SupplierMutation) ResetDescription() {
	m.description = nil
}

// SetEmail sets the "email" field.
func (m *SupplierMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *SupplierMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the Supplier entity.
// If the Supplier object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SupplierMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ResetEmail resets all changes to the "email" field.
func (m *SupplierMutation) ResetEmail() {
	m.email = nil
}

// SetIsDefault sets the "isDefault" field.
func (m *SupplierMutation) SetIsDefault(b bool) {
	m.isDefault = &b
}

// IsDefault returns the value of the "isDefault" field in the mutation.
func (m *SupplierMutation) IsDefault() (r bool, exists bool) {
	v := m.isDefault
	if v == nil {
		return
	}
	return *v, true
}

// OldIsDefault returns the old "isDefault" field's value of the Supplier entity.
// If the Supplier object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SupplierMutation) OldIsDefault(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsDefault is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsDefault requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsDefault: %w", err)
	}
	return oldValue.IsDefault, nil
}

// ClearIsDefault clears the value of the "isDefault" field.
func (m *SupplierMutation) ClearIsDefault() {
	m.isDefault = nil
	m.clearedFields[supplier.FieldIsDefault] = struct{}{}
}

// IsDefaultCleared returns if the "isDefault" field was cleared in this mutation.
func (m *SupplierMutation) IsDefaultCleared() bool {
	_, ok := m.clearedFields[supplier.FieldIsDefault]
	return ok
}

// ResetIsDefault resets all changes to the "isDefault" field.
func (m *SupplierMutation) ResetIsDefault() {
	m.isDefault = nil
	delete(m.clearedFields, supplier.FieldIsDefault)
}

// SetName sets the "name" field.
func (m *SupplierMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *SupplierMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Supplier entity.
// If the Supplier object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SupplierMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *SupplierMutation) ResetName() {
	m.name = nil
}

// SetPhone sets the "phone" field.
func (m *SupplierMutation) SetPhone(s string) {
	m.phone = &s
}

// Phone returns the value of the "phone" field in the mutation.
func (m *SupplierMutation) Phone() (r string, exists bool) {
	v := m.phone
	if v == nil {
		return
	}
	return *v, true
}

// OldPhone returns the old "phone" field's value of the Supplier entity.
// If the Supplier object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SupplierMutation) OldPhone(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPhone is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPhone requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPhone: %w", err)
	}
	return oldValue.Phone, nil
}

// ResetPhone resets all changes to the "phone" field.
func (m *SupplierMutation) ResetPhone() {
	m.phone = nil
}

// SetTaxId sets the "taxId" field.
func (m *SupplierMutation) SetTaxId(s string) {
	m.taxId = &s
}

// TaxId returns the value of the "taxId" field in the mutation.
func (m *SupplierMutation) TaxId() (r string, exists bool) {
	v := m.taxId
	if v == nil {
		return
	}
	return *v, true
}

// OldTaxId returns the old "taxId" field's value of the Supplier entity.
// If the Supplier object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SupplierMutation) OldTaxId(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTaxId is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTaxId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTaxId: %w", err)
	}
	return oldValue.TaxId, nil
}

// ResetTaxId resets all changes to the "taxId" field.
func (m *SupplierMutation) ResetTaxId() {
	m.taxId = nil
}

// SetCompanyID sets the "company" edge to the Company entity by id.
func (m *SupplierMutation) SetCompanyID(id int) {
	m.company = &id
}

// ClearCompany clears the "company" edge to the Company entity.
func (m *SupplierMutation) ClearCompany() {
	m.clearedcompany = true
}

// CompanyCleared reports if the "company" edge to the Company entity was cleared.
func (m *SupplierMutation) CompanyCleared() bool {
	return m.clearedcompany
}

// CompanyID returns the "company" edge ID in the mutation.
func (m *SupplierMutation) CompanyID() (id int, exists bool) {
	if m.company != nil {
		return *m.company, true
	}
	return
}

// CompanyIDs returns the "company" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CompanyID instead. It exists only for internal usage by the builders.
func (m *SupplierMutation) CompanyIDs() (ids []int) {
	if id := m.company; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCompany resets all changes to the "company" edge.
func (m *SupplierMutation) ResetCompany() {
	m.company = nil
	m.clearedcompany = false
}

// AddPayableIDs adds the "payables" edge to the Payable entity by ids.
func (m *SupplierMutation) AddPayableIDs(ids ...int) {
	if m.payables == nil {
		m.payables = make(map[int]struct{})
	}
	for i := range ids {
		m.payables[ids[i]] = struct{}{}
	}
}

// ClearPayables clears the "payables" edge to the Payable entity.
func (m *SupplierMutation) ClearPayables() {
	m.clearedpayables = true
}

// PayablesCleared reports if the "payables" edge to the Payable entity was cleared.
func (m *SupplierMutation) PayablesCleared() bool {
	return m.clearedpayables
}

// RemovePayableIDs removes the "payables" edge to the Payable entity by IDs.
func (m *SupplierMutation) RemovePayableIDs(ids ...int) {
	if m.removedpayables == nil {
		m.removedpayables = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.payables, ids[i])
		m.removedpayables[ids[i]] = struct{}{}
	}
}

// RemovedPayables returns the removed IDs of the "payables" edge to the Payable entity.
func (m *SupplierMutation) RemovedPayablesIDs() (ids []int) {
	for id := range m.removedpayables {
		ids = append(ids, id)
	}
	return
}

// PayablesIDs returns the "payables" edge IDs in the mutation.
func (m *SupplierMutation) PayablesIDs() (ids []int) {
	for id := range m.payables {
		ids = append(ids, id)
	}
	return
}

// ResetPayables resets all changes to the "payables" edge.
func (m *SupplierMutation) ResetPayables() {
	m.payables = nil
	m.clearedpayables = false
	m.removedpayables = nil
}

// Where appends a list predicates to the SupplierMutation builder.
func (m *SupplierMutation) Where(ps ...predicate.Supplier) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SupplierMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SupplierMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Supplier, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SupplierMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SupplierMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Supplier).
func (m *SupplierMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SupplierMutation) Fields() []string {
	fields := make([]string, 0, 12)
	if m.createdAt != nil {
		fields = append(fields, supplier.FieldCreatedAt)
	}
	if m.updatedAt != nil {
		fields = append(fields, supplier.FieldUpdatedAt)
	}
	if m.deletedAt != nil {
		fields = append(fields, supplier.FieldDeletedAt)
	}
	if m.address != nil {
		fields = append(fields, supplier.FieldAddress)
	}
	if m.city != nil {
		fields = append(fields, supplier.FieldCity)
	}
	if m.country != nil {
		fields = append(fields, supplier.FieldCountry)
	}
	if m.description != nil {
		fields = append(fields, supplier.FieldDescription)
	}
	if m.email != nil {
		fields = append(fields, supplier.FieldEmail)
	}
	if m.isDefault != nil {
		fields = append(fields, supplier.FieldIsDefault)
	}
	if m.name != nil {
		fields = append(fields, supplier.FieldName)
	}
	if m.phone != nil {
		fields = append(fields, supplier.FieldPhone)
	}
	if m.taxId != nil {
		fields = append(fields, supplier.FieldTaxId)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SupplierMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case supplier.FieldCreatedAt:
		return m.CreatedAt()
	case supplier.FieldUpdatedAt:
		return m.UpdatedAt()
	case supplier.FieldDeletedAt:
		return m.DeletedAt()
	case supplier.FieldAddress:
		return m.Address()
	case supplier.FieldCity:
		return m.City()
	case supplier.FieldCountry:
		return m.Country()
	case supplier.FieldDescription:
		return m.Description()
	case supplier.FieldEmail:
		return m.Email()
	case supplier.FieldIsDefault:
		return m.IsDefault()
	case supplier.FieldName:
		return m.Name()
	case supplier.FieldPhone:
		return m.Phone()
	case supplier.FieldTaxId:
		return m.TaxId()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SupplierMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case supplier.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case supplier.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case supplier.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case supplier.FieldAddress:
		return m.OldAddress(ctx)
	case supplier.FieldCity:
		return m.OldCity(ctx)
	case supplier.FieldCountry:
		return m.OldCountry(ctx)
	case supplier.FieldDescription:
		return m.OldDescription(ctx)
	case supplier.FieldEmail:
		return m.OldEmail(ctx)
	case supplier.FieldIsDefault:
		return m.OldIsDefault(ctx)
	case supplier.FieldName:
		return m.OldName(ctx)
	case supplier.FieldPhone:
		return m.OldPhone(ctx)
	case supplier.FieldTaxId:
		return m.OldTaxId(ctx)
	}
	return nil, fmt.Errorf("unknown Supplier field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SupplierMutation) SetField(name string, value ent.Value) error {
	switch name {
	case supplier.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case supplier.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case supplier.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case supplier.FieldAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAddress(v)
		return nil
	case supplier.FieldCity:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCity(v)
		return nil
	case supplier.FieldCountry:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCountry(v)
		return nil
	case supplier.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case supplier.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case supplier.FieldIsDefault:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsDefault(v)
		return nil
	case supplier.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case supplier.FieldPhone:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPhone(v)
		return nil
	case supplier.FieldTaxId:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTaxId(v)
		return nil
	}
	return fmt.Errorf("unknown Supplier field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SupplierMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SupplierMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SupplierMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Supplier numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SupplierMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(supplier.FieldDeletedAt) {
		fields = append(fields, supplier.FieldDeletedAt)
	}
	if m.FieldCleared(supplier.FieldIsDefault) {
		fields = append(fields, supplier.FieldIsDefault)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SupplierMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SupplierMutation) ClearField(name string) error {
	switch name {
	case supplier.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case supplier.FieldIsDefault:
		m.ClearIsDefault()
		return nil
	}
	return fmt.Errorf("unknown Supplier nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SupplierMutation) ResetField(name string) error {
	switch name {
	case supplier.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case supplier.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case supplier.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case supplier.FieldAddress:
		m.ResetAddress()
		return nil
	case supplier.FieldCity:
		m.ResetCity()
		return nil
	case supplier.FieldCountry:
		m.ResetCountry()
		return nil
	case supplier.FieldDescription:
		m.ResetDescription()
		return nil
	case supplier.FieldEmail:
		m.ResetEmail()
		return nil
	case supplier.FieldIsDefault:
		m.ResetIsDefault()
		return nil
	case supplier.FieldName:
		m.ResetName()
		return nil
	case supplier.FieldPhone:
		m.ResetPhone()
		return nil
	case supplier.FieldTaxId:
		m.ResetTaxId()
		return nil
	}
	return fmt.Errorf("unknown Supplier field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SupplierMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.company != nil {
		edges = append(edges, supplier.EdgeCompany)
	}
	if m.payables != nil {
		edges = append(edges, supplier.EdgePayables)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SupplierMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case supplier.EdgeCompany:
		if id := m.company; id != nil {
			return []ent.Value{*id}
		}
	case supplier.EdgePayables:
		ids := make([]ent.Value, 0, len(m.payables))
		for id := range m.payables {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SupplierMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedpayables != nil {
		edges = append(edges, supplier.EdgePayables)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SupplierMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case supplier.EdgePayables:
		ids := make([]ent.Value, 0, len(m.removedpayables))
		for id := range m.removedpayables {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SupplierMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedcompany {
		edges = append(edges, supplier.EdgeCompany)
	}
	if m.clearedpayables {
		edges = append(edges, supplier.EdgePayables)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SupplierMutation) EdgeCleared(name string) bool {
	switch name {
	case supplier.EdgeCompany:
		return m.clearedcompany
	case supplier.EdgePayables:
		return m.clearedpayables
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SupplierMutation) ClearEdge(name string) error {
	switch name {
	case supplier.EdgeCompany:
		m.ClearCompany()
		return nil
	}
	return fmt.Errorf("unknown Supplier unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SupplierMutation) ResetEdge(name string) error {
	switch name {
	case supplier.EdgeCompany:
		m.ResetCompany()
		return nil
	case supplier.EdgePayables:
		m.ResetPayables()
		return nil
	}
	return fmt.Errorf("unknown Supplier edge %s", name)
}

// TokenMutation represents an operation that mutates the Token nodes in the graph.
type TokenMutation struct {
	config
	op             Op
	typ            string
	id             *int
	expiry         *time.Time
	category       *token.Category
	token          *string
	clearedFields  map[string]struct{}
	company        *int
	clearedcompany bool
	user           *int
	cleareduser    bool
	done           bool
	oldValue       func(context.Context) (*Token, error)
	predicates     []predicate.Token
}

var _ ent.Mutation = (*TokenMutation)(nil)

// tokenOption allows management of the mutation configuration using functional options.
type tokenOption func(*TokenMutation)

// newTokenMutation creates new mutation for the Token entity.
func newTokenMutation(c config, op Op, opts ...tokenOption) *TokenMutation {
	m := &TokenMutation{
		config:        c,
		op:            op,
		typ:           TypeToken,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTokenID sets the ID field of the mutation.
func withTokenID(id int) tokenOption {
	return func(m *TokenMutation) {
		var (
			err   error
			once  sync.Once
			value *Token
		)
		m.oldValue = func(ctx context.Context) (*Token, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Token.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withToken sets the old Token of the mutation.
func withToken(node *Token) tokenOption {
	return func(m *TokenMutation) {
		m.oldValue = func(context.Context) (*Token, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TokenMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TokenMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TokenMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TokenMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Token.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetExpiry sets the "expiry" field.
func (m *TokenMutation) SetExpiry(t time.Time) {
	m.expiry = &t
}

// Expiry returns the value of the "expiry" field in the mutation.
func (m *TokenMutation) Expiry() (r time.Time, exists bool) {
	v := m.expiry
	if v == nil {
		return
	}
	return *v, true
}

// OldExpiry returns the old "expiry" field's value of the Token entity.
// If the Token object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TokenMutation) OldExpiry(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExpiry is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExpiry requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpiry: %w", err)
	}
	return oldValue.Expiry, nil
}

// ResetExpiry resets all changes to the "expiry" field.
func (m *TokenMutation) ResetExpiry() {
	m.expiry = nil
}

// SetCategory sets the "category" field.
func (m *TokenMutation) SetCategory(t token.Category) {
	m.category = &t
}

// Category returns the value of the "category" field in the mutation.
func (m *TokenMutation) Category() (r token.Category, exists bool) {
	v := m.category
	if v == nil {
		return
	}
	return *v, true
}

// OldCategory returns the old "category" field's value of the Token entity.
// If the Token object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TokenMutation) OldCategory(ctx context.Context) (v token.Category, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCategory is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCategory requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCategory: %w", err)
	}
	return oldValue.Category, nil
}

// ResetCategory resets all changes to the "category" field.
func (m *TokenMutation) ResetCategory() {
	m.category = nil
}

// SetToken sets the "token" field.
func (m *TokenMutation) SetToken(s string) {
	m.token = &s
}

// Token returns the value of the "token" field in the mutation.
func (m *TokenMutation) Token() (r string, exists bool) {
	v := m.token
	if v == nil {
		return
	}
	return *v, true
}

// OldToken returns the old "token" field's value of the Token entity.
// If the Token object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TokenMutation) OldToken(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldToken is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldToken requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldToken: %w", err)
	}
	return oldValue.Token, nil
}

// ResetToken resets all changes to the "token" field.
func (m *TokenMutation) ResetToken() {
	m.token = nil
}

// SetCompanyID sets the "company" edge to the Company entity by id.
func (m *TokenMutation) SetCompanyID(id int) {
	m.company = &id
}

// ClearCompany clears the "company" edge to the Company entity.
func (m *TokenMutation) ClearCompany() {
	m.clearedcompany = true
}

// CompanyCleared reports if the "company" edge to the Company entity was cleared.
func (m *TokenMutation) CompanyCleared() bool {
	return m.clearedcompany
}

// CompanyID returns the "company" edge ID in the mutation.
func (m *TokenMutation) CompanyID() (id int, exists bool) {
	if m.company != nil {
		return *m.company, true
	}
	return
}

// CompanyIDs returns the "company" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CompanyID instead. It exists only for internal usage by the builders.
func (m *TokenMutation) CompanyIDs() (ids []int) {
	if id := m.company; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCompany resets all changes to the "company" edge.
func (m *TokenMutation) ResetCompany() {
	m.company = nil
	m.clearedcompany = false
}

// SetUserID sets the "user" edge to the User entity by id.
func (m *TokenMutation) SetUserID(id int) {
	m.user = &id
}

// ClearUser clears the "user" edge to the User entity.
func (m *TokenMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *TokenMutation) UserCleared() bool {
	return m.cleareduser
}

// UserID returns the "user" edge ID in the mutation.
func (m *TokenMutation) UserID() (id int, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *TokenMutation) UserIDs() (ids []int) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *TokenMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the TokenMutation builder.
func (m *TokenMutation) Where(ps ...predicate.Token) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TokenMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TokenMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Token, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TokenMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TokenMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Token).
func (m *TokenMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TokenMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.expiry != nil {
		fields = append(fields, token.FieldExpiry)
	}
	if m.category != nil {
		fields = append(fields, token.FieldCategory)
	}
	if m.token != nil {
		fields = append(fields, token.FieldToken)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TokenMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case token.FieldExpiry:
		return m.Expiry()
	case token.FieldCategory:
		return m.Category()
	case token.FieldToken:
		return m.Token()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TokenMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case token.FieldExpiry:
		return m.OldExpiry(ctx)
	case token.FieldCategory:
		return m.OldCategory(ctx)
	case token.FieldToken:
		return m.OldToken(ctx)
	}
	return nil, fmt.Errorf("unknown Token field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TokenMutation) SetField(name string, value ent.Value) error {
	switch name {
	case token.FieldExpiry:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpiry(v)
		return nil
	case token.FieldCategory:
		v, ok := value.(token.Category)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCategory(v)
		return nil
	case token.FieldToken:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetToken(v)
		return nil
	}
	return fmt.Errorf("unknown Token field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TokenMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TokenMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TokenMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Token numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TokenMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TokenMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TokenMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Token nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TokenMutation) ResetField(name string) error {
	switch name {
	case token.FieldExpiry:
		m.ResetExpiry()
		return nil
	case token.FieldCategory:
		m.ResetCategory()
		return nil
	case token.FieldToken:
		m.ResetToken()
		return nil
	}
	return fmt.Errorf("unknown Token field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TokenMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.company != nil {
		edges = append(edges, token.EdgeCompany)
	}
	if m.user != nil {
		edges = append(edges, token.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TokenMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case token.EdgeCompany:
		if id := m.company; id != nil {
			return []ent.Value{*id}
		}
	case token.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TokenMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TokenMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TokenMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedcompany {
		edges = append(edges, token.EdgeCompany)
	}
	if m.cleareduser {
		edges = append(edges, token.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TokenMutation) EdgeCleared(name string) bool {
	switch name {
	case token.EdgeCompany:
		return m.clearedcompany
	case token.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TokenMutation) ClearEdge(name string) error {
	switch name {
	case token.EdgeCompany:
		m.ClearCompany()
		return nil
	case token.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown Token unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TokenMutation) ResetEdge(name string) error {
	switch name {
	case token.EdgeCompany:
		m.ResetCompany()
		return nil
	case token.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown Token edge %s", name)
}

// TreasuryMutation represents an operation that mutates the Treasury nodes in the graph.
type TreasuryMutation struct {
	config
	op                   Op
	typ                  string
	id                   *int
	createdAt            *time.Time
	updatedAt            *time.Time
	deletedAt            *time.Time
	accountNumber        *string
	balance              *float64
	addbalance           *float64
	bankName             *string
	currency             *treasury.Currency
	description          *string
	iban                 *string
	isDefault            *bool
	isMainAccount        *bool
	name                 *string
	category             *treasury.Category
	swiftCode            *string
	clearedFields        map[string]struct{}
	company              *int
	clearedcompany       bool
	cashMovements        map[int]struct{}
	removedcashMovements map[int]struct{}
	clearedcashMovements bool
	done                 bool
	oldValue             func(context.Context) (*Treasury, error)
	predicates           []predicate.Treasury
}

var _ ent.Mutation = (*TreasuryMutation)(nil)

// treasuryOption allows management of the mutation configuration using functional options.
type treasuryOption func(*TreasuryMutation)

// newTreasuryMutation creates new mutation for the Treasury entity.
func newTreasuryMutation(c config, op Op, opts ...treasuryOption) *TreasuryMutation {
	m := &TreasuryMutation{
		config:        c,
		op:            op,
		typ:           TypeTreasury,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTreasuryID sets the ID field of the mutation.
func withTreasuryID(id int) treasuryOption {
	return func(m *TreasuryMutation) {
		var (
			err   error
			once  sync.Once
			value *Treasury
		)
		m.oldValue = func(ctx context.Context) (*Treasury, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Treasury.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTreasury sets the old Treasury of the mutation.
func withTreasury(node *Treasury) treasuryOption {
	return func(m *TreasuryMutation) {
		m.oldValue = func(context.Context) (*Treasury, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TreasuryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TreasuryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TreasuryMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TreasuryMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Treasury.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "createdAt" field.
func (m *TreasuryMutation) SetCreatedAt(t time.Time) {
	m.createdAt = &t
}

// CreatedAt returns the value of the "createdAt" field in the mutation.
func (m *TreasuryMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.createdAt
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "createdAt" field's value of the Treasury entity.
// If the Treasury object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TreasuryMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "createdAt" field.
func (m *TreasuryMutation) ResetCreatedAt() {
	m.createdAt = nil
}

// SetUpdatedAt sets the "updatedAt" field.
func (m *TreasuryMutation) SetUpdatedAt(t time.Time) {
	m.updatedAt = &t
}

// UpdatedAt returns the value of the "updatedAt" field in the mutation.
func (m *TreasuryMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updatedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updatedAt" field's value of the Treasury entity.
// If the Treasury object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TreasuryMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updatedAt" field.
func (m *TreasuryMutation) ResetUpdatedAt() {
	m.updatedAt = nil
}

// SetDeletedAt sets the "deletedAt" field.
func (m *TreasuryMutation) SetDeletedAt(t time.Time) {
	m.deletedAt = &t
}

// DeletedAt returns the value of the "deletedAt" field in the mutation.
func (m *TreasuryMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deletedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deletedAt" field's value of the Treasury entity.
// If the Treasury object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TreasuryMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deletedAt" field.
func (m *TreasuryMutation) ClearDeletedAt() {
	m.deletedAt = nil
	m.clearedFields[treasury.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deletedAt" field was cleared in this mutation.
func (m *TreasuryMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[treasury.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deletedAt" field.
func (m *TreasuryMutation) ResetDeletedAt() {
	m.deletedAt = nil
	delete(m.clearedFields, treasury.FieldDeletedAt)
}

// SetAccountNumber sets the "accountNumber" field.
func (m *TreasuryMutation) SetAccountNumber(s string) {
	m.accountNumber = &s
}

// AccountNumber returns the value of the "accountNumber" field in the mutation.
func (m *TreasuryMutation) AccountNumber() (r string, exists bool) {
	v := m.accountNumber
	if v == nil {
		return
	}
	return *v, true
}

// OldAccountNumber returns the old "accountNumber" field's value of the Treasury entity.
// If the Treasury object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TreasuryMutation) OldAccountNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAccountNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAccountNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAccountNumber: %w", err)
	}
	return oldValue.AccountNumber, nil
}

// ClearAccountNumber clears the value of the "accountNumber" field.
func (m *TreasuryMutation) ClearAccountNumber() {
	m.accountNumber = nil
	m.clearedFields[treasury.FieldAccountNumber] = struct{}{}
}

// AccountNumberCleared returns if the "accountNumber" field was cleared in this mutation.
func (m *TreasuryMutation) AccountNumberCleared() bool {
	_, ok := m.clearedFields[treasury.FieldAccountNumber]
	return ok
}

// ResetAccountNumber resets all changes to the "accountNumber" field.
func (m *TreasuryMutation) ResetAccountNumber() {
	m.accountNumber = nil
	delete(m.clearedFields, treasury.FieldAccountNumber)
}

// SetBalance sets the "balance" field.
func (m *TreasuryMutation) SetBalance(f float64) {
	m.balance = &f
	m.addbalance = nil
}

// Balance returns the value of the "balance" field in the mutation.
func (m *TreasuryMutation) Balance() (r float64, exists bool) {
	v := m.balance
	if v == nil {
		return
	}
	return *v, true
}

// OldBalance returns the old "balance" field's value of the Treasury entity.
// If the Treasury object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TreasuryMutation) OldBalance(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBalance is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBalance requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBalance: %w", err)
	}
	return oldValue.Balance, nil
}

// AddBalance adds f to the "balance" field.
func (m *TreasuryMutation) AddBalance(f float64) {
	if m.addbalance != nil {
		*m.addbalance += f
	} else {
		m.addbalance = &f
	}
}

// AddedBalance returns the value that was added to the "balance" field in this mutation.
func (m *TreasuryMutation) AddedBalance() (r float64, exists bool) {
	v := m.addbalance
	if v == nil {
		return
	}
	return *v, true
}

// ResetBalance resets all changes to the "balance" field.
func (m *TreasuryMutation) ResetBalance() {
	m.balance = nil
	m.addbalance = nil
}

// SetBankName sets the "bankName" field.
func (m *TreasuryMutation) SetBankName(s string) {
	m.bankName = &s
}

// BankName returns the value of the "bankName" field in the mutation.
func (m *TreasuryMutation) BankName() (r string, exists bool) {
	v := m.bankName
	if v == nil {
		return
	}
	return *v, true
}

// OldBankName returns the old "bankName" field's value of the Treasury entity.
// If the Treasury object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TreasuryMutation) OldBankName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBankName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBankName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBankName: %w", err)
	}
	return oldValue.BankName, nil
}

// ClearBankName clears the value of the "bankName" field.
func (m *TreasuryMutation) ClearBankName() {
	m.bankName = nil
	m.clearedFields[treasury.FieldBankName] = struct{}{}
}

// BankNameCleared returns if the "bankName" field was cleared in this mutation.
func (m *TreasuryMutation) BankNameCleared() bool {
	_, ok := m.clearedFields[treasury.FieldBankName]
	return ok
}

// ResetBankName resets all changes to the "bankName" field.
func (m *TreasuryMutation) ResetBankName() {
	m.bankName = nil
	delete(m.clearedFields, treasury.FieldBankName)
}

// SetCurrency sets the "currency" field.
func (m *TreasuryMutation) SetCurrency(t treasury.Currency) {
	m.currency = &t
}

// Currency returns the value of the "currency" field in the mutation.
func (m *TreasuryMutation) Currency() (r treasury.Currency, exists bool) {
	v := m.currency
	if v == nil {
		return
	}
	return *v, true
}

// OldCurrency returns the old "currency" field's value of the Treasury entity.
// If the Treasury object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TreasuryMutation) OldCurrency(ctx context.Context) (v treasury.Currency, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCurrency is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCurrency requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCurrency: %w", err)
	}
	return oldValue.Currency, nil
}

// ResetCurrency resets all changes to the "currency" field.
func (m *TreasuryMutation) ResetCurrency() {
	m.currency = nil
}

// SetDescription sets the "description" field.
func (m *TreasuryMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *TreasuryMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Treasury entity.
// If the Treasury object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TreasuryMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *TreasuryMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[treasury.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *TreasuryMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[treasury.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *TreasuryMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, treasury.FieldDescription)
}

// SetIban sets the "iban" field.
func (m *TreasuryMutation) SetIban(s string) {
	m.iban = &s
}

// Iban returns the value of the "iban" field in the mutation.
func (m *TreasuryMutation) Iban() (r string, exists bool) {
	v := m.iban
	if v == nil {
		return
	}
	return *v, true
}

// OldIban returns the old "iban" field's value of the Treasury entity.
// If the Treasury object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TreasuryMutation) OldIban(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIban is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIban requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIban: %w", err)
	}
	return oldValue.Iban, nil
}

// ClearIban clears the value of the "iban" field.
func (m *TreasuryMutation) ClearIban() {
	m.iban = nil
	m.clearedFields[treasury.FieldIban] = struct{}{}
}

// IbanCleared returns if the "iban" field was cleared in this mutation.
func (m *TreasuryMutation) IbanCleared() bool {
	_, ok := m.clearedFields[treasury.FieldIban]
	return ok
}

// ResetIban resets all changes to the "iban" field.
func (m *TreasuryMutation) ResetIban() {
	m.iban = nil
	delete(m.clearedFields, treasury.FieldIban)
}

// SetIsDefault sets the "isDefault" field.
func (m *TreasuryMutation) SetIsDefault(b bool) {
	m.isDefault = &b
}

// IsDefault returns the value of the "isDefault" field in the mutation.
func (m *TreasuryMutation) IsDefault() (r bool, exists bool) {
	v := m.isDefault
	if v == nil {
		return
	}
	return *v, true
}

// OldIsDefault returns the old "isDefault" field's value of the Treasury entity.
// If the Treasury object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TreasuryMutation) OldIsDefault(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsDefault is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsDefault requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsDefault: %w", err)
	}
	return oldValue.IsDefault, nil
}

// ClearIsDefault clears the value of the "isDefault" field.
func (m *TreasuryMutation) ClearIsDefault() {
	m.isDefault = nil
	m.clearedFields[treasury.FieldIsDefault] = struct{}{}
}

// IsDefaultCleared returns if the "isDefault" field was cleared in this mutation.
func (m *TreasuryMutation) IsDefaultCleared() bool {
	_, ok := m.clearedFields[treasury.FieldIsDefault]
	return ok
}

// ResetIsDefault resets all changes to the "isDefault" field.
func (m *TreasuryMutation) ResetIsDefault() {
	m.isDefault = nil
	delete(m.clearedFields, treasury.FieldIsDefault)
}

// SetIsMainAccount sets the "isMainAccount" field.
func (m *TreasuryMutation) SetIsMainAccount(b bool) {
	m.isMainAccount = &b
}

// IsMainAccount returns the value of the "isMainAccount" field in the mutation.
func (m *TreasuryMutation) IsMainAccount() (r bool, exists bool) {
	v := m.isMainAccount
	if v == nil {
		return
	}
	return *v, true
}

// OldIsMainAccount returns the old "isMainAccount" field's value of the Treasury entity.
// If the Treasury object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TreasuryMutation) OldIsMainAccount(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsMainAccount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsMainAccount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsMainAccount: %w", err)
	}
	return oldValue.IsMainAccount, nil
}

// ClearIsMainAccount clears the value of the "isMainAccount" field.
func (m *TreasuryMutation) ClearIsMainAccount() {
	m.isMainAccount = nil
	m.clearedFields[treasury.FieldIsMainAccount] = struct{}{}
}

// IsMainAccountCleared returns if the "isMainAccount" field was cleared in this mutation.
func (m *TreasuryMutation) IsMainAccountCleared() bool {
	_, ok := m.clearedFields[treasury.FieldIsMainAccount]
	return ok
}

// ResetIsMainAccount resets all changes to the "isMainAccount" field.
func (m *TreasuryMutation) ResetIsMainAccount() {
	m.isMainAccount = nil
	delete(m.clearedFields, treasury.FieldIsMainAccount)
}

// SetName sets the "name" field.
func (m *TreasuryMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *TreasuryMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Treasury entity.
// If the Treasury object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TreasuryMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *TreasuryMutation) ResetName() {
	m.name = nil
}

// SetCategory sets the "category" field.
func (m *TreasuryMutation) SetCategory(t treasury.Category) {
	m.category = &t
}

// Category returns the value of the "category" field in the mutation.
func (m *TreasuryMutation) Category() (r treasury.Category, exists bool) {
	v := m.category
	if v == nil {
		return
	}
	return *v, true
}

// OldCategory returns the old "category" field's value of the Treasury entity.
// If the Treasury object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TreasuryMutation) OldCategory(ctx context.Context) (v treasury.Category, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCategory is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCategory requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCategory: %w", err)
	}
	return oldValue.Category, nil
}

// ResetCategory resets all changes to the "category" field.
func (m *TreasuryMutation) ResetCategory() {
	m.category = nil
}

// SetSwiftCode sets the "swiftCode" field.
func (m *TreasuryMutation) SetSwiftCode(s string) {
	m.swiftCode = &s
}

// SwiftCode returns the value of the "swiftCode" field in the mutation.
func (m *TreasuryMutation) SwiftCode() (r string, exists bool) {
	v := m.swiftCode
	if v == nil {
		return
	}
	return *v, true
}

// OldSwiftCode returns the old "swiftCode" field's value of the Treasury entity.
// If the Treasury object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TreasuryMutation) OldSwiftCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSwiftCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSwiftCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSwiftCode: %w", err)
	}
	return oldValue.SwiftCode, nil
}

// ClearSwiftCode clears the value of the "swiftCode" field.
func (m *TreasuryMutation) ClearSwiftCode() {
	m.swiftCode = nil
	m.clearedFields[treasury.FieldSwiftCode] = struct{}{}
}

// SwiftCodeCleared returns if the "swiftCode" field was cleared in this mutation.
func (m *TreasuryMutation) SwiftCodeCleared() bool {
	_, ok := m.clearedFields[treasury.FieldSwiftCode]
	return ok
}

// ResetSwiftCode resets all changes to the "swiftCode" field.
func (m *TreasuryMutation) ResetSwiftCode() {
	m.swiftCode = nil
	delete(m.clearedFields, treasury.FieldSwiftCode)
}

// SetCompanyID sets the "company" edge to the Company entity by id.
func (m *TreasuryMutation) SetCompanyID(id int) {
	m.company = &id
}

// ClearCompany clears the "company" edge to the Company entity.
func (m *TreasuryMutation) ClearCompany() {
	m.clearedcompany = true
}

// CompanyCleared reports if the "company" edge to the Company entity was cleared.
func (m *TreasuryMutation) CompanyCleared() bool {
	return m.clearedcompany
}

// CompanyID returns the "company" edge ID in the mutation.
func (m *TreasuryMutation) CompanyID() (id int, exists bool) {
	if m.company != nil {
		return *m.company, true
	}
	return
}

// CompanyIDs returns the "company" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CompanyID instead. It exists only for internal usage by the builders.
func (m *TreasuryMutation) CompanyIDs() (ids []int) {
	if id := m.company; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCompany resets all changes to the "company" edge.
func (m *TreasuryMutation) ResetCompany() {
	m.company = nil
	m.clearedcompany = false
}

// AddCashMovementIDs adds the "cashMovements" edge to the CashMovement entity by ids.
func (m *TreasuryMutation) AddCashMovementIDs(ids ...int) {
	if m.cashMovements == nil {
		m.cashMovements = make(map[int]struct{})
	}
	for i := range ids {
		m.cashMovements[ids[i]] = struct{}{}
	}
}

// ClearCashMovements clears the "cashMovements" edge to the CashMovement entity.
func (m *TreasuryMutation) ClearCashMovements() {
	m.clearedcashMovements = true
}

// CashMovementsCleared reports if the "cashMovements" edge to the CashMovement entity was cleared.
func (m *TreasuryMutation) CashMovementsCleared() bool {
	return m.clearedcashMovements
}

// RemoveCashMovementIDs removes the "cashMovements" edge to the CashMovement entity by IDs.
func (m *TreasuryMutation) RemoveCashMovementIDs(ids ...int) {
	if m.removedcashMovements == nil {
		m.removedcashMovements = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.cashMovements, ids[i])
		m.removedcashMovements[ids[i]] = struct{}{}
	}
}

// RemovedCashMovements returns the removed IDs of the "cashMovements" edge to the CashMovement entity.
func (m *TreasuryMutation) RemovedCashMovementsIDs() (ids []int) {
	for id := range m.removedcashMovements {
		ids = append(ids, id)
	}
	return
}

// CashMovementsIDs returns the "cashMovements" edge IDs in the mutation.
func (m *TreasuryMutation) CashMovementsIDs() (ids []int) {
	for id := range m.cashMovements {
		ids = append(ids, id)
	}
	return
}

// ResetCashMovements resets all changes to the "cashMovements" edge.
func (m *TreasuryMutation) ResetCashMovements() {
	m.cashMovements = nil
	m.clearedcashMovements = false
	m.removedcashMovements = nil
}

// Where appends a list predicates to the TreasuryMutation builder.
func (m *TreasuryMutation) Where(ps ...predicate.Treasury) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TreasuryMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TreasuryMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Treasury, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TreasuryMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TreasuryMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Treasury).
func (m *TreasuryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TreasuryMutation) Fields() []string {
	fields := make([]string, 0, 14)
	if m.createdAt != nil {
		fields = append(fields, treasury.FieldCreatedAt)
	}
	if m.updatedAt != nil {
		fields = append(fields, treasury.FieldUpdatedAt)
	}
	if m.deletedAt != nil {
		fields = append(fields, treasury.FieldDeletedAt)
	}
	if m.accountNumber != nil {
		fields = append(fields, treasury.FieldAccountNumber)
	}
	if m.balance != nil {
		fields = append(fields, treasury.FieldBalance)
	}
	if m.bankName != nil {
		fields = append(fields, treasury.FieldBankName)
	}
	if m.currency != nil {
		fields = append(fields, treasury.FieldCurrency)
	}
	if m.description != nil {
		fields = append(fields, treasury.FieldDescription)
	}
	if m.iban != nil {
		fields = append(fields, treasury.FieldIban)
	}
	if m.isDefault != nil {
		fields = append(fields, treasury.FieldIsDefault)
	}
	if m.isMainAccount != nil {
		fields = append(fields, treasury.FieldIsMainAccount)
	}
	if m.name != nil {
		fields = append(fields, treasury.FieldName)
	}
	if m.category != nil {
		fields = append(fields, treasury.FieldCategory)
	}
	if m.swiftCode != nil {
		fields = append(fields, treasury.FieldSwiftCode)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TreasuryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case treasury.FieldCreatedAt:
		return m.CreatedAt()
	case treasury.FieldUpdatedAt:
		return m.UpdatedAt()
	case treasury.FieldDeletedAt:
		return m.DeletedAt()
	case treasury.FieldAccountNumber:
		return m.AccountNumber()
	case treasury.FieldBalance:
		return m.Balance()
	case treasury.FieldBankName:
		return m.BankName()
	case treasury.FieldCurrency:
		return m.Currency()
	case treasury.FieldDescription:
		return m.Description()
	case treasury.FieldIban:
		return m.Iban()
	case treasury.FieldIsDefault:
		return m.IsDefault()
	case treasury.FieldIsMainAccount:
		return m.IsMainAccount()
	case treasury.FieldName:
		return m.Name()
	case treasury.FieldCategory:
		return m.Category()
	case treasury.FieldSwiftCode:
		return m.SwiftCode()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TreasuryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case treasury.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case treasury.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case treasury.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case treasury.FieldAccountNumber:
		return m.OldAccountNumber(ctx)
	case treasury.FieldBalance:
		return m.OldBalance(ctx)
	case treasury.FieldBankName:
		return m.OldBankName(ctx)
	case treasury.FieldCurrency:
		return m.OldCurrency(ctx)
	case treasury.FieldDescription:
		return m.OldDescription(ctx)
	case treasury.FieldIban:
		return m.OldIban(ctx)
	case treasury.FieldIsDefault:
		return m.OldIsDefault(ctx)
	case treasury.FieldIsMainAccount:
		return m.OldIsMainAccount(ctx)
	case treasury.FieldName:
		return m.OldName(ctx)
	case treasury.FieldCategory:
		return m.OldCategory(ctx)
	case treasury.FieldSwiftCode:
		return m.OldSwiftCode(ctx)
	}
	return nil, fmt.Errorf("unknown Treasury field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TreasuryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case treasury.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case treasury.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case treasury.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case treasury.FieldAccountNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAccountNumber(v)
		return nil
	case treasury.FieldBalance:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBalance(v)
		return nil
	case treasury.FieldBankName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBankName(v)
		return nil
	case treasury.FieldCurrency:
		v, ok := value.(treasury.Currency)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCurrency(v)
		return nil
	case treasury.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case treasury.FieldIban:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIban(v)
		return nil
	case treasury.FieldIsDefault:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsDefault(v)
		return nil
	case treasury.FieldIsMainAccount:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsMainAccount(v)
		return nil
	case treasury.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case treasury.FieldCategory:
		v, ok := value.(treasury.Category)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCategory(v)
		return nil
	case treasury.FieldSwiftCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSwiftCode(v)
		return nil
	}
	return fmt.Errorf("unknown Treasury field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TreasuryMutation) AddedFields() []string {
	var fields []string
	if m.addbalance != nil {
		fields = append(fields, treasury.FieldBalance)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TreasuryMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case treasury.FieldBalance:
		return m.AddedBalance()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TreasuryMutation) AddField(name string, value ent.Value) error {
	switch name {
	case treasury.FieldBalance:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddBalance(v)
		return nil
	}
	return fmt.Errorf("unknown Treasury numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TreasuryMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(treasury.FieldDeletedAt) {
		fields = append(fields, treasury.FieldDeletedAt)
	}
	if m.FieldCleared(treasury.FieldAccountNumber) {
		fields = append(fields, treasury.FieldAccountNumber)
	}
	if m.FieldCleared(treasury.FieldBankName) {
		fields = append(fields, treasury.FieldBankName)
	}
	if m.FieldCleared(treasury.FieldDescription) {
		fields = append(fields, treasury.FieldDescription)
	}
	if m.FieldCleared(treasury.FieldIban) {
		fields = append(fields, treasury.FieldIban)
	}
	if m.FieldCleared(treasury.FieldIsDefault) {
		fields = append(fields, treasury.FieldIsDefault)
	}
	if m.FieldCleared(treasury.FieldIsMainAccount) {
		fields = append(fields, treasury.FieldIsMainAccount)
	}
	if m.FieldCleared(treasury.FieldSwiftCode) {
		fields = append(fields, treasury.FieldSwiftCode)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TreasuryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TreasuryMutation) ClearField(name string) error {
	switch name {
	case treasury.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case treasury.FieldAccountNumber:
		m.ClearAccountNumber()
		return nil
	case treasury.FieldBankName:
		m.ClearBankName()
		return nil
	case treasury.FieldDescription:
		m.ClearDescription()
		return nil
	case treasury.FieldIban:
		m.ClearIban()
		return nil
	case treasury.FieldIsDefault:
		m.ClearIsDefault()
		return nil
	case treasury.FieldIsMainAccount:
		m.ClearIsMainAccount()
		return nil
	case treasury.FieldSwiftCode:
		m.ClearSwiftCode()
		return nil
	}
	return fmt.Errorf("unknown Treasury nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TreasuryMutation) ResetField(name string) error {
	switch name {
	case treasury.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case treasury.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case treasury.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case treasury.FieldAccountNumber:
		m.ResetAccountNumber()
		return nil
	case treasury.FieldBalance:
		m.ResetBalance()
		return nil
	case treasury.FieldBankName:
		m.ResetBankName()
		return nil
	case treasury.FieldCurrency:
		m.ResetCurrency()
		return nil
	case treasury.FieldDescription:
		m.ResetDescription()
		return nil
	case treasury.FieldIban:
		m.ResetIban()
		return nil
	case treasury.FieldIsDefault:
		m.ResetIsDefault()
		return nil
	case treasury.FieldIsMainAccount:
		m.ResetIsMainAccount()
		return nil
	case treasury.FieldName:
		m.ResetName()
		return nil
	case treasury.FieldCategory:
		m.ResetCategory()
		return nil
	case treasury.FieldSwiftCode:
		m.ResetSwiftCode()
		return nil
	}
	return fmt.Errorf("unknown Treasury field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TreasuryMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.company != nil {
		edges = append(edges, treasury.EdgeCompany)
	}
	if m.cashMovements != nil {
		edges = append(edges, treasury.EdgeCashMovements)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TreasuryMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case treasury.EdgeCompany:
		if id := m.company; id != nil {
			return []ent.Value{*id}
		}
	case treasury.EdgeCashMovements:
		ids := make([]ent.Value, 0, len(m.cashMovements))
		for id := range m.cashMovements {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TreasuryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedcashMovements != nil {
		edges = append(edges, treasury.EdgeCashMovements)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TreasuryMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case treasury.EdgeCashMovements:
		ids := make([]ent.Value, 0, len(m.removedcashMovements))
		for id := range m.removedcashMovements {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TreasuryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedcompany {
		edges = append(edges, treasury.EdgeCompany)
	}
	if m.clearedcashMovements {
		edges = append(edges, treasury.EdgeCashMovements)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TreasuryMutation) EdgeCleared(name string) bool {
	switch name {
	case treasury.EdgeCompany:
		return m.clearedcompany
	case treasury.EdgeCashMovements:
		return m.clearedcashMovements
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TreasuryMutation) ClearEdge(name string) error {
	switch name {
	case treasury.EdgeCompany:
		m.ClearCompany()
		return nil
	}
	return fmt.Errorf("unknown Treasury unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TreasuryMutation) ResetEdge(name string) error {
	switch name {
	case treasury.EdgeCompany:
		m.ResetCompany()
		return nil
	case treasury.EdgeCashMovements:
		m.ResetCashMovements()
		return nil
	}
	return fmt.Errorf("unknown Treasury edge %s", name)
}

// UserMutation represents an operation that mutates the User nodes in the graph.
type UserMutation struct {
	config
	op                       Op
	typ                      string
	id                       *int
	createdAt                *time.Time
	updatedAt                *time.Time
	deletedAt                *time.Time
	fcmToken                 *string
	email                    *string
	name                     *string
	password                 *string
	username                 *string
	disabled                 *bool
	notVerified              *bool
	clearedFields            map[string]struct{}
	accountingEntries        map[int]struct{}
	removedaccountingEntries map[int]struct{}
	clearedaccountingEntries bool
	company                  map[int]struct{}
	removedcompany           map[int]struct{}
	clearedcompany           bool
	assignedRoles            map[int]struct{}
	removedassignedRoles     map[int]struct{}
	clearedassignedRoles     bool
	createdTasks             map[int]struct{}
	removedcreatedTasks      map[int]struct{}
	clearedcreatedTasks      bool
	employee                 *int
	clearedemployee          bool
	tokens                   map[int]struct{}
	removedtokens            map[int]struct{}
	clearedtokens            bool
	done                     bool
	oldValue                 func(context.Context) (*User, error)
	predicates               []predicate.User
}

var _ ent.Mutation = (*UserMutation)(nil)

// userOption allows management of the mutation configuration using functional options.
type userOption func(*UserMutation)

// newUserMutation creates new mutation for the User entity.
func newUserMutation(c config, op Op, opts ...userOption) *UserMutation {
	m := &UserMutation{
		config:        c,
		op:            op,
		typ:           TypeUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserID sets the ID field of the mutation.
func withUserID(id int) userOption {
	return func(m *UserMutation) {
		var (
			err   error
			once  sync.Once
			value *User
		)
		m.oldValue = func(ctx context.Context) (*User, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().User.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUser sets the old User of the mutation.
func withUser(node *User) userOption {
	return func(m *UserMutation) {
		m.oldValue = func(context.Context) (*User, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().User.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "createdAt" field.
func (m *UserMutation) SetCreatedAt(t time.Time) {
	m.createdAt = &t
}

// CreatedAt returns the value of the "createdAt" field in the mutation.
func (m *UserMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.createdAt
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "createdAt" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "createdAt" field.
func (m *UserMutation) ResetCreatedAt() {
	m.createdAt = nil
}

// SetUpdatedAt sets the "updatedAt" field.
func (m *UserMutation) SetUpdatedAt(t time.Time) {
	m.updatedAt = &t
}

// UpdatedAt returns the value of the "updatedAt" field in the mutation.
func (m *UserMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updatedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updatedAt" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updatedAt" field.
func (m *UserMutation) ResetUpdatedAt() {
	m.updatedAt = nil
}

// SetDeletedAt sets the "deletedAt" field.
func (m *UserMutation) SetDeletedAt(t time.Time) {
	m.deletedAt = &t
}

// DeletedAt returns the value of the "deletedAt" field in the mutation.
func (m *UserMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deletedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deletedAt" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deletedAt" field.
func (m *UserMutation) ClearDeletedAt() {
	m.deletedAt = nil
	m.clearedFields[user.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deletedAt" field was cleared in this mutation.
func (m *UserMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[user.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deletedAt" field.
func (m *UserMutation) ResetDeletedAt() {
	m.deletedAt = nil
	delete(m.clearedFields, user.FieldDeletedAt)
}

// SetFcmToken sets the "fcmToken" field.
func (m *UserMutation) SetFcmToken(s string) {
	m.fcmToken = &s
}

// FcmToken returns the value of the "fcmToken" field in the mutation.
func (m *UserMutation) FcmToken() (r string, exists bool) {
	v := m.fcmToken
	if v == nil {
		return
	}
	return *v, true
}

// OldFcmToken returns the old "fcmToken" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldFcmToken(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFcmToken is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFcmToken requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFcmToken: %w", err)
	}
	return oldValue.FcmToken, nil
}

// ClearFcmToken clears the value of the "fcmToken" field.
func (m *UserMutation) ClearFcmToken() {
	m.fcmToken = nil
	m.clearedFields[user.FieldFcmToken] = struct{}{}
}

// FcmTokenCleared returns if the "fcmToken" field was cleared in this mutation.
func (m *UserMutation) FcmTokenCleared() bool {
	_, ok := m.clearedFields[user.FieldFcmToken]
	return ok
}

// ResetFcmToken resets all changes to the "fcmToken" field.
func (m *UserMutation) ResetFcmToken() {
	m.fcmToken = nil
	delete(m.clearedFields, user.FieldFcmToken)
}

// SetEmail sets the "email" field.
func (m *UserMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *UserMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldEmail(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ClearEmail clears the value of the "email" field.
func (m *UserMutation) ClearEmail() {
	m.email = nil
	m.clearedFields[user.FieldEmail] = struct{}{}
}

// EmailCleared returns if the "email" field was cleared in this mutation.
func (m *UserMutation) EmailCleared() bool {
	_, ok := m.clearedFields[user.FieldEmail]
	return ok
}

// ResetEmail resets all changes to the "email" field.
func (m *UserMutation) ResetEmail() {
	m.email = nil
	delete(m.clearedFields, user.FieldEmail)
}

// SetName sets the "name" field.
func (m *UserMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *UserMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *UserMutation) ResetName() {
	m.name = nil
}

// SetPassword sets the "password" field.
func (m *UserMutation) SetPassword(s string) {
	m.password = &s
}

// Password returns the value of the "password" field in the mutation.
func (m *UserMutation) Password() (r string, exists bool) {
	v := m.password
	if v == nil {
		return
	}
	return *v, true
}

// OldPassword returns the old "password" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldPassword(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPassword is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPassword requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPassword: %w", err)
	}
	return oldValue.Password, nil
}

// ResetPassword resets all changes to the "password" field.
func (m *UserMutation) ResetPassword() {
	m.password = nil
}

// SetUsername sets the "username" field.
func (m *UserMutation) SetUsername(s string) {
	m.username = &s
}

// Username returns the value of the "username" field in the mutation.
func (m *UserMutation) Username() (r string, exists bool) {
	v := m.username
	if v == nil {
		return
	}
	return *v, true
}

// OldUsername returns the old "username" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUsername(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsername is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsername requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsername: %w", err)
	}
	return oldValue.Username, nil
}

// ResetUsername resets all changes to the "username" field.
func (m *UserMutation) ResetUsername() {
	m.username = nil
}

// SetDisabled sets the "disabled" field.
func (m *UserMutation) SetDisabled(b bool) {
	m.disabled = &b
}

// Disabled returns the value of the "disabled" field in the mutation.
func (m *UserMutation) Disabled() (r bool, exists bool) {
	v := m.disabled
	if v == nil {
		return
	}
	return *v, true
}

// OldDisabled returns the old "disabled" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldDisabled(ctx context.Context) (v *bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDisabled is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDisabled requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisabled: %w", err)
	}
	return oldValue.Disabled, nil
}

// ClearDisabled clears the value of the "disabled" field.
func (m *UserMutation) ClearDisabled() {
	m.disabled = nil
	m.clearedFields[user.FieldDisabled] = struct{}{}
}

// DisabledCleared returns if the "disabled" field was cleared in this mutation.
func (m *UserMutation) DisabledCleared() bool {
	_, ok := m.clearedFields[user.FieldDisabled]
	return ok
}

// ResetDisabled resets all changes to the "disabled" field.
func (m *UserMutation) ResetDisabled() {
	m.disabled = nil
	delete(m.clearedFields, user.FieldDisabled)
}

// SetNotVerified sets the "notVerified" field.
func (m *UserMutation) SetNotVerified(b bool) {
	m.notVerified = &b
}

// NotVerified returns the value of the "notVerified" field in the mutation.
func (m *UserMutation) NotVerified() (r bool, exists bool) {
	v := m.notVerified
	if v == nil {
		return
	}
	return *v, true
}

// OldNotVerified returns the old "notVerified" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldNotVerified(ctx context.Context) (v *bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNotVerified is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNotVerified requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNotVerified: %w", err)
	}
	return oldValue.NotVerified, nil
}

// ClearNotVerified clears the value of the "notVerified" field.
func (m *UserMutation) ClearNotVerified() {
	m.notVerified = nil
	m.clearedFields[user.FieldNotVerified] = struct{}{}
}

// NotVerifiedCleared returns if the "notVerified" field was cleared in this mutation.
func (m *UserMutation) NotVerifiedCleared() bool {
	_, ok := m.clearedFields[user.FieldNotVerified]
	return ok
}

// ResetNotVerified resets all changes to the "notVerified" field.
func (m *UserMutation) ResetNotVerified() {
	m.notVerified = nil
	delete(m.clearedFields, user.FieldNotVerified)
}

// AddAccountingEntryIDs adds the "accountingEntries" edge to the AccountingEntry entity by ids.
func (m *UserMutation) AddAccountingEntryIDs(ids ...int) {
	if m.accountingEntries == nil {
		m.accountingEntries = make(map[int]struct{})
	}
	for i := range ids {
		m.accountingEntries[ids[i]] = struct{}{}
	}
}

// ClearAccountingEntries clears the "accountingEntries" edge to the AccountingEntry entity.
func (m *UserMutation) ClearAccountingEntries() {
	m.clearedaccountingEntries = true
}

// AccountingEntriesCleared reports if the "accountingEntries" edge to the AccountingEntry entity was cleared.
func (m *UserMutation) AccountingEntriesCleared() bool {
	return m.clearedaccountingEntries
}

// RemoveAccountingEntryIDs removes the "accountingEntries" edge to the AccountingEntry entity by IDs.
func (m *UserMutation) RemoveAccountingEntryIDs(ids ...int) {
	if m.removedaccountingEntries == nil {
		m.removedaccountingEntries = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.accountingEntries, ids[i])
		m.removedaccountingEntries[ids[i]] = struct{}{}
	}
}

// RemovedAccountingEntries returns the removed IDs of the "accountingEntries" edge to the AccountingEntry entity.
func (m *UserMutation) RemovedAccountingEntriesIDs() (ids []int) {
	for id := range m.removedaccountingEntries {
		ids = append(ids, id)
	}
	return
}

// AccountingEntriesIDs returns the "accountingEntries" edge IDs in the mutation.
func (m *UserMutation) AccountingEntriesIDs() (ids []int) {
	for id := range m.accountingEntries {
		ids = append(ids, id)
	}
	return
}

// ResetAccountingEntries resets all changes to the "accountingEntries" edge.
func (m *UserMutation) ResetAccountingEntries() {
	m.accountingEntries = nil
	m.clearedaccountingEntries = false
	m.removedaccountingEntries = nil
}

// AddCompanyIDs adds the "company" edge to the Company entity by ids.
func (m *UserMutation) AddCompanyIDs(ids ...int) {
	if m.company == nil {
		m.company = make(map[int]struct{})
	}
	for i := range ids {
		m.company[ids[i]] = struct{}{}
	}
}

// ClearCompany clears the "company" edge to the Company entity.
func (m *UserMutation) ClearCompany() {
	m.clearedcompany = true
}

// CompanyCleared reports if the "company" edge to the Company entity was cleared.
func (m *UserMutation) CompanyCleared() bool {
	return m.clearedcompany
}

// RemoveCompanyIDs removes the "company" edge to the Company entity by IDs.
func (m *UserMutation) RemoveCompanyIDs(ids ...int) {
	if m.removedcompany == nil {
		m.removedcompany = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.company, ids[i])
		m.removedcompany[ids[i]] = struct{}{}
	}
}

// RemovedCompany returns the removed IDs of the "company" edge to the Company entity.
func (m *UserMutation) RemovedCompanyIDs() (ids []int) {
	for id := range m.removedcompany {
		ids = append(ids, id)
	}
	return
}

// CompanyIDs returns the "company" edge IDs in the mutation.
func (m *UserMutation) CompanyIDs() (ids []int) {
	for id := range m.company {
		ids = append(ids, id)
	}
	return
}

// ResetCompany resets all changes to the "company" edge.
func (m *UserMutation) ResetCompany() {
	m.company = nil
	m.clearedcompany = false
	m.removedcompany = nil
}

// AddAssignedRoleIDs adds the "assignedRoles" edge to the UserRole entity by ids.
func (m *UserMutation) AddAssignedRoleIDs(ids ...int) {
	if m.assignedRoles == nil {
		m.assignedRoles = make(map[int]struct{})
	}
	for i := range ids {
		m.assignedRoles[ids[i]] = struct{}{}
	}
}

// ClearAssignedRoles clears the "assignedRoles" edge to the UserRole entity.
func (m *UserMutation) ClearAssignedRoles() {
	m.clearedassignedRoles = true
}

// AssignedRolesCleared reports if the "assignedRoles" edge to the UserRole entity was cleared.
func (m *UserMutation) AssignedRolesCleared() bool {
	return m.clearedassignedRoles
}

// RemoveAssignedRoleIDs removes the "assignedRoles" edge to the UserRole entity by IDs.
func (m *UserMutation) RemoveAssignedRoleIDs(ids ...int) {
	if m.removedassignedRoles == nil {
		m.removedassignedRoles = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.assignedRoles, ids[i])
		m.removedassignedRoles[ids[i]] = struct{}{}
	}
}

// RemovedAssignedRoles returns the removed IDs of the "assignedRoles" edge to the UserRole entity.
func (m *UserMutation) RemovedAssignedRolesIDs() (ids []int) {
	for id := range m.removedassignedRoles {
		ids = append(ids, id)
	}
	return
}

// AssignedRolesIDs returns the "assignedRoles" edge IDs in the mutation.
func (m *UserMutation) AssignedRolesIDs() (ids []int) {
	for id := range m.assignedRoles {
		ids = append(ids, id)
	}
	return
}

// ResetAssignedRoles resets all changes to the "assignedRoles" edge.
func (m *UserMutation) ResetAssignedRoles() {
	m.assignedRoles = nil
	m.clearedassignedRoles = false
	m.removedassignedRoles = nil
}

// AddCreatedTaskIDs adds the "createdTasks" edge to the Worktask entity by ids.
func (m *UserMutation) AddCreatedTaskIDs(ids ...int) {
	if m.createdTasks == nil {
		m.createdTasks = make(map[int]struct{})
	}
	for i := range ids {
		m.createdTasks[ids[i]] = struct{}{}
	}
}

// ClearCreatedTasks clears the "createdTasks" edge to the Worktask entity.
func (m *UserMutation) ClearCreatedTasks() {
	m.clearedcreatedTasks = true
}

// CreatedTasksCleared reports if the "createdTasks" edge to the Worktask entity was cleared.
func (m *UserMutation) CreatedTasksCleared() bool {
	return m.clearedcreatedTasks
}

// RemoveCreatedTaskIDs removes the "createdTasks" edge to the Worktask entity by IDs.
func (m *UserMutation) RemoveCreatedTaskIDs(ids ...int) {
	if m.removedcreatedTasks == nil {
		m.removedcreatedTasks = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.createdTasks, ids[i])
		m.removedcreatedTasks[ids[i]] = struct{}{}
	}
}

// RemovedCreatedTasks returns the removed IDs of the "createdTasks" edge to the Worktask entity.
func (m *UserMutation) RemovedCreatedTasksIDs() (ids []int) {
	for id := range m.removedcreatedTasks {
		ids = append(ids, id)
	}
	return
}

// CreatedTasksIDs returns the "createdTasks" edge IDs in the mutation.
func (m *UserMutation) CreatedTasksIDs() (ids []int) {
	for id := range m.createdTasks {
		ids = append(ids, id)
	}
	return
}

// ResetCreatedTasks resets all changes to the "createdTasks" edge.
func (m *UserMutation) ResetCreatedTasks() {
	m.createdTasks = nil
	m.clearedcreatedTasks = false
	m.removedcreatedTasks = nil
}

// SetEmployeeID sets the "employee" edge to the Employee entity by id.
func (m *UserMutation) SetEmployeeID(id int) {
	m.employee = &id
}

// ClearEmployee clears the "employee" edge to the Employee entity.
func (m *UserMutation) ClearEmployee() {
	m.clearedemployee = true
}

// EmployeeCleared reports if the "employee" edge to the Employee entity was cleared.
func (m *UserMutation) EmployeeCleared() bool {
	return m.clearedemployee
}

// EmployeeID returns the "employee" edge ID in the mutation.
func (m *UserMutation) EmployeeID() (id int, exists bool) {
	if m.employee != nil {
		return *m.employee, true
	}
	return
}

// EmployeeIDs returns the "employee" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// EmployeeID instead. It exists only for internal usage by the builders.
func (m *UserMutation) EmployeeIDs() (ids []int) {
	if id := m.employee; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEmployee resets all changes to the "employee" edge.
func (m *UserMutation) ResetEmployee() {
	m.employee = nil
	m.clearedemployee = false
}

// AddTokenIDs adds the "tokens" edge to the Token entity by ids.
func (m *UserMutation) AddTokenIDs(ids ...int) {
	if m.tokens == nil {
		m.tokens = make(map[int]struct{})
	}
	for i := range ids {
		m.tokens[ids[i]] = struct{}{}
	}
}

// ClearTokens clears the "tokens" edge to the Token entity.
func (m *UserMutation) ClearTokens() {
	m.clearedtokens = true
}

// TokensCleared reports if the "tokens" edge to the Token entity was cleared.
func (m *UserMutation) TokensCleared() bool {
	return m.clearedtokens
}

// RemoveTokenIDs removes the "tokens" edge to the Token entity by IDs.
func (m *UserMutation) RemoveTokenIDs(ids ...int) {
	if m.removedtokens == nil {
		m.removedtokens = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.tokens, ids[i])
		m.removedtokens[ids[i]] = struct{}{}
	}
}

// RemovedTokens returns the removed IDs of the "tokens" edge to the Token entity.
func (m *UserMutation) RemovedTokensIDs() (ids []int) {
	for id := range m.removedtokens {
		ids = append(ids, id)
	}
	return
}

// TokensIDs returns the "tokens" edge IDs in the mutation.
func (m *UserMutation) TokensIDs() (ids []int) {
	for id := range m.tokens {
		ids = append(ids, id)
	}
	return
}

// ResetTokens resets all changes to the "tokens" edge.
func (m *UserMutation) ResetTokens() {
	m.tokens = nil
	m.clearedtokens = false
	m.removedtokens = nil
}

// Where appends a list predicates to the UserMutation builder.
func (m *UserMutation) Where(ps ...predicate.User) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.User, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (User).
func (m *UserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.createdAt != nil {
		fields = append(fields, user.FieldCreatedAt)
	}
	if m.updatedAt != nil {
		fields = append(fields, user.FieldUpdatedAt)
	}
	if m.deletedAt != nil {
		fields = append(fields, user.FieldDeletedAt)
	}
	if m.fcmToken != nil {
		fields = append(fields, user.FieldFcmToken)
	}
	if m.email != nil {
		fields = append(fields, user.FieldEmail)
	}
	if m.name != nil {
		fields = append(fields, user.FieldName)
	}
	if m.password != nil {
		fields = append(fields, user.FieldPassword)
	}
	if m.username != nil {
		fields = append(fields, user.FieldUsername)
	}
	if m.disabled != nil {
		fields = append(fields, user.FieldDisabled)
	}
	if m.notVerified != nil {
		fields = append(fields, user.FieldNotVerified)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case user.FieldCreatedAt:
		return m.CreatedAt()
	case user.FieldUpdatedAt:
		return m.UpdatedAt()
	case user.FieldDeletedAt:
		return m.DeletedAt()
	case user.FieldFcmToken:
		return m.FcmToken()
	case user.FieldEmail:
		return m.Email()
	case user.FieldName:
		return m.Name()
	case user.FieldPassword:
		return m.Password()
	case user.FieldUsername:
		return m.Username()
	case user.FieldDisabled:
		return m.Disabled()
	case user.FieldNotVerified:
		return m.NotVerified()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case user.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case user.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case user.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case user.FieldFcmToken:
		return m.OldFcmToken(ctx)
	case user.FieldEmail:
		return m.OldEmail(ctx)
	case user.FieldName:
		return m.OldName(ctx)
	case user.FieldPassword:
		return m.OldPassword(ctx)
	case user.FieldUsername:
		return m.OldUsername(ctx)
	case user.FieldDisabled:
		return m.OldDisabled(ctx)
	case user.FieldNotVerified:
		return m.OldNotVerified(ctx)
	}
	return nil, fmt.Errorf("unknown User field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case user.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case user.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case user.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case user.FieldFcmToken:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFcmToken(v)
		return nil
	case user.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case user.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case user.FieldPassword:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPassword(v)
		return nil
	case user.FieldUsername:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsername(v)
		return nil
	case user.FieldDisabled:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisabled(v)
		return nil
	case user.FieldNotVerified:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNotVerified(v)
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown User numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(user.FieldDeletedAt) {
		fields = append(fields, user.FieldDeletedAt)
	}
	if m.FieldCleared(user.FieldFcmToken) {
		fields = append(fields, user.FieldFcmToken)
	}
	if m.FieldCleared(user.FieldEmail) {
		fields = append(fields, user.FieldEmail)
	}
	if m.FieldCleared(user.FieldDisabled) {
		fields = append(fields, user.FieldDisabled)
	}
	if m.FieldCleared(user.FieldNotVerified) {
		fields = append(fields, user.FieldNotVerified)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserMutation) ClearField(name string) error {
	switch name {
	case user.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case user.FieldFcmToken:
		m.ClearFcmToken()
		return nil
	case user.FieldEmail:
		m.ClearEmail()
		return nil
	case user.FieldDisabled:
		m.ClearDisabled()
		return nil
	case user.FieldNotVerified:
		m.ClearNotVerified()
		return nil
	}
	return fmt.Errorf("unknown User nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserMutation) ResetField(name string) error {
	switch name {
	case user.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case user.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case user.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case user.FieldFcmToken:
		m.ResetFcmToken()
		return nil
	case user.FieldEmail:
		m.ResetEmail()
		return nil
	case user.FieldName:
		m.ResetName()
		return nil
	case user.FieldPassword:
		m.ResetPassword()
		return nil
	case user.FieldUsername:
		m.ResetUsername()
		return nil
	case user.FieldDisabled:
		m.ResetDisabled()
		return nil
	case user.FieldNotVerified:
		m.ResetNotVerified()
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserMutation) AddedEdges() []string {
	edges := make([]string, 0, 6)
	if m.accountingEntries != nil {
		edges = append(edges, user.EdgeAccountingEntries)
	}
	if m.company != nil {
		edges = append(edges, user.EdgeCompany)
	}
	if m.assignedRoles != nil {
		edges = append(edges, user.EdgeAssignedRoles)
	}
	if m.createdTasks != nil {
		edges = append(edges, user.EdgeCreatedTasks)
	}
	if m.employee != nil {
		edges = append(edges, user.EdgeEmployee)
	}
	if m.tokens != nil {
		edges = append(edges, user.EdgeTokens)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeAccountingEntries:
		ids := make([]ent.Value, 0, len(m.accountingEntries))
		for id := range m.accountingEntries {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeCompany:
		ids := make([]ent.Value, 0, len(m.company))
		for id := range m.company {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeAssignedRoles:
		ids := make([]ent.Value, 0, len(m.assignedRoles))
		for id := range m.assignedRoles {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeCreatedTasks:
		ids := make([]ent.Value, 0, len(m.createdTasks))
		for id := range m.createdTasks {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeEmployee:
		if id := m.employee; id != nil {
			return []ent.Value{*id}
		}
	case user.EdgeTokens:
		ids := make([]ent.Value, 0, len(m.tokens))
		for id := range m.tokens {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 6)
	if m.removedaccountingEntries != nil {
		edges = append(edges, user.EdgeAccountingEntries)
	}
	if m.removedcompany != nil {
		edges = append(edges, user.EdgeCompany)
	}
	if m.removedassignedRoles != nil {
		edges = append(edges, user.EdgeAssignedRoles)
	}
	if m.removedcreatedTasks != nil {
		edges = append(edges, user.EdgeCreatedTasks)
	}
	if m.removedtokens != nil {
		edges = append(edges, user.EdgeTokens)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeAccountingEntries:
		ids := make([]ent.Value, 0, len(m.removedaccountingEntries))
		for id := range m.removedaccountingEntries {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeCompany:
		ids := make([]ent.Value, 0, len(m.removedcompany))
		for id := range m.removedcompany {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeAssignedRoles:
		ids := make([]ent.Value, 0, len(m.removedassignedRoles))
		for id := range m.removedassignedRoles {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeCreatedTasks:
		ids := make([]ent.Value, 0, len(m.removedcreatedTasks))
		for id := range m.removedcreatedTasks {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeTokens:
		ids := make([]ent.Value, 0, len(m.removedtokens))
		for id := range m.removedtokens {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 6)
	if m.clearedaccountingEntries {
		edges = append(edges, user.EdgeAccountingEntries)
	}
	if m.clearedcompany {
		edges = append(edges, user.EdgeCompany)
	}
	if m.clearedassignedRoles {
		edges = append(edges, user.EdgeAssignedRoles)
	}
	if m.clearedcreatedTasks {
		edges = append(edges, user.EdgeCreatedTasks)
	}
	if m.clearedemployee {
		edges = append(edges, user.EdgeEmployee)
	}
	if m.clearedtokens {
		edges = append(edges, user.EdgeTokens)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserMutation) EdgeCleared(name string) bool {
	switch name {
	case user.EdgeAccountingEntries:
		return m.clearedaccountingEntries
	case user.EdgeCompany:
		return m.clearedcompany
	case user.EdgeAssignedRoles:
		return m.clearedassignedRoles
	case user.EdgeCreatedTasks:
		return m.clearedcreatedTasks
	case user.EdgeEmployee:
		return m.clearedemployee
	case user.EdgeTokens:
		return m.clearedtokens
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserMutation) ClearEdge(name string) error {
	switch name {
	case user.EdgeEmployee:
		m.ClearEmployee()
		return nil
	}
	return fmt.Errorf("unknown User unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserMutation) ResetEdge(name string) error {
	switch name {
	case user.EdgeAccountingEntries:
		m.ResetAccountingEntries()
		return nil
	case user.EdgeCompany:
		m.ResetCompany()
		return nil
	case user.EdgeAssignedRoles:
		m.ResetAssignedRoles()
		return nil
	case user.EdgeCreatedTasks:
		m.ResetCreatedTasks()
		return nil
	case user.EdgeEmployee:
		m.ResetEmployee()
		return nil
	case user.EdgeTokens:
		m.ResetTokens()
		return nil
	}
	return fmt.Errorf("unknown User edge %s", name)
}

// UserRoleMutation represents an operation that mutates the UserRole nodes in the graph.
type UserRoleMutation struct {
	config
	op             Op
	typ            string
	id             *int
	role           *userrole.Role
	clearedFields  map[string]struct{}
	company        *int
	clearedcompany bool
	user           map[int]struct{}
	removeduser    map[int]struct{}
	cleareduser    bool
	done           bool
	oldValue       func(context.Context) (*UserRole, error)
	predicates     []predicate.UserRole
}

var _ ent.Mutation = (*UserRoleMutation)(nil)

// userroleOption allows management of the mutation configuration using functional options.
type userroleOption func(*UserRoleMutation)

// newUserRoleMutation creates new mutation for the UserRole entity.
func newUserRoleMutation(c config, op Op, opts ...userroleOption) *UserRoleMutation {
	m := &UserRoleMutation{
		config:        c,
		op:            op,
		typ:           TypeUserRole,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserRoleID sets the ID field of the mutation.
func withUserRoleID(id int) userroleOption {
	return func(m *UserRoleMutation) {
		var (
			err   error
			once  sync.Once
			value *UserRole
		)
		m.oldValue = func(ctx context.Context) (*UserRole, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().UserRole.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUserRole sets the old UserRole of the mutation.
func withUserRole(node *UserRole) userroleOption {
	return func(m *UserRoleMutation) {
		m.oldValue = func(context.Context) (*UserRole, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserRoleMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserRoleMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserRoleMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserRoleMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().UserRole.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetRole sets the "role" field.
func (m *UserRoleMutation) SetRole(u userrole.Role) {
	m.role = &u
}

// Role returns the value of the "role" field in the mutation.
func (m *UserRoleMutation) Role() (r userrole.Role, exists bool) {
	v := m.role
	if v == nil {
		return
	}
	return *v, true
}

// OldRole returns the old "role" field's value of the UserRole entity.
// If the UserRole object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserRoleMutation) OldRole(ctx context.Context) (v userrole.Role, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRole is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRole requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRole: %w", err)
	}
	return oldValue.Role, nil
}

// ResetRole resets all changes to the "role" field.
func (m *UserRoleMutation) ResetRole() {
	m.role = nil
}

// SetCompanyID sets the "company" edge to the Company entity by id.
func (m *UserRoleMutation) SetCompanyID(id int) {
	m.company = &id
}

// ClearCompany clears the "company" edge to the Company entity.
func (m *UserRoleMutation) ClearCompany() {
	m.clearedcompany = true
}

// CompanyCleared reports if the "company" edge to the Company entity was cleared.
func (m *UserRoleMutation) CompanyCleared() bool {
	return m.clearedcompany
}

// CompanyID returns the "company" edge ID in the mutation.
func (m *UserRoleMutation) CompanyID() (id int, exists bool) {
	if m.company != nil {
		return *m.company, true
	}
	return
}

// CompanyIDs returns the "company" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CompanyID instead. It exists only for internal usage by the builders.
func (m *UserRoleMutation) CompanyIDs() (ids []int) {
	if id := m.company; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCompany resets all changes to the "company" edge.
func (m *UserRoleMutation) ResetCompany() {
	m.company = nil
	m.clearedcompany = false
}

// AddUserIDs adds the "user" edge to the User entity by ids.
func (m *UserRoleMutation) AddUserIDs(ids ...int) {
	if m.user == nil {
		m.user = make(map[int]struct{})
	}
	for i := range ids {
		m.user[ids[i]] = struct{}{}
	}
}

// ClearUser clears the "user" edge to the User entity.
func (m *UserRoleMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *UserRoleMutation) UserCleared() bool {
	return m.cleareduser
}

// RemoveUserIDs removes the "user" edge to the User entity by IDs.
func (m *UserRoleMutation) RemoveUserIDs(ids ...int) {
	if m.removeduser == nil {
		m.removeduser = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.user, ids[i])
		m.removeduser[ids[i]] = struct{}{}
	}
}

// RemovedUser returns the removed IDs of the "user" edge to the User entity.
func (m *UserRoleMutation) RemovedUserIDs() (ids []int) {
	for id := range m.removeduser {
		ids = append(ids, id)
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
func (m *UserRoleMutation) UserIDs() (ids []int) {
	for id := range m.user {
		ids = append(ids, id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *UserRoleMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
	m.removeduser = nil
}

// Where appends a list predicates to the UserRoleMutation builder.
func (m *UserRoleMutation) Where(ps ...predicate.UserRole) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserRoleMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserRoleMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.UserRole, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserRoleMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserRoleMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (UserRole).
func (m *UserRoleMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserRoleMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.role != nil {
		fields = append(fields, userrole.FieldRole)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserRoleMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case userrole.FieldRole:
		return m.Role()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserRoleMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case userrole.FieldRole:
		return m.OldRole(ctx)
	}
	return nil, fmt.Errorf("unknown UserRole field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserRoleMutation) SetField(name string, value ent.Value) error {
	switch name {
	case userrole.FieldRole:
		v, ok := value.(userrole.Role)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRole(v)
		return nil
	}
	return fmt.Errorf("unknown UserRole field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserRoleMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserRoleMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserRoleMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown UserRole numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserRoleMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserRoleMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserRoleMutation) ClearField(name string) error {
	return fmt.Errorf("unknown UserRole nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserRoleMutation) ResetField(name string) error {
	switch name {
	case userrole.FieldRole:
		m.ResetRole()
		return nil
	}
	return fmt.Errorf("unknown UserRole field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserRoleMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.company != nil {
		edges = append(edges, userrole.EdgeCompany)
	}
	if m.user != nil {
		edges = append(edges, userrole.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserRoleMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case userrole.EdgeCompany:
		if id := m.company; id != nil {
			return []ent.Value{*id}
		}
	case userrole.EdgeUser:
		ids := make([]ent.Value, 0, len(m.user))
		for id := range m.user {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserRoleMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removeduser != nil {
		edges = append(edges, userrole.EdgeUser)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserRoleMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case userrole.EdgeUser:
		ids := make([]ent.Value, 0, len(m.removeduser))
		for id := range m.removeduser {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserRoleMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedcompany {
		edges = append(edges, userrole.EdgeCompany)
	}
	if m.cleareduser {
		edges = append(edges, userrole.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserRoleMutation) EdgeCleared(name string) bool {
	switch name {
	case userrole.EdgeCompany:
		return m.clearedcompany
	case userrole.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserRoleMutation) ClearEdge(name string) error {
	switch name {
	case userrole.EdgeCompany:
		m.ClearCompany()
		return nil
	}
	return fmt.Errorf("unknown UserRole unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserRoleMutation) ResetEdge(name string) error {
	switch name {
	case userrole.EdgeCompany:
		m.ResetCompany()
		return nil
	case userrole.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown UserRole edge %s", name)
}

// WorkshiftMutation represents an operation that mutates the Workshift nodes in the graph.
type WorkshiftMutation struct {
	config
	op                 Op
	typ                string
	id                 *int
	createdAt          *time.Time
	updatedAt          *time.Time
	deletedAt          *time.Time
	approvedAt         *time.Time
	clockIn            *time.Time
	clockOut           *time.Time
	clockInLocation    *string
	clockOutLocation   *string
	description        *string
	note               *string
	status             *workshift.Status
	clearedFields      map[string]struct{}
	company            *int
	clearedcompany     bool
	employee           *int
	clearedemployee    bool
	approvedBy         *int
	clearedapprovedBy  bool
	workTask           *int
	clearedworkTask    bool
	editRequest        *int
	clearededitRequest bool
	workShift          *int
	clearedworkShift   bool
	done               bool
	oldValue           func(context.Context) (*Workshift, error)
	predicates         []predicate.Workshift
}

var _ ent.Mutation = (*WorkshiftMutation)(nil)

// workshiftOption allows management of the mutation configuration using functional options.
type workshiftOption func(*WorkshiftMutation)

// newWorkshiftMutation creates new mutation for the Workshift entity.
func newWorkshiftMutation(c config, op Op, opts ...workshiftOption) *WorkshiftMutation {
	m := &WorkshiftMutation{
		config:        c,
		op:            op,
		typ:           TypeWorkshift,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withWorkshiftID sets the ID field of the mutation.
func withWorkshiftID(id int) workshiftOption {
	return func(m *WorkshiftMutation) {
		var (
			err   error
			once  sync.Once
			value *Workshift
		)
		m.oldValue = func(ctx context.Context) (*Workshift, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Workshift.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withWorkshift sets the old Workshift of the mutation.
func withWorkshift(node *Workshift) workshiftOption {
	return func(m *WorkshiftMutation) {
		m.oldValue = func(context.Context) (*Workshift, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m WorkshiftMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m WorkshiftMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *WorkshiftMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *WorkshiftMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Workshift.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "createdAt" field.
func (m *WorkshiftMutation) SetCreatedAt(t time.Time) {
	m.createdAt = &t
}

// CreatedAt returns the value of the "createdAt" field in the mutation.
func (m *WorkshiftMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.createdAt
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "createdAt" field's value of the Workshift entity.
// If the Workshift object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkshiftMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "createdAt" field.
func (m *WorkshiftMutation) ResetCreatedAt() {
	m.createdAt = nil
}

// SetUpdatedAt sets the "updatedAt" field.
func (m *WorkshiftMutation) SetUpdatedAt(t time.Time) {
	m.updatedAt = &t
}

// UpdatedAt returns the value of the "updatedAt" field in the mutation.
func (m *WorkshiftMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updatedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updatedAt" field's value of the Workshift entity.
// If the Workshift object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkshiftMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updatedAt" field.
func (m *WorkshiftMutation) ResetUpdatedAt() {
	m.updatedAt = nil
}

// SetDeletedAt sets the "deletedAt" field.
func (m *WorkshiftMutation) SetDeletedAt(t time.Time) {
	m.deletedAt = &t
}

// DeletedAt returns the value of the "deletedAt" field in the mutation.
func (m *WorkshiftMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deletedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deletedAt" field's value of the Workshift entity.
// If the Workshift object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkshiftMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deletedAt" field.
func (m *WorkshiftMutation) ClearDeletedAt() {
	m.deletedAt = nil
	m.clearedFields[workshift.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deletedAt" field was cleared in this mutation.
func (m *WorkshiftMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[workshift.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deletedAt" field.
func (m *WorkshiftMutation) ResetDeletedAt() {
	m.deletedAt = nil
	delete(m.clearedFields, workshift.FieldDeletedAt)
}

// SetApprovedAt sets the "approvedAt" field.
func (m *WorkshiftMutation) SetApprovedAt(t time.Time) {
	m.approvedAt = &t
}

// ApprovedAt returns the value of the "approvedAt" field in the mutation.
func (m *WorkshiftMutation) ApprovedAt() (r time.Time, exists bool) {
	v := m.approvedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldApprovedAt returns the old "approvedAt" field's value of the Workshift entity.
// If the Workshift object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkshiftMutation) OldApprovedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldApprovedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldApprovedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldApprovedAt: %w", err)
	}
	return oldValue.ApprovedAt, nil
}

// ClearApprovedAt clears the value of the "approvedAt" field.
func (m *WorkshiftMutation) ClearApprovedAt() {
	m.approvedAt = nil
	m.clearedFields[workshift.FieldApprovedAt] = struct{}{}
}

// ApprovedAtCleared returns if the "approvedAt" field was cleared in this mutation.
func (m *WorkshiftMutation) ApprovedAtCleared() bool {
	_, ok := m.clearedFields[workshift.FieldApprovedAt]
	return ok
}

// ResetApprovedAt resets all changes to the "approvedAt" field.
func (m *WorkshiftMutation) ResetApprovedAt() {
	m.approvedAt = nil
	delete(m.clearedFields, workshift.FieldApprovedAt)
}

// SetClockIn sets the "clockIn" field.
func (m *WorkshiftMutation) SetClockIn(t time.Time) {
	m.clockIn = &t
}

// ClockIn returns the value of the "clockIn" field in the mutation.
func (m *WorkshiftMutation) ClockIn() (r time.Time, exists bool) {
	v := m.clockIn
	if v == nil {
		return
	}
	return *v, true
}

// OldClockIn returns the old "clockIn" field's value of the Workshift entity.
// If the Workshift object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkshiftMutation) OldClockIn(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClockIn is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClockIn requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClockIn: %w", err)
	}
	return oldValue.ClockIn, nil
}

// ResetClockIn resets all changes to the "clockIn" field.
func (m *WorkshiftMutation) ResetClockIn() {
	m.clockIn = nil
}

// SetClockOut sets the "clockOut" field.
func (m *WorkshiftMutation) SetClockOut(t time.Time) {
	m.clockOut = &t
}

// ClockOut returns the value of the "clockOut" field in the mutation.
func (m *WorkshiftMutation) ClockOut() (r time.Time, exists bool) {
	v := m.clockOut
	if v == nil {
		return
	}
	return *v, true
}

// OldClockOut returns the old "clockOut" field's value of the Workshift entity.
// If the Workshift object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkshiftMutation) OldClockOut(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClockOut is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClockOut requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClockOut: %w", err)
	}
	return oldValue.ClockOut, nil
}

// ClearClockOut clears the value of the "clockOut" field.
func (m *WorkshiftMutation) ClearClockOut() {
	m.clockOut = nil
	m.clearedFields[workshift.FieldClockOut] = struct{}{}
}

// ClockOutCleared returns if the "clockOut" field was cleared in this mutation.
func (m *WorkshiftMutation) ClockOutCleared() bool {
	_, ok := m.clearedFields[workshift.FieldClockOut]
	return ok
}

// ResetClockOut resets all changes to the "clockOut" field.
func (m *WorkshiftMutation) ResetClockOut() {
	m.clockOut = nil
	delete(m.clearedFields, workshift.FieldClockOut)
}

// SetClockInLocation sets the "clockInLocation" field.
func (m *WorkshiftMutation) SetClockInLocation(s string) {
	m.clockInLocation = &s
}

// ClockInLocation returns the value of the "clockInLocation" field in the mutation.
func (m *WorkshiftMutation) ClockInLocation() (r string, exists bool) {
	v := m.clockInLocation
	if v == nil {
		return
	}
	return *v, true
}

// OldClockInLocation returns the old "clockInLocation" field's value of the Workshift entity.
// If the Workshift object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkshiftMutation) OldClockInLocation(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClockInLocation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClockInLocation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClockInLocation: %w", err)
	}
	return oldValue.ClockInLocation, nil
}

// ResetClockInLocation resets all changes to the "clockInLocation" field.
func (m *WorkshiftMutation) ResetClockInLocation() {
	m.clockInLocation = nil
}

// SetClockOutLocation sets the "clockOutLocation" field.
func (m *WorkshiftMutation) SetClockOutLocation(s string) {
	m.clockOutLocation = &s
}

// ClockOutLocation returns the value of the "clockOutLocation" field in the mutation.
func (m *WorkshiftMutation) ClockOutLocation() (r string, exists bool) {
	v := m.clockOutLocation
	if v == nil {
		return
	}
	return *v, true
}

// OldClockOutLocation returns the old "clockOutLocation" field's value of the Workshift entity.
// If the Workshift object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkshiftMutation) OldClockOutLocation(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClockOutLocation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClockOutLocation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClockOutLocation: %w", err)
	}
	return oldValue.ClockOutLocation, nil
}

// ClearClockOutLocation clears the value of the "clockOutLocation" field.
func (m *WorkshiftMutation) ClearClockOutLocation() {
	m.clockOutLocation = nil
	m.clearedFields[workshift.FieldClockOutLocation] = struct{}{}
}

// ClockOutLocationCleared returns if the "clockOutLocation" field was cleared in this mutation.
func (m *WorkshiftMutation) ClockOutLocationCleared() bool {
	_, ok := m.clearedFields[workshift.FieldClockOutLocation]
	return ok
}

// ResetClockOutLocation resets all changes to the "clockOutLocation" field.
func (m *WorkshiftMutation) ResetClockOutLocation() {
	m.clockOutLocation = nil
	delete(m.clearedFields, workshift.FieldClockOutLocation)
}

// SetDescription sets the "description" field.
func (m *WorkshiftMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *WorkshiftMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Workshift entity.
// If the Workshift object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkshiftMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *WorkshiftMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[workshift.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *WorkshiftMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[workshift.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *WorkshiftMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, workshift.FieldDescription)
}

// SetNote sets the "note" field.
func (m *WorkshiftMutation) SetNote(s string) {
	m.note = &s
}

// Note returns the value of the "note" field in the mutation.
func (m *WorkshiftMutation) Note() (r string, exists bool) {
	v := m.note
	if v == nil {
		return
	}
	return *v, true
}

// OldNote returns the old "note" field's value of the Workshift entity.
// If the Workshift object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkshiftMutation) OldNote(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNote is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNote requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNote: %w", err)
	}
	return oldValue.Note, nil
}

// ClearNote clears the value of the "note" field.
func (m *WorkshiftMutation) ClearNote() {
	m.note = nil
	m.clearedFields[workshift.FieldNote] = struct{}{}
}

// NoteCleared returns if the "note" field was cleared in this mutation.
func (m *WorkshiftMutation) NoteCleared() bool {
	_, ok := m.clearedFields[workshift.FieldNote]
	return ok
}

// ResetNote resets all changes to the "note" field.
func (m *WorkshiftMutation) ResetNote() {
	m.note = nil
	delete(m.clearedFields, workshift.FieldNote)
}

// SetStatus sets the "status" field.
func (m *WorkshiftMutation) SetStatus(w workshift.Status) {
	m.status = &w
}

// Status returns the value of the "status" field in the mutation.
func (m *WorkshiftMutation) Status() (r workshift.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Workshift entity.
// If the Workshift object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkshiftMutation) OldStatus(ctx context.Context) (v workshift.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *WorkshiftMutation) ResetStatus() {
	m.status = nil
}

// SetCompanyID sets the "company" edge to the Company entity by id.
func (m *WorkshiftMutation) SetCompanyID(id int) {
	m.company = &id
}

// ClearCompany clears the "company" edge to the Company entity.
func (m *WorkshiftMutation) ClearCompany() {
	m.clearedcompany = true
}

// CompanyCleared reports if the "company" edge to the Company entity was cleared.
func (m *WorkshiftMutation) CompanyCleared() bool {
	return m.clearedcompany
}

// CompanyID returns the "company" edge ID in the mutation.
func (m *WorkshiftMutation) CompanyID() (id int, exists bool) {
	if m.company != nil {
		return *m.company, true
	}
	return
}

// CompanyIDs returns the "company" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CompanyID instead. It exists only for internal usage by the builders.
func (m *WorkshiftMutation) CompanyIDs() (ids []int) {
	if id := m.company; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCompany resets all changes to the "company" edge.
func (m *WorkshiftMutation) ResetCompany() {
	m.company = nil
	m.clearedcompany = false
}

// SetEmployeeID sets the "employee" edge to the Employee entity by id.
func (m *WorkshiftMutation) SetEmployeeID(id int) {
	m.employee = &id
}

// ClearEmployee clears the "employee" edge to the Employee entity.
func (m *WorkshiftMutation) ClearEmployee() {
	m.clearedemployee = true
}

// EmployeeCleared reports if the "employee" edge to the Employee entity was cleared.
func (m *WorkshiftMutation) EmployeeCleared() bool {
	return m.clearedemployee
}

// EmployeeID returns the "employee" edge ID in the mutation.
func (m *WorkshiftMutation) EmployeeID() (id int, exists bool) {
	if m.employee != nil {
		return *m.employee, true
	}
	return
}

// EmployeeIDs returns the "employee" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// EmployeeID instead. It exists only for internal usage by the builders.
func (m *WorkshiftMutation) EmployeeIDs() (ids []int) {
	if id := m.employee; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEmployee resets all changes to the "employee" edge.
func (m *WorkshiftMutation) ResetEmployee() {
	m.employee = nil
	m.clearedemployee = false
}

// SetApprovedByID sets the "approvedBy" edge to the Employee entity by id.
func (m *WorkshiftMutation) SetApprovedByID(id int) {
	m.approvedBy = &id
}

// ClearApprovedBy clears the "approvedBy" edge to the Employee entity.
func (m *WorkshiftMutation) ClearApprovedBy() {
	m.clearedapprovedBy = true
}

// ApprovedByCleared reports if the "approvedBy" edge to the Employee entity was cleared.
func (m *WorkshiftMutation) ApprovedByCleared() bool {
	return m.clearedapprovedBy
}

// ApprovedByID returns the "approvedBy" edge ID in the mutation.
func (m *WorkshiftMutation) ApprovedByID() (id int, exists bool) {
	if m.approvedBy != nil {
		return *m.approvedBy, true
	}
	return
}

// ApprovedByIDs returns the "approvedBy" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ApprovedByID instead. It exists only for internal usage by the builders.
func (m *WorkshiftMutation) ApprovedByIDs() (ids []int) {
	if id := m.approvedBy; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetApprovedBy resets all changes to the "approvedBy" edge.
func (m *WorkshiftMutation) ResetApprovedBy() {
	m.approvedBy = nil
	m.clearedapprovedBy = false
}

// SetWorkTaskID sets the "workTask" edge to the Worktask entity by id.
func (m *WorkshiftMutation) SetWorkTaskID(id int) {
	m.workTask = &id
}

// ClearWorkTask clears the "workTask" edge to the Worktask entity.
func (m *WorkshiftMutation) ClearWorkTask() {
	m.clearedworkTask = true
}

// WorkTaskCleared reports if the "workTask" edge to the Worktask entity was cleared.
func (m *WorkshiftMutation) WorkTaskCleared() bool {
	return m.clearedworkTask
}

// WorkTaskID returns the "workTask" edge ID in the mutation.
func (m *WorkshiftMutation) WorkTaskID() (id int, exists bool) {
	if m.workTask != nil {
		return *m.workTask, true
	}
	return
}

// WorkTaskIDs returns the "workTask" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// WorkTaskID instead. It exists only for internal usage by the builders.
func (m *WorkshiftMutation) WorkTaskIDs() (ids []int) {
	if id := m.workTask; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetWorkTask resets all changes to the "workTask" edge.
func (m *WorkshiftMutation) ResetWorkTask() {
	m.workTask = nil
	m.clearedworkTask = false
}

// SetEditRequestID sets the "editRequest" edge to the Workshift entity by id.
func (m *WorkshiftMutation) SetEditRequestID(id int) {
	m.editRequest = &id
}

// ClearEditRequest clears the "editRequest" edge to the Workshift entity.
func (m *WorkshiftMutation) ClearEditRequest() {
	m.clearededitRequest = true
}

// EditRequestCleared reports if the "editRequest" edge to the Workshift entity was cleared.
func (m *WorkshiftMutation) EditRequestCleared() bool {
	return m.clearededitRequest
}

// EditRequestID returns the "editRequest" edge ID in the mutation.
func (m *WorkshiftMutation) EditRequestID() (id int, exists bool) {
	if m.editRequest != nil {
		return *m.editRequest, true
	}
	return
}

// EditRequestIDs returns the "editRequest" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// EditRequestID instead. It exists only for internal usage by the builders.
func (m *WorkshiftMutation) EditRequestIDs() (ids []int) {
	if id := m.editRequest; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEditRequest resets all changes to the "editRequest" edge.
func (m *WorkshiftMutation) ResetEditRequest() {
	m.editRequest = nil
	m.clearededitRequest = false
}

// SetWorkShiftID sets the "workShift" edge to the Workshift entity by id.
func (m *WorkshiftMutation) SetWorkShiftID(id int) {
	m.workShift = &id
}

// ClearWorkShift clears the "workShift" edge to the Workshift entity.
func (m *WorkshiftMutation) ClearWorkShift() {
	m.clearedworkShift = true
}

// WorkShiftCleared reports if the "workShift" edge to the Workshift entity was cleared.
func (m *WorkshiftMutation) WorkShiftCleared() bool {
	return m.clearedworkShift
}

// WorkShiftID returns the "workShift" edge ID in the mutation.
func (m *WorkshiftMutation) WorkShiftID() (id int, exists bool) {
	if m.workShift != nil {
		return *m.workShift, true
	}
	return
}

// WorkShiftIDs returns the "workShift" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// WorkShiftID instead. It exists only for internal usage by the builders.
func (m *WorkshiftMutation) WorkShiftIDs() (ids []int) {
	if id := m.workShift; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetWorkShift resets all changes to the "workShift" edge.
func (m *WorkshiftMutation) ResetWorkShift() {
	m.workShift = nil
	m.clearedworkShift = false
}

// Where appends a list predicates to the WorkshiftMutation builder.
func (m *WorkshiftMutation) Where(ps ...predicate.Workshift) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the WorkshiftMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *WorkshiftMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Workshift, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *WorkshiftMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *WorkshiftMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Workshift).
func (m *WorkshiftMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *WorkshiftMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.createdAt != nil {
		fields = append(fields, workshift.FieldCreatedAt)
	}
	if m.updatedAt != nil {
		fields = append(fields, workshift.FieldUpdatedAt)
	}
	if m.deletedAt != nil {
		fields = append(fields, workshift.FieldDeletedAt)
	}
	if m.approvedAt != nil {
		fields = append(fields, workshift.FieldApprovedAt)
	}
	if m.clockIn != nil {
		fields = append(fields, workshift.FieldClockIn)
	}
	if m.clockOut != nil {
		fields = append(fields, workshift.FieldClockOut)
	}
	if m.clockInLocation != nil {
		fields = append(fields, workshift.FieldClockInLocation)
	}
	if m.clockOutLocation != nil {
		fields = append(fields, workshift.FieldClockOutLocation)
	}
	if m.description != nil {
		fields = append(fields, workshift.FieldDescription)
	}
	if m.note != nil {
		fields = append(fields, workshift.FieldNote)
	}
	if m.status != nil {
		fields = append(fields, workshift.FieldStatus)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *WorkshiftMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case workshift.FieldCreatedAt:
		return m.CreatedAt()
	case workshift.FieldUpdatedAt:
		return m.UpdatedAt()
	case workshift.FieldDeletedAt:
		return m.DeletedAt()
	case workshift.FieldApprovedAt:
		return m.ApprovedAt()
	case workshift.FieldClockIn:
		return m.ClockIn()
	case workshift.FieldClockOut:
		return m.ClockOut()
	case workshift.FieldClockInLocation:
		return m.ClockInLocation()
	case workshift.FieldClockOutLocation:
		return m.ClockOutLocation()
	case workshift.FieldDescription:
		return m.Description()
	case workshift.FieldNote:
		return m.Note()
	case workshift.FieldStatus:
		return m.Status()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *WorkshiftMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case workshift.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case workshift.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case workshift.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case workshift.FieldApprovedAt:
		return m.OldApprovedAt(ctx)
	case workshift.FieldClockIn:
		return m.OldClockIn(ctx)
	case workshift.FieldClockOut:
		return m.OldClockOut(ctx)
	case workshift.FieldClockInLocation:
		return m.OldClockInLocation(ctx)
	case workshift.FieldClockOutLocation:
		return m.OldClockOutLocation(ctx)
	case workshift.FieldDescription:
		return m.OldDescription(ctx)
	case workshift.FieldNote:
		return m.OldNote(ctx)
	case workshift.FieldStatus:
		return m.OldStatus(ctx)
	}
	return nil, fmt.Errorf("unknown Workshift field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WorkshiftMutation) SetField(name string, value ent.Value) error {
	switch name {
	case workshift.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case workshift.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case workshift.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case workshift.FieldApprovedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetApprovedAt(v)
		return nil
	case workshift.FieldClockIn:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClockIn(v)
		return nil
	case workshift.FieldClockOut:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClockOut(v)
		return nil
	case workshift.FieldClockInLocation:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClockInLocation(v)
		return nil
	case workshift.FieldClockOutLocation:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClockOutLocation(v)
		return nil
	case workshift.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case workshift.FieldNote:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNote(v)
		return nil
	case workshift.FieldStatus:
		v, ok := value.(workshift.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	}
	return fmt.Errorf("unknown Workshift field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *WorkshiftMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *WorkshiftMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WorkshiftMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Workshift numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *WorkshiftMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(workshift.FieldDeletedAt) {
		fields = append(fields, workshift.FieldDeletedAt)
	}
	if m.FieldCleared(workshift.FieldApprovedAt) {
		fields = append(fields, workshift.FieldApprovedAt)
	}
	if m.FieldCleared(workshift.FieldClockOut) {
		fields = append(fields, workshift.FieldClockOut)
	}
	if m.FieldCleared(workshift.FieldClockOutLocation) {
		fields = append(fields, workshift.FieldClockOutLocation)
	}
	if m.FieldCleared(workshift.FieldDescription) {
		fields = append(fields, workshift.FieldDescription)
	}
	if m.FieldCleared(workshift.FieldNote) {
		fields = append(fields, workshift.FieldNote)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *WorkshiftMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *WorkshiftMutation) ClearField(name string) error {
	switch name {
	case workshift.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case workshift.FieldApprovedAt:
		m.ClearApprovedAt()
		return nil
	case workshift.FieldClockOut:
		m.ClearClockOut()
		return nil
	case workshift.FieldClockOutLocation:
		m.ClearClockOutLocation()
		return nil
	case workshift.FieldDescription:
		m.ClearDescription()
		return nil
	case workshift.FieldNote:
		m.ClearNote()
		return nil
	}
	return fmt.Errorf("unknown Workshift nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *WorkshiftMutation) ResetField(name string) error {
	switch name {
	case workshift.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case workshift.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case workshift.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case workshift.FieldApprovedAt:
		m.ResetApprovedAt()
		return nil
	case workshift.FieldClockIn:
		m.ResetClockIn()
		return nil
	case workshift.FieldClockOut:
		m.ResetClockOut()
		return nil
	case workshift.FieldClockInLocation:
		m.ResetClockInLocation()
		return nil
	case workshift.FieldClockOutLocation:
		m.ResetClockOutLocation()
		return nil
	case workshift.FieldDescription:
		m.ResetDescription()
		return nil
	case workshift.FieldNote:
		m.ResetNote()
		return nil
	case workshift.FieldStatus:
		m.ResetStatus()
		return nil
	}
	return fmt.Errorf("unknown Workshift field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *WorkshiftMutation) AddedEdges() []string {
	edges := make([]string, 0, 6)
	if m.company != nil {
		edges = append(edges, workshift.EdgeCompany)
	}
	if m.employee != nil {
		edges = append(edges, workshift.EdgeEmployee)
	}
	if m.approvedBy != nil {
		edges = append(edges, workshift.EdgeApprovedBy)
	}
	if m.workTask != nil {
		edges = append(edges, workshift.EdgeWorkTask)
	}
	if m.editRequest != nil {
		edges = append(edges, workshift.EdgeEditRequest)
	}
	if m.workShift != nil {
		edges = append(edges, workshift.EdgeWorkShift)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *WorkshiftMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case workshift.EdgeCompany:
		if id := m.company; id != nil {
			return []ent.Value{*id}
		}
	case workshift.EdgeEmployee:
		if id := m.employee; id != nil {
			return []ent.Value{*id}
		}
	case workshift.EdgeApprovedBy:
		if id := m.approvedBy; id != nil {
			return []ent.Value{*id}
		}
	case workshift.EdgeWorkTask:
		if id := m.workTask; id != nil {
			return []ent.Value{*id}
		}
	case workshift.EdgeEditRequest:
		if id := m.editRequest; id != nil {
			return []ent.Value{*id}
		}
	case workshift.EdgeWorkShift:
		if id := m.workShift; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *WorkshiftMutation) RemovedEdges() []string {
	edges := make([]string, 0, 6)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *WorkshiftMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *WorkshiftMutation) ClearedEdges() []string {
	edges := make([]string, 0, 6)
	if m.clearedcompany {
		edges = append(edges, workshift.EdgeCompany)
	}
	if m.clearedemployee {
		edges = append(edges, workshift.EdgeEmployee)
	}
	if m.clearedapprovedBy {
		edges = append(edges, workshift.EdgeApprovedBy)
	}
	if m.clearedworkTask {
		edges = append(edges, workshift.EdgeWorkTask)
	}
	if m.clearededitRequest {
		edges = append(edges, workshift.EdgeEditRequest)
	}
	if m.clearedworkShift {
		edges = append(edges, workshift.EdgeWorkShift)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *WorkshiftMutation) EdgeCleared(name string) bool {
	switch name {
	case workshift.EdgeCompany:
		return m.clearedcompany
	case workshift.EdgeEmployee:
		return m.clearedemployee
	case workshift.EdgeApprovedBy:
		return m.clearedapprovedBy
	case workshift.EdgeWorkTask:
		return m.clearedworkTask
	case workshift.EdgeEditRequest:
		return m.clearededitRequest
	case workshift.EdgeWorkShift:
		return m.clearedworkShift
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *WorkshiftMutation) ClearEdge(name string) error {
	switch name {
	case workshift.EdgeCompany:
		m.ClearCompany()
		return nil
	case workshift.EdgeEmployee:
		m.ClearEmployee()
		return nil
	case workshift.EdgeApprovedBy:
		m.ClearApprovedBy()
		return nil
	case workshift.EdgeWorkTask:
		m.ClearWorkTask()
		return nil
	case workshift.EdgeEditRequest:
		m.ClearEditRequest()
		return nil
	case workshift.EdgeWorkShift:
		m.ClearWorkShift()
		return nil
	}
	return fmt.Errorf("unknown Workshift unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *WorkshiftMutation) ResetEdge(name string) error {
	switch name {
	case workshift.EdgeCompany:
		m.ResetCompany()
		return nil
	case workshift.EdgeEmployee:
		m.ResetEmployee()
		return nil
	case workshift.EdgeApprovedBy:
		m.ResetApprovedBy()
		return nil
	case workshift.EdgeWorkTask:
		m.ResetWorkTask()
		return nil
	case workshift.EdgeEditRequest:
		m.ResetEditRequest()
		return nil
	case workshift.EdgeWorkShift:
		m.ResetWorkShift()
		return nil
	}
	return fmt.Errorf("unknown Workshift edge %s", name)
}

// WorktagMutation represents an operation that mutates the Worktag nodes in the graph.
type WorktagMutation struct {
	config
	op               Op
	typ              string
	id               *int
	createdAt        *time.Time
	updatedAt        *time.Time
	deletedAt        *time.Time
	name             *string
	color            *string
	clearedFields    map[string]struct{}
	company          *int
	clearedcompany   bool
	workTasks        map[int]struct{}
	removedworkTasks map[int]struct{}
	clearedworkTasks bool
	done             bool
	oldValue         func(context.Context) (*Worktag, error)
	predicates       []predicate.Worktag
}

var _ ent.Mutation = (*WorktagMutation)(nil)

// worktagOption allows management of the mutation configuration using functional options.
type worktagOption func(*WorktagMutation)

// newWorktagMutation creates new mutation for the Worktag entity.
func newWorktagMutation(c config, op Op, opts ...worktagOption) *WorktagMutation {
	m := &WorktagMutation{
		config:        c,
		op:            op,
		typ:           TypeWorktag,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withWorktagID sets the ID field of the mutation.
func withWorktagID(id int) worktagOption {
	return func(m *WorktagMutation) {
		var (
			err   error
			once  sync.Once
			value *Worktag
		)
		m.oldValue = func(ctx context.Context) (*Worktag, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Worktag.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withWorktag sets the old Worktag of the mutation.
func withWorktag(node *Worktag) worktagOption {
	return func(m *WorktagMutation) {
		m.oldValue = func(context.Context) (*Worktag, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m WorktagMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m WorktagMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *WorktagMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *WorktagMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Worktag.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "createdAt" field.
func (m *WorktagMutation) SetCreatedAt(t time.Time) {
	m.createdAt = &t
}

// CreatedAt returns the value of the "createdAt" field in the mutation.
func (m *WorktagMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.createdAt
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "createdAt" field's value of the Worktag entity.
// If the Worktag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorktagMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "createdAt" field.
func (m *WorktagMutation) ResetCreatedAt() {
	m.createdAt = nil
}

// SetUpdatedAt sets the "updatedAt" field.
func (m *WorktagMutation) SetUpdatedAt(t time.Time) {
	m.updatedAt = &t
}

// UpdatedAt returns the value of the "updatedAt" field in the mutation.
func (m *WorktagMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updatedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updatedAt" field's value of the Worktag entity.
// If the Worktag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorktagMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updatedAt" field.
func (m *WorktagMutation) ResetUpdatedAt() {
	m.updatedAt = nil
}

// SetDeletedAt sets the "deletedAt" field.
func (m *WorktagMutation) SetDeletedAt(t time.Time) {
	m.deletedAt = &t
}

// DeletedAt returns the value of the "deletedAt" field in the mutation.
func (m *WorktagMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deletedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deletedAt" field's value of the Worktag entity.
// If the Worktag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorktagMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deletedAt" field.
func (m *WorktagMutation) ClearDeletedAt() {
	m.deletedAt = nil
	m.clearedFields[worktag.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deletedAt" field was cleared in this mutation.
func (m *WorktagMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[worktag.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deletedAt" field.
func (m *WorktagMutation) ResetDeletedAt() {
	m.deletedAt = nil
	delete(m.clearedFields, worktag.FieldDeletedAt)
}

// SetName sets the "name" field.
func (m *WorktagMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *WorktagMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Worktag entity.
// If the Worktag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorktagMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *WorktagMutation) ResetName() {
	m.name = nil
}

// SetColor sets the "color" field.
func (m *WorktagMutation) SetColor(s string) {
	m.color = &s
}

// Color returns the value of the "color" field in the mutation.
func (m *WorktagMutation) Color() (r string, exists bool) {
	v := m.color
	if v == nil {
		return
	}
	return *v, true
}

// OldColor returns the old "color" field's value of the Worktag entity.
// If the Worktag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorktagMutation) OldColor(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldColor is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldColor requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldColor: %w", err)
	}
	return oldValue.Color, nil
}

// ResetColor resets all changes to the "color" field.
func (m *WorktagMutation) ResetColor() {
	m.color = nil
}

// SetCompanyID sets the "company" edge to the Company entity by id.
func (m *WorktagMutation) SetCompanyID(id int) {
	m.company = &id
}

// ClearCompany clears the "company" edge to the Company entity.
func (m *WorktagMutation) ClearCompany() {
	m.clearedcompany = true
}

// CompanyCleared reports if the "company" edge to the Company entity was cleared.
func (m *WorktagMutation) CompanyCleared() bool {
	return m.clearedcompany
}

// CompanyID returns the "company" edge ID in the mutation.
func (m *WorktagMutation) CompanyID() (id int, exists bool) {
	if m.company != nil {
		return *m.company, true
	}
	return
}

// CompanyIDs returns the "company" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CompanyID instead. It exists only for internal usage by the builders.
func (m *WorktagMutation) CompanyIDs() (ids []int) {
	if id := m.company; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCompany resets all changes to the "company" edge.
func (m *WorktagMutation) ResetCompany() {
	m.company = nil
	m.clearedcompany = false
}

// AddWorkTaskIDs adds the "workTasks" edge to the Worktask entity by ids.
func (m *WorktagMutation) AddWorkTaskIDs(ids ...int) {
	if m.workTasks == nil {
		m.workTasks = make(map[int]struct{})
	}
	for i := range ids {
		m.workTasks[ids[i]] = struct{}{}
	}
}

// ClearWorkTasks clears the "workTasks" edge to the Worktask entity.
func (m *WorktagMutation) ClearWorkTasks() {
	m.clearedworkTasks = true
}

// WorkTasksCleared reports if the "workTasks" edge to the Worktask entity was cleared.
func (m *WorktagMutation) WorkTasksCleared() bool {
	return m.clearedworkTasks
}

// RemoveWorkTaskIDs removes the "workTasks" edge to the Worktask entity by IDs.
func (m *WorktagMutation) RemoveWorkTaskIDs(ids ...int) {
	if m.removedworkTasks == nil {
		m.removedworkTasks = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.workTasks, ids[i])
		m.removedworkTasks[ids[i]] = struct{}{}
	}
}

// RemovedWorkTasks returns the removed IDs of the "workTasks" edge to the Worktask entity.
func (m *WorktagMutation) RemovedWorkTasksIDs() (ids []int) {
	for id := range m.removedworkTasks {
		ids = append(ids, id)
	}
	return
}

// WorkTasksIDs returns the "workTasks" edge IDs in the mutation.
func (m *WorktagMutation) WorkTasksIDs() (ids []int) {
	for id := range m.workTasks {
		ids = append(ids, id)
	}
	return
}

// ResetWorkTasks resets all changes to the "workTasks" edge.
func (m *WorktagMutation) ResetWorkTasks() {
	m.workTasks = nil
	m.clearedworkTasks = false
	m.removedworkTasks = nil
}

// Where appends a list predicates to the WorktagMutation builder.
func (m *WorktagMutation) Where(ps ...predicate.Worktag) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the WorktagMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *WorktagMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Worktag, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *WorktagMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *WorktagMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Worktag).
func (m *WorktagMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *WorktagMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.createdAt != nil {
		fields = append(fields, worktag.FieldCreatedAt)
	}
	if m.updatedAt != nil {
		fields = append(fields, worktag.FieldUpdatedAt)
	}
	if m.deletedAt != nil {
		fields = append(fields, worktag.FieldDeletedAt)
	}
	if m.name != nil {
		fields = append(fields, worktag.FieldName)
	}
	if m.color != nil {
		fields = append(fields, worktag.FieldColor)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *WorktagMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case worktag.FieldCreatedAt:
		return m.CreatedAt()
	case worktag.FieldUpdatedAt:
		return m.UpdatedAt()
	case worktag.FieldDeletedAt:
		return m.DeletedAt()
	case worktag.FieldName:
		return m.Name()
	case worktag.FieldColor:
		return m.Color()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *WorktagMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case worktag.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case worktag.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case worktag.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case worktag.FieldName:
		return m.OldName(ctx)
	case worktag.FieldColor:
		return m.OldColor(ctx)
	}
	return nil, fmt.Errorf("unknown Worktag field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WorktagMutation) SetField(name string, value ent.Value) error {
	switch name {
	case worktag.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case worktag.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case worktag.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case worktag.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case worktag.FieldColor:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetColor(v)
		return nil
	}
	return fmt.Errorf("unknown Worktag field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *WorktagMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *WorktagMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WorktagMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Worktag numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *WorktagMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(worktag.FieldDeletedAt) {
		fields = append(fields, worktag.FieldDeletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *WorktagMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *WorktagMutation) ClearField(name string) error {
	switch name {
	case worktag.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown Worktag nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *WorktagMutation) ResetField(name string) error {
	switch name {
	case worktag.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case worktag.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case worktag.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case worktag.FieldName:
		m.ResetName()
		return nil
	case worktag.FieldColor:
		m.ResetColor()
		return nil
	}
	return fmt.Errorf("unknown Worktag field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *WorktagMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.company != nil {
		edges = append(edges, worktag.EdgeCompany)
	}
	if m.workTasks != nil {
		edges = append(edges, worktag.EdgeWorkTasks)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *WorktagMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case worktag.EdgeCompany:
		if id := m.company; id != nil {
			return []ent.Value{*id}
		}
	case worktag.EdgeWorkTasks:
		ids := make([]ent.Value, 0, len(m.workTasks))
		for id := range m.workTasks {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *WorktagMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedworkTasks != nil {
		edges = append(edges, worktag.EdgeWorkTasks)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *WorktagMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case worktag.EdgeWorkTasks:
		ids := make([]ent.Value, 0, len(m.removedworkTasks))
		for id := range m.removedworkTasks {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *WorktagMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedcompany {
		edges = append(edges, worktag.EdgeCompany)
	}
	if m.clearedworkTasks {
		edges = append(edges, worktag.EdgeWorkTasks)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *WorktagMutation) EdgeCleared(name string) bool {
	switch name {
	case worktag.EdgeCompany:
		return m.clearedcompany
	case worktag.EdgeWorkTasks:
		return m.clearedworkTasks
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *WorktagMutation) ClearEdge(name string) error {
	switch name {
	case worktag.EdgeCompany:
		m.ClearCompany()
		return nil
	}
	return fmt.Errorf("unknown Worktag unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *WorktagMutation) ResetEdge(name string) error {
	switch name {
	case worktag.EdgeCompany:
		m.ResetCompany()
		return nil
	case worktag.EdgeWorkTasks:
		m.ResetWorkTasks()
		return nil
	}
	return fmt.Errorf("unknown Worktag edge %s", name)
}

// WorktaskMutation represents an operation that mutates the Worktask nodes in the graph.
type WorktaskMutation struct {
	config
	op                Op
	typ               string
	id                *int
	createdAt         *time.Time
	updatedAt         *time.Time
	deletedAt         *time.Time
	description       *string
	status            *worktask.Status
	subtasks          *[]string
	appendsubtasks    []string
	title             *string
	startTime         *time.Time
	endTime           *time.Time
	clearedFields     map[string]struct{}
	company           *int
	clearedcompany    bool
	createdBy         *int
	clearedcreatedBy  bool
	assignedTo        map[int]struct{}
	removedassignedTo map[int]struct{}
	clearedassignedTo bool
	workShifts        map[int]struct{}
	removedworkShifts map[int]struct{}
	clearedworkShifts bool
	workTags          map[int]struct{}
	removedworkTags   map[int]struct{}
	clearedworkTags   bool
	done              bool
	oldValue          func(context.Context) (*Worktask, error)
	predicates        []predicate.Worktask
}

var _ ent.Mutation = (*WorktaskMutation)(nil)

// worktaskOption allows management of the mutation configuration using functional options.
type worktaskOption func(*WorktaskMutation)

// newWorktaskMutation creates new mutation for the Worktask entity.
func newWorktaskMutation(c config, op Op, opts ...worktaskOption) *WorktaskMutation {
	m := &WorktaskMutation{
		config:        c,
		op:            op,
		typ:           TypeWorktask,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withWorktaskID sets the ID field of the mutation.
func withWorktaskID(id int) worktaskOption {
	return func(m *WorktaskMutation) {
		var (
			err   error
			once  sync.Once
			value *Worktask
		)
		m.oldValue = func(ctx context.Context) (*Worktask, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Worktask.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withWorktask sets the old Worktask of the mutation.
func withWorktask(node *Worktask) worktaskOption {
	return func(m *WorktaskMutation) {
		m.oldValue = func(context.Context) (*Worktask, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m WorktaskMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m WorktaskMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *WorktaskMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *WorktaskMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Worktask.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "createdAt" field.
func (m *WorktaskMutation) SetCreatedAt(t time.Time) {
	m.createdAt = &t
}

// CreatedAt returns the value of the "createdAt" field in the mutation.
func (m *WorktaskMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.createdAt
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "createdAt" field's value of the Worktask entity.
// If the Worktask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorktaskMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "createdAt" field.
func (m *WorktaskMutation) ResetCreatedAt() {
	m.createdAt = nil
}

// SetUpdatedAt sets the "updatedAt" field.
func (m *WorktaskMutation) SetUpdatedAt(t time.Time) {
	m.updatedAt = &t
}

// UpdatedAt returns the value of the "updatedAt" field in the mutation.
func (m *WorktaskMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updatedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updatedAt" field's value of the Worktask entity.
// If the Worktask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorktaskMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updatedAt" field.
func (m *WorktaskMutation) ResetUpdatedAt() {
	m.updatedAt = nil
}

// SetDeletedAt sets the "deletedAt" field.
func (m *WorktaskMutation) SetDeletedAt(t time.Time) {
	m.deletedAt = &t
}

// DeletedAt returns the value of the "deletedAt" field in the mutation.
func (m *WorktaskMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deletedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deletedAt" field's value of the Worktask entity.
// If the Worktask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorktaskMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deletedAt" field.
func (m *WorktaskMutation) ClearDeletedAt() {
	m.deletedAt = nil
	m.clearedFields[worktask.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deletedAt" field was cleared in this mutation.
func (m *WorktaskMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[worktask.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deletedAt" field.
func (m *WorktaskMutation) ResetDeletedAt() {
	m.deletedAt = nil
	delete(m.clearedFields, worktask.FieldDeletedAt)
}

// SetDescription sets the "description" field.
func (m *WorktaskMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *WorktaskMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Worktask entity.
// If the Worktask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorktaskMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *WorktaskMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[worktask.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *WorktaskMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[worktask.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *WorktaskMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, worktask.FieldDescription)
}

// SetStatus sets the "status" field.
func (m *WorktaskMutation) SetStatus(w worktask.Status) {
	m.status = &w
}

// Status returns the value of the "status" field in the mutation.
func (m *WorktaskMutation) Status() (r worktask.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Worktask entity.
// If the Worktask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorktaskMutation) OldStatus(ctx context.Context) (v worktask.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *WorktaskMutation) ResetStatus() {
	m.status = nil
}

// SetSubtasks sets the "subtasks" field.
func (m *WorktaskMutation) SetSubtasks(s []string) {
	m.subtasks = &s
	m.appendsubtasks = nil
}

// Subtasks returns the value of the "subtasks" field in the mutation.
func (m *WorktaskMutation) Subtasks() (r []string, exists bool) {
	v := m.subtasks
	if v == nil {
		return
	}
	return *v, true
}

// OldSubtasks returns the old "subtasks" field's value of the Worktask entity.
// If the Worktask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorktaskMutation) OldSubtasks(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSubtasks is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSubtasks requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSubtasks: %w", err)
	}
	return oldValue.Subtasks, nil
}

// AppendSubtasks adds s to the "subtasks" field.
func (m *WorktaskMutation) AppendSubtasks(s []string) {
	m.appendsubtasks = append(m.appendsubtasks, s...)
}

// AppendedSubtasks returns the list of values that were appended to the "subtasks" field in this mutation.
func (m *WorktaskMutation) AppendedSubtasks() ([]string, bool) {
	if len(m.appendsubtasks) == 0 {
		return nil, false
	}
	return m.appendsubtasks, true
}

// ClearSubtasks clears the value of the "subtasks" field.
func (m *WorktaskMutation) ClearSubtasks() {
	m.subtasks = nil
	m.appendsubtasks = nil
	m.clearedFields[worktask.FieldSubtasks] = struct{}{}
}

// SubtasksCleared returns if the "subtasks" field was cleared in this mutation.
func (m *WorktaskMutation) SubtasksCleared() bool {
	_, ok := m.clearedFields[worktask.FieldSubtasks]
	return ok
}

// ResetSubtasks resets all changes to the "subtasks" field.
func (m *WorktaskMutation) ResetSubtasks() {
	m.subtasks = nil
	m.appendsubtasks = nil
	delete(m.clearedFields, worktask.FieldSubtasks)
}

// SetTitle sets the "title" field.
func (m *WorktaskMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *WorktaskMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the Worktask entity.
// If the Worktask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorktaskMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *WorktaskMutation) ResetTitle() {
	m.title = nil
}

// SetStartTime sets the "startTime" field.
func (m *WorktaskMutation) SetStartTime(t time.Time) {
	m.startTime = &t
}

// StartTime returns the value of the "startTime" field in the mutation.
func (m *WorktaskMutation) StartTime() (r time.Time, exists bool) {
	v := m.startTime
	if v == nil {
		return
	}
	return *v, true
}

// OldStartTime returns the old "startTime" field's value of the Worktask entity.
// If the Worktask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorktaskMutation) OldStartTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartTime: %w", err)
	}
	return oldValue.StartTime, nil
}

// ResetStartTime resets all changes to the "startTime" field.
func (m *WorktaskMutation) ResetStartTime() {
	m.startTime = nil
}

// SetEndTime sets the "endTime" field.
func (m *WorktaskMutation) SetEndTime(t time.Time) {
	m.endTime = &t
}

// EndTime returns the value of the "endTime" field in the mutation.
func (m *WorktaskMutation) EndTime() (r time.Time, exists bool) {
	v := m.endTime
	if v == nil {
		return
	}
	return *v, true
}

// OldEndTime returns the old "endTime" field's value of the Worktask entity.
// If the Worktask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorktaskMutation) OldEndTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEndTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEndTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEndTime: %w", err)
	}
	return oldValue.EndTime, nil
}

// ClearEndTime clears the value of the "endTime" field.
func (m *WorktaskMutation) ClearEndTime() {
	m.endTime = nil
	m.clearedFields[worktask.FieldEndTime] = struct{}{}
}

// EndTimeCleared returns if the "endTime" field was cleared in this mutation.
func (m *WorktaskMutation) EndTimeCleared() bool {
	_, ok := m.clearedFields[worktask.FieldEndTime]
	return ok
}

// ResetEndTime resets all changes to the "endTime" field.
func (m *WorktaskMutation) ResetEndTime() {
	m.endTime = nil
	delete(m.clearedFields, worktask.FieldEndTime)
}

// SetCompanyID sets the "company" edge to the Company entity by id.
func (m *WorktaskMutation) SetCompanyID(id int) {
	m.company = &id
}

// ClearCompany clears the "company" edge to the Company entity.
func (m *WorktaskMutation) ClearCompany() {
	m.clearedcompany = true
}

// CompanyCleared reports if the "company" edge to the Company entity was cleared.
func (m *WorktaskMutation) CompanyCleared() bool {
	return m.clearedcompany
}

// CompanyID returns the "company" edge ID in the mutation.
func (m *WorktaskMutation) CompanyID() (id int, exists bool) {
	if m.company != nil {
		return *m.company, true
	}
	return
}

// CompanyIDs returns the "company" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CompanyID instead. It exists only for internal usage by the builders.
func (m *WorktaskMutation) CompanyIDs() (ids []int) {
	if id := m.company; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCompany resets all changes to the "company" edge.
func (m *WorktaskMutation) ResetCompany() {
	m.company = nil
	m.clearedcompany = false
}

// SetCreatedByID sets the "createdBy" edge to the User entity by id.
func (m *WorktaskMutation) SetCreatedByID(id int) {
	m.createdBy = &id
}

// ClearCreatedBy clears the "createdBy" edge to the User entity.
func (m *WorktaskMutation) ClearCreatedBy() {
	m.clearedcreatedBy = true
}

// CreatedByCleared reports if the "createdBy" edge to the User entity was cleared.
func (m *WorktaskMutation) CreatedByCleared() bool {
	return m.clearedcreatedBy
}

// CreatedByID returns the "createdBy" edge ID in the mutation.
func (m *WorktaskMutation) CreatedByID() (id int, exists bool) {
	if m.createdBy != nil {
		return *m.createdBy, true
	}
	return
}

// CreatedByIDs returns the "createdBy" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CreatedByID instead. It exists only for internal usage by the builders.
func (m *WorktaskMutation) CreatedByIDs() (ids []int) {
	if id := m.createdBy; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCreatedBy resets all changes to the "createdBy" edge.
func (m *WorktaskMutation) ResetCreatedBy() {
	m.createdBy = nil
	m.clearedcreatedBy = false
}

// AddAssignedToIDs adds the "assignedTo" edge to the Employee entity by ids.
func (m *WorktaskMutation) AddAssignedToIDs(ids ...int) {
	if m.assignedTo == nil {
		m.assignedTo = make(map[int]struct{})
	}
	for i := range ids {
		m.assignedTo[ids[i]] = struct{}{}
	}
}

// ClearAssignedTo clears the "assignedTo" edge to the Employee entity.
func (m *WorktaskMutation) ClearAssignedTo() {
	m.clearedassignedTo = true
}

// AssignedToCleared reports if the "assignedTo" edge to the Employee entity was cleared.
func (m *WorktaskMutation) AssignedToCleared() bool {
	return m.clearedassignedTo
}

// RemoveAssignedToIDs removes the "assignedTo" edge to the Employee entity by IDs.
func (m *WorktaskMutation) RemoveAssignedToIDs(ids ...int) {
	if m.removedassignedTo == nil {
		m.removedassignedTo = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.assignedTo, ids[i])
		m.removedassignedTo[ids[i]] = struct{}{}
	}
}

// RemovedAssignedTo returns the removed IDs of the "assignedTo" edge to the Employee entity.
func (m *WorktaskMutation) RemovedAssignedToIDs() (ids []int) {
	for id := range m.removedassignedTo {
		ids = append(ids, id)
	}
	return
}

// AssignedToIDs returns the "assignedTo" edge IDs in the mutation.
func (m *WorktaskMutation) AssignedToIDs() (ids []int) {
	for id := range m.assignedTo {
		ids = append(ids, id)
	}
	return
}

// ResetAssignedTo resets all changes to the "assignedTo" edge.
func (m *WorktaskMutation) ResetAssignedTo() {
	m.assignedTo = nil
	m.clearedassignedTo = false
	m.removedassignedTo = nil
}

// AddWorkShiftIDs adds the "workShifts" edge to the Workshift entity by ids.
func (m *WorktaskMutation) AddWorkShiftIDs(ids ...int) {
	if m.workShifts == nil {
		m.workShifts = make(map[int]struct{})
	}
	for i := range ids {
		m.workShifts[ids[i]] = struct{}{}
	}
}

// ClearWorkShifts clears the "workShifts" edge to the Workshift entity.
func (m *WorktaskMutation) ClearWorkShifts() {
	m.clearedworkShifts = true
}

// WorkShiftsCleared reports if the "workShifts" edge to the Workshift entity was cleared.
func (m *WorktaskMutation) WorkShiftsCleared() bool {
	return m.clearedworkShifts
}

// RemoveWorkShiftIDs removes the "workShifts" edge to the Workshift entity by IDs.
func (m *WorktaskMutation) RemoveWorkShiftIDs(ids ...int) {
	if m.removedworkShifts == nil {
		m.removedworkShifts = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.workShifts, ids[i])
		m.removedworkShifts[ids[i]] = struct{}{}
	}
}

// RemovedWorkShifts returns the removed IDs of the "workShifts" edge to the Workshift entity.
func (m *WorktaskMutation) RemovedWorkShiftsIDs() (ids []int) {
	for id := range m.removedworkShifts {
		ids = append(ids, id)
	}
	return
}

// WorkShiftsIDs returns the "workShifts" edge IDs in the mutation.
func (m *WorktaskMutation) WorkShiftsIDs() (ids []int) {
	for id := range m.workShifts {
		ids = append(ids, id)
	}
	return
}

// ResetWorkShifts resets all changes to the "workShifts" edge.
func (m *WorktaskMutation) ResetWorkShifts() {
	m.workShifts = nil
	m.clearedworkShifts = false
	m.removedworkShifts = nil
}

// AddWorkTagIDs adds the "workTags" edge to the Worktag entity by ids.
func (m *WorktaskMutation) AddWorkTagIDs(ids ...int) {
	if m.workTags == nil {
		m.workTags = make(map[int]struct{})
	}
	for i := range ids {
		m.workTags[ids[i]] = struct{}{}
	}
}

// ClearWorkTags clears the "workTags" edge to the Worktag entity.
func (m *WorktaskMutation) ClearWorkTags() {
	m.clearedworkTags = true
}

// WorkTagsCleared reports if the "workTags" edge to the Worktag entity was cleared.
func (m *WorktaskMutation) WorkTagsCleared() bool {
	return m.clearedworkTags
}

// RemoveWorkTagIDs removes the "workTags" edge to the Worktag entity by IDs.
func (m *WorktaskMutation) RemoveWorkTagIDs(ids ...int) {
	if m.removedworkTags == nil {
		m.removedworkTags = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.workTags, ids[i])
		m.removedworkTags[ids[i]] = struct{}{}
	}
}

// RemovedWorkTags returns the removed IDs of the "workTags" edge to the Worktag entity.
func (m *WorktaskMutation) RemovedWorkTagsIDs() (ids []int) {
	for id := range m.removedworkTags {
		ids = append(ids, id)
	}
	return
}

// WorkTagsIDs returns the "workTags" edge IDs in the mutation.
func (m *WorktaskMutation) WorkTagsIDs() (ids []int) {
	for id := range m.workTags {
		ids = append(ids, id)
	}
	return
}

// ResetWorkTags resets all changes to the "workTags" edge.
func (m *WorktaskMutation) ResetWorkTags() {
	m.workTags = nil
	m.clearedworkTags = false
	m.removedworkTags = nil
}

// Where appends a list predicates to the WorktaskMutation builder.
func (m *WorktaskMutation) Where(ps ...predicate.Worktask) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the WorktaskMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *WorktaskMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Worktask, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *WorktaskMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *WorktaskMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Worktask).
func (m *WorktaskMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *WorktaskMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.createdAt != nil {
		fields = append(fields, worktask.FieldCreatedAt)
	}
	if m.updatedAt != nil {
		fields = append(fields, worktask.FieldUpdatedAt)
	}
	if m.deletedAt != nil {
		fields = append(fields, worktask.FieldDeletedAt)
	}
	if m.description != nil {
		fields = append(fields, worktask.FieldDescription)
	}
	if m.status != nil {
		fields = append(fields, worktask.FieldStatus)
	}
	if m.subtasks != nil {
		fields = append(fields, worktask.FieldSubtasks)
	}
	if m.title != nil {
		fields = append(fields, worktask.FieldTitle)
	}
	if m.startTime != nil {
		fields = append(fields, worktask.FieldStartTime)
	}
	if m.endTime != nil {
		fields = append(fields, worktask.FieldEndTime)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *WorktaskMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case worktask.FieldCreatedAt:
		return m.CreatedAt()
	case worktask.FieldUpdatedAt:
		return m.UpdatedAt()
	case worktask.FieldDeletedAt:
		return m.DeletedAt()
	case worktask.FieldDescription:
		return m.Description()
	case worktask.FieldStatus:
		return m.Status()
	case worktask.FieldSubtasks:
		return m.Subtasks()
	case worktask.FieldTitle:
		return m.Title()
	case worktask.FieldStartTime:
		return m.StartTime()
	case worktask.FieldEndTime:
		return m.EndTime()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *WorktaskMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case worktask.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case worktask.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case worktask.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case worktask.FieldDescription:
		return m.OldDescription(ctx)
	case worktask.FieldStatus:
		return m.OldStatus(ctx)
	case worktask.FieldSubtasks:
		return m.OldSubtasks(ctx)
	case worktask.FieldTitle:
		return m.OldTitle(ctx)
	case worktask.FieldStartTime:
		return m.OldStartTime(ctx)
	case worktask.FieldEndTime:
		return m.OldEndTime(ctx)
	}
	return nil, fmt.Errorf("unknown Worktask field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WorktaskMutation) SetField(name string, value ent.Value) error {
	switch name {
	case worktask.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case worktask.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case worktask.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case worktask.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case worktask.FieldStatus:
		v, ok := value.(worktask.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case worktask.FieldSubtasks:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSubtasks(v)
		return nil
	case worktask.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case worktask.FieldStartTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartTime(v)
		return nil
	case worktask.FieldEndTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEndTime(v)
		return nil
	}
	return fmt.Errorf("unknown Worktask field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *WorktaskMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *WorktaskMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WorktaskMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Worktask numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *WorktaskMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(worktask.FieldDeletedAt) {
		fields = append(fields, worktask.FieldDeletedAt)
	}
	if m.FieldCleared(worktask.FieldDescription) {
		fields = append(fields, worktask.FieldDescription)
	}
	if m.FieldCleared(worktask.FieldSubtasks) {
		fields = append(fields, worktask.FieldSubtasks)
	}
	if m.FieldCleared(worktask.FieldEndTime) {
		fields = append(fields, worktask.FieldEndTime)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *WorktaskMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *WorktaskMutation) ClearField(name string) error {
	switch name {
	case worktask.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case worktask.FieldDescription:
		m.ClearDescription()
		return nil
	case worktask.FieldSubtasks:
		m.ClearSubtasks()
		return nil
	case worktask.FieldEndTime:
		m.ClearEndTime()
		return nil
	}
	return fmt.Errorf("unknown Worktask nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *WorktaskMutation) ResetField(name string) error {
	switch name {
	case worktask.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case worktask.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case worktask.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case worktask.FieldDescription:
		m.ResetDescription()
		return nil
	case worktask.FieldStatus:
		m.ResetStatus()
		return nil
	case worktask.FieldSubtasks:
		m.ResetSubtasks()
		return nil
	case worktask.FieldTitle:
		m.ResetTitle()
		return nil
	case worktask.FieldStartTime:
		m.ResetStartTime()
		return nil
	case worktask.FieldEndTime:
		m.ResetEndTime()
		return nil
	}
	return fmt.Errorf("unknown Worktask field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *WorktaskMutation) AddedEdges() []string {
	edges := make([]string, 0, 5)
	if m.company != nil {
		edges = append(edges, worktask.EdgeCompany)
	}
	if m.createdBy != nil {
		edges = append(edges, worktask.EdgeCreatedBy)
	}
	if m.assignedTo != nil {
		edges = append(edges, worktask.EdgeAssignedTo)
	}
	if m.workShifts != nil {
		edges = append(edges, worktask.EdgeWorkShifts)
	}
	if m.workTags != nil {
		edges = append(edges, worktask.EdgeWorkTags)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *WorktaskMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case worktask.EdgeCompany:
		if id := m.company; id != nil {
			return []ent.Value{*id}
		}
	case worktask.EdgeCreatedBy:
		if id := m.createdBy; id != nil {
			return []ent.Value{*id}
		}
	case worktask.EdgeAssignedTo:
		ids := make([]ent.Value, 0, len(m.assignedTo))
		for id := range m.assignedTo {
			ids = append(ids, id)
		}
		return ids
	case worktask.EdgeWorkShifts:
		ids := make([]ent.Value, 0, len(m.workShifts))
		for id := range m.workShifts {
			ids = append(ids, id)
		}
		return ids
	case worktask.EdgeWorkTags:
		ids := make([]ent.Value, 0, len(m.workTags))
		for id := range m.workTags {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *WorktaskMutation) RemovedEdges() []string {
	edges := make([]string, 0, 5)
	if m.removedassignedTo != nil {
		edges = append(edges, worktask.EdgeAssignedTo)
	}
	if m.removedworkShifts != nil {
		edges = append(edges, worktask.EdgeWorkShifts)
	}
	if m.removedworkTags != nil {
		edges = append(edges, worktask.EdgeWorkTags)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *WorktaskMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case worktask.EdgeAssignedTo:
		ids := make([]ent.Value, 0, len(m.removedassignedTo))
		for id := range m.removedassignedTo {
			ids = append(ids, id)
		}
		return ids
	case worktask.EdgeWorkShifts:
		ids := make([]ent.Value, 0, len(m.removedworkShifts))
		for id := range m.removedworkShifts {
			ids = append(ids, id)
		}
		return ids
	case worktask.EdgeWorkTags:
		ids := make([]ent.Value, 0, len(m.removedworkTags))
		for id := range m.removedworkTags {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *WorktaskMutation) ClearedEdges() []string {
	edges := make([]string, 0, 5)
	if m.clearedcompany {
		edges = append(edges, worktask.EdgeCompany)
	}
	if m.clearedcreatedBy {
		edges = append(edges, worktask.EdgeCreatedBy)
	}
	if m.clearedassignedTo {
		edges = append(edges, worktask.EdgeAssignedTo)
	}
	if m.clearedworkShifts {
		edges = append(edges, worktask.EdgeWorkShifts)
	}
	if m.clearedworkTags {
		edges = append(edges, worktask.EdgeWorkTags)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *WorktaskMutation) EdgeCleared(name string) bool {
	switch name {
	case worktask.EdgeCompany:
		return m.clearedcompany
	case worktask.EdgeCreatedBy:
		return m.clearedcreatedBy
	case worktask.EdgeAssignedTo:
		return m.clearedassignedTo
	case worktask.EdgeWorkShifts:
		return m.clearedworkShifts
	case worktask.EdgeWorkTags:
		return m.clearedworkTags
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *WorktaskMutation) ClearEdge(name string) error {
	switch name {
	case worktask.EdgeCompany:
		m.ClearCompany()
		return nil
	case worktask.EdgeCreatedBy:
		m.ClearCreatedBy()
		return nil
	}
	return fmt.Errorf("unknown Worktask unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *WorktaskMutation) ResetEdge(name string) error {
	switch name {
	case worktask.EdgeCompany:
		m.ResetCompany()
		return nil
	case worktask.EdgeCreatedBy:
		m.ResetCreatedBy()
		return nil
	case worktask.EdgeAssignedTo:
		m.ResetAssignedTo()
		return nil
	case worktask.EdgeWorkShifts:
		m.ResetWorkShifts()
		return nil
	case worktask.EdgeWorkTags:
		m.ResetWorkTags()
		return nil
	}
	return fmt.Errorf("unknown Worktask edge %s", name)
}
