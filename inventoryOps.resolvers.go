package mazza

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.52

import (
	"context"
	"fmt"
	accountingentry "mazza/app/accountingEntry"
	"mazza/ent/generated"
	"mazza/ent/generated/company"
	"mazza/ent/generated/inventory"
	"mazza/ent/utils"
	"mazza/mazza/generated/model"
)

// CreateInventoryMovement is the resolver for the createInventoryMovement field.
func (r *mutationResolver) CreateInventoryMovement(ctx context.Context, input generated.CreateInventoryMovementInput, accountingEntry *model.BaseEntryRegistrationInput) (*generated.InventoryMovement, error) {
	// _, activeCompany := utils.GetSession(&ctx)
	// var movement *generated.InventoryMovement
	// var quantity float64
	// var value float64

	// if input.Category == inventorymovement.CategoryOUT {
	// 	// Check if there is enough inventory for this movement
	// 	inventoryItem, err := r.client.Inventory.Query().Where(
	// 		inventory.ID(input.InventoryID),
	// 		inventory.HasCompanyWith(company.ID(activeCompany.ID)),
	// 		inventory.QuantityGTE(input.Quantity),
	// 	).First(ctx)
	// 	if err != nil {
	// 		fmt.Println("CreateInventoryMovement inventory err:", err)
	// 		return nil, fmt.Errorf("not enough inventory")
	// 	}

	// 	quantity = -input.Quantity
	// 	if inventoryItem.Quantity > 0 {
	// 		unitValue := inventoryItem.CurrentValue / inventoryItem.Quantity
	// 		value = unitValue * quantity
	// 	} else {
	// 		value = 0
	// 	}
	// } else {
	// 	quantity = input.Quantity
	// 	value = input.Value
	// }

	tx, err := r.client.Tx(ctx)
	if err != nil {
		fmt.Println("CreateInventoryMovement tx err:", err)
		return nil, fmt.Errorf("an error occurred")
	}

	movement, err := accountingentry.CreateInventoryMovement(ctx, tx, input, accountingEntry)
	if err != nil {
		fmt.Println("err:", err)
		return nil, fmt.Errorf("an error occurred")
	}

	// movement, err := tx.InventoryMovement.Create().
	// 	SetInput(input).
	// 	SetValue(math.Abs(value)).
	// 	SetCompanyID(activeCompany.ID).
	// 	Save(ctx)
	// if err != nil {
	// 	fmt.Println("err:", err)
	// 	return nil, err
	// }

	// // Update inventory
	// _, err = tx.Inventory.UpdateOneID(input.InventoryID).
	// 	Where(inventory.HasCompanyWith(company.ID(activeCompany.ID))).
	// 	AddQuantity(quantity).
	// 	AddCurrentValue(value).
	// 	Save(ctx)
	// if err != nil {
	// 	fmt.Println("err:", err)
	// 	return nil, err
	// }

	// if accountingEntry != nil {
	// 	// Create accounting entry
	// 	_, err = accountingentry.RegisterAccountingOperations(ctx, tx, *accountingEntry)
	// 	if err != nil {
	// 		fmt.Println("err:", err)
	// 		return nil, fmt.Errorf("an error occurred")
	// 	}
	// }

	err = tx.Commit()
	if err != nil {
		fmt.Println("err:", err)
		_ = tx.Rollback()
		return nil, fmt.Errorf("an error occurred")
	}

	return movement, nil
}

// CreateInventory is the resolver for the createInventory field.
func (r *mutationResolver) CreateInventory(ctx context.Context, input generated.CreateInventoryInput) (*generated.Inventory, error) {
	_, activeCompany := utils.GetSession(&ctx)
	newItem, err := r.client.Inventory.Create().
		SetInput(input).SetCompanyID(activeCompany.ID).
		Save(ctx)
	if err != nil {
		return nil, err
	}
	return newItem, nil
}

// UpdateInventory is the resolver for the updateInventory field.
func (r *mutationResolver) UpdateInventory(ctx context.Context, id int, input generated.UpdateInventoryInput) (*generated.Inventory, error) {
	_, activeCompany := utils.GetSession(&ctx)
	updatedItem, err := r.client.Inventory.UpdateOneID(id).
		Where(inventory.HasCompanyWith(company.ID(activeCompany.ID))).
		SetInput(input).
		Save(ctx)
	if err != nil {
		return nil, err
	}
	return updatedItem, nil
}

// DeleteInventory is the resolver for the deleteInventory field.
func (r *mutationResolver) DeleteInventory(ctx context.Context, id int) (bool, error) {
	_, activeCompany := utils.GetSession(&ctx)
	err := r.client.Inventory.DeleteOneID(id).
		Where(inventory.HasCompanyWith(company.ID(activeCompany.ID))).
		Exec(ctx)
	if err != nil {
		return false, err
	}
	return true, err
}

// CountInventoryCategories is the resolver for the countInventoryCategories field.
func (r *queryResolver) CountInventoryCategories(ctx context.Context) ([]*model.InventoryCategoryCount, error) {
	_, currentCompany := utils.GetSession(&ctx)
	var output []*model.InventoryCategoryCount
	companyFilter := inventory.HasCompanyWith(company.ID(currentCompany.ID))

	err := r.client.Inventory.Query().Where(companyFilter).
		GroupBy(inventory.FieldCategory).
		Aggregate(generated.Count()).
		Scan(ctx, &output)
	if err != nil {
		fmt.Println("CountInvoices err:", err)
		return nil, err
	}

	return output, nil
}
