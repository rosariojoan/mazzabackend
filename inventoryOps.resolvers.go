package mazza

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.52

import (
	"context"
	"fmt"
	accountingentry "mazza/app/accountingEntry"
	"mazza/ent/generated"
	"mazza/ent/generated/company"
	"mazza/ent/generated/inventory"
	"mazza/ent/utils"
	"mazza/mazza/generated/model"
)

// CreateInventory is the resolver for the createInventory field.
func (r *mutationResolver) CreateInventory(ctx context.Context, input generated.CreateInventoryInput) (*generated.Inventory, error) {
	_, activeCompany := utils.GetSession(&ctx)
	newItem, err := r.client.Inventory.Create().
		SetInput(input).SetCompanyID(activeCompany.ID).
		Save(ctx)
	if err != nil {
		return nil, err
	}
	return newItem, nil
}

// UpdateInventory is the resolver for the updateInventory field.
func (r *mutationResolver) UpdateInventory(ctx context.Context, id int, input generated.UpdateInventoryInput) (*generated.Inventory, error) {
	_, activeCompany := utils.GetSession(&ctx)
	updatedItem, err := r.client.Inventory.UpdateOneID(id).
		Where(inventory.HasCompanyWith(company.ID(activeCompany.ID))).
		SetInput(input).
		Save(ctx)
	if err != nil {
		return nil, err
	}
	return updatedItem, nil
}

// DeleteInventory is the resolver for the deleteInventory field.
func (r *mutationResolver) DeleteInventory(ctx context.Context, id int) (bool, error) {
	_, activeCompany := utils.GetSession(&ctx)
	err := r.client.Inventory.DeleteOneID(id).
		Where(inventory.HasCompanyWith(company.ID(activeCompany.ID))).
		Exec(ctx)
	if err != nil {
		return false, err
	}
	return true, err
}

// CreateInventoryMovement is the resolver for the createInventoryMovement field.
func (r *mutationResolver) CreateInventoryMovement(ctx context.Context, input generated.CreateInventoryMovementInput, accountingEntry *model.BaseEntryRegistrationInput) (*generated.InventoryMovement, error) {
	tx, err := r.client.Tx(ctx)
	if err != nil {
		fmt.Println("CreateInventoryMovement tx err:", err)
		return nil, fmt.Errorf("an error occurred")
	}

	movement, err := accountingentry.CreateInventoryMovement(ctx, tx, input, accountingEntry)
	if err != nil {
		fmt.Println("err:", err)
		return nil, fmt.Errorf("an error occurred")
	}

	err = tx.Commit()
	if err != nil {
		fmt.Println("err:", err)
		_ = tx.Rollback()
		return nil, fmt.Errorf("an error occurred")
	}

	return movement, nil
}

// CountInventoryCategories is the resolver for the countInventoryCategories field.
func (r *queryResolver) CountInventoryCategories(ctx context.Context) ([]*model.InventoryCategoryCount, error) {
	_, currentCompany := utils.GetSession(&ctx)
	var output []*model.InventoryCategoryCount
	companyFilter := inventory.HasCompanyWith(company.ID(currentCompany.ID))

	err := r.client.Inventory.Query().Where(companyFilter).
		GroupBy(inventory.FieldCategory).
		Aggregate(generated.Count()).
		Scan(ctx, &output)
	if err != nil {
		fmt.Println("CountInvoices err:", err)
		return nil, err
	}

	return output, nil
}
