// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package model

import (
	"fmt"
	"io"
	"mazza/ent/generated"
	"mazza/ent/generated/accountingentry"
	"mazza/ent/generated/companydocument"
	"mazza/ent/generated/inventory"
	"mazza/ent/generated/invoice"
	"strconv"
	"time"
)

type AgingBucket struct {
	Range       string  `json:"range"`
	TotalAmount float64 `json:"totalAmount"`
	Count       *int    `json:"count,omitempty"`
}

type Assets struct {
	CurrentAssets      []*ReportRowItem `json:"currentAssets"`
	TotalCurrentAssets float64          `json:"totalCurrentAssets"`
	FixedAssets        []*ReportRowItem `json:"fixedAssets"`
	TotalFixedAssets   float64          `json:"totalFixedAssets"`
	TotalAssets        float64          `json:"totalAssets"`
}

type BalanceSheetOuput struct {
	Assets                  *Assets      `json:"assets"`
	Liabilities             *Liabilities `json:"liabilities"`
	Equity                  *Equity      `json:"equity"`
	TotalLiabilityAndEquity float64      `json:"totalLiabilityAndEquity"`
	Period                  *Period      `json:"period"`
	IsProvisional           bool         `json:"isProvisional"`
}

type BaseEntryRegistrationInput struct {
	Main                  []*EntryItem      `json:"main"`
	Counterpart           []*EntryItem      `json:"counterpart"`
	Attachment            []string          `json:"attachment,omitempty"`
	CashInput             *float64          `json:"cashInput,omitempty"`
	Date                  time.Time         `json:"date"`
	Description           *string           `json:"description,omitempty"`
	OperationType         BaseOperationType `json:"operationType"`
	PayableInput          *PayableInput     `json:"payableInput,omitempty"`
	ProductInput          *int              `json:"productInput,omitempty"`
	ReceivableInput       *ReceivableInput  `json:"receivableInput,omitempty"`
	TotalTransactionValue float64           `json:"totalTransactionValue"`
}

type CompanyInfoInput struct {
	Industry string  `json:"industry"`
	VatRate  float64 `json:"vatRate"`
}

type CreateMemberSignupTokenOutput struct {
	Token     string    `json:"token"`
	ExpiresAt time.Time `json:"expiresAt"`
}

type CustomerAggregationOutput struct {
	Company *int `json:"company,omitempty"`
	Count   *int `json:"count,omitempty"`
}

type DocumentCount struct {
	Category companydocument.Category `json:"category"`
	Count    int                      `json:"count"`
}

type EntryItem struct {
	Account     string                      `json:"account"`
	AccountType accountingentry.AccountType `json:"accountType"`
	Amount      float64                     `json:"amount"`
	IsDebit     bool                        `json:"isDebit"`
	Label       string                      `json:"label"`
	Category    string                      `json:"category"`
}

type EntryProductInput struct {
	ID       int     `json:"id"`
	Amount   float64 `json:"amount"`
	Quantity int     `json:"quantity"`
}

type Equity struct {
	Equity      []*ReportRowItem `json:"equity"`
	TotalEquity float64          `json:"totalEquity"`
}

type ExpensesBreakdownOutput struct {
	Name   string  `json:"name"`
	Amount float64 `json:"amount"`
}

type FileDetailsOutput struct {
	Message string      `json:"message"`
	File    *FileOutput `json:"file,omitempty"`
}

type FileOutput struct {
	Encoding string `json:"encoding"`
	Kind     string `json:"kind"`
	Name     string `json:"name"`
	Data     string `json:"data"`
}

type HomepageAnalytics struct {
	RevenueFrequency   TimeRange                    `json:"revenueFrequency"`
	RevenueAggregation []*RevenueTrendOutput        `json:"revenueAggregation"`
	PendingInvoices    int                          `json:"pendingInvoices"`
	OverdueTasks       int                          `json:"overdueTasks"`
	ActiveProjects     int                          `json:"activeProjects"`
	RecentTransactions []*generated.AccountingEntry `json:"recentTransactions"`
}

type IncomeStatementOuput struct {
	Revenues          []*IncomeStatementRowItem `json:"revenues"`
	NetRevenue        float64                   `json:"netRevenue"`
	Expenses          []*IncomeStatementRowItem `json:"expenses"`
	TotalExpenses     float64                   `json:"totalExpenses"`
	EarningsBeforeTax float64                   `json:"earningsBeforeTax"`
	TaxExpense        float64                   `json:"taxExpense"`
	NetIncome         float64                   `json:"netIncome"`
	Period            *Period                   `json:"period"`
	IsProvisional     bool                      `json:"isProvisional"`
}

type IncomeStatementRowItem struct {
	Account     string  `json:"account"`
	AccountType string  `json:"accountType"`
	Category    string  `json:"category"`
	Label       string  `json:"label"`
	Value       float64 `json:"value"`
}

type InitialSetupInput struct {
	AccountingEntry *BaseEntryRegistrationInput `json:"accountingEntry,omitempty"`
	CompanyInfo     *CompanyInfoInput           `json:"companyInfo"`
}

type InventoryCategoryCount struct {
	Category inventory.Category `json:"category"`
	Count    int                `json:"count"`
}

type InvoiceCount struct {
	Status invoice.Status `json:"status"`
	Count  int            `json:"count"`
}

type InvoiceCustomer struct {
	Name    string `json:"name"`
	TaxID   string `json:"taxID"`
	Address string `json:"address"`
	City    string `json:"city"`
	Country string `json:"country"`
	Phone   string `json:"phone"`
	Email   string `json:"email"`
}

type InvoiceInput struct {
	AccountingEntryData *BaseEntryRegistrationInput               `json:"accountingEntryData"`
	InvoiceData         *generated.CreateInvoiceInput             `json:"invoiceData"`
	InventoryMovements  []*generated.CreateInventoryMovementInput `json:"inventoryMovements,omitempty"`
}

type InvoiceIssuanceOutput struct {
	Message string `json:"message"`
	FileURL string `json:"fileUrl"`
}

type InvoiceIssuer struct {
	Name    string `json:"name"`
	TaxID   string `json:"taxID"`
	Address string `json:"address"`
	City    string `json:"city"`
	Country string `json:"country"`
	Phone   string `json:"phone"`
	Email   string `json:"email"`
}

type InvoiceTotals struct {
	Subtotal string `json:"subtotal"`
	VatRate  string `json:"vatRate"`
	Vat      string `json:"vat"`
	Total    string `json:"total"`
}

type LedgerDownloadInput struct {
	StartDate time.Time `json:"startDate"`
	EndDate   time.Time `json:"endDate"`
}

type Liabilities struct {
	CurrentLiabilities         []*ReportRowItem `json:"currentLiabilities"`
	TotalCurrentLiabilities    float64          `json:"totalCurrentLiabilities"`
	NonCurrentLiabilities      []*ReportRowItem `json:"nonCurrentLiabilities"`
	TotalNonCurrentLiabilities float64          `json:"totalNonCurrentLiabilities"`
	TotalLiabilities           float64          `json:"totalLiabilities"`
}

type LoginInput struct {
	Username string `json:"username"`
	Password string `json:"password"`
	FcmToken string `json:"fcmToken"`
}

type LoginOutput struct {
	User         *generated.User      `json:"user"`
	CompanyID    int                  `json:"companyId"`
	Companies    []*generated.Company `json:"companies"`
	AccessToken  string               `json:"accessToken"`
	RefreshToken string               `json:"refreshToken"`
	TTL          int                  `json:"ttl"`
}

type PayableInput struct {
	Amount  float64   `json:"amount"`
	Name    string    `json:"name"`
	Date    time.Time `json:"date"`
	DueDate time.Time `json:"dueDate"`
}

type PaymentDetails struct {
	BankName      string `json:"bankName"`
	AccountNumber string `json:"accountNumber"`
	Iban          string `json:"iban"`
	DueDate       string `json:"dueDate"`
}

type Period struct {
	Start time.Time `json:"start"`
	End   time.Time `json:"end"`
}

type ProfilePhotoInput struct {
	URL        string `json:"url"`
	StorageURI string `json:"storageURI"`
}

type ReceivableAggregationOutput struct {
	Company *int     `json:"company,omitempty"`
	Count   *int     `json:"count,omitempty"`
	Sum     *float64 `json:"sum,omitempty"`
}

type ReceivableInput struct {
	Amount  float64   `json:"amount"`
	Name    string    `json:"name"`
	Date    time.Time `json:"date"`
	DueDate time.Time `json:"dueDate"`
}

type ReportInput struct {
	CompanyID *int      `json:"companyID,omitempty"`
	Date      time.Time `json:"date"`
}

type ReportRowItem struct {
	Account string  `json:"account"`
	Label   string  `json:"label"`
	Value   float64 `json:"value"`
}

type ResetPasswordInput struct {
	Token    string `json:"token"`
	Password string `json:"password"`
}

type RevenueTrendOutput struct {
	Date   string  `json:"date"`
	Amount float64 `json:"amount"`
}

type SalesQuotationInput struct {
	InvoiceData *generated.CreateInvoiceInput `json:"invoiceData"`
}

type SignupInput struct {
	CompanyInput     *generated.CreateCompanyInput `json:"companyInput"`
	UserInput        *generated.CreateUserInput    `json:"userInput"`
	UserProfilePhoto *ProfilePhotoInput            `json:"userProfilePhoto,omitempty"`
	CompanyLogo      *ProfilePhotoInput            `json:"companyLogo,omitempty"`
}

type TreasuryAggregatePayload struct {
	CompanyID    int     `json:"companyID"`
	Count        int     `json:"count"`
	TotalBalance float64 `json:"totalBalance"`
}

type TrialBalanceRowItem struct {
	Account     string  `json:"account"`
	AccountType string  `json:"accountType"`
	Label       string  `json:"label"`
	Debit       float64 `json:"debit"`
	Credit      float64 `json:"credit"`
	Balance     float64 `json:"balance"`
}

type VerifyMemberSignupTokenInput struct {
	Token string  `json:"token"`
	Email *string `json:"email,omitempty"`
}

type WorkShiftAggregationPayload struct {
	Date              string `json:"date"`
	Count             int    `json:"count"`
	DurationInMinutes *int   `json:"durationInMinutes,omitempty"`
	PendingCount      *int   `json:"pendingCount,omitempty"`
}

type InvitedUserSignupInput struct {
	UserInput        *generated.CreateUserInput `json:"userInput"`
	UserProfilePhoto *ProfilePhotoInput         `json:"userProfilePhoto,omitempty"`
	InvitationToken  int                        `json:"invitationToken"`
}

type BaseOperationType string

const (
	BaseOperationTypeSales          BaseOperationType = "SALES"
	BaseOperationTypeSalesReturn    BaseOperationType = "SALES_RETURN"
	BaseOperationTypePurchase       BaseOperationType = "PURCHASE"
	BaseOperationTypePurchaseReturn BaseOperationType = "PURCHASE_RETURN"
	BaseOperationTypeOther          BaseOperationType = "OTHER"
	BaseOperationTypeInitialSetup   BaseOperationType = "INITIAL_SETUP"
)

var AllBaseOperationType = []BaseOperationType{
	BaseOperationTypeSales,
	BaseOperationTypeSalesReturn,
	BaseOperationTypePurchase,
	BaseOperationTypePurchaseReturn,
	BaseOperationTypeOther,
	BaseOperationTypeInitialSetup,
}

func (e BaseOperationType) IsValid() bool {
	switch e {
	case BaseOperationTypeSales, BaseOperationTypeSalesReturn, BaseOperationTypePurchase, BaseOperationTypePurchaseReturn, BaseOperationTypeOther, BaseOperationTypeInitialSetup:
		return true
	}
	return false
}

func (e BaseOperationType) String() string {
	return string(e)
}

func (e *BaseOperationType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = BaseOperationType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid BaseOperationType", str)
	}
	return nil
}

func (e BaseOperationType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type CustomersGroupBy string

const (
	CustomersGroupByCompany CustomersGroupBy = "COMPANY"
	CustomersGroupByCity    CustomersGroupBy = "CITY"
)

var AllCustomersGroupBy = []CustomersGroupBy{
	CustomersGroupByCompany,
	CustomersGroupByCity,
}

func (e CustomersGroupBy) IsValid() bool {
	switch e {
	case CustomersGroupByCompany, CustomersGroupByCity:
		return true
	}
	return false
}

func (e CustomersGroupBy) String() string {
	return string(e)
}

func (e *CustomersGroupBy) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = CustomersGroupBy(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid CustomersGroupBy", str)
	}
	return nil
}

func (e CustomersGroupBy) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type ReceivablesGroupBy string

const (
	ReceivablesGroupByAge      ReceivablesGroupBy = "AGE"
	ReceivablesGroupByCompany  ReceivablesGroupBy = "COMPANY"
	ReceivablesGroupByCustomer ReceivablesGroupBy = "CUSTOMER"
	ReceivablesGroupByDaysdue  ReceivablesGroupBy = "DAYSDUE"
	ReceivablesGroupByStatus   ReceivablesGroupBy = "STATUS"
)

var AllReceivablesGroupBy = []ReceivablesGroupBy{
	ReceivablesGroupByAge,
	ReceivablesGroupByCompany,
	ReceivablesGroupByCustomer,
	ReceivablesGroupByDaysdue,
	ReceivablesGroupByStatus,
}

func (e ReceivablesGroupBy) IsValid() bool {
	switch e {
	case ReceivablesGroupByAge, ReceivablesGroupByCompany, ReceivablesGroupByCustomer, ReceivablesGroupByDaysdue, ReceivablesGroupByStatus:
		return true
	}
	return false
}

func (e ReceivablesGroupBy) String() string {
	return string(e)
}

func (e *ReceivablesGroupBy) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ReceivablesGroupBy(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ReceivablesGroupBy", str)
	}
	return nil
}

func (e ReceivablesGroupBy) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type SalesOperationType string

const (
	SalesOperationTypeSales       SalesOperationType = "SALES"
	SalesOperationTypeSalesReturn SalesOperationType = "SALES_RETURN"
)

var AllSalesOperationType = []SalesOperationType{
	SalesOperationTypeSales,
	SalesOperationTypeSalesReturn,
}

func (e SalesOperationType) IsValid() bool {
	switch e {
	case SalesOperationTypeSales, SalesOperationTypeSalesReturn:
		return true
	}
	return false
}

func (e SalesOperationType) String() string {
	return string(e)
}

func (e *SalesOperationType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SalesOperationType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SalesOperationType", str)
	}
	return nil
}

func (e SalesOperationType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type ShiftGroupBy string

const (
	ShiftGroupByApprovedAt ShiftGroupBy = "APPROVED_AT"
	ShiftGroupByClockIn    ShiftGroupBy = "CLOCK_IN"
	ShiftGroupByClockOut   ShiftGroupBy = "CLOCK_OUT"
	ShiftGroupByStatus     ShiftGroupBy = "STATUS"
)

var AllShiftGroupBy = []ShiftGroupBy{
	ShiftGroupByApprovedAt,
	ShiftGroupByClockIn,
	ShiftGroupByClockOut,
	ShiftGroupByStatus,
}

func (e ShiftGroupBy) IsValid() bool {
	switch e {
	case ShiftGroupByApprovedAt, ShiftGroupByClockIn, ShiftGroupByClockOut, ShiftGroupByStatus:
		return true
	}
	return false
}

func (e ShiftGroupBy) String() string {
	return string(e)
}

func (e *ShiftGroupBy) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ShiftGroupBy(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ShiftGroupBy", str)
	}
	return nil
}

func (e ShiftGroupBy) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type TimeRange string

const (
	TimeRangeWeek    TimeRange = "WEEK"
	TimeRangeMonth   TimeRange = "MONTH"
	TimeRangeQuarter TimeRange = "QUARTER"
	TimeRangeYear    TimeRange = "YEAR"
)

var AllTimeRange = []TimeRange{
	TimeRangeWeek,
	TimeRangeMonth,
	TimeRangeQuarter,
	TimeRangeYear,
}

func (e TimeRange) IsValid() bool {
	switch e {
	case TimeRangeWeek, TimeRangeMonth, TimeRangeQuarter, TimeRangeYear:
		return true
	}
	return false
}

func (e TimeRange) String() string {
	return string(e)
}

func (e *TimeRange) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = TimeRange(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid TimeRange", str)
	}
	return nil
}

func (e TimeRange) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}
