package mazza

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.54

import (
	"context"
	"fmt"
	"mazza/app/auth"
	appUtils "mazza/app/utils"
	"mazza/ent/generated"
	"mazza/ent/generated/company"
	"mazza/ent/generated/customer"
	"mazza/ent/generated/employee"
	"mazza/ent/generated/payable"
	"mazza/ent/generated/product"
	"mazza/ent/generated/project"
	"mazza/ent/generated/projectmilestone"
	"mazza/ent/generated/projecttask"
	"mazza/ent/generated/receivable"
	"mazza/ent/generated/supplier"
	"mazza/ent/generated/treasury"
	"mazza/ent/generated/user"
	"mazza/ent/generated/userrole"
	"mazza/ent/generated/workshift"
	"mazza/ent/generated/worktag"
	"mazza/ent/generated/worktask"
	"mazza/ent/utils"
	"mazza/mazza/generated/model"
	"strings"
	"time"

	"entgo.io/ent/dialect/sql"
	"github.com/vektah/gqlparser/v2/gqlerror"
)

// Signup is the resolver for the signup field.
func (r *mutationResolver) Signup(ctx context.Context, input model.SignupInput) (*model.LoginOutput, error) {
	newCompany, err := r.CreateCompany(ctx, input.CompanyInput)
	if err != nil {
		return nil, err
	}

	newUser, err := r.CreateUser(ctx, *input.UserInput)
	if err != nil {
		return nil, err
	}

	role, err := r.client.UserRole.Create().SetRole(userrole.RoleAdmin).Save(ctx)
	if err != nil {
		return nil, err
	}

	_, err = newCompany.Update().AddAvailableRoleIDs(role.ID).Save(ctx)
	if err != nil {
		return nil, err
	}

	newUser, err = newUser.Update().AddAssignedRoleIDs(role.ID).Save(ctx)
	if err != nil {
		return nil, err
	}

	// loginInput := model.LoginInput{Username: newUser.Username, Password: input.UserInput.Password, FcmToken: *input.UserInput.FcmToken}
	// loginOutput, err := r.Login(ctx, loginInput)
	err = fmt.Errorf("miiniijnjn")
	// if err != nil {
	return nil, fmt.Errorf("your account was created, please use your creations to log in")
}

// CreateCompany is the resolver for the createCompany field.
func (r *mutationResolver) CreateCompany(ctx context.Context, input *generated.CreateCompanyInput) (*generated.Company, error) {
	client := generated.FromContext(ctx)
	company, err := client.Company.Create().SetInput(*input).Save(ctx)
	if err == nil {
		_ = appUtils.CreateDefaultItems(ctx, company.ID)
	}
	return company, err
}

// UpdateCompany is the resolver for the updateCompany field.
func (r *mutationResolver) UpdateCompany(ctx context.Context, id int, input generated.UpdateCompanyInput) (*generated.Company, error) {
	client := generated.FromContext(ctx)
	currentCompany, _, _ := utils.GetSession(&ctx)
	if currentCompany.ID != id {
		return nil, fmt.Errorf("unauthorized")
	}
	return client.Company.UpdateOneID(id).SetInput(input).Save(ctx)
}

// InvitedUserSignup is the resolver for the invitedUserSignup field.
func (r *mutationResolver) InvitedUserSignup(ctx context.Context, input model.InvitedUserSignupInput) (*generated.User, error) {
	panic(fmt.Errorf("not implemented: InvitedUserSignup - invitedUserSignup"))
}

// CreateUser is the resolver for the createUser field.
func (r *mutationResolver) CreateUser(ctx context.Context, input generated.CreateUserInput) (*generated.User, error) {
	client := generated.FromContext(ctx)
	pwd, err := appUtils.HashPwd(&input.Password)
	if err != nil {
		return nil, gqlerror.Errorf("ocorreu um erro ao criar o usu√°rio")
	}
	input.Password = pwd
	return client.User.Create().SetInput(input).Save(ctx)
}

// UpdateUser is the resolver for the updateUser field.
func (r *mutationResolver) UpdateUser(ctx context.Context, id int, input generated.UpdateUserInput) (*generated.User, error) {
	client := generated.FromContext(ctx)
	currentUser, _, _ := utils.GetSession(&ctx)
	if currentUser == nil {
		return nil, fmt.Errorf("unauthorized")
	}

	// Beside from admin, users can only update themselves
	if currentUser.ID != id {
		return nil, fmt.Errorf("unauthorized")
	}
	// Admin updating other users from the same company is not implemented yet.
	return client.User.UpdateOneID(id).SetInput(input).Save(ctx)
}

// ForgotPassword is the resolver for the forgotPassword field.
func (r *mutationResolver) ForgotPassword(ctx context.Context, username string) (string, error) {
	err := auth.ForgotPassword(&ctx, username)
	return "reset email sent to " + username, err
}

// ResetPassword is the resolver for the resetPassword field.
func (r *mutationResolver) ResetPassword(ctx context.Context, input model.ResetPasswordInput) (bool, error) {
	err := auth.ResetPassword(&ctx, input.Token, input.Password)
	if err != nil {
		return false, fmt.Errorf("invalid token")
	}
	return true, nil
}

// Unsubscribe is the resolver for the unsubscribe field.
func (r *mutationResolver) Unsubscribe(ctx context.Context, id int) (bool, error) {
	err := auth.Unsubscribe(&ctx)
	if err != nil {
		return false, fmt.Errorf("not allowed")
	}
	return true, nil
}

// CreateUserRole is the resolver for the createUserRole field.
func (r *mutationResolver) CreateUserRole(ctx context.Context, input generated.CreateUserRoleInput) (bool, error) {
	panic(fmt.Errorf("not implemented: CreateUserRole - createUserRole"))
}

// CreateCustomer is the resolver for the createCustomer field.
func (r *mutationResolver) CreateCustomer(ctx context.Context, input generated.CreateCustomerInput) (*generated.Customer, error) {
	_, currentCompany, _ := utils.GetSession(&ctx)
	return r.client.Customer.Create().SetInput(input).SetCompanyID(currentCompany.ID).Save(ctx)
}

// UpdateCustomer is the resolver for the updateCustomer field.
func (r *mutationResolver) UpdateCustomer(ctx context.Context, id int, input generated.UpdateCustomerInput) (*generated.Customer, error) {
	companyQ := utils.CurrentCompanyQuery(&ctx)
	filter := customer.HasCompanyWith(companyQ)
	return generated.FromContext(ctx).Customer.UpdateOneID(id).Where(filter).SetInput(input).Save(ctx)
}

// DeleteCustomer is the resolver for the deleteCustomer field.
func (r *mutationResolver) DeleteCustomer(ctx context.Context, id int) (bool, error) {
	companyQ := utils.CurrentCompanyQuery(&ctx)
	filter := customer.HasCompanyWith(companyQ)

	if err := generated.FromContext(ctx).Customer.DeleteOneID(id).Where(filter).Exec(ctx); err != nil {
		return false, fmt.Errorf("")
	}
	return true, nil
}

// CreateEmployee is the resolver for the createEmployee field.
func (r *mutationResolver) CreateEmployee(ctx context.Context, input generated.CreateEmployeeInput) (*generated.Employee, error) {
	_, currentCompany, _ := utils.GetSession(&ctx)
	return r.client.Employee.Create().SetInput(input).SetCompanyID(currentCompany.ID).Save(ctx)
}

// UpdateEmployee is the resolver for the updateEmployee field.
func (r *mutationResolver) UpdateEmployee(ctx context.Context, id int, input generated.UpdateEmployeeInput) (*generated.Employee, error) {
	companyQ := utils.CurrentCompanyQuery(&ctx)
	filter := employee.HasCompanyWith(companyQ)
	return generated.FromContext(ctx).Employee.UpdateOneID(id).Where(filter).SetInput(input).Save(ctx)
}

// DeleteEmployee is the resolver for the deleteEmployee field.
func (r *mutationResolver) DeleteEmployee(ctx context.Context, id int) (bool, error) {
	companyQ := utils.CurrentCompanyQuery(&ctx)
	filter := employee.HasCompanyWith(companyQ)

	if err := generated.FromContext(ctx).Employee.DeleteOneID(id).Where(filter).Exec(ctx); err != nil {
		return false, fmt.Errorf("")
	}
	return true, nil
}

// CreateProduct is the resolver for the createProduct field.
func (r *mutationResolver) CreateProduct(ctx context.Context, input generated.CreateProductInput) (*generated.Product, error) {
	_, currentCompany, _ := utils.GetSession(&ctx)
	product, err := r.client.Product.Create().SetInput(input).SetCompanyID(currentCompany.ID).Save(ctx)
	if err != nil {
		errStr := err.Error()
		if strings.Contains(errStr, "unique") && strings.Contains(errStr, "product_name_company_products") {
			return product, gqlerror.Errorf("name is not unique")
		} else if strings.Contains(errStr, "unique") && strings.Contains(errStr, "product_sku_company_products") {
			return product, gqlerror.Errorf("sku is not unique")
		}
		fmt.Println("err:", errStr)
	}

	return product, err
}

// UpdateProduct is the resolver for the updateProduct field.
func (r *mutationResolver) UpdateProduct(ctx context.Context, id int, input generated.UpdateProductInput) (*generated.Product, error) {
	companyQ := utils.CurrentCompanyQuery(&ctx)
	filter := product.HasCompanyWith(companyQ)
	return generated.FromContext(ctx).Product.UpdateOneID(id).Where(filter).SetInput(input).Save(ctx)
}

// DeleteProduct is the resolver for the deleteProduct field.
func (r *mutationResolver) DeleteProduct(ctx context.Context, id int) (bool, error) {
	companyQ := utils.CurrentCompanyQuery(&ctx)
	filter := product.HasCompanyWith(companyQ)

	if err := generated.FromContext(ctx).Product.DeleteOneID(id).Where(filter).Exec(ctx); err != nil {
		return false, fmt.Errorf("there was an error deleting the product")
	}
	return true, nil
}

// CreateProject is the resolver for the createProject field.
func (r *mutationResolver) CreateProject(ctx context.Context, input generated.CreateProjectInput) (*generated.Project, error) {
	_, currentCompany, _ := utils.GetSession(&ctx)
	return r.client.Project.Create().SetInput(input).SetCompanyID(currentCompany.ID).Save(ctx)
}

// UpdateProject is the resolver for the updateProject field.
func (r *mutationResolver) UpdateProject(ctx context.Context, id int, input generated.UpdateProjectInput) (*generated.Project, error) {
	_, currentCompany, _ := utils.GetSession(&ctx)
	filter := project.HasCompanyWith(company.IDEQ(currentCompany.ID))
	return generated.FromContext(ctx).Project.UpdateOneID(id).Where(filter).SetInput(input).Save(ctx)
}

// DeleteProject is the resolver for the deleteProject field.
func (r *mutationResolver) DeleteProject(ctx context.Context, id int) (bool, error) {
	_, currentCompany, _ := utils.GetSession(&ctx)
	filter := project.HasCompanyWith(company.IDEQ(currentCompany.ID))

	if err := generated.FromContext(ctx).Project.DeleteOneID(id).Where(filter).Exec(ctx); err != nil {
		return false, fmt.Errorf("there was an error deleting the project")
	}
	return true, nil
}

// CreateProjectTask is the resolver for the createProjectTask field.
func (r *mutationResolver) CreateProjectTask(ctx context.Context, input generated.CreateProjectTaskInput) (*generated.ProjectTask, error) {
	_, currentCompany, _ := utils.GetSession(&ctx)
	if _, err := r.client.Project.Query().Where(project.IDEQ(input.ProjectID), project.HasCompanyWith(company.IDEQ(currentCompany.ID))).First(ctx); err != nil {
		fmt.Println("err 1:", err)
		return nil, gqlerror.Errorf("invalid project input")
	}
	// Check if the task assignee belongs to the company
	if input.AssigneeID != nil {
		if _, err := r.client.Company.Query().Where(company.IDEQ(currentCompany.ID), company.HasUsersWith(user.IDEQ(*input.AssigneeID))).First(ctx); err != nil {
			fmt.Println("err 2:", err)
			return nil, gqlerror.Errorf("invalid user input")
		}
	}

	newTask, err := r.client.ProjectTask.Create().SetInput(input).Save(ctx)
	if err != nil {
		fmt.Println("err 3:", err)
		return nil, err
	}

	return newTask, err
}

// UpdateProjectTask is the resolver for the updateProjectTask field.
func (r *mutationResolver) UpdateProjectTask(ctx context.Context, id int, input generated.UpdateProjectTaskInput) (*generated.ProjectTask, error) {
	_, currentCompany, _ := utils.GetSession(&ctx)
	filter := projecttask.HasProjectWith(project.HasCompanyWith(company.IDEQ(currentCompany.ID)))
	updatedTask, err := generated.FromContext(ctx).ProjectTask.UpdateOneID(id).Where(filter).SetInput(input).Save(ctx)
	if err != nil {
		return nil, err
	}
	return updatedTask, nil
}

// DeleteProjectTask is the resolver for the deleteProjectTask field.
func (r *mutationResolver) DeleteProjectTask(ctx context.Context, id int) (bool, error) {
	_, currentCompany, _ := utils.GetSession(&ctx)
	filter := projecttask.HasProjectWith(project.HasCompanyWith(company.IDEQ(currentCompany.ID)))

	if err := generated.FromContext(ctx).ProjectTask.DeleteOneID(id).Where(filter).Exec(ctx); err != nil {
		fmt.Println("err:", err)
		return false, fmt.Errorf("there was an error deleting the project task")
	}
	return true, nil
}

// CreateProjectMilestone is the resolver for the createProjectMilestone field.
func (r *mutationResolver) CreateProjectMilestone(ctx context.Context, input generated.CreateProjectMilestoneInput) (*generated.ProjectMilestone, error) {
	_, currentCompany, _ := utils.GetSession(&ctx)
	if _, err := r.client.Project.Query().Where(project.IDEQ(input.ProjectID), project.HasCompanyWith(company.IDEQ(currentCompany.ID))).First(ctx); err != nil {
		return nil, gqlerror.Errorf("invalid project input")
	}

	return r.client.ProjectMilestone.Create().SetInput(input).Save(ctx)
}

// UpdateProjectMilestone is the resolver for the updateProjectMilestone field.
func (r *mutationResolver) UpdateProjectMilestone(ctx context.Context, id int, input generated.UpdateProjectMilestoneInput) (*generated.ProjectMilestone, error) {
	_, currentCompany, _ := utils.GetSession(&ctx)
	filter := projectmilestone.HasProjectWith(project.HasCompanyWith(company.IDEQ(currentCompany.ID)))
	return generated.FromContext(ctx).ProjectMilestone.UpdateOneID(id).Where(filter).SetInput(input).Save(ctx)
}

// DeleteProjectMilestone is the resolver for the deleteProjectMilestone field.
func (r *mutationResolver) DeleteProjectMilestone(ctx context.Context, id int) (bool, error) {
	_, currentCompany, _ := utils.GetSession(&ctx)
	filter := projectmilestone.HasProjectWith(project.HasCompanyWith(company.IDEQ(currentCompany.ID)))

	if err := generated.FromContext(ctx).ProjectMilestone.DeleteOneID(id).Where(filter).Exec(ctx); err != nil {
		return false, fmt.Errorf("there was an error deleting the project milestone")
	}
	return true, nil
}

// CreateSupplier is the resolver for the createSupplier field.
func (r *mutationResolver) CreateSupplier(ctx context.Context, input generated.CreateSupplierInput) (*generated.Supplier, error) {
	_, currentCompany, _ := utils.GetSession(&ctx)
	return r.client.Supplier.Create().SetInput(input).SetCompanyID(currentCompany.ID).Save(ctx)
}

// UpdateSupplier is the resolver for the updateSupplier field.
func (r *mutationResolver) UpdateSupplier(ctx context.Context, id int, input generated.UpdateSupplierInput) (*generated.Supplier, error) {
	companyQ := utils.CurrentCompanyQuery(&ctx)
	filter := supplier.HasCompanyWith(companyQ)
	return generated.FromContext(ctx).Supplier.UpdateOneID(id).Where(filter).SetInput(input).Save(ctx)
}

// DeleteSupplier is the resolver for the deleteSupplier field.
func (r *mutationResolver) DeleteSupplier(ctx context.Context, id int) (bool, error) {
	companyQ := utils.CurrentCompanyQuery(&ctx)
	filter := supplier.HasCompanyWith(companyQ)

	if err := generated.FromContext(ctx).Supplier.DeleteOneID(id).Where(filter).Exec(ctx); err != nil {
		return false, fmt.Errorf("the supplier could not be deleted")
	}
	return true, nil
}

// CreateTreasury is the resolver for the createTreasury field.
func (r *mutationResolver) CreateTreasury(ctx context.Context, input generated.CreateTreasuryInput) (*generated.Treasury, error) {
	_, currentCompany, _ := utils.GetSession(&ctx)
	output, err := r.client.Treasury.Create().SetInput(input).SetCompanyID(currentCompany.ID).Save(ctx)
	if err != nil {
		errStr := err.Error()
		if strings.Contains(errStr, "unique") && strings.Contains(errStr, "treasury_name_company_treasuries") {
			return output, gqlerror.Errorf("name is not unique")
		}
		fmt.Println("err:", errStr)
	}
	return output, err
}

// UpdateTreasury is the resolver for the updateTreasury field.
func (r *mutationResolver) UpdateTreasury(ctx context.Context, id int, input generated.UpdateTreasuryInput) (*generated.Treasury, error) {
	companyQ := utils.CurrentCompanyQuery(&ctx)
	filter := treasury.HasCompanyWith(companyQ)
	return generated.FromContext(ctx).Treasury.UpdateOneID(id).Where(filter).SetInput(input).Save(ctx)
}

// DeleteTreasury is the resolver for the deleteTreasury field.
func (r *mutationResolver) DeleteTreasury(ctx context.Context, id int) (bool, error) {
	companyQ := utils.CurrentCompanyQuery(&ctx)
	filter := treasury.HasCompanyWith(companyQ)

	if err := generated.FromContext(ctx).Treasury.DeleteOneID(id).Where(filter).Exec(ctx); err != nil {
		return false, fmt.Errorf("the treasury account could not be delete")
	}
	return true, nil
}

// CreateWorkShift is the resolver for the createWorkShift field.
func (r *mutationResolver) CreateWorkShift(ctx context.Context, input generated.CreateWorkshiftInput) (*generated.Workshift, error) {
	_, currentCompany, employeeID := utils.GetSession(&ctx)
	var clockIn time.Time
	fmt.Println("## edit iD:", input.EditRequestID)
	// Clock-in is the current time if this is a workshift
	if input.WorkShiftID == nil {
		clockIn = time.Now()
	} else {
		// If it is a edit request, clock-in is the given input
		clockIn = *input.ClockIn
	}
	fmt.Println("** emp  id:", employeeID)
	return r.client.Workshift.Create().SetInput(input).
		SetCompanyID(currentCompany.ID).
		SetEmployeeID(*employeeID).
		SetClockIn(clockIn).SetStatus(workshift.StatusPENDING).
		Save(ctx)
}

// UpdateWorkShift is the resolver for the updateWorkShift field.
func (r *mutationResolver) UpdateWorkShift(ctx context.Context, id int, input generated.UpdateWorkshiftInput) (*generated.Workshift, error) {
	companyQ := utils.CurrentCompanyQuery(&ctx)
	filter := workshift.HasCompanyWith(companyQ)

	return generated.FromContext(ctx).Workshift.UpdateOneID(id).Where(filter).SetInput(input).Save(ctx)
}

// DeleteWorkShift is the resolver for the deleteWorkShift field.
func (r *mutationResolver) DeleteWorkShift(ctx context.Context, id int) (bool, error) {
	companyQ := utils.CurrentCompanyQuery(&ctx)
	filter := workshift.HasCompanyWith(companyQ)

	if err := generated.FromContext(ctx).Workshift.DeleteOneID(id).Where(filter).Exec(ctx); err != nil {
		return false, err
	}
	return true, nil
}

// CreateWorkTask is the resolver for the createWorkTask field.
func (r *mutationResolver) CreateWorkTask(ctx context.Context, input generated.CreateWorktaskInput) (*generated.Worktask, error) {
	currentUser, currentCompany, _ := utils.GetSession(&ctx)
	return r.client.Worktask.Create().SetInput(input).SetCompanyID(currentCompany.ID).
		SetCreatedByID(currentUser.ID).Save(ctx)
}

// UpdateWorkTask is the resolver for the updateWorkTask field.
func (r *mutationResolver) UpdateWorkTask(ctx context.Context, id int, input generated.UpdateWorktaskInput) (*generated.Worktask, error) {
	companyQ := utils.CurrentCompanyQuery(&ctx)
	filter := worktask.HasCompanyWith(companyQ)
	return generated.FromContext(ctx).Worktask.UpdateOneID(id).Where(filter).SetInput(input).Save(ctx)
}

// DeleteWorkTask is the resolver for the deleteWorkTask field.
func (r *mutationResolver) DeleteWorkTask(ctx context.Context, id int) (bool, error) {
	companyQ := utils.CurrentCompanyQuery(&ctx)
	filter := worktask.HasCompanyWith(companyQ)

	if err := generated.FromContext(ctx).Worktask.DeleteOneID(id).Where(filter).Exec(ctx); err != nil {
		return false, err
	}
	return true, nil
}

// CreateWorkTag is the resolver for the createWorkTag field.
func (r *mutationResolver) CreateWorkTag(ctx context.Context, input generated.CreateWorktagInput) (*generated.Worktag, error) {
	_, currentCompany, _ := utils.GetSession(&ctx)
	return r.client.Worktag.Create().SetInput(input).SetCompanyID(currentCompany.ID).Save(ctx)
}

// UpdateWorkTag is the resolver for the updateWorkTag field.
func (r *mutationResolver) UpdateWorkTag(ctx context.Context, id int, input generated.UpdateWorktagInput) (*generated.Worktag, error) {
	companyQ := utils.CurrentCompanyQuery(&ctx)
	filter := worktag.HasCompanyWith(companyQ)
	return generated.FromContext(ctx).Worktag.UpdateOneID(id).Where(filter).SetInput(input).Save(ctx)
}

// DeleteWorkTag is the resolver for the deleteWorkTag field.
func (r *mutationResolver) DeleteWorkTag(ctx context.Context, id int) (bool, error) {
	companyQ := utils.CurrentCompanyQuery(&ctx)
	filter := worktag.HasCompanyWith(companyQ)

	if err := generated.FromContext(ctx).Worktag.DeleteOneID(id).Where(filter).Exec(ctx); err != nil {
		return false, fmt.Errorf("worktag could not be deleted")
	}
	return true, nil
}

// VerifyPasswordResetToken is the resolver for the verifyPasswordResetToken field.
func (r *queryResolver) VerifyPasswordResetToken(ctx context.Context, token string) (bool, error) {
	err := auth.VerifyPasswordResetToken(&ctx, r.client, token)
	if err != nil {
		return false, &generated.NotFoundError{}
	}
	return true, nil
}

// Companies is the resolver for the companies field.
func (r *queryResolver) Companies(ctx context.Context, where *generated.CompanyWhereInput) ([]*generated.Company, error) {
	filter := utils.CompanyQuery(&ctx)
	query, err := where.Filter(r.client.Company.Query().Where(filter))
	if err != nil {
		return nil, err
	}
	return query.All(ctx)
}

// Customers is the resolver for the customers field.
func (r *queryResolver) Customers(ctx context.Context, where *generated.CustomerWhereInput) ([]*generated.Customer, error) {
	companyQ := utils.CurrentCompanyQuery(&ctx)
	filter := customer.HasCompanyWith(companyQ)
	query, err := where.Filter(r.client.Customer.Query().Where(filter))
	if err != nil {
		return nil, err
	}
	return query.All(ctx)
}

// AggregateCustomers is the resolver for the aggregateCustomers field.
func (r *queryResolver) AggregateCustomers(ctx context.Context, where *generated.CustomerWhereInput, groupBy []model.CustomersGroupBy) ([]*model.CustomerAggregationOutput, error) {
	_, currentCompany, _ := utils.GetSession(&ctx)
	var result []*model.CustomerAggregationOutput
	var agg []struct {
		Company int `json:"company_customers"`
		Count   int `json:"count"`
	}

	query, err := where.Filter(r.client.Customer.Query())
	if err != nil {
		return nil, err
	}
	err = query.Where(customer.HasCompanyWith(company.IDEQ(currentCompany.ID))).
		GroupBy(customer.CompanyColumn).
		Aggregate(generated.Count()).Scan(ctx, &agg)

	if err == nil {
		for _, item := range agg {
			result = append(result, &model.CustomerAggregationOutput{
				Company: &item.Company,
				Count:   &item.Count,
			})
		}
	}

	return result, err
}

// AggregateReceivables is the resolver for the aggregateReceivables field.
func (r *queryResolver) AggregateReceivables(ctx context.Context, where *generated.ReceivableWhereInput, groupBy []model.ReceivablesGroupBy) ([]*model.ReceivableAggregationOutput, error) {
	_, currentCompany, _ := utils.GetSession(&ctx)
	var result []*model.ReceivableAggregationOutput
	var agg []struct {
		Company int     `json:"company_customers"`
		Count   int     `json:"count"`
		Sum     float64 `json:"sum"`
	}

	query, err := where.Filter(r.client.Receivable.Query())
	if err != nil {
		return nil, err
	}
	err = query.Where(receivable.HasCustomerWith(customer.HasCompanyWith(company.IDEQ(currentCompany.ID)))).
		// GroupBy().
		Aggregate(generated.Count(), generated.Sum(receivable.FieldOutstandingBalance)).Scan(ctx, &agg)

	if err == nil {
		for _, item := range agg {
			result = append(result, &model.ReceivableAggregationOutput{
				Company: &item.Company,
				Count:   &item.Count,
				Sum:     &item.Sum,
			})
		}
	}

	return result, err
}

// Employees is the resolver for the employees field.
func (r *queryResolver) Employees(ctx context.Context, where *generated.EmployeeWhereInput) ([]*generated.Employee, error) {
	companyQ := utils.CurrentCompanyQuery(&ctx)
	filter := employee.HasCompanyWith(companyQ)
	query, err := where.Filter(r.client.Employee.Query().Where(filter))
	if err != nil {
		return nil, err
	}
	return query.All(ctx)
}

// Payables is the resolver for the payables field.
func (r *queryResolver) Payables(ctx context.Context, where *generated.PayableWhereInput) ([]*generated.Payable, error) {
	supplierQ := supplier.HasCompanyWith(utils.CurrentCompanyQuery(&ctx))
	filter := payable.HasSupplierWith(supplierQ)
	query, err := where.Filter(r.client.Payable.Query().Where(filter))
	if err != nil {
		return nil, err
	}
	return query.All(ctx)
}

// Products is the resolver for the products field.
func (r *queryResolver) Products(ctx context.Context, where *generated.ProductWhereInput) ([]*generated.Product, error) {
	filter := product.HasCompanyWith(utils.CurrentCompanyQuery(&ctx))
	query, err := where.Filter(r.client.Product.Query().Where(filter))
	if err != nil {
		return nil, err
	}
	return query.All(ctx)
}

// LowStock is the resolver for the lowStock field.
func (r *queryResolver) LowStock(ctx context.Context, where *generated.ProductWhereInput) ([]*generated.Product, error) {
	companyQ := product.HasCompanyWith(utils.CurrentCompanyQuery(&ctx))
	productQ := sql.FieldsLT(product.FieldStock, product.FieldMinimumStock)
	query, err := where.Filter(r.client.Product.Query().Where(companyQ, productQ))
	if err != nil {
		return nil, err
	}
	return query.All(ctx)
}

// NumberOfProducts is the resolver for the numberOfProducts field.
func (r *queryResolver) NumberOfProducts(ctx context.Context, where *generated.ProductWhereInput) (int, error) {
	filter := product.HasCompanyWith(utils.CurrentCompanyQuery(&ctx))
	query, err := where.Filter(r.client.Product.Query().Where(filter))
	if err != nil {
		return 0, err
	}
	return query.Count(ctx)
}

// NumberOfLowStock is the resolver for the numberOfLowStock field.
func (r *queryResolver) NumberOfLowStock(ctx context.Context, where *generated.ProductWhereInput) (int, error) {
	companyQ := product.HasCompanyWith(utils.CurrentCompanyQuery(&ctx))
	productQ := sql.FieldsLT(product.FieldStock, product.FieldMinimumStock)
	query, err := where.Filter(r.client.Product.Query().Where(companyQ, productQ))
	if err != nil {
		return 0, err
	}
	return query.Count(ctx)
}

// NumberOfOutOfStock is the resolver for the numberOfOutOfStock field.
func (r *queryResolver) NumberOfOutOfStock(ctx context.Context, where *generated.ProductWhereInput) (int, error) {
	companyQ := product.HasCompanyWith(utils.CurrentCompanyQuery(&ctx))
	productQ := product.And(product.CategoryEQ(product.CategoryMERCHANDISE))
	query, err := where.Filter(r.client.Product.Query().Where(companyQ, productQ))
	if err != nil {
		return 0, err
	}
	return query.Count(ctx)
}

// Projects is the resolver for the projects field.
func (r *queryResolver) Projects(ctx context.Context, where *generated.ProjectWhereInput) ([]*generated.Project, error) {
	_, currentCompany, _ := utils.GetSession(&ctx)
	companyQ := project.HasCompanyWith(company.IDEQ(currentCompany.ID))
	query, err := where.Filter(r.client.Project.Query().Where(companyQ))
	if err != nil {
		fmt.Println("err:", err)
		return nil, err
	}

	return query.All(ctx)
}

// ProjectTasks is the resolver for the projectTasks field.
func (r *queryResolver) ProjectTasks(ctx context.Context, where *generated.ProjectTaskWhereInput) ([]*generated.ProjectTask, error) {
	_, currentCompany, _ := utils.GetSession(&ctx)
	companyQ := projecttask.HasProjectWith(project.HasCompanyWith(company.IDEQ(currentCompany.ID)))
	query, err := where.Filter(r.client.ProjectTask.Query().Where(companyQ))
	if err != nil {
		fmt.Println("err:", err)
		return nil, err
	}

	return query.All(ctx)
}

// Suppliers is the resolver for the suppliers field.
func (r *queryResolver) Suppliers(ctx context.Context, where *generated.SupplierWhereInput) ([]*generated.Supplier, error) {
	filter := supplier.HasCompanyWith(utils.CurrentCompanyQuery(&ctx))
	query, err := where.Filter(r.client.Supplier.Query().Where(filter))
	if err != nil {
		return nil, err
	}
	return query.All(ctx)
}

// Treasuries is the resolver for the treasuries field.
func (r *queryResolver) Treasuries(ctx context.Context, where *generated.TreasuryWhereInput) ([]*generated.Treasury, error) {
	filter := treasury.HasCompanyWith(utils.CurrentCompanyQuery(&ctx))
	query, err := where.Filter(r.client.Treasury.Query().Where(filter))
	if err != nil {
		return nil, err
	}
	return query.All(ctx)
}

// AggregateTreasury is the resolver for the aggregateTreasury field.
func (r *queryResolver) AggregateTreasury(ctx context.Context, where *generated.TreasuryWhereInput) ([]*model.TreasuryAggregatePayload, error) {
	_, currentCompany, _ := utils.GetSession(&ctx)
	var result []*struct {
		CompanyID    int     `json:"company_treasuries"`
		Count        int     `json:"count"`
		TotalBalance float64 `json:"sum"`
	}

	query, err := where.Filter(r.client.Treasury.Query().Where(treasury.HasCompanyWith(company.IDEQ(currentCompany.ID))))
	if err != nil {
		return nil, err
	}
	err = query.GroupBy(treasury.CompanyColumn).
		Aggregate(generated.Count(), generated.Sum(treasury.FieldBalance)).
		Scan(ctx, &result)
	if err != nil {
		return nil, err
	}

	var output []*model.TreasuryAggregatePayload
	for _, res := range result {
		output = append(output, &model.TreasuryAggregatePayload{
			CompanyID:    res.CompanyID,
			Count:        res.Count,
			TotalBalance: res.TotalBalance,
		})
	}

	return output, err
}

// Users is the resolver for the users field.
func (r *queryResolver) Users(ctx context.Context, where *generated.UserWhereInput) ([]*generated.User, error) {
	roleQ := utils.UserRoleQuery(&ctx)
	filter := user.HasAssignedRolesWith(roleQ)
	query, err := where.Filter(r.client.User.Query().Where(filter))
	if err != nil {
		return nil, err
	}
	return query.All(ctx)
}

// UserRoles is the resolver for the userRoles field.
func (r *queryResolver) UserRoles(ctx context.Context, where *generated.UserRoleWhereInput) ([]*generated.UserRole, error) {
	filter := userrole.HasCompanyWith(utils.CurrentCompanyQuery(&ctx))
	query, err := where.Filter(r.client.UserRole.Query().Where(filter))
	if err != nil {
		return nil, err
	}
	return query.All(ctx)
}

// WorkShifts is the resolver for the workShifts field.
func (r *queryResolver) WorkShifts(ctx context.Context, where *generated.WorkshiftWhereInput) ([]*generated.Workshift, error) {
	_, currentCompany, _ := utils.GetSession(&ctx)
	companyQ := workshift.HasCompanyWith(company.IDEQ(currentCompany.ID))
	query, err := where.Filter(r.client.Workshift.Query().Where(companyQ))
	if err != nil {
		return nil, err
	}
	return query.All(ctx)
}

// AggregateWorkShift is the resolver for the aggregateWorkShift field.
func (r *queryResolver) AggregateWorkShift(ctx context.Context, where *generated.WorkshiftWhereInput, groupBy []model.ShiftGroupBy) ([]*model.WorkShiftAggregationPayload, error) {
	_, _, employeeID := utils.GetSession(&ctx)
	var payload = []*model.WorkShiftAggregationPayload{}

	var result []struct {
		ClockIn           time.Time `json:"clock_in"`
		Count             int       `json:"count"`
		DurationInMinutes int       `json:"durationinminutes,omitempty"`
		PendingCount      int       `json:"pendingcount"`
		Status            string    `json:"status"`
		Employee          int       `json:"employee_work_shifts"`
	}

	// DurationInMinutes is an aggregate function to calculate the duration between clockIn and clockOut
	duration := func(s *sql.Selector) string {
		return "ROUND(SUM(EXTRACT(EPOCH FROM (clock_out - clock_in)) / 60))::INT AS durationInMinutes," +
			"(status = 'PENDING')::INT as pendingCount"
	}

	query, err := where.Filter(
		r.client.Workshift.Query().
			Where(workshift.HasEmployeeWith(employee.IDEQ(*employeeID))),
	)

	if err != nil {
		return nil, err
	}

	err = query.Order(generated.Desc(workshift.FieldClockIn)).
		GroupBy(workshift.FieldClockIn, workshift.FieldStatus). //, workshift.EmployeeColumn
		Aggregate(generated.Count(), duration).Scan(ctx, &result)

	if err != nil {
		return nil, err
	}

	for i, rs := range result {
		date := rs.ClockIn.Format("2006-01-02")
		lastIdx := len(payload) - 1

		if i == 0 || (i > 0 && payload[lastIdx].Date != date) {
			payload = append(payload, &model.WorkShiftAggregationPayload{
				Date:              date,
				Count:             1,
				DurationInMinutes: &rs.DurationInMinutes,
				PendingCount:      &rs.PendingCount,
			})
		} else {
			payload[lastIdx].Count += rs.Count
			*payload[lastIdx].DurationInMinutes += rs.DurationInMinutes
			*payload[lastIdx].PendingCount += rs.PendingCount
		}
	}

	return payload, nil
}

// WorkTags is the resolver for the workTags field.
func (r *queryResolver) WorkTags(ctx context.Context, where *generated.WorktagWhereInput) ([]*generated.Worktag, error) {
	_, currentCompany, _ := utils.GetSession(&ctx)
	companyQ := worktag.HasCompanyWith(company.IDEQ(currentCompany.ID))
	query, err := where.Filter(r.client.Worktag.Query().Where(companyQ))
	if err != nil {
		return nil, err
	}
	return query.All(ctx)
}

// WorkTasks is the resolver for the workTasks field.
func (r *queryResolver) WorkTasks(ctx context.Context, where *generated.WorktaskWhereInput) ([]*generated.Worktask, error) {
	currentUser, currentCompany, _ := utils.GetSession(&ctx)
	userQ := worktask.Or(
		worktask.HasAssignedToWith(employee.HasUserWith(user.IDEQ(currentUser.ID))),
		worktask.HasCreatedByWith(user.IDEQ(currentUser.ID)),
	)
	companyQ := worktask.HasCompanyWith(company.IDEQ(currentCompany.ID))
	query, err := where.Filter(r.client.Worktask.Query().Where(userQ, companyQ))
	if err != nil {
		return nil, err
	}
	return query.All(ctx)
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

type mutationResolver struct{ *Resolver }
