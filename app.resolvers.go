package mazza

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.52

import (
	"context"
	"fmt"
	"mazza/app/auth"
	appUtils "mazza/app/utils"
	"mazza/ent/generated"
	"mazza/ent/generated/company"
	"mazza/ent/generated/customer"
	"mazza/ent/generated/employee"
	"mazza/ent/generated/product"
	"mazza/ent/generated/project"
	"mazza/ent/generated/projectmilestone"
	"mazza/ent/generated/projecttask"
	"mazza/ent/generated/receivable"
	"mazza/ent/generated/supplier"
	"mazza/ent/generated/treasury"
	"mazza/ent/generated/user"
	"mazza/ent/generated/userrole"
	"mazza/ent/generated/workshift"
	"mazza/ent/utils"
	"mazza/mazza/generated/model"
	"strings"
	"time"

	"entgo.io/ent/dialect/sql"
	"github.com/vektah/gqlparser/v2/gqlerror"
)

// Signup is the resolver for the signup field.
func (r *mutationResolver) Signup(ctx context.Context, input model.SignupInput) (*model.LoginOutput, error) {
	newCompany, err := r.CreateCompany(ctx, input.CompanyInput, nil)
	if err != nil {
		return nil, err
	}

	newUser, err := r.CreateUser(ctx, *input.UserInput)
	if err != nil {
		return nil, err
	}

	role, err := r.client.UserRole.Create().SetRole(userrole.RoleADMIN).Save(ctx)
	if err != nil {
		return nil, err
	}

	_, err = newCompany.Update().AddAvailableRoleIDs(role.ID).Save(ctx)
	if err != nil {
		return nil, err
	}

	newUser, err = newUser.Update().AddAssignedRoleIDs(role.ID).Save(ctx)
	if err != nil {
		return nil, err
	}
	_ = newUser

	// loginInput := model.LoginInput{Username: newUser.Username, Password: input.UserInput.Password, FcmToken: *input.UserInput.FcmToken}
	// loginOutput, err := r.Login(ctx, loginInput)
	// err = fmt.Errorf("miiniijnjn")
	// if err != nil {
	return nil, fmt.Errorf("your account was created, please use your creations to log in")
}

// CreateCompany is the resolver for the createCompany field.
func (r *mutationResolver) CreateCompany(ctx context.Context, input *generated.CreateCompanyInput, companyLogo *model.ProfilePhotoInput) (*generated.Company, error) {
	client := generated.FromContext(ctx)
	company, err := client.Company.Create().SetInput(*input).Save(ctx)
	if err == nil {
		_ = appUtils.CreateDefaultItems(ctx, company.ID)
	}
	return company, err
}

// UpdateCompany is the resolver for the updateCompany field.
func (r *mutationResolver) UpdateCompany(ctx context.Context, id int, input generated.UpdateCompanyInput, companyLogo *model.ProfilePhotoInput) (*generated.Company, error) {
	client := generated.FromContext(ctx)
	_, currentCompany := utils.GetSession(&ctx)
	if currentCompany.ID != id {
		return nil, fmt.Errorf("unauthorized")
	}

	updateBuilder := client.Company.UpdateOneID(id).SetInput(input)
	if companyLogo != nil {
		updateBuilder = updateBuilder.SetLogoStorageURI(companyLogo.StorageURI).SetLogoURL(companyLogo.URL)
	}
	return updateBuilder.Save(ctx)
}

// InvitedUserSignup is the resolver for the invitedUserSignup field.
func (r *mutationResolver) InvitedUserSignup(ctx context.Context, input model.InvitedUserSignupInput) (*generated.User, error) {
	token, err := r.client.MemberSignupToken.Get(ctx, input.InvitationToken)
	if err != nil {
		fmt.Println("InvitedUserSignup get token err:", err)
		return nil, fmt.Errorf("invalid token")
	}

	companyID, err := token.QueryCompany().FirstID(ctx)
	if err != nil {
		fmt.Println("InvitedUserSignup get company err:", err)
		return nil, fmt.Errorf("invalid token")
	}

	inviteeID, err := token.QueryCreatedBy().FirstID(ctx)
	if err != nil {
		fmt.Println("InvitedUserSignup get invitee err:", err)
		return nil, fmt.Errorf("invalid token")
	}

	roleInput := generated.CreateUserRoleInput{
		Role:      userrole.Role(token.Role),
		CompanyID: &companyID,
	}

	user, err := r.client.User.Create().SetInput(*input.UserInput).
		AddCompanyIDs(companyID).
		SetActive(false).SetLastLogin(time.Now()).SetLeaderID(inviteeID).
		AddAssignedRoles(r.client.UserRole.Create().SetInput(roleInput).SaveX(ctx)).
		Save(ctx)
	if err != nil {
		fmt.Println("InvitedUserSignup create user err:", err)
		return nil, fmt.Errorf("an error occurred")
	}

	return user, nil
}

// CreateUser is the resolver for the createUser field.
func (r *mutationResolver) CreateUser(ctx context.Context, input generated.CreateUserInput) (*generated.User, error) {
	client := generated.FromContext(ctx)
	// pwd, err := appUtils.HashPwd(&input.Password)
	// if err != nil {
	// 	return nil, gqlerror.Errorf("ocorreu um erro ao criar o usu√°rio")
	// }
	// input.Password = pwd
	return client.User.Create().SetInput(input).Save(ctx)
}

// UpdateUser is the resolver for the updateUser field.
func (r *mutationResolver) UpdateUser(ctx context.Context, id int, input generated.UpdateUserInput, companyLogo *model.ProfilePhotoInput) (*generated.User, error) {
	client := generated.FromContext(ctx)
	currentUser, currentCompany := utils.GetSession(&ctx)
	if currentUser == nil {
		return nil, fmt.Errorf("unauthorized")
	}

	// Beside from admin, users can only update themselves
	if currentUser.ID == id {
		return client.User.UpdateOneID(id).SetInput(input).Save(ctx)
	}

	// Check if the current user is admin. If yes, perform the update
	_, err := currentUser.QueryAssignedRoles().Where(
		userrole.HasCompanyWith(company.ID(currentCompany.ID)),
		userrole.Or(
			userrole.RoleEQ(userrole.RoleADMIN),
			userrole.RoleEQ(userrole.RoleSUPERUSER),
		),
	).Exist(ctx)
	if err != nil {
		fmt.Println("user:", currentCompany.ID, currentUser.Name, err)
		return nil, fmt.Errorf("unauthorized")
	}

	return client.User.UpdateOneID(id).SetInput(input).Save(ctx)
}

// ForgotPassword is the resolver for the forgotPassword field.
func (r *mutationResolver) ForgotPassword(ctx context.Context, username string) (string, error) {
	// err := auth.ForgotPassword(&ctx, username)
	return "reset email sent to " + username, nil
}

// ResetPassword is the resolver for the resetPassword field.
func (r *mutationResolver) ResetPassword(ctx context.Context, input model.ResetPasswordInput) (bool, error) {
	// err := auth.ResetPassword(&ctx, input.Token, input.Password)
	// if err != nil {
	// 	return false, fmt.Errorf("invalid token")
	// }
	return true, nil
}

// Unsubscribe is the resolver for the unsubscribe field.
func (r *mutationResolver) Unsubscribe(ctx context.Context, id int) (bool, error) {
	err := auth.Unsubscribe(&ctx, r.client)
	return true, err
}

// CreateUserRole is the resolver for the createUserRole field.
func (r *mutationResolver) CreateUserRole(ctx context.Context, input generated.CreateUserRoleInput) (bool, error) {
	panic(fmt.Errorf("not implemented: CreateUserRole - createUserRole"))
}

// CreateCustomer is the resolver for the createCustomer field.
func (r *mutationResolver) CreateCustomer(ctx context.Context, input generated.CreateCustomerInput) (*generated.Customer, error) {
	_, currentCompany := utils.GetSession(&ctx)
	return r.client.Customer.Create().SetInput(input).SetCompanyID(currentCompany.ID).Save(ctx)
}

// UpdateCustomer is the resolver for the updateCustomer field.
func (r *mutationResolver) UpdateCustomer(ctx context.Context, id int, input generated.UpdateCustomerInput) (*generated.Customer, error) {
	_, activeCompany := utils.GetSession(&ctx)
	companyFilter := customer.HasCompanyWith(company.ID(activeCompany.ID))
	return generated.FromContext(ctx).Customer.UpdateOneID(id).
		Where(companyFilter).SetInput(input).
		Save(ctx)
}

// DeleteCustomer is the resolver for the deleteCustomer field.
func (r *mutationResolver) DeleteCustomer(ctx context.Context, id int) (bool, error) {
	companyQ := utils.CurrentCompanyQuery(&ctx)
	filter := customer.HasCompanyWith(companyQ)

	if err := generated.FromContext(ctx).Customer.DeleteOneID(id).Where(filter).Exec(ctx); err != nil {
		return false, fmt.Errorf("")
	}
	return true, nil
}

// CreateEmployee is the resolver for the createEmployee field.
func (r *mutationResolver) CreateEmployee(ctx context.Context, input generated.CreateEmployeeInput) (*generated.Employee, error) {
	_, currentCompany := utils.GetSession(&ctx)
	return r.client.Employee.Create().SetInput(input).SetCompanyID(currentCompany.ID).Save(ctx)
}

// UpdateEmployee is the resolver for the updateEmployee field.
func (r *mutationResolver) UpdateEmployee(ctx context.Context, id int, input generated.UpdateEmployeeInput) (*generated.Employee, error) {
	companyQ := utils.CurrentCompanyQuery(&ctx)
	filter := employee.HasCompanyWith(companyQ)
	return generated.FromContext(ctx).Employee.UpdateOneID(id).Where(filter).SetInput(input).Save(ctx)
}

// DeleteEmployee is the resolver for the deleteEmployee field.
func (r *mutationResolver) DeleteEmployee(ctx context.Context, id int) (bool, error) {
	companyQ := utils.CurrentCompanyQuery(&ctx)
	filter := employee.HasCompanyWith(companyQ)

	if err := generated.FromContext(ctx).Employee.DeleteOneID(id).Where(filter).Exec(ctx); err != nil {
		return false, fmt.Errorf("")
	}
	return true, nil
}

// CreateProduct is the resolver for the createProduct field.
func (r *mutationResolver) CreateProduct(ctx context.Context, input generated.CreateProductInput) (*generated.Product, error) {
	_, currentCompany := utils.GetSession(&ctx)
	product, err := r.client.Product.Create().SetInput(input).SetCompanyID(currentCompany.ID).Save(ctx)
	if err != nil {
		errStr := err.Error()
		if strings.Contains(errStr, "unique") && strings.Contains(errStr, "product_name_company_products") {
			return product, gqlerror.Errorf("name is not unique")
		} else if strings.Contains(errStr, "unique") && strings.Contains(errStr, "product_sku_company_products") {
			return product, gqlerror.Errorf("sku is not unique")
		}
		fmt.Println("err:", errStr)
	}

	return product, err
}

// UpdateProduct is the resolver for the updateProduct field.
func (r *mutationResolver) UpdateProduct(ctx context.Context, id int, input generated.UpdateProductInput) (*generated.Product, error) {
	companyQ := utils.CurrentCompanyQuery(&ctx)
	filter := product.HasCompanyWith(companyQ)
	return generated.FromContext(ctx).Product.UpdateOneID(id).Where(filter).SetInput(input).Save(ctx)
}

// DeleteProduct is the resolver for the deleteProduct field.
func (r *mutationResolver) DeleteProduct(ctx context.Context, id int) (bool, error) {
	companyQ := utils.CurrentCompanyQuery(&ctx)
	filter := product.HasCompanyWith(companyQ)

	if err := generated.FromContext(ctx).Product.DeleteOneID(id).Where(filter).Exec(ctx); err != nil {
		return false, fmt.Errorf("there was an error deleting the product")
	}
	return true, nil
}

// CreateProject is the resolver for the createProject field.
func (r *mutationResolver) CreateProject(ctx context.Context, input generated.CreateProjectInput) (*generated.Project, error) {
	_, currentCompany := utils.GetSession(&ctx)
	return r.client.Project.Create().SetInput(input).SetCompanyID(currentCompany.ID).Save(ctx)
}

// UpdateProject is the resolver for the updateProject field.
func (r *mutationResolver) UpdateProject(ctx context.Context, id int, input generated.UpdateProjectInput) (*generated.Project, error) {
	_, currentCompany := utils.GetSession(&ctx)
	filter := project.HasCompanyWith(company.IDEQ(currentCompany.ID))
	return generated.FromContext(ctx).Project.UpdateOneID(id).Where(filter).SetInput(input).Save(ctx)
}

// DeleteProject is the resolver for the deleteProject field.
func (r *mutationResolver) DeleteProject(ctx context.Context, id int) (bool, error) {
	_, currentCompany := utils.GetSession(&ctx)
	filter := project.HasCompanyWith(company.IDEQ(currentCompany.ID))

	if err := generated.FromContext(ctx).Project.DeleteOneID(id).Where(filter).Exec(ctx); err != nil {
		return false, fmt.Errorf("there was an error deleting the project")
	}
	return true, nil
}

// CreateProjectTask is the resolver for the createProjectTask field.
func (r *mutationResolver) CreateProjectTask(ctx context.Context, input generated.CreateProjectTaskInput) (*generated.ProjectTask, error) {
	_, currentCompany := utils.GetSession(&ctx)
	if _, err := r.client.Project.Query().Where(project.IDEQ(input.ProjectID), project.HasCompanyWith(company.IDEQ(currentCompany.ID))).First(ctx); err != nil {
		fmt.Println("err 1:", err)
		return nil, gqlerror.Errorf("invalid project input")
	}
	// Check if the task assignee belongs to the company
	if input.AssigneeID != nil {
		if _, err := r.client.Company.Query().Where(company.IDEQ(currentCompany.ID), company.HasUsersWith(user.IDEQ(*input.AssigneeID))).First(ctx); err != nil {
			fmt.Println("err 2:", err)
			return nil, gqlerror.Errorf("invalid user input")
		}
	}

	newTask, err := r.client.ProjectTask.Create().SetInput(input).Save(ctx)
	if err != nil {
		fmt.Println("err 3:", err)
		return nil, err
	}

	return newTask, err
}

// UpdateProjectTask is the resolver for the updateProjectTask field.
func (r *mutationResolver) UpdateProjectTask(ctx context.Context, id int, input generated.UpdateProjectTaskInput) (*generated.ProjectTask, error) {
	_, currentCompany := utils.GetSession(&ctx)
	filter := projecttask.HasProjectWith(project.HasCompanyWith(company.IDEQ(currentCompany.ID)))
	updatedTask, err := generated.FromContext(ctx).ProjectTask.UpdateOneID(id).Where(filter).SetInput(input).Save(ctx)
	if err != nil {
		return nil, err
	}
	return updatedTask, nil
}

// DeleteProjectTask is the resolver for the deleteProjectTask field.
func (r *mutationResolver) DeleteProjectTask(ctx context.Context, id int) (bool, error) {
	_, currentCompany := utils.GetSession(&ctx)
	filter := projecttask.HasProjectWith(project.HasCompanyWith(company.IDEQ(currentCompany.ID)))

	if err := r.client.ProjectTask.DeleteOneID(id).Where(filter).Exec(ctx); err != nil {
		fmt.Println("err:", err)
		return false, fmt.Errorf("there was an error deleting the project task")
	}
	return true, nil
}

// CreateProjectMilestone is the resolver for the createProjectMilestone field.
func (r *mutationResolver) CreateProjectMilestone(ctx context.Context, input generated.CreateProjectMilestoneInput) (*generated.ProjectMilestone, error) {
	_, currentCompany := utils.GetSession(&ctx)
	if _, err := r.client.Project.Query().Where(project.IDEQ(input.ProjectID), project.HasCompanyWith(company.IDEQ(currentCompany.ID))).First(ctx); err != nil {
		return nil, gqlerror.Errorf("invalid project input")
	}

	return r.client.ProjectMilestone.Create().SetInput(input).Save(ctx)
}

// UpdateProjectMilestone is the resolver for the updateProjectMilestone field.
func (r *mutationResolver) UpdateProjectMilestone(ctx context.Context, id int, input generated.UpdateProjectMilestoneInput) (*generated.ProjectMilestone, error) {
	_, currentCompany := utils.GetSession(&ctx)
	filter := projectmilestone.HasProjectWith(project.HasCompanyWith(company.IDEQ(currentCompany.ID)))
	return generated.FromContext(ctx).ProjectMilestone.UpdateOneID(id).Where(filter).SetInput(input).Save(ctx)
}

// DeleteProjectMilestone is the resolver for the deleteProjectMilestone field.
func (r *mutationResolver) DeleteProjectMilestone(ctx context.Context, id int) (bool, error) {
	_, currentCompany := utils.GetSession(&ctx)
	filter := projectmilestone.HasProjectWith(project.HasCompanyWith(company.IDEQ(currentCompany.ID)))

	if err := generated.FromContext(ctx).ProjectMilestone.DeleteOneID(id).Where(filter).Exec(ctx); err != nil {
		return false, fmt.Errorf("there was an error deleting the project milestone")
	}
	return true, nil
}

// CreateSupplier is the resolver for the createSupplier field.
func (r *mutationResolver) CreateSupplier(ctx context.Context, input generated.CreateSupplierInput) (*generated.Supplier, error) {
	_, currentCompany := utils.GetSession(&ctx)
	return r.client.Supplier.Create().SetInput(input).SetCompanyID(currentCompany.ID).Save(ctx)
}

// UpdateSupplier is the resolver for the updateSupplier field.
func (r *mutationResolver) UpdateSupplier(ctx context.Context, id int, input generated.UpdateSupplierInput) (*generated.Supplier, error) {
	companyQ := utils.CurrentCompanyQuery(&ctx)
	filter := supplier.HasCompanyWith(companyQ)
	return generated.FromContext(ctx).Supplier.UpdateOneID(id).Where(filter).SetInput(input).Save(ctx)
}

// DeleteSupplier is the resolver for the deleteSupplier field.
func (r *mutationResolver) DeleteSupplier(ctx context.Context, id int) (bool, error) {
	companyQ := utils.CurrentCompanyQuery(&ctx)
	filter := supplier.HasCompanyWith(companyQ)

	if err := generated.FromContext(ctx).Supplier.DeleteOneID(id).Where(filter).Exec(ctx); err != nil {
		return false, fmt.Errorf("the supplier could not be deleted")
	}
	return true, nil
}

// CreateTreasury is the resolver for the createTreasury field.
func (r *mutationResolver) CreateTreasury(ctx context.Context, input generated.CreateTreasuryInput) (*generated.Treasury, error) {
	_, currentCompany := utils.GetSession(&ctx)
	output, err := r.client.Treasury.Create().SetInput(input).SetCompanyID(currentCompany.ID).Save(ctx)
	if err != nil {
		errStr := err.Error()
		if strings.Contains(errStr, "unique") && strings.Contains(errStr, "treasury_name_company_treasuries") {
			return output, gqlerror.Errorf("name is not unique")
		}
		fmt.Println("err:", errStr)
	}
	return output, err
}

// UpdateTreasury is the resolver for the updateTreasury field.
func (r *mutationResolver) UpdateTreasury(ctx context.Context, id int, input generated.UpdateTreasuryInput) (*generated.Treasury, error) {
	companyQ := utils.CurrentCompanyQuery(&ctx)
	filter := treasury.HasCompanyWith(companyQ)
	return generated.FromContext(ctx).Treasury.UpdateOneID(id).Where(filter).SetInput(input).Save(ctx)
}

// DeleteTreasury is the resolver for the deleteTreasury field.
func (r *mutationResolver) DeleteTreasury(ctx context.Context, id int) (bool, error) {
	companyQ := utils.CurrentCompanyQuery(&ctx)
	filter := treasury.HasCompanyWith(companyQ)

	if err := generated.FromContext(ctx).Treasury.DeleteOneID(id).Where(filter).Exec(ctx); err != nil {
		return false, fmt.Errorf("the treasury account could not be delete")
	}
	return true, nil
}

// CreateWorkShift is the resolver for the createWorkShift field.
func (r *mutationResolver) CreateWorkShift(ctx context.Context, input generated.CreateWorkshiftInput) (*generated.Workshift, error) {
	currentUser, currentCompany := utils.GetSession(&ctx)
	var clockIn time.Time
	fmt.Println("## edit iD:", input.EditRequestID)
	// Clock-in is the current time if this is a workshift
	if input.WorkShiftID == nil {
		clockIn = time.Now()
	} else {
		// If it is a edit request, clock-in is the given input
		clockIn = *input.ClockIn
	}
	// fmt.Println("** emp  id:", employeeID)
	return r.client.Workshift.Create().SetInput(input).
		SetCompanyID(currentCompany.ID).
		SetUserID(currentUser.ID).
		SetClockIn(clockIn).SetStatus(workshift.StatusPENDING).
		Save(ctx)
}

// UpdateWorkShift is the resolver for the updateWorkShift field.
func (r *mutationResolver) UpdateWorkShift(ctx context.Context, id int, input generated.UpdateWorkshiftInput) (*generated.Workshift, error) {
	companyQ := utils.CurrentCompanyQuery(&ctx)
	filter := workshift.HasCompanyWith(companyQ)

	return generated.FromContext(ctx).Workshift.UpdateOneID(id).Where(filter).SetInput(input).Save(ctx)
}

// DeleteWorkShift is the resolver for the deleteWorkShift field.
func (r *mutationResolver) DeleteWorkShift(ctx context.Context, id int) (bool, error) {
	companyQ := utils.CurrentCompanyQuery(&ctx)
	filter := workshift.HasCompanyWith(companyQ)

	if err := generated.FromContext(ctx).Workshift.DeleteOneID(id).Where(filter).Exec(ctx); err != nil {
		return false, err
	}
	return true, nil
}

// VerifyPasswordResetToken is the resolver for the verifyPasswordResetToken field.
func (r *queryResolver) VerifyPasswordResetToken(ctx context.Context, token string) (bool, error) {
	// err := auth.VerifyPasswordResetToken(&ctx, r.client, token)
	// if err != nil {
	// 	return false, &generated.NotFoundError{}
	// }
	return true, nil
}

// Companies is the resolver for the companies field.
func (r *queryResolver) Companies(ctx context.Context, where *generated.CompanyWhereInput) ([]*generated.Company, error) {
	filter := utils.CompanyQuery(&ctx)
	query, err := where.Filter(r.client.Company.Query().Where(filter))
	if err != nil {
		return nil, err
	}
	return query.All(ctx)
}

// Customers is the resolver for the customers field.
func (r *queryResolver) Customers(ctx context.Context, where *generated.CustomerWhereInput) ([]*generated.Customer, error) {
	companyQ := utils.CurrentCompanyQuery(&ctx)
	filter := customer.HasCompanyWith(companyQ)
	query, err := where.Filter(r.client.Customer.Query().Where(filter))
	if err != nil {
		return nil, err
	}
	return query.All(ctx)
}

// AggregateCustomers is the resolver for the aggregateCustomers field.
func (r *queryResolver) AggregateCustomers(ctx context.Context, where *generated.CustomerWhereInput, groupBy []model.CustomersGroupBy) ([]*model.CustomerAggregationOutput, error) {
	_, currentCompany := utils.GetSession(&ctx)
	var result []*model.CustomerAggregationOutput
	var agg []struct {
		Company int `json:"company_customers"`
		Count   int `json:"count"`
	}

	query, err := where.Filter(r.client.Customer.Query())
	if err != nil {
		return nil, err
	}
	err = query.Where(customer.HasCompanyWith(company.IDEQ(currentCompany.ID))).
		GroupBy(customer.CompanyColumn).
		Aggregate(generated.Count()).Scan(ctx, &agg)

	if err == nil {
		for _, item := range agg {
			result = append(result, &model.CustomerAggregationOutput{
				Company: &item.Company,
				Count:   &item.Count,
			})
		}
	}

	return result, err
}

// AggregateReceivables is the resolver for the aggregateReceivables field.
func (r *queryResolver) AggregateReceivables(ctx context.Context, where *generated.ReceivableWhereInput, groupBy []model.ReceivablesGroupBy) ([]*model.ReceivableAggregationOutput, error) {
	_, currentCompany := utils.GetSession(&ctx)
	var result []*model.ReceivableAggregationOutput
	var agg []struct {
		Company int     `json:"company_customers"`
		Count   int     `json:"count"`
		Sum     float64 `json:"sum"`
	}

	query, err := where.Filter(r.client.Receivable.Query())
	if err != nil {
		return nil, err
	}
	err = query.Where(receivable.HasCompanyWith(company.IDEQ(currentCompany.ID))).
		// GroupBy().
		Aggregate(generated.Count(), generated.Sum(receivable.FieldOutstandingBalance)).Scan(ctx, &agg)

	if err == nil {
		for _, item := range agg {
			result = append(result, &model.ReceivableAggregationOutput{
				Company: &item.Company,
				Count:   &item.Count,
				Sum:     &item.Sum,
			})
		}
	}

	return result, err
}

// AccountsReceivableAging is the resolver for the accountsReceivableAging field.
func (r *queryResolver) AccountsReceivableAging(ctx context.Context) ([]*model.AgingBucket, error) {
	_, currentCompany := utils.GetSession(&ctx)
	// Current date for age calculation
	now := time.Now().Format(time.RFC3339) // Convert time to RFC3339 format which PostgreSQL accepts

	sqlStr := fmt.Sprintf(`
	SELECT 
		age_interval,
		SUM(outstanding_balance) AS total_amount,
		COUNT(*) AS count
	FROM (
		SELECT 
			CASE
				WHEN DATE_PART('day', due_date - '%s'::TIMESTAMP) < -30 THEN '> 30 days overdue'
				WHEN DATE_PART('day', due_date - '%s'::TIMESTAMP) < 0 THEN '1-30 days overdue'
				WHEN DATE_PART('day', due_date - '%s'::TIMESTAMP) <= 7 THEN 'due in 0-7 days'
				WHEN DATE_PART('day', due_date - '%s'::TIMESTAMP) <= 30 THEN 'due in 8-30 days'
				ELSE 'due in 30+ days'
			END AS age_interval,
			outstanding_balance
		FROM receivables
		WHERE company_receivables = '%d' AND outstanding_balance > 0  -- Only include unpaid invoices
	) AS subquery
	GROUP BY age_interval
	ORDER BY 
		CASE age_interval
			WHEN '> 30 days overdue' THEN 1
			WHEN '1-30 days overdue' THEN 2
			WHEN 'due in 0-7 days' THEN 3
			WHEN 'due in 8-30 days' THEN 4
			WHEN 'due in 30+ days' THEN 5
		END;
	`, now, now, now, now, currentCompany.ID)

	rows, err := r.client.QueryContext(ctx, sqlStr)
	if err != nil {
		fmt.Println("err:", err)
		return nil, fmt.Errorf("an error occurred")
	}

	var scannedRows []*model.AgingBucket
	defer rows.Close()
	for rows.Next() {
		var item model.AgingBucket
		if err := rows.Scan(&item.Range, &item.TotalAmount, &item.Count); err != nil {
			// Check for a scan error. Query rows will be closed with defer.
			fmt.Println("err:", err)
			return nil, err
		}
		scannedRows = append(scannedRows, &item)
	}

	// appUtils.PP(scannedRows)
	return scannedRows, nil
}

// AccountsPayableAging is the resolver for the accountsPayableAging field.
func (r *queryResolver) AccountsPayableAging(ctx context.Context) ([]*model.AgingBucket, error) {
	_, currentCompany := utils.GetSession(&ctx)
	// Current date for age calculation
	now := time.Now().Format(time.RFC3339) // Convert time to RFC3339 format which PostgreSQL accepts

	sqlStr := fmt.Sprintf(`
	SELECT 
		age_interval,
		SUM(outstanding_balance) AS total_amount,
		COUNT(*) AS count
	FROM (
		SELECT 
			CASE
				WHEN DATE_PART('day', due_date - '%s'::TIMESTAMP) < -30 THEN '> 30 days overdue'
				WHEN DATE_PART('day', due_date - '%s'::TIMESTAMP) < 0 THEN '1-30 days overdue'
				WHEN DATE_PART('day', due_date - '%s'::TIMESTAMP) <= 7 THEN 'due in 0-7 days'
				WHEN DATE_PART('day', due_date - '%s'::TIMESTAMP) <= 30 THEN 'due in 8-30 days'
				ELSE 'due in 30+ days'
			END AS age_interval,
			outstanding_balance
		FROM payables
		WHERE company_payables = '%d' AND outstanding_balance > 0  -- Only include unpaid invoices
	) AS subquery
	GROUP BY age_interval
	ORDER BY 
		CASE age_interval
			WHEN '> 30 days overdue' THEN 1
			WHEN '1-30 days overdue' THEN 2
			WHEN 'due in 0-7 days' THEN 3
			WHEN 'due in 8-30 days' THEN 4
			WHEN 'due in 30+ days' THEN 5
		END;
	`, now, now, now, now, currentCompany.ID)

	rows, err := r.client.QueryContext(ctx, sqlStr)
	if err != nil {
		fmt.Println("err:", err)
		return nil, fmt.Errorf("an error occurred")
	}

	var scannedRows []*model.AgingBucket
	defer rows.Close()
	for rows.Next() {
		var item model.AgingBucket
		if err := rows.Scan(&item.Range, &item.TotalAmount, &item.Count); err != nil {
			// Check for a scan error. Query rows will be closed with defer.
			fmt.Println("err:", err)
			return nil, err
		}
		scannedRows = append(scannedRows, &item)
	}

	// appUtils.PP(scannedRows)
	return scannedRows, nil
}

// Employees is the resolver for the employees field.
func (r *queryResolver) Employees(ctx context.Context, where *generated.EmployeeWhereInput) ([]*generated.Employee, error) {
	companyQ := utils.CurrentCompanyQuery(&ctx)
	filter := employee.HasCompanyWith(companyQ)
	query, err := where.Filter(r.client.Employee.Query().Where(filter))
	if err != nil {
		return nil, err
	}
	return query.All(ctx)
}

// Products is the resolver for the products field.
func (r *queryResolver) Products(ctx context.Context, where *generated.ProductWhereInput) ([]*generated.Product, error) {
	filter := product.HasCompanyWith(utils.CurrentCompanyQuery(&ctx))
	query, err := where.Filter(r.client.Product.Query().Where(filter))
	if err != nil {
		return nil, err
	}
	return query.All(ctx)
}

// LowStock is the resolver for the lowStock field.
func (r *queryResolver) LowStock(ctx context.Context, where *generated.ProductWhereInput) ([]*generated.Product, error) {
	companyQ := product.HasCompanyWith(utils.CurrentCompanyQuery(&ctx))
	query, err := where.Filter(r.client.Product.Query().Where(companyQ, product.StockLTE(0)))
	if err != nil {
		return nil, err
	}
	return query.All(ctx)
}

// NumberOfProducts is the resolver for the numberOfProducts field.
func (r *queryResolver) NumberOfProducts(ctx context.Context, where *generated.ProductWhereInput) (int, error) {
	filter := product.HasCompanyWith(utils.CurrentCompanyQuery(&ctx))
	query, err := where.Filter(r.client.Product.Query().Where(filter))
	if err != nil {
		return 0, err
	}
	return query.Count(ctx)
}

// NumberOfLowStock is the resolver for the numberOfLowStock field.
func (r *queryResolver) NumberOfLowStock(ctx context.Context, where *generated.ProductWhereInput) (int, error) {
	companyQ := product.HasCompanyWith(utils.CurrentCompanyQuery(&ctx))
	query, err := where.Filter(r.client.Product.Query().Where(companyQ, product.StockLTE(0)))
	if err != nil {
		return 0, err
	}
	return query.Count(ctx)
}

// NumberOfOutOfStock is the resolver for the numberOfOutOfStock field.
func (r *queryResolver) NumberOfOutOfStock(ctx context.Context, where *generated.ProductWhereInput) (int, error) {
	companyQ := product.HasCompanyWith(utils.CurrentCompanyQuery(&ctx))
	query, err := where.Filter(r.client.Product.Query().Where(companyQ, product.StockLTE(0)))
	if err != nil {
		return 0, err
	}
	return query.Count(ctx)
}

// RetrieveProject is the resolver for the retrieveProject field.
func (r *queryResolver) RetrieveProject(ctx context.Context, id int) (*generated.Project, error) {
	companyFilter := project.HasCompanyWith(utils.CurrentCompanyQuery(&ctx))
	return r.client.Project.Query().Where(project.ID(id), companyFilter).First(ctx)
}

// RetrieveProjectTask is the resolver for the retrieveProjectTask field.
func (r *queryResolver) RetrieveProjectTask(ctx context.Context, id int) (*generated.ProjectTask, error) {
	companyFilter := project.HasCompanyWith(utils.CurrentCompanyQuery(&ctx))
	projectFilter := projecttask.HasProjectWith(companyFilter)
	return r.client.ProjectTask.Query().Where(projecttask.ID(id), projectFilter).First(ctx)
}

// Suppliers is the resolver for the suppliers field.
func (r *queryResolver) Suppliers(ctx context.Context, where *generated.SupplierWhereInput) ([]*generated.Supplier, error) {
	filter := supplier.HasCompanyWith(utils.CurrentCompanyQuery(&ctx))
	query, err := where.Filter(r.client.Supplier.Query().Where(filter))
	if err != nil {
		return nil, err
	}
	return query.All(ctx)
}

// Treasuries is the resolver for the treasuries field.
func (r *queryResolver) Treasuries(ctx context.Context, where *generated.TreasuryWhereInput) ([]*generated.Treasury, error) {
	filter := treasury.HasCompanyWith(utils.CurrentCompanyQuery(&ctx))
	query, err := where.Filter(r.client.Treasury.Query().Where(filter))
	// t, _ := r.AccountingEntries(ctx, nil, nil, nil, nil, nil, nil)
	// appUtils.PP(t)
	if err != nil {
		return nil, err
	}
	return query.All(ctx)
}

// AggregateTreasury is the resolver for the aggregateTreasury field.
func (r *queryResolver) AggregateTreasury(ctx context.Context, where *generated.TreasuryWhereInput) ([]*model.TreasuryAggregatePayload, error) {
	_, currentCompany := utils.GetSession(&ctx)
	var result []*struct {
		CompanyID    int     `json:"company_treasuries"`
		Count        int     `json:"count"`
		TotalBalance float64 `json:"sum"`
	}

	query, err := where.Filter(r.client.Treasury.Query().Where(treasury.HasCompanyWith(company.IDEQ(currentCompany.ID))))
	if err != nil {
		return nil, err
	}
	err = query.GroupBy(treasury.CompanyColumn).
		Aggregate(generated.Count(), generated.Sum(treasury.FieldBalance)).
		Scan(ctx, &result)
	if err != nil {
		return nil, err
	}

	var output []*model.TreasuryAggregatePayload
	for _, res := range result {
		output = append(output, &model.TreasuryAggregatePayload{
			CompanyID:    res.CompanyID,
			Count:        res.Count,
			TotalBalance: res.TotalBalance,
		})
	}

	return output, err
}

// Users is the resolver for the users field.
func (r *queryResolver) Users(ctx context.Context, where *generated.UserWhereInput) ([]*generated.User, error) {
	_, currentCompany := utils.GetSession(&ctx)
	companyFilter := company.ID(currentCompany.ID)
	queryBuilder := r.client.User.Query().Where(user.HasCompanyWith(companyFilter))
	query, err := where.Filter(queryBuilder)
	if err != nil {
		fmt.Println("Users query err:", err)
		return nil, fmt.Errorf("an error occurred")
	}

	users, err := query.All(ctx)
	if err != nil {
		fmt.Println("Users query err:", err)
		return nil, fmt.Errorf("an error occurred")
	}

	return users, nil
}

// UserRoles is the resolver for the userRoles field.
func (r *queryResolver) UserRoles(ctx context.Context, where *generated.UserRoleWhereInput) ([]*generated.UserRole, error) {
	filter := userrole.HasCompanyWith(utils.CurrentCompanyQuery(&ctx))
	query, err := where.Filter(r.client.UserRole.Query().Where(filter))
	if err != nil {
		return nil, err
	}
	return query.All(ctx)
}

// WorkShifts is the resolver for the workShifts field.
func (r *queryResolver) WorkShifts(ctx context.Context, where *generated.WorkshiftWhereInput) ([]*generated.Workshift, error) {
	_, currentCompany := utils.GetSession(&ctx)
	companyQ := workshift.HasCompanyWith(company.IDEQ(currentCompany.ID))
	query, err := where.Filter(r.client.Workshift.Query().Where(companyQ))
	if err != nil {
		return nil, err
	}
	return query.All(ctx)
}

// AggregateWorkShift is the resolver for the aggregateWorkShift field.
func (r *queryResolver) AggregateWorkShift(ctx context.Context, where *generated.WorkshiftWhereInput, groupBy []model.ShiftGroupBy) ([]*model.WorkShiftAggregationPayload, error) {
	currentUser, _ := utils.GetSession(&ctx)
	var payload = []*model.WorkShiftAggregationPayload{}

	var result []struct {
		ClockIn           time.Time `json:"clock_in"`
		Count             int       `json:"count"`
		DurationInMinutes int       `json:"durationinminutes,omitempty"`
		PendingCount      int       `json:"pendingcount"`
		Status            string    `json:"status"`
		User              int       `json:"user_work_shifts"`
	}

	// DurationInMinutes is an aggregate function to calculate the duration between clockIn and clockOut
	duration := func(s *sql.Selector) string {
		return "ROUND(SUM(EXTRACT(EPOCH FROM (clock_out - clock_in)) / 60))::INT AS durationInMinutes," +
			"(status = 'PENDING')::INT as pendingCount"
	}

	query, err := where.Filter(
		r.client.Workshift.Query().
			Where(workshift.HasUserWith(user.IDEQ(currentUser.ID))),
	)

	if err != nil {
		return nil, err
	}

	err = query.Order(generated.Desc(workshift.FieldClockIn)).
		GroupBy(workshift.FieldClockIn, workshift.FieldStatus). //, workshift.EmployeeColumn
		Aggregate(generated.Count(), duration).Scan(ctx, &result)

	if err != nil {
		return nil, err
	}

	for i, rs := range result {
		date := rs.ClockIn.Format("2006-01-02")
		lastIdx := len(payload) - 1

		if i == 0 || (i > 0 && payload[lastIdx].Date != date) {
			payload = append(payload, &model.WorkShiftAggregationPayload{
				Date:              date,
				Count:             1,
				DurationInMinutes: &rs.DurationInMinutes,
				PendingCount:      &rs.PendingCount,
			})
		} else {
			payload[lastIdx].Count += rs.Count
			*payload[lastIdx].DurationInMinutes += rs.DurationInMinutes
			*payload[lastIdx].PendingCount += rs.PendingCount
		}
	}

	return payload, nil
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

type mutationResolver struct{ *Resolver }
